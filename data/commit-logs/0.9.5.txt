From 110e197527cc385ee8b1fe27430bb15cd2978fa6 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Tue, 16 Dec 2003 23:02:03 +0000
Subject: [PATCH 001/143] More ignores

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@6 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/.cvsignore | 1 +
 1 file changed, 1 insertion(+)

diff --git a/JodaTime/.cvsignore b/JodaTime/.cvsignore
index 34f2c6f2a..f0ca06bba 100644
--- a/JodaTime/.cvsignore
+++ b/JodaTime/.cvsignore
@@ -2,3 +2,4 @@
 .project
 target
 bin
+build.properties

From 078176943bde33a8061fcd79444f070f7de00965 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Tue, 16 Dec 2003 23:02:33 +0000
Subject: [PATCH 002/143] Update to new joda-time structure

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@7 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/build.xml | 49 +++++++++++++++++++++++++++++++++++++++++-----
 1 file changed, 44 insertions(+), 5 deletions(-)

diff --git a/JodaTime/build.xml b/JodaTime/build.xml
index 57e11e84a..6ca55dd4c 100644
--- a/JodaTime/build.xml
+++ b/JodaTime/build.xml
@@ -119,8 +119,12 @@
 
 <!-- ====================================================================== -->
 
-  <target name="compile" depends="static"
-          description="Compile shareable components">
+  <target name="compile" depends="static,compile.main,compile.zoneinfo"
+          description="Compile shareable components"/>
+          
+          
+  <target name="compile.main" depends="static"
+          description="Compile main datetime classes">
     <javac  srcdir="${source.home}"
            destdir="${build.classes}"
              debug="${compile.debug}"
@@ -133,6 +137,41 @@
     </copy>
   </target>
 
+<!-- ====================================================================== -->
+
+  <target name="compile.zoneinfo"
+          depends="compile.main"
+          description="Compile timezone data files" >
+    <!-- Invoke the newly built ZoneInfoCompiler to compile the zoneinfo data files -->
+    <mkdir dir="${build.classes}/org/joda/time/tz/data" />
+    <java classname="org.joda.time.tz.ZoneInfoCompiler"
+          fork="true"
+          dir="${source.home}/org/joda/time/tz/src"
+          failonerror="true">
+      <classpath path="${build.classes}" />
+      <!-- Override default provider since data directory doesn't exist yet -->
+      <sysproperty key="org.joda.time.DateTimeZone.Provider"
+                   value="org.joda.time.DateTimeZone$UTCProvider" />
+      <!-- Specify destination directory for compiled data files -->
+      <arg line="-d ../../../../../../../${build.classes}/org/joda/time/tz/data" />
+      <!-- Specify all the data files to compile -->
+      <arg value="africa" />
+      <arg value="antarctica" />
+      <arg value="asia" />
+      <arg value="australasia" />
+      <arg value="europe" />
+      <arg value="northamerica" />
+      <arg value="southamerica" />
+      <arg value="pacificnew" />
+      <arg value="etcetera" />
+      <arg value="backward" />
+      <arg value="systemv" />
+      <arg value="solar87" />
+      <arg value="solar88" />
+      <arg value="solar89" />
+    </java>
+  </target>
+  
 <!-- ====================================================================== -->
 
   <target name="compile.tests" depends="compile"
@@ -194,7 +233,7 @@
     <mkdir      dir="${build.classes}/META-INF"/>
     <copy      file="LICENSE.txt"
              tofile="${build.classes}/META-INF/LICENSE.txt"/>
-    <jar    jarfile="${dist.home}/${component.name}.jar"
+    <jar    jarfile="${dist.home}/${component.name}-${component.version}.jar"
             basedir="${build.classes}"
            manifest="${build.conf}/MANIFEST.MF"/>
   </target>
@@ -214,12 +253,12 @@
         <pathelement path="${java.class.path}"/>
       </classpath>
 
-      <batchtest fork="yes">
+<!--      <batchtest fork="yes">
         <fileset dir="${src.tests}">
           <include name="**/*Test*.java"/>
           <exclude name="**/AllTests.java"/>
         </fileset>
-      </batchtest>
+      </batchtest>-->
     </junit>
   </target>
 

From b50127377fb1a048115d708c05a644934a93c937 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Tue, 16 Dec 2003 23:40:37 +0000
Subject: [PATCH 003/143] Integrate joda-time code

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@8 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/maven.xml   | 33 ++++++++++++++++++++++++++++++++-
 JodaTime/project.xml |  8 ++++----
 2 files changed, 36 insertions(+), 5 deletions(-)

diff --git a/JodaTime/maven.xml b/JodaTime/maven.xml
index 1a28e1d45..4e7c98d1d 100644
--- a/JodaTime/maven.xml
+++ b/JodaTime/maven.xml
@@ -1,4 +1,35 @@
 <project default="java:jar"
-  xmlns:j="jelly:core">
+  xmlns:j="jelly:core"
+  xmlns:ant="jelly:ant">
 
+  <postGoal name="java:compile">
+    <ant:mkdir dir="${maven.build.dest}/org/joda/time/tz/data" />
+    <ant:java classname="org.joda.time.tz.ZoneInfoCompiler"
+          fork="true"
+          dir="${pom.build.sourceDirectory}/org/joda/time/tz/src"
+          failonerror="true">
+      <classpath path="${maven.build.dest}" />
+      <!-- Override default provider since data directory doesn't exist yet -->
+      <sysproperty key="org.joda.time.DateTimeZone.Provider"
+                   value="org.joda.time.DateTimeZone$UTCProvider" />
+      <!-- Specify destination directory for compiled data files -->
+      <arg line="-d ${maven.build.dest}/org/joda/time/tz/data" />
+      <!-- Specify all the data files to compile -->
+      <arg value="africa" />
+      <arg value="antarctica" />
+      <arg value="asia" />
+      <arg value="australasia" />
+      <arg value="europe" />
+      <arg value="northamerica" />
+      <arg value="southamerica" />
+      <arg value="pacificnew" />
+      <arg value="etcetera" />
+      <arg value="backward" />
+      <arg value="systemv" />
+      <arg value="solar87" />
+      <arg value="solar88" />
+      <arg value="solar89" />
+    </ant:java>
+  </postGoal>
+  
 </project>
diff --git a/JodaTime/project.xml b/JodaTime/project.xml
index 99692b2ea..9e0f262b3 100644
--- a/JodaTime/project.xml
+++ b/JodaTime/project.xml
@@ -5,7 +5,7 @@
   <id>joda-time</id>
   <name>Joda time</name>
   <groupId>joda-time</groupId>
-  <currentVersion>0.5</currentVersion>
+  <currentVersion>0.91</currentVersion>
   <organization>
     <name>Joda.org</name>
     <url>http://www.joda.org</url>
@@ -16,12 +16,12 @@
   <logo>http://sourceforge.net/sflogo.php?group_id=97367&amp;type=2</logo>
 
   <description>
-    Utility classes that aid integration between time and objects.
+    Date and time library to replace JDK date handling.
   </description>
-  <shortDescription>Joda primitive type utilities</shortDescription>
+  <shortDescription>Joda time</shortDescription>
   <url>http://joda-time.sourceforge.net</url>
   
-  <issueTrackingUrl>http://sourceforge.net/tracker/?atid=617889&group_id=97367&func=browse</issueTrackingUrl>
+  <issueTrackingUrl>http://sourceforge.net/tracker/?atid=617889&amp;group_id=97367&amp;func=browse</issueTrackingUrl>
   
   <siteAddress>shell.sourceforge.net</siteAddress>
   <siteDirectory>/home/groups/j/jo/joda-time/htdocs/</siteDirectory>

From 1ba4f9861a0cfbc32c56efced3619874a43ec5dd Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Thu, 18 Dec 2003 22:04:55 +0000
Subject: [PATCH 004/143] Add more ignores

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@9 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/.cvsignore | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/JodaTime/.cvsignore b/JodaTime/.cvsignore
index f0ca06bba..42efc53d2 100644
--- a/JodaTime/.cvsignore
+++ b/JodaTime/.cvsignore
@@ -3,3 +3,7 @@
 target
 bin
 build.properties
+velocity.log
+maven.log
+jcoverage.ser
+build

From 0e07ac6b2cff63550d7df336355ca63cc05aa40b Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Fri, 19 Dec 2003 02:07:36 +0000
Subject: [PATCH 005/143] Move from Joda CVS

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@10 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/.cvsignore                       |    1 +
 .../org/joda/example/time/AgeCalculator.java  |   85 +-
 .../joda/example/time/DateTimeBrowser.java    |   46 +-
 .../example/time/DateTimePerformance.java     |  181 ++-
 .../java/org/joda/time/AbstractDateTime.java  |  916 +++++-------
 .../time/AbstractDateTimeFieldProperty.java   |  359 +++++
 .../java/org/joda/time/AbstractDuration.java  | 1274 +++++++++++++++++
 .../java/org/joda/time/AbstractInstant.java   |  361 ++++-
 .../org/joda/time/AbstractPartialInstant.java |  452 ++++++
 .../src/java/org/joda/time/Chronology.java    |  401 ++++--
 JodaTime/src/java/org/joda/time/DateOnly.java |  486 +++++++
 JodaTime/src/java/org/joda/time/DateTime.java |  555 ++++---
 .../org/joda/time/DateTimeComparator.java     |  105 +-
 .../java/org/joda/time/DateTimeConstants.java |   53 +-
 .../src/java/org/joda/time/DateTimeField.java |  503 ++-----
 .../org/joda/time/DateTimeFieldProperty.java  |  319 ++---
 .../src/java/org/joda/time/DateTimeZone.java  |  241 ++--
 JodaTime/src/java/org/joda/time/Duration.java |  255 ++++
 .../src/java/org/joda/time/DurationField.java |  317 ++++
 .../src/java/org/joda/time/DurationType.java  |  723 ++++++++++
 JodaTime/src/java/org/joda/time/Instant.java  |  119 +-
 .../java/org/joda/time/MutableDateTime.java   | 1141 +++++++--------
 .../time/MutableDateTimeFieldProperty.java    |  111 +-
 .../java/org/joda/time/MutableDuration.java   |  445 ++++++
 .../java/org/joda/time/PartialInstant.java    |  190 +++
 .../org/joda/time/ReadWritableDateTime.java   |  373 +++++
 .../org/joda/time/ReadWritableDuration.java   |  280 ++++
 .../org/joda/time/ReadWritableInstant.java    |  100 +-
 .../java/org/joda/time/ReadableDateTime.java  |   72 +-
 .../java/org/joda/time/ReadableDuration.java  |  311 ++++
 .../java/org/joda/time/ReadableInstant.java   |   47 +-
 JodaTime/src/java/org/joda/time/TimeOnly.java |  413 ++++++
 .../time/chrono/AbstractDateTimeField.java    |  621 ++++++++
 .../time/chrono/AbstractDurationField.java    |  199 +++
 .../joda/time/chrono/DecoratedChronology.java |  129 ++
 ...Field.java => DecoratedDateTimeField.java} |  140 +-
 .../time/chrono/DecoratedDurationField.java   |  137 ++
 ...ronology.java => DelegatedChronology.java} |  167 ++-
 .../time/chrono/DelegatedDateTimeField.java   |  240 ++++
 .../time/chrono/DelegatedDurationField.java   |  179 +++
 .../time/chrono/DividedDateTimeField.java     |  186 +--
 .../time/chrono/FractionalDateTimeField.java  |  238 ---
 .../time/chrono/ImpreciseDateTimeField.java   |  237 +++
 .../joda/time/chrono/LenientChronology.java   |  369 +++++
 .../time/chrono/LenientDateTimeField.java     |  109 ++
 .../org/joda/time/chrono/LimitChronology.java |  830 +++++++++++
 .../joda/time/chrono/LimitDateTimeField.java  |  306 ----
 .../joda/time/chrono/MillisDurationField.java |  187 +++
 .../time/chrono/NonZeroDateTimeField.java     |   98 +-
 .../joda/time/chrono/OffsetDateTimeField.java |  118 +-
 .../time/chrono/PreciseDateTimeField.java     |  170 +++
 .../chrono/PreciseDurationDateTimeField.java  |  225 +++
 .../time/chrono/PreciseDurationField.java     |  151 ++
 .../time/chrono/RemainderDateTimeField.java   |  179 ++-
 .../joda/time/chrono/ScaledDurationField.java |  151 ++
 .../joda/time/chrono/StrictChronology.java    |  369 +++++
 .../joda/time/chrono/StrictDateTimeField.java |  107 ++
 .../time/chrono/UnsupportedDateTimeField.java |  433 ++++++
 .../time/chrono/UnsupportedDurationField.java |  272 ++++
 .../src/java/org/joda/time/chrono/Utils.java  |  225 +++
 .../org/joda/time/chrono/ZonedChronology.java |  531 +++++--
 .../chrono/buddhist/BuddhistChronology.java   |  369 ++++-
 .../buddhist/BuddhistEraDateTimeField.java    |  116 +-
 .../joda/time/chrono/buddhist/package.html    |   69 +-
 .../time/chrono/gj/CutoverChronology.java     |  581 +++++---
 .../time/chrono/gj/GJCenturyChronology.java   |   84 +-
 .../org/joda/time/chrono/gj/GJChronology.java |  196 ++-
 .../chrono/gj/GJDayOfMonthDateTimeField.java  |  118 +-
 .../chrono/gj/GJDayOfWeekDateTimeField.java   |  131 +-
 .../chrono/gj/GJDayOfYearDateTimeField.java   |  108 +-
 .../time/chrono/gj/GJEraDateTimeField.java    |  124 +-
 .../joda/time/chrono/gj/GJLocaleSymbols.java  |   32 +-
 .../chrono/gj/GJMonthOfYearDateTimeField.java |  132 +-
 .../gj/GJWeekOfWeekyearDateTimeField.java     |  111 +-
 .../chrono/gj/GJWeekyearDateTimeField.java    |  138 +-
 .../time/chrono/gj/GJYearDateTimeField.java   |  216 +--
 .../chrono/gj/GJYearOfEraDateTimeField.java   |   77 +-
 .../time/chrono/gj/GJZonedChronology.java     |   76 +-
 .../time/chrono/gj/GregorianChronology.java   |    3 +
 .../joda/time/chrono/gj/JulianChronology.java |  100 +-
 .../gj/JulianWithYearZeroChronology.java      |    3 +
 .../time/chrono/gj/ProlepticChronology.java   |  264 +++-
 .../java/org/joda/time/chrono/gj/package.html |   78 +-
 .../joda/time/chrono/iso/ISOChronology.java   |   75 +-
 .../org/joda/time/chrono/iso/package.html     |   72 +-
 .../java/org/joda/time/chrono/package.html    |   67 +-
 .../joda/time/convert/AbstractConverter.java  |  165 +++
 .../joda/time/convert/CalendarConverter.java  |  149 ++
 .../java/org/joda/time/convert/Converter.java |   70 +
 .../joda/time/convert/ConverterManager.java   |  302 ++++
 .../org/joda/time/convert/ConverterSet.java   |  370 +++++
 .../org/joda/time/convert/DateConverter.java  |   99 ++
 .../joda/time/convert/DurationConverter.java  |   73 +
 .../joda/time/convert/InstantConverter.java   |  132 ++
 .../org/joda/time/convert/LongConverter.java  |  108 ++
 .../time/convert/PartialInstantConverter.java |  156 ++
 .../convert/ReadableDurationConverter.java    |   99 ++
 .../convert/ReadableInstantConverter.java     |  144 ++
 .../joda/time/convert/StringConverter.java    |  123 ++
 .../java/org/joda/time/convert/package.html   |   68 +
 .../format/AbstractDateTimeFormatter.java     |  157 +-
 .../format/AbstractDurationFormatter.java     |  111 ++
 .../org/joda/time/format/DateTimeFormat.java  |  576 ++++++--
 .../joda/time/format/DateTimeFormatter.java   |  240 +---
 .../time/format/DateTimeFormatterBuilder.java |  710 +++------
 .../org/joda/time/format/DateTimeParser.java  |   87 +-
 .../time/format/DateTimeParserBucket.java     |   47 +-
 .../org/joda/time/format/DateTimePrinter.java |  103 +-
 .../joda/time/format/DurationFieldAffix.java  |   70 +
 .../joda/time/format/DurationFormatter.java   |   67 +
 .../time/format/DurationFormatterBuilder.java |  957 +++++++++++++
 .../org/joda/time/format/DurationParser.java  |  109 ++
 .../org/joda/time/format/DurationPrinter.java |  121 ++
 .../org/joda/time/format/FormatUtils.java     |   35 +-
 .../joda/time/format/ISODateTimeFormat.java   |   83 +-
 .../java/org/joda/time/format/package.html    |   73 +-
 JodaTime/src/java/org/joda/time/package.html  |  211 ++-
 .../org/joda/time/tz/CachedDateTimeZone.java  |   61 +-
 .../org/joda/time/tz/DateTimeZoneBuilder.java |  224 +--
 .../joda/time/tz/DateTimeZonePermission.java  |   78 +
 .../org/joda/time/tz/DefaultNameProvider.java |    2 +
 .../org/joda/time/tz/FixedDateTimeZone.java   |   22 +-
 .../org/joda/time/tz/ZoneInfoCompiler.java    |  105 +-
 .../org/joda/time/tz/ZoneInfoProvider.java    |   44 +-
 .../src/java/org/joda/time/tz/package.html    |   68 +-
 .../src/java/org/joda/time/tz/src/Readme.txt  |    2 +-
 JodaTime/src/java/org/joda/time/tz/src/asia   |   51 +-
 .../src/java/org/joda/time/tz/src/australasia |  101 +-
 .../src/java/org/joda/time/tz/src/backward    |    4 +-
 JodaTime/src/java/org/joda/time/tz/src/europe |   40 +-
 .../java/org/joda/time/tz/src/northamerica    |  223 ++-
 .../java/org/joda/time/tz/src/southamerica    |   39 +-
 .../test/time/AbstractTestDateTimeCommon.java |    3 -
 .../src/test/org/joda/test/time/BulkTest.java |   20 +-
 .../org/joda/test/time/ClassLoadTest.java     |   92 ++
 .../org/joda/test/time/TestConstructors.java  |   26 +-
 .../test/time/TestDateTimeComparator.java     |   22 +-
 .../joda/test/time/TestDateTimeFormat.java    |  346 ++---
 .../test/org/joda/test/time/TestMDTAdd.java   |   22 +-
 .../org/joda/test/time/TestMDTAddWrapped.java |   20 +-
 .../test/org/joda/test/time/TestMDTGet.java   |   27 +-
 .../test/org/joda/test/time/TestMDTSet.java   |   22 +-
 .../org/joda/test/time/chrono/gj/Test.java    |   29 +
 .../test/time/chrono/gj/TestGJChronology.java |   25 +
 .../time/chrono/gj/TestGJDateTimeField.java   |   22 +-
 .../time/chrono/gj/TestGJDayOfMonthField.java |   16 +-
 .../time/chrono/gj/TestGJDayOfWeekField.java  |   30 +-
 .../time/chrono/gj/TestGJDayOfYearField.java  |   18 +-
 .../chrono/gj/TestGJMonthOfYearField.java     |   43 +-
 .../chrono/gj/TestGJWeekOfWeekyearField.java  |   17 +-
 .../time/chrono/gj/TestGJWeekyearField.java   |   16 +-
 .../test/time/chrono/gj/TestGJYearField.java  |   20 +-
 .../chrono/gj/TestGregorianChronology.java    |   12 +
 .../time/chrono/gj/TestJulianChronology.java  |   12 +
 .../chrono/gj/TestJulianDayOfMonthField.java  |    2 +-
 .../chrono/gj/TestJulianMonthOfYearField.java |   22 +-
 .../chrono/gj/TestJulianWeekyearField.java    |   14 +-
 .../time/chrono/gj/TestJulianYearField.java   |   14 +-
 .../test/time/gj/TestGJYearDateTimeField.java |    2 +-
 .../time/gj/TestGJYearOfEraDateTimeField.java |    2 +-
 160 files changed, 23062 insertions(+), 6611 deletions(-)
 create mode 100644 JodaTime/src/.cvsignore
 create mode 100644 JodaTime/src/java/org/joda/time/AbstractDateTimeFieldProperty.java
 create mode 100644 JodaTime/src/java/org/joda/time/AbstractDuration.java
 create mode 100644 JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
 create mode 100644 JodaTime/src/java/org/joda/time/DateOnly.java
 create mode 100644 JodaTime/src/java/org/joda/time/Duration.java
 create mode 100644 JodaTime/src/java/org/joda/time/DurationField.java
 create mode 100644 JodaTime/src/java/org/joda/time/DurationType.java
 create mode 100644 JodaTime/src/java/org/joda/time/MutableDuration.java
 create mode 100644 JodaTime/src/java/org/joda/time/PartialInstant.java
 create mode 100644 JodaTime/src/java/org/joda/time/ReadWritableDateTime.java
 create mode 100644 JodaTime/src/java/org/joda/time/ReadWritableDuration.java
 create mode 100644 JodaTime/src/java/org/joda/time/ReadableDuration.java
 create mode 100644 JodaTime/src/java/org/joda/time/TimeOnly.java
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/AbstractDateTimeField.java
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/AbstractDurationField.java
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/DecoratedChronology.java
 rename JodaTime/src/java/org/joda/time/chrono/{DelegateDateTimeField.java => DecoratedDateTimeField.java} (52%)
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/DecoratedDurationField.java
 rename JodaTime/src/java/org/joda/time/chrono/{DelegateChronology.java => DelegatedChronology.java} (66%)
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/DelegatedDateTimeField.java
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/DelegatedDurationField.java
 delete mode 100644 JodaTime/src/java/org/joda/time/chrono/FractionalDateTimeField.java
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/ImpreciseDateTimeField.java
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/LenientChronology.java
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/LenientDateTimeField.java
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/LimitChronology.java
 delete mode 100644 JodaTime/src/java/org/joda/time/chrono/LimitDateTimeField.java
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/MillisDurationField.java
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/PreciseDateTimeField.java
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/PreciseDurationDateTimeField.java
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/PreciseDurationField.java
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/ScaledDurationField.java
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/StrictChronology.java
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/StrictDateTimeField.java
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/UnsupportedDateTimeField.java
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/UnsupportedDurationField.java
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/Utils.java
 create mode 100644 JodaTime/src/java/org/joda/time/convert/AbstractConverter.java
 create mode 100644 JodaTime/src/java/org/joda/time/convert/CalendarConverter.java
 create mode 100644 JodaTime/src/java/org/joda/time/convert/Converter.java
 create mode 100644 JodaTime/src/java/org/joda/time/convert/ConverterManager.java
 create mode 100644 JodaTime/src/java/org/joda/time/convert/ConverterSet.java
 create mode 100644 JodaTime/src/java/org/joda/time/convert/DateConverter.java
 create mode 100644 JodaTime/src/java/org/joda/time/convert/DurationConverter.java
 create mode 100644 JodaTime/src/java/org/joda/time/convert/InstantConverter.java
 create mode 100644 JodaTime/src/java/org/joda/time/convert/LongConverter.java
 create mode 100644 JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java
 create mode 100644 JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java
 create mode 100644 JodaTime/src/java/org/joda/time/convert/ReadableInstantConverter.java
 create mode 100644 JodaTime/src/java/org/joda/time/convert/StringConverter.java
 create mode 100644 JodaTime/src/java/org/joda/time/convert/package.html
 create mode 100644 JodaTime/src/java/org/joda/time/format/AbstractDurationFormatter.java
 create mode 100644 JodaTime/src/java/org/joda/time/format/DurationFieldAffix.java
 create mode 100644 JodaTime/src/java/org/joda/time/format/DurationFormatter.java
 create mode 100644 JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java
 create mode 100644 JodaTime/src/java/org/joda/time/format/DurationParser.java
 create mode 100644 JodaTime/src/java/org/joda/time/format/DurationPrinter.java
 create mode 100644 JodaTime/src/java/org/joda/time/tz/DateTimeZonePermission.java
 create mode 100644 JodaTime/src/test/org/joda/test/time/ClassLoadTest.java

diff --git a/JodaTime/src/.cvsignore b/JodaTime/src/.cvsignore
new file mode 100644
index 000000000..0883ff070
--- /dev/null
+++ b/JodaTime/src/.cvsignore
@@ -0,0 +1 @@
+tzdata
diff --git a/JodaTime/src/example/org/joda/example/time/AgeCalculator.java b/JodaTime/src/example/org/joda/example/time/AgeCalculator.java
index ecf8da613..6e3bd3927 100644
--- a/JodaTime/src/example/org/joda/example/time/AgeCalculator.java
+++ b/JodaTime/src/example/org/joda/example/time/AgeCalculator.java
@@ -63,7 +63,6 @@
 import java.awt.event.ActionListener;
 import java.awt.event.ItemEvent;
 import java.awt.event.ItemListener;
-import java.text.ParseException;
 
 import javax.swing.BorderFactory;
 import javax.swing.Box;
@@ -82,8 +81,8 @@
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTime;
-import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeZone;
+import org.joda.time.DurationField;
 import org.joda.time.chrono.iso.ISOChronology;
 
 /**
@@ -95,15 +94,14 @@
  */
 public class AgeCalculator extends JFrame {
     static final int
-        YEAR = 1,
-        MONTH_OF_YEAR = 2,
-        DAY_OF_MONTH = 3,
-        WEEKYEAR = 4,
-        WEEK_OF_WEEKYEAR = 5,
-        DAY_OF_WEEK = 6,
-        HOUR_OF_DAY = 101,
-        MINUTE_OF_HOUR = 102,
-        SECOND_OF_MINUTE = 103;
+        YEARS = 1,
+        MONTHS = 2,
+        DAYS = 3,
+        WEEKYEARS = 4,
+        WEEKS = 5,
+        HOURS = 101,
+        MINUTES = 102,
+        SECONDS = 103;
 
     public static void main(String[] args) throws Exception {
         new AgeCalculator().show();
@@ -223,21 +221,21 @@ public void itemStateChanged(ItemEvent e) {
 
         iFieldSets = new FieldSet[] {
             new FieldSet("Month Based", new FieldGroup[] {
-                new FieldGroup(listener, "Years", YEAR),
-                new FieldGroup(listener, "Months", MONTH_OF_YEAR),
-                new FieldGroup(listener, "Days", DAY_OF_MONTH),
-                new FieldGroup(listener, "Hours", HOUR_OF_DAY),
-                new FieldGroup(listener, "Minutes", MINUTE_OF_HOUR),
-                new FieldGroup(listener, "Seconds", SECOND_OF_MINUTE)
+                new FieldGroup(listener, "Years", YEARS),
+                new FieldGroup(listener, "Months", MONTHS),
+                new FieldGroup(listener, "Days", DAYS),
+                new FieldGroup(listener, "Hours", HOURS),
+                new FieldGroup(listener, "Minutes", MINUTES),
+                new FieldGroup(listener, "Seconds", SECONDS)
             })
             ,
             new FieldSet("Week Based", new FieldGroup[] {
-                new FieldGroup(listener, "Weekyears", WEEKYEAR),
-                new FieldGroup(listener, "Weeks", WEEK_OF_WEEKYEAR),
-                new FieldGroup(listener, "Days", DAY_OF_WEEK),
-                new FieldGroup(listener, "Hours", HOUR_OF_DAY),
-                new FieldGroup(listener, "Minutes", MINUTE_OF_HOUR),
-                new FieldGroup(listener, "Seconds", SECOND_OF_MINUTE)
+                new FieldGroup(listener, "Weekyears", WEEKYEARS),
+                new FieldGroup(listener, "Weeks", WEEKS),
+                new FieldGroup(listener, "Days", DAYS),
+                new FieldGroup(listener, "Hours", HOURS),
+                new FieldGroup(listener, "Minutes", MINUTES),
+                new FieldGroup(listener, "Seconds", SECONDS)
             })
         };
 
@@ -263,7 +261,7 @@ private void updateResults() {
                 iFieldSets[i].updateResults(minuend, subtrahend);
             }
         }
-        catch (ParseException e) {
+        catch (IllegalArgumentException e) {
             for (int i=0; i<iFieldSets.length; i++) {
                 iFieldSets[i].setResultsText("");
             }
@@ -287,41 +285,38 @@ public long updateResult(long minuend, long subtrahend) {
             // Because time zone can be dynamically changed, field must be
             // dynamically acquired.
 
-            DateTimeField field;
+            DurationField field;
             switch (iFieldType) {
-            case YEAR:
-                field = iChronology.year();
+            case YEARS:
+                field = iChronology.years();
                 break;
-            case MONTH_OF_YEAR:
-                field = iChronology.monthOfYear();
+            case MONTHS:
+                field = iChronology.months();
                 break;
-            case DAY_OF_MONTH:
-                field = iChronology.dayOfMonth();
+            case DAYS:
+                field = iChronology.days();
                 break;
-            case WEEKYEAR:
-                field = iChronology.weekyear();
+            case WEEKYEARS:
+                field = iChronology.weekyears();
                 break;
-            case WEEK_OF_WEEKYEAR:
-                field = iChronology.weekOfWeekyear();
+            case WEEKS:
+                field = iChronology.weeks();
                 break;
-            case DAY_OF_WEEK:
-                field = iChronology.dayOfWeek();
+            case HOURS:
+                field = iChronology.hours();
                 break;
-            case HOUR_OF_DAY:
-                field = iChronology.hourOfDay();
+            case MINUTES:
+                field = iChronology.minutes();
                 break;
-            case MINUTE_OF_HOUR:
-                field = iChronology.minuteOfHour();
-                break;
-            case SECOND_OF_MINUTE: default:
-                field = iChronology.secondOfMinute();
+            case SECONDS: default:
+                field = iChronology.seconds();
                 break;
             }
 
             String textToSet = "";
 
             if (iCheckbox.isSelected()) {
-                long difference = field.getDifference(minuend, subtrahend);
+                long difference = field.getDifferenceAsLong(minuend, subtrahend);
                 textToSet = Long.toString(difference);
                 subtrahend = field.add(subtrahend, difference);
             }
diff --git a/JodaTime/src/example/org/joda/example/time/DateTimeBrowser.java b/JodaTime/src/example/org/joda/example/time/DateTimeBrowser.java
index 1f18e095c..3597a4563 100644
--- a/JodaTime/src/example/org/joda/example/time/DateTimeBrowser.java
+++ b/JodaTime/src/example/org/joda/example/time/DateTimeBrowser.java
@@ -58,17 +58,39 @@
 /*
  * Import required Java packages.
  */
-import java.awt.*;
-import java.awt.event.*;
-import javax.swing.*;
-import javax.swing.table.*;
-import java.io.*;
-import java.util.*;
-import java.text.*;
-/*
- * Import required Joda packages.
- */
-import org.joda.time.*;
+import java.awt.Dimension;
+import java.awt.Toolkit;
+import java.awt.event.ActionEvent;
+import java.awt.event.WindowAdapter;
+import java.awt.event.WindowEvent;
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.PrintStream;
+import java.text.DateFormat;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.TimeZone;
+
+import javax.swing.AbstractAction;
+import javax.swing.Action;
+import javax.swing.JFileChooser;
+import javax.swing.JFrame;
+import javax.swing.JMenu;
+import javax.swing.JMenuBar;
+import javax.swing.JMenuItem;
+import javax.swing.JScrollPane;
+import javax.swing.JTable;
+import javax.swing.WindowConstants;
+import javax.swing.table.TableColumn;
+import javax.swing.table.TableColumnModel;
+
+import org.joda.time.DateTime;
 
 /** DateTimeBrowser is a Java Swing application which reads a file contining
  * strings and displays DateTime values in a JTable.<p>
@@ -381,7 +403,7 @@ private DateTime getADate(String s) {
         {
             retDT = new DateTime( s );
         } // the try
-        catch(ParseException pe)
+        catch(IllegalArgumentException pe)
         {
             // ignore it here, caller sees null
         } // the catch
diff --git a/JodaTime/src/example/org/joda/example/time/DateTimePerformance.java b/JodaTime/src/example/org/joda/example/time/DateTimePerformance.java
index 4e2d28345..279a281d9 100644
--- a/JodaTime/src/example/org/joda/example/time/DateTimePerformance.java
+++ b/JodaTime/src/example/org/joda/example/time/DateTimePerformance.java
@@ -64,7 +64,7 @@
 import org.joda.time.DateTime;
 import org.joda.time.MutableDateTime;
 import org.joda.time.chrono.gj.GJChronology;
-import org.joda.time.chrono.iso.ISOChronology;
+
 /**
  * DateTimePerformance provides various comparisons between the Java supplied
  * Date classes and the Joda ones.
@@ -110,51 +110,63 @@ public static void main(String[] args) {
      */
     public DateTimePerformance() throws Exception {
         checkJodaConstructor1();
+        checkJISOConstructor1();
         checkGCalConstructor1();
         checkDateConstructor1();
         
         checkJodaConstructor2();
+        checkJISOConstructor2();
         checkGCalConstructor2();
         checkDateConstructor2();
         
         checkJodaConstructor3();
+        checkJISOConstructor3();
         checkGCalConstructor3();
         checkDateConstructor3();
         
         checkJodaGetYear();
+        checkJISOGetYear();
         checkGCalGetYear();
         checkDateGetYear();
         
 //        checkJodaGetMonth();
+//        checkJISOGetMonth();
 //        checkGCalGetMonth();
 //        checkDateGetMonth();
         
 //        checkJodaGetDay();
+//        checkJISOGetDay();
 //        checkGCalGetDay();
 //        checkDateGetDay();
         
         checkJodaGetHour();
+        checkJISOGetHour();
         checkGCalGetHour();
         checkDateGetHour();
         
         checkJodaSetYear();
+        checkJISOSetYear();
         checkGCalSetYear();
         checkDateSetYear();
         
         checkJodaSetGetYear();
+        checkJISOSetGetYear();
         checkGCalSetGetYear();
         checkDateSetGetYear();
         
         checkJodaSetHour();
+        checkJISOSetHour();
         checkGCalSetHour();
         checkDateSetHour();
         
         checkJodaSetGetHour();
+        checkJISOSetGetHour();
         checkGCalSetGetHour();
         checkDateSetGetHour();
         
         System.out.println("");
         long jodaTotal = 0;
+        long jisoTotal = 0;
         long gcalTotal = 0;
         long dateTotal = 0;
         for (Iterator it = resultList.iterator(); it.hasNext();) {
@@ -162,6 +174,8 @@ public DateTimePerformance() throws Exception {
             System.out.println(res.object + "." + res.name + ": " + res.avg + "ns");
             if (res.object.equals("Joda")) {
                 jodaTotal += res.avg;
+            } else if (res.object.equals("JISO")) {
+                jisoTotal += res.avg;
             } else if (res.object.equals("GCal")) {
                 gcalTotal += res.avg;
             } else if (res.object.equals("Date")) {
@@ -170,6 +184,7 @@ public DateTimePerformance() throws Exception {
             }
         }
         System.out.println("Joda: " + jodaTotal);
+        System.out.println("JISO: " + jisoTotal);
         System.out.println("GCal: " + gcalTotal);
         System.out.println("Date: " + dateTotal);
     }
@@ -181,7 +196,7 @@ private void checkJodaConstructor1() {
         int COUNT = COUNT_SLOW;
         DateTime dt = new DateTime(GJChronology.getInstance());
         for (int i = 0; i < AVERAGE; i++) {
-            start("Joda", "new");
+            start("Joda", "new()");
             for (int j = 0; j < COUNT; j++) {
                 dt = new DateTime(GJChronology.getInstance());
                 if (dt == null) {System.out.println("Anti optimise");}
@@ -190,11 +205,24 @@ private void checkJodaConstructor1() {
         }
     }
 
+    private void checkJISOConstructor1() {
+        int COUNT = COUNT_SLOW;
+        DateTime dt = new DateTime();
+        for (int i = 0; i < AVERAGE; i++) {
+            start("JISO", "new()");
+            for (int j = 0; j < COUNT; j++) {
+                dt = new DateTime();
+                if (dt == null) {System.out.println("Anti optimise");}
+            }
+            end(COUNT);
+        }
+    }
+
     private void checkGCalConstructor1() {
         int COUNT = COUNT_SLOW;
         GregorianCalendar dt = new GregorianCalendar();
         for (int i = 0; i < AVERAGE; i++) {
-            start("GCal", "new");
+            start("GCal", "new()");
             for (int j = 0; j < COUNT; j++) {
                 dt = new GregorianCalendar();
                 if (dt == null) {System.out.println("Anti optimise");}
@@ -207,7 +235,7 @@ private void checkDateConstructor1() {
         int COUNT = COUNT_SLOW;
         Date dt = new Date();
         for (int i = 0; i < AVERAGE; i++) {
-            start("Date", "new");
+            start("Date", "new()");
             for (int j = 0; j < COUNT; j++) {
                 dt = new Date();
                 if (dt == null) {System.out.println("Anti optimise");}
@@ -232,6 +260,19 @@ private void checkJodaConstructor2() {
         }
     }
 
+    private void checkJISOConstructor2() {
+        int COUNT = COUNT_VERY_FAST;
+        DateTime dt = new DateTime(12345L);
+        for (int i = 0; i < AVERAGE; i++) {
+            start("JISO", "new(millis)");
+            for (int j = 0; j < COUNT; j++) {
+                dt = new DateTime(12345L);
+                if (dt == null) {System.out.println("Anti optimise");}
+            }
+            end(COUNT);
+        }
+    }
+
     private void checkGCalConstructor2() {
         int COUNT = COUNT_SLOW;
         GregorianCalendar dt = new GregorianCalendar();
@@ -264,14 +305,26 @@ private void checkDateConstructor2() {
     
     private void checkJodaConstructor3() {
         int COUNT = COUNT_SLOW;
-        DateTime dt = new DateTime(12345L, GJChronology.getInstance());
-        MutableDateTime mdt = new MutableDateTime(ISOChronology.getInstance());
+        DateTime dt = new DateTime(1972, 10, 1, 0, 0, 0, 0,
+                                   GJChronology.getInstance());
         for (int i = 0; i < AVERAGE; i++) {
             start("Joda", "new(YMD)");
             for (int j = 0; j < COUNT; j++) {
-                mdt = new MutableDateTime(ISOChronology.getInstance());
-                mdt.setDate(1972, 10, 1);
-                dt = mdt.toDateTime();
+                dt = new DateTime(1972, 10, 1, 0, 0, 0, 0,
+                                  GJChronology.getInstance());
+                if (dt == null) {System.out.println("Anti optimise");}
+            }
+            end(COUNT);
+        }
+    }
+
+    private void checkJISOConstructor3() {
+        int COUNT = COUNT_SLOW;
+        DateTime dt = new DateTime(1972, 10, 1, 0, 0, 0, 0);
+        for (int i = 0; i < AVERAGE; i++) {
+            start("JISO", "new(YMD)");
+            for (int j = 0; j < COUNT; j++) {
+                dt = new DateTime(1972, 10, 1, 0, 0, 0, 0);
                 if (dt == null) {System.out.println("Anti optimise");}
             }
             end(COUNT);
@@ -320,6 +373,19 @@ private void checkJodaGetYear() {
         }
     }
 
+    private void checkJISOGetYear() {
+        int COUNT = COUNT_VERY_FAST;
+        DateTime dt = new DateTime();
+        for (int i = 0; i < AVERAGE; i++) {
+            start("JISO", "getYear");
+            for (int j = 0; j < COUNT; j++) {
+                int val = dt.getYear();
+                if (val == 0) {System.out.println("Anti optimise");}
+            }
+            end(COUNT);
+        }
+    }
+
     private void checkGCalGetYear() {
         int COUNT = COUNT_VERY_FAST;
         GregorianCalendar dt = new GregorianCalendar();
@@ -362,6 +428,19 @@ private void checkJodaGetMonth() {
         }
     }
 
+    private void checkJISOGetMonth() {
+        int COUNT = COUNT_VERY_FAST;
+        DateTime dt = new DateTime();
+        for (int i = 0; i < AVERAGE; i++) {
+            start("JISO", "getMonth");
+            for (int j = 0; j < COUNT; j++) {
+                int val = dt.getMonthOfYear();
+                if (val == 0) {System.out.println("Anti optimise");}
+            }
+            end(COUNT);
+        }
+    }
+
     private void checkGCalGetMonth() {
         int COUNT = COUNT_VERY_FAST;
         GregorianCalendar dt = new GregorianCalendar();
@@ -404,6 +483,19 @@ private void checkJodaGetDay() {
         }
     }
 
+    private void checkJISOGetDay() {
+        int COUNT = COUNT_VERY_FAST;
+        DateTime dt = new DateTime();
+        for (int i = 0; i < AVERAGE; i++) {
+            start("JISO", "getDay");
+            for (int j = 0; j < COUNT; j++) {
+                int val = dt.getDayOfMonth();
+                if (val == 0) {System.out.println("Anti optimise");}
+            }
+            end(COUNT);
+        }
+    }
+
     private void checkGCalGetDay() {
         int COUNT = COUNT_VERY_FAST;
         GregorianCalendar dt = new GregorianCalendar();
@@ -446,6 +538,19 @@ private void checkJodaGetHour() {
         }
     }
 
+    private void checkJISOGetHour() {
+        int COUNT = COUNT_VERY_FAST;
+        DateTime dt = new DateTime();
+        for (int i = 0; i < AVERAGE; i++) {
+            start("JISO", "getHour");
+            for (int j = 0; j < COUNT; j++) {
+                int val = dt.getHourOfDay();
+                if (val == -1) {System.out.println("Anti optimise");}
+            }
+            end(COUNT);
+        }
+    }
+
     private void checkGCalGetHour() {
         int COUNT = COUNT_VERY_FAST;
         GregorianCalendar dt = new GregorianCalendar();
@@ -489,6 +594,20 @@ private void checkJodaSetYear() {
         }
     }
 
+    private void checkJISOSetYear() {
+        int COUNT = COUNT_FAST;
+        // Is it fair to use only MutableDateTime here? You decide.
+        MutableDateTime dt = new MutableDateTime();
+        for (int i = 0; i < AVERAGE; i++) {
+            start("JISO", "setYear");
+            for (int j = 0; j < COUNT; j++) {
+                dt.setYear(1972);
+                if (dt == null) {System.out.println("Anti optimise");}
+            }
+            end(COUNT);
+        }
+    }
+
     private void checkGCalSetYear() {
         int COUNT = COUNT_VERY_FAST;
         GregorianCalendar dt = new GregorianCalendar();
@@ -533,6 +652,21 @@ private void checkJodaSetGetYear() {
         }
     }
 
+    private void checkJISOSetGetYear() {
+        int COUNT = COUNT_FAST;
+        // Is it fair to use only MutableDateTime here? You decide.
+        MutableDateTime dt = new MutableDateTime();
+        for (int i = 0; i < AVERAGE; i++) {
+            start("JISO", "setGetYear");
+            for (int j = 0; j < COUNT; j++) {
+                dt.setYear(1972);
+                int val = dt.getYear();
+                if (dt == null) {System.out.println("Anti optimise");}
+            }
+            end(COUNT);
+        }
+    }
+
     private void checkGCalSetGetYear() {
         int COUNT = COUNT_FAST;
         GregorianCalendar dt = new GregorianCalendar();
@@ -578,6 +712,20 @@ private void checkJodaSetHour() {
         }
     }
 
+    private void checkJISOSetHour() {
+        int COUNT = COUNT_VERY_FAST;
+        // Is it fair to use only MutableDateTime here? You decide.
+        MutableDateTime dt = new MutableDateTime();
+        for (int i = 0; i < AVERAGE; i++) {
+            start("JISO", "setHour");
+            for (int j = 0; j < COUNT; j++) {
+                dt.setHourOfDay(13);
+                if (dt == null) {System.out.println("Anti optimise");}
+            }
+            end(COUNT);
+        }
+    }
+
     private void checkGCalSetHour() {
         int COUNT = COUNT_VERY_FAST;
         GregorianCalendar dt = new GregorianCalendar();
@@ -622,6 +770,21 @@ private void checkJodaSetGetHour() {
         }
     }
 
+    private void checkJISOSetGetHour() {
+        int COUNT = COUNT_VERY_FAST;
+        // Is it fair to use only MutableDateTime here? You decide.
+        MutableDateTime dt = new MutableDateTime();
+        for (int i = 0; i < AVERAGE; i++) {
+            start("JISO", "setGetHour");
+            for (int j = 0; j < COUNT; j++) {
+                dt.setHourOfDay(13);
+                int val = dt.getHourOfDay();
+                if (dt == null) {System.out.println("Anti optimise");}
+            }
+            end(COUNT);
+        }
+    }
+
     private void checkGCalSetGetHour() {
         int COUNT = COUNT_VERY_FAST;
         GregorianCalendar dt = new GregorianCalendar();
diff --git a/JodaTime/src/java/org/joda/time/AbstractDateTime.java b/JodaTime/src/java/org/joda/time/AbstractDateTime.java
index 21a4cf641..108446cf0 100644
--- a/JodaTime/src/java/org/joda/time/AbstractDateTime.java
+++ b/JodaTime/src/java/org/joda/time/AbstractDateTime.java
@@ -53,337 +53,348 @@
  */
 package org.joda.time;
 
-import java.util.Calendar;
-import java.util.Date;
-import java.util.GregorianCalendar;
+import java.io.Serializable;
 import java.util.Locale;
 
-import org.joda.time.chrono.buddhist.BuddhistChronology;
-import org.joda.time.chrono.gj.GJChronology;
 import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.convert.InstantConverter;
+import org.joda.time.convert.ConverterManager;
 import org.joda.time.format.DateTimeFormat;
 import org.joda.time.format.ISODateTimeFormat;
 
 /**
- * AbstractDateTime provides the common behaviour for immutable datetime
- * classes.
+ * AbstractDateTime provides the common behaviour for datetime classes.
  * <p>
- * This class should generally not be used directly by API users. The 
- * {@link ReadableDateTime} interface should be used when different 
+ * This class should generally not be used directly by API users.
+ * The {@link ReadableDateTime} interface should be used when different 
  * kinds of date/time objects are to be referenced.
+ * <p>
+ * AbstractDateTime subclasses may be mutable and not thread-safe.
  *
  * @author Brian S O'Neill
+ * @author Stephen Colebourne
  * @since 1.0
  */
 public abstract class AbstractDateTime extends AbstractInstant
-        implements ReadableDateTime {
+    implements ReadableDateTime, Serializable {
 
-    // The following package-private static methods are used in the
-    // constructors for DateTime, DateOnly, TimeOnly, and MutableDateTime.
+    static final long serialVersionUID = 597501475466447837L;
 
     /**
-     * Validates the parameters and returns a suitable chronology.
+     * Selects the correct chronology to use for the chronology based constructors
+     * on subclasses.
      * 
      * @param chrono  the chronology to use, must not be null
      * @return the passed in Chronology
-     * @throws IllegalArgumentException if the chronology is null
      */
-    static Chronology selectChronology(Chronology chrono) {
+    private static Chronology selectChronology(Chronology chrono) {
         if (chrono == null) {
-            throw new IllegalArgumentException("The Chronology must not be null");
+            return ISOChronology.getInstance();
         }
         return chrono;
     }
 
-    /**
-     * Validates the parameters and returns a suitable chronology. If the
-     * instant's chronology is null, ISOChronology in the default time zone is
-     * returned.
-     * 
-     * @param instant  the instant to use, must not be null
-     * @return a suitable Chronology
-     * @throws IllegalArgumentException if the instant is null
-     */
-    static Chronology selectChronology(ReadableInstant instant) {
-        if (instant == null) {
-            throw new IllegalArgumentException("The ReadableInstant must not be null");
-        }
-        Chronology chrono = instant.getChronology();
-        if (chrono == null) {
-            chrono = ISOChronology.getInstance();
-        }
-        return chrono;
-    }
+    /** The millis from 1970-01-01T00:00:00Z */
+    private long iMillis;
+    /** The chronology to use */
+    private Chronology iChronology;
 
+    // Constructors
+    //-----------------------------------------------------------------------
     /**
-     * Validates the parameters and returns a suitable chronology. If the
-     * instant's chronology is null, ISOChronology in the given time zone is
-     * returned.
-     * 
-     * @param instant  the instant to use, must not be null
-     * @param zone  the time zone to use, must not be null
-     * @return a suitable Chronology
-     * @throws IllegalArgumentException if the instant or zone is null
+     * Constructs an instance set to the current system millisecond time
+     * using <code>ISOChronology</code> in the default time zone.
      */
-    static Chronology selectChronology(ReadableInstant instant, DateTimeZone zone) {
-        Chronology chrono = selectChronology(instant);
-        if (zone == null) {
-            throw new IllegalArgumentException("The DateTimeZone must not be null");
-        }
-        if (chrono.getDateTimeZone() != zone) {
-            chrono = chrono.withDateTimeZone(zone);
-            if (chrono == null) {
-                chrono = ISOChronology.getInstance(zone);
-            }
-        }
-        return chrono;
+    protected AbstractDateTime() {
+        super();
+        iChronology = ISOChronology.getInstance();
+        iMillis = System.currentTimeMillis();
     }
 
     /**
-     * Validates the parameters and returns a suitable chronology.
+     * Constructs an instance set to the current system millisecond time
+     * using <code>ISOChronology</code> in the specified time zone.
+     * <p>
+     * If the specified time zone is null, the default zone is used.
      *
-     * @param instant  the instant to use, must not be null
-     * @param chrono  the chronology to use, must not be null
-     * @return the passed in chronology
-     * @throws IllegalArgumentException if the instant or chronology is null
+     * @param zone  the time zone, null means default zone
      */
-    static Chronology selectChronology(ReadableInstant instant, Chronology chrono) {
-        if (instant == null) {
-            throw new IllegalArgumentException("The ReadableInstant must not be null");
-        }
-        return selectChronology(chrono);
+    protected AbstractDateTime(final DateTimeZone zone) {
+        super();
+        iChronology = ISOChronology.getInstance(zone);
+        iMillis = System.currentTimeMillis();
     }
 
     /**
-     * Validates the parameters and returns a suitable chronology. If the
-     * instant's chronology is null, ISOChronology in UTC is returned.
+     * Constructs an instance set to the current system millisecond time
+     * using the specified chronology.
+     * <p>
+     * If the chronology is null, <code>ISOChronology</code>
+     * in the default time zone is used.
      *
-     * <p>Note: This method does not guarantee returning a UTC chronology
-     * 
-     * @param instant  the instant to use, must not be null
-     * @return a suitable Chronology
-     * @throws IllegalArgumentException if the instant is null
+     * @param chronology  the chronology, null means ISOChronology in default zone
      */
-    static Chronology selectChronologyUTC(ReadableInstant instant) {
-        if (instant == null) {
-            throw new IllegalArgumentException("The ReadableInstant must not be null");
-        }
-        Chronology chrono = instant.getChronology();
-        if (chrono == null) {
-            chrono = ISOChronology.getInstanceUTC();
-        }
-        return chrono;
+    protected AbstractDateTime(final Chronology chronology) {
+        super();
+        iChronology = selectChronology(chronology);
+        iMillis = System.currentTimeMillis();
     }
 
+    //-----------------------------------------------------------------------
     /**
-     * Validates the parameters and returns a suitable chronology.
-     * 
-     * @param date  the date to be validated, must not be null
-     * @return a suitable Chronology
-     * @throws IllegalArgumentException if the date is null
+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z
+     * using <code>ISOChronology</code> in the default time zone.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
      */
-    static Chronology selectChronology(Date date) {
-        return selectChronology(date, ISOChronology.getInstance());
+    protected AbstractDateTime(final long instant) {
+        super();
+        iChronology = ISOChronology.getInstance();
+        iMillis = instant;
     }
 
     /**
-     * Validates the parameters and returns a suitable chronology.
-     * 
-     * @param date  the date to be validated, must not be null
-     * @param zone  the zone to use, must not be null
-     * @return a suitable Chronology
-     * @throws IllegalArgumentException if the date or zone is null
+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z
+     * using <code>ISOChronology</code> in the specified time zone.
+     * <p>
+     * If the specified time zone is null, the default zone is used.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
+     * @param zone  the time zone, null means default zone
      */
-    static Chronology selectChronology(Date date, DateTimeZone zone) {
-        return selectChronology(date, ISOChronology.getInstance(zone));
+    protected AbstractDateTime(final long instant, final DateTimeZone zone) {
+        super();
+        iChronology = ISOChronology.getInstance(zone);
+        iMillis = instant;
     }
 
     /**
-     * Validates the parameters and returns a suitable chronology.
-     * 
-     * @param date  the date to be validated, must not be null
-     * @param chrono  the chronology to use, must not be null
-     * @return a suitable Chronology
-     * @throws IllegalArgumentException if the date or chronology is null
+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z
+     * using the specified chronology.
+     * <p>
+     * If the chronology is null, <code>ISOChronology</code>
+     * in the default time zone is used.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
+     * @param chronology  the chronology, null means ISOChronology in default zone
      */
-    static Chronology selectChronology(Date date, Chronology chrono) {
-        if (date == null) {
-            throw new IllegalArgumentException("The Date must not be null");
-        }
-        return selectChronology(chrono);
+    protected AbstractDateTime(final long instant, final Chronology chronology) {
+        super();
+        iChronology = selectChronology(chronology);
+        iMillis = instant;
     }
 
+    //-----------------------------------------------------------------------
     /**
-     * Validates the parameters and returns a suitable chronology. The method
-     * is aware of GregorianCalendar and BuddhistCalendar and maps them
-     * accordingly. Other calendars map to ISO.
-     * 
-     * @param calendar  the calendar to be used, must not be null
-     * @return a suitable Chronology
-     * @throws IllegalArgumentException if the calendar is null
+     * Constructs an instance from an Object that represents a datetime.
+     * <p>
+     * If the object contains no chronology, <code>ISOChronology</code>
+     * in the default time zone is used.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     *
+     * @param instant  the datetime object, must not be null
+     * @throws IllegalArgumentException if the instant is null or invalid
      */
-    static Chronology selectChronology(Calendar calendar) {
-        if (calendar == null) {
-            throw new IllegalArgumentException("The Calendar must not be null");
-        }
-        DateTimeZone zone = null;
-        try {
-            zone = DateTimeZone.getInstance(calendar.getTimeZone());
-        } catch (IllegalArgumentException ex) {
-            return ISOChronology.getInstance();
-        }
-        return selectChronology(calendar, zone);
-    }
-
-    /**
-     * Validates the parameters and returns a suitable chronology. The method
-     * is aware of GregorianCalendar and BuddhistCalendar and maps them
-     * accordingly. Other calendars map to ISO.
-     * 
-     * @param calendar  the calendar to be used, must not be null
-     * @param zone  the time zone to use
-     * @return a suitable Chronology
-     * @throws IllegalArgumentException if the calendar is null
-     */
-    static Chronology selectChronology(Calendar calendar, DateTimeZone zone) {
-        if (calendar == null) {
-            throw new IllegalArgumentException("The Calendar must not be null");
-        }
-        if (zone == null) {
-            throw new IllegalArgumentException("The DateTimeZone must not be null");
-        }
-        if (calendar instanceof GregorianCalendar) {
-            GregorianCalendar gc = (GregorianCalendar) calendar;
-            return GJChronology.getInstance(zone, gc.getGregorianChange().getTime(), false);
-        } else if (calendar.getClass().getName().endsWith(".BuddhistCalendar")) {
-            return BuddhistChronology.getInstance(zone);
-        } else {
-            return ISOChronology.getInstance(zone);
-        }
+    protected AbstractDateTime(final Object instant) {
+        super();
+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
+        iChronology = converter.getChronology(instant);
+        iMillis = converter.getInstantMillis(instant);
     }
 
     /**
-     * Validates the parameters and returns a suitable chronology.
-     * 
-     * @param calendar  the calendar to be used, must not be null
-     * @param chrono  the chronology to use, must not be null
-     * @return a suitable Chronology
-     * @throws IllegalArgumentException if the calendar is null
+     * Constructs an instance from an Object that represents a datetime,
+     * forcing the time zone to that specified.
+     * <p>
+     * If the object contains no chronology, <code>ISOChronology</code> is used.
+     * If the specified time zone is null, the default zone is used.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     *
+     * @param instant  the datetime object, must not be null
+     * @param zone  the time zone, null means default time zone
+     * @throws IllegalArgumentException if the instant is null or invalid
      */
-    static Chronology selectChronology(Calendar calendar, Chronology chrono) {
-        if (calendar == null) {
-            throw new IllegalArgumentException("The Calendar must not be null");
-        }
-        return selectChronology(chrono);
+    protected AbstractDateTime(final Object instant, final DateTimeZone zone) {
+        super();
+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
+        iChronology = converter.getChronology(instant, zone);
+        iMillis = converter.getInstantMillis(instant, zone);
     }
 
     /**
-     * Validates the parameters and returns a suitable chronology.
-     * 
-     * @param string  the string to parse, must not be null
-     * @return a suitable Chronology
-     * @throws IllegalArgumentException if the string is null
+     * Constructs an instance from an Object that represents a datetime,
+     * using the specified chronology.
+     * <p>
+     * If the chronology is null, ISOChronology in the default time zone is used.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     *
+     * @param instant  the datetime object, must not be null
+     * @param chronology  the chronology, null means ISOChronology in default zone
+     * @throws IllegalArgumentException if the instant is null or invalid
      */
-    static Chronology selectChronology(String str) {
-        return selectChronology(str, ISOChronology.getInstance());
+    protected AbstractDateTime(final Object instant, final Chronology chronology) {
+        super();
+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
+        iChronology = converter.getChronology(instant, chronology);
+        iMillis = converter.getInstantMillis(instant, chronology);
     }
 
+    //-----------------------------------------------------------------------
     /**
-     * Validates the parameters and returns a suitable chronology.
-     * 
-     * @param string  the string to parse, must not be null
-     * @param zone  the zone to use, must not be null
-     * @return a suitable Chronology
-     * @throws IllegalArgumentException if the string or zone is null
-     */
-    static Chronology selectChronology(String str, DateTimeZone zone) {
-        return selectChronology(str, ISOChronology.getInstance(zone));
+     * Constructs an instance from datetime field values
+     * using <code>ISOChronology</code> in the default time zone.
+     *
+     * @param year  the year
+     * @param monthOfYear  the month of the year
+     * @param dayOfMonth  the day of the month
+     * @param hourOfDay  the hour of the day
+     * @param minuteOfHour  the minute of the hour
+     * @param secondOfMinute  the second of the minute
+     * @param millisOfSecond  the milisecond of the second
+     */
+    protected AbstractDateTime(
+            final int year,
+            final int monthOfYear,
+            final int dayOfMonth,
+            final int hourOfDay,
+            final int minuteOfHour,
+            final int secondOfMinute,
+            final int millisOfSecond) {
+        super();
+        iChronology = ISOChronology.getInstance();
+        iMillis = iChronology.getDateTimeMillis(
+            year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
     }
 
     /**
-     * Validates the parameters and returns a suitable chronology.
-     * 
-     * @param str  the string to parse, must not be null
-     * @param chrono  the chronology to use, must not be null
-     * @return a suitable Chronology
-     * @throws IllegalArgumentException if the string or chronology is null
-     */
-    static Chronology selectChronology(String str, Chronology chrono) {
-        if (str == null) {
-            throw new IllegalArgumentException("The String must not be null");
-        }
-        return selectChronology(chrono);
-    }
-
-    public AbstractDateTime() {
+     * Constructs an instance from datetime field values
+     * using <code>ISOChronology</code> in the specified time zone.
+     * <p>
+     * If the specified time zone is null, the default zone is used.
+     *
+     * @param year  the year
+     * @param monthOfYear  the month of the year
+     * @param dayOfMonth  the day of the month
+     * @param hourOfDay  the hour of the day
+     * @param minuteOfHour  the minute of the hour
+     * @param secondOfMinute  the second of the minute
+     * @param millisOfSecond  the milisecond of the second
+     * @param zone  the time zone, null means default time zone
+     */
+    protected AbstractDateTime(
+            final int year,
+            final int monthOfYear,
+            final int dayOfMonth,
+            final int hourOfDay,
+            final int minuteOfHour,
+            final int secondOfMinute,
+            final int millisOfSecond,
+            final DateTimeZone zone) {
         super();
+        iChronology = ISOChronology.getInstance(zone);
+        iMillis = iChronology.getDateTimeMillis(
+            year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
     }
 
-    // Date field access
-    //-----------------------------------------------------------------------
     /**
-     * Get the day of week field value.
+     * Constructs an instance from datetime field values
+     * using the specified chronology.
      * <p>
-     * The values for the day of week are defined in {@link DateTimeConstants}.
-     * 
-     * @return the day of week
-     */
-    public final int getDayOfWeek() {
-        return getChronology().dayOfWeek().get(getMillis());
+     * If the chronology is null, <code>ISOChronology</code>
+     * in the default time zone is used.
+     *
+     * @param year  the year
+     * @param monthOfYear  the month of the year
+     * @param dayOfMonth  the day of the month
+     * @param hourOfDay  the hour of the day
+     * @param minuteOfHour  the minute of the hour
+     * @param secondOfMinute  the second of the minute
+     * @param millisOfSecond  the milisecond of the second
+     * @param chronology  the chronology, null means ISOChronology in default zone
+     */
+    protected AbstractDateTime(
+            final int year,
+            final int monthOfYear,
+            final int dayOfMonth,
+            final int hourOfDay,
+            final int minuteOfHour,
+            final int secondOfMinute,
+            final int millisOfSecond,
+            final Chronology chronology) {
+        super();
+        iChronology = selectChronology(chronology);
+        iMillis = iChronology.getDateTimeMillis(
+            year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
     }
 
+    // Accessors
+    //-----------------------------------------------------------------------
     /**
-     * Get the day of month field value.
+     * Gets the milliseconds of the datetime instant from the Java epoch
+     * of 1970-01-01T00:00:00Z.
      * 
-     * @return the day of month
+     * @return the number of milliseconds since 1970-01-01T00:00:00Z
      */
-    public final int getDayOfMonth() {
-        return getChronology().dayOfMonth().get(getMillis());
+    public final long getMillis() {
+        return iMillis;
     }
 
     /**
-     * Get the day of year field value.
+     * Gets the milliseconds of the datetime instant from the Java epoch
+     * of 1970-01-01T00:00:00Z.
      * 
-     * @return the day of year
+     * @param base ignored
+     * @return the number of milliseconds since 1970-01-01T00:00:00Z
      */
-    public final int getDayOfYear() {
-        return getChronology().dayOfYear().get(getMillis());
+    public final long getMillis(ReadableInstant base) {
+        return iMillis;
     }
 
     /**
-     * Get the week of weekyear field value.
+     * Gets the milliseconds of the datetime instant from the Java epoch
+     * of 1970-01-01T00:00:00Z.
      * 
-     * @return the week of a week based year
+     * @param base ignored
+     * @param zone ignored
+     * @return the number of milliseconds since 1970-01-01T00:00:00Z
      */
-    public final int getWeekOfWeekyear() {
-        return getChronology().weekOfWeekyear().get(getMillis());
+    public final long getMillis(ReadableInstant base, DateTimeZone zone) {
+        return iMillis;
     }
 
     /**
-     * Get the weekyear field value.
+     * Gets the chronology of the datetime.
      * 
-     * @return the year of a week based year
+     * @return the Chronology that the datetime is using
      */
-    public final int getWeekyear() {
-        return getChronology().weekyear().get(getMillis());
+    public final Chronology getChronology() {
+        return iChronology;
     }
 
+    // Date field access
+    //-----------------------------------------------------------------------
     /**
-     * Get the month of year field value.
+     * Get the era field value.
      * 
-     * @return the month of year
+     * @return the era
      */
-    public final int getMonthOfYear() {
-        return getChronology().monthOfYear().get(getMillis());
+    public final int getEra() {
+        return getChronology().era().get(getMillis());
     }
 
     /**
-     * Get the year field value.
+     * Get the year of era field value.
      * 
-     * @return the year
+     * @return the year of era
      */
-    public final int getYear() {
-        return getChronology().year().get(getMillis());
+    public final int getCenturyOfEra() {
+        return getChronology().centuryOfEra().get(getMillis());
     }
 
     /**
@@ -405,79 +416,74 @@ public final int getYearOfCentury() {
     }
 
     /**
-     * Get the year of era field value.
+     * Get the year field value.
      * 
-     * @return the year of era
+     * @return the year
      */
-    public final int getCenturyOfEra() {
-        return getChronology().centuryOfEra().get(getMillis());
+    public final int getYear() {
+        return getChronology().year().get(getMillis());
     }
 
     /**
-     * Get the era field value.
+     * Get the weekyear field value.
      * 
-     * @return the era
-     */
-    public final int getEra() {
-        return getChronology().era().get(getMillis());
-    }
-
-    // Time field access
-    //-----------------------------------------------------------------------
-    /**
-     * Get the millis of second field value.
-     *
-     * @return the millis of second
+     * @return the year of a week based year
      */
-    public final int getMillisOfSecond() {
-        return getChronology().millisOfSecond().get(getMillis());
+    public final int getWeekyear() {
+        return getChronology().weekyear().get(getMillis());
     }
 
     /**
-     * Get the millis of day field value.
-     *
-     * @return the millis of day
+     * Get the month of year field value.
+     * 
+     * @return the month of year
      */
-    public final int getMillisOfDay() {
-        return getChronology().millisOfDay().get(getMillis());
+    public final int getMonthOfYear() {
+        return getChronology().monthOfYear().get(getMillis());
     }
 
     /**
-     * Get the second of minute field value.
-     *
-     * @return the second of minute
+     * Get the week of weekyear field value.
+     * 
+     * @return the week of a week based year
      */
-    public final int getSecondOfMinute() {
-        return getChronology().secondOfMinute().get(getMillis());
+    public final int getWeekOfWeekyear() {
+        return getChronology().weekOfWeekyear().get(getMillis());
     }
 
     /**
-     * Get the second of day field value.
-     *
-     * @return the second of day
+     * Get the day of year field value.
+     * 
+     * @return the day of year
      */
-    public final int getSecondOfDay() {
-        return getChronology().secondOfDay().get(getMillis());
+    public final int getDayOfYear() {
+        return getChronology().dayOfYear().get(getMillis());
     }
 
     /**
-     * Get the minute of hour field value.
-     *
-     * @return the minute of hour
+     * Get the day of month field value.
+     * <p>
+     * The values for the day of month are defined in {@link DateTimeConstants}.
+     * 
+     * @return the day of month
      */
-    public final int getMinuteOfHour() {
-        return getChronology().minuteOfHour().get(getMillis());
+    public final int getDayOfMonth() {
+        return getChronology().dayOfMonth().get(getMillis());
     }
 
     /**
-     * Get the minute of day field value.
-     *
-     * @return the minute of day
+     * Get the day of week field value.
+     * <p>
+     * The values for the day of week are defined in {@link DateTimeConstants}.
+     * 
+     * @return the day of week
      */
-    public final int getMinuteOfDay() {
-        return getChronology().minuteOfDay().get(getMillis());
+    public final int getDayOfWeek() {
+        return getChronology().dayOfWeek().get(getMillis());
     }
 
+    // Time field access
+    //-----------------------------------------------------------------------
     /**
      * Get the hour of day field value.
      *
@@ -487,314 +493,186 @@ public final int getHourOfDay() {
         return getChronology().hourOfDay().get(getMillis());
     }
 
-    // Conversion
-    //-----------------------------------------------------------------------
     /**
-     * Get this object as a DateTime.
-     * 
-     * @return a DateTime using the same millis
+     * Get the minute of day field value.
+     *
+     * @return the minute of day
      */
-    public final DateTime toDateTime() {
-        if (this instanceof DateTime) {
-            return (DateTime)this;
-        }
-        return new DateTime(this);
+    public final int getMinuteOfDay() {
+        return getChronology().minuteOfDay().get(getMillis());
     }
 
     /**
-     * Get this object as a DateTime.
-     * 
-     * @param zone time zone to apply
-     * @return a DateTime using the same millis
-     * @throws IllegalArgumentException if the time zone is null
+     * Get the minute of hour field value.
+     *
+     * @return the minute of hour
      */
-    public final DateTime toDateTime(DateTimeZone zone) {
-        if (zone == null) {
-            throw new IllegalArgumentException("The DateTimeZone must not be null");
-        }
-        if (this instanceof DateTime) {
-            DateTime dt = (DateTime)this;
-            if (dt.getDateTimeZone() == zone) {
-                return dt;
-            }
-        }
-        return new DateTime(this, zone);
+    public final int getMinuteOfHour() {
+        return getChronology().minuteOfHour().get(getMillis());
     }
 
     /**
-     * Get this object as a DateTime.
-     * 
-     * @param chronology chronology to apply
-     * @return a DateTime using the same millis
-     * @throws IllegalArgumentException if the chronology is null
+     * Get the second of day field value.
+     *
+     * @return the second of day
      */
-    public final DateTime toDateTime(Chronology chronology) {
-        if (chronology == null) {
-            throw new IllegalArgumentException("The Chronology must not be null");
-        }
-        if (this instanceof DateTime) {
-            DateTime dt = (DateTime)this;
-            if (dt.getChronology() == chronology) {
-                return dt;
-            }
-        }
-        return new DateTime(this, chronology);
-    }
-
-    /**
-     * Get this object as a trusted ISO DateTime.
-     * 
-     * @return an ISO DateTime using the same millis
-     */
-    public final DateTime toISODateTime() {
-        if (this instanceof DateTime) {
-            DateTime dt = (DateTime)this;
-            if (dt.getChronology() instanceof ISOChronology) {
-                // Verify that the time zone is trusted.
-                DateTimeZone tz = dt.getDateTimeZone();
-                DateTimeZone trusted = DateTimeZone.getInstance(tz.getID());
-                if (tz == trusted) {
-                    return dt;
-                }
-                return new DateTime(this, trusted);
-            }
-        }
-        return new DateTime(this);
+    public final int getSecondOfDay() {
+        return getChronology().secondOfDay().get(getMillis());
     }
 
     /**
-     * Get this object as a trusted ISO DateTime.
-     * 
-     * @param zone time zone to apply
-     * @return an ISO DateTime using the same millis
-     * @throws IllegalArgumentException if the time zone is null
+     * Get the second of minute field value.
+     *
+     * @return the second of minute
      */
-    public final DateTime toISODateTime(DateTimeZone zone) {
-        if (zone == null) {
-            throw new IllegalArgumentException("The DateTimeZone must not be null");
-        }
-        if (this instanceof DateTime) {
-            DateTime dt = (DateTime)this;
-            if (dt.getChronology() instanceof ISOChronology) {
-                if (dt.getDateTimeZone() == zone) {
-                    return dt;
-                }
-            }
-        }
-        return new DateTime(this, zone);
+    public final int getSecondOfMinute() {
+        return getChronology().secondOfMinute().get(getMillis());
     }
 
     /**
-     * Get this object as a MutableDateTime.
-     * 
-     * @return a MutableDateTime using the same millis
+     * Get the millis of day field value.
+     *
+     * @return the millis of day
      */
-    public final MutableDateTime toMutableDateTime() {
-        if (this instanceof MutableDateTime) {
-            return (MutableDateTime)this;
-        }
-        return new MutableDateTime(this);
+    public final int getMillisOfDay() {
+        return getChronology().millisOfDay().get(getMillis());
     }
 
     /**
-     * Get this object as a MutableDateTime.
-     * 
-     * @param zone time zone to apply
-     * @return a MutableDateTime using the same millis
-     * @throws IllegalArgumentException if the time zone is null
+     * Get the millis of second field value.
+     *
+     * @return the millis of second
      */
-    public final MutableDateTime toMutableDateTime(DateTimeZone zone) {
-        if (zone == null) {
-            throw new IllegalArgumentException("The DateTimeZone must not be null");
-        }
-        if (this instanceof MutableDateTime) {
-            MutableDateTime mdt = (MutableDateTime)this;
-            if (mdt.getDateTimeZone() == zone) {
-                return mdt;
-            }
-        }
-        return new MutableDateTime(this, zone);
+    public final int getMillisOfSecond() {
+        return getChronology().millisOfSecond().get(getMillis());
     }
 
+    // Output
+    //-----------------------------------------------------------------------
     /**
-     * Get this object as a MutableDateTime.
-     * 
-     * @param chronology chronology to apply
-     * @return a MutableDateTime using the same millis
-     * @throws IllegalArgumentException if the chronology is null
+     * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZ).
+     *
+     * @return ISO8601 time formatted string.
      */
-    public final MutableDateTime toMutableDateTime(Chronology chronology) {
-        if (chronology == null) {
-            throw new IllegalArgumentException("The Chronology must not be null");
-        }
-        if (this instanceof MutableDateTime) {
-            MutableDateTime mdt = (MutableDateTime)this;
-            if (mdt.getChronology() == chronology) {
-                return mdt;
-            }
-        }
-        return new MutableDateTime(this, chronology);
-    }
-
-    /**
-     * Get this object as a trusted ISO MutableDateTime.
-     * 
-     * @return an ISO MutableDateTime using the same millis
-     */
-    public final MutableDateTime toISOMutableDateTime() {
-        if (this instanceof DateTime) {
-            MutableDateTime mdt = (MutableDateTime)this;
-            if (mdt.getChronology() instanceof ISOChronology) {
-                // Verify that the time zone is trusted.
-                DateTimeZone tz = mdt.getDateTimeZone();
-                DateTimeZone trusted = DateTimeZone.getInstance(tz.getID());
-                if (tz == trusted) {
-                    return mdt;
-                }
-                return new MutableDateTime(this, trusted);
-            }
-        }
-        return new MutableDateTime(this);
+    public String toString() {
+        return ISODateTimeFormat.getInstance(getChronology()).dateTime().print(this);
     }
 
     /**
-     * Get this object as a trusted ISO MutableDateTime.
-     * 
-     * @param zone time zone to apply
-     * @return an ISO MutableDateTime using the same millis
-     * @throws IllegalArgumentException if the time zone is null
+     * Output the instant using the specified format pattern.
+     *
+     * @param pattern  the pattern specification
+     * @throws IllegalArgumentException  if pattern is invalid
+     * @see  org.joda.time.format.DateTimeFormat
      */
-    public final MutableDateTime toISOMutableDateTime(DateTimeZone zone) {
-        if (zone == null) {
-            throw new IllegalArgumentException("The DateTimeZone must not be null");
-        }
-        if (this instanceof MutableDateTime) {
-            MutableDateTime mdt = (MutableDateTime)this;
-            if (mdt.getChronology() instanceof ISOChronology) {
-                if (mdt.getDateTimeZone() == zone) {
-                    return mdt;
-                }
-            }
-        }
-        return new MutableDateTime(this, zone);
+    public String toString(String pattern) throws IllegalArgumentException {
+        return DateTimeFormat.getInstance(getChronology()).forPattern(pattern).print(this);
     }
 
     /**
-     * Get this object as a DateOnly.
-     * 
-     * @return a DateOnly using the same millis
+     * Output the instant using the specified format pattern.
+     *
+     * @param pattern  the pattern specification
+     * @param locale  Locale to use, or default if null
+     * @throws IllegalArgumentException  if pattern is invalid
+     * @see  org.joda.time.format.DateTimeFormat
      */
-    /*
-    public final DateOnly toDateOnly() {
-        if (this instanceof DateOnly) {
-            return (DateOnly)this;
-        }
-        return new DateOnly(this);
+    public String toString(String pattern, Locale locale) throws IllegalArgumentException {
+        return DateTimeFormat.getInstance(getChronology(), locale).forPattern(pattern).print(this);
     }
-    /*
 
     /**
-     * Get this object as a DateOnly.
-     * 
-     * @param chronology chronology to apply
-     * @return a DateOnly using the same millis
-     * @throws IllegalArgumentException if the chronology is null
-     */
-    /*
-    public final DateOnly toDateOnly(Chronology chronology) {
-        if (chronology == null) {
-            throw new IllegalArgumentException("The Chronology must not be null");
-        }
-        chronology = chronology.withUTC();
-        if (this instanceof DateOnly) {
-            DateOnly d = (DateOnly)this;
-            if (d.getChronology() == chronology) {
-                return d;
-            }
-        }
-        return new DateOnly(this, chronology);
+     * Set the value as the number of miliseconds since the epoch,
+     * 1970-01-01T00:00:00Z.
+     * <p>
+     * Subclasses that wish to be immutable should override this method with an
+     * empty implementation that is protected and final. This also ensures that
+     * all lower subclasses are also immutable.
+     *
+     * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the
+     * instant to
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    protected void setMillis(long instant) {
+        iMillis = instant;
     }
-    */
 
     /**
-     * Get this object as a TimeOnly.
+     * Set the value from an Object representing an instant.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
      * 
-     * @return a TimeOnly using the same millis
+     * @param instant  an object representing an instant
+     * @throws IllegalArgumentException if the value is invalid
      */
-    /*
-    public final TimeOnly toTimeOnly() {
-        if (this instanceof TimeOnly) {
-            return (TimeOnly)this;
+    protected void setMillis(Object instant) {
+        // Don't set iMillis directly, as it may provide a backdoor to
+        // immutable subclasses.
+        if (instant instanceof ReadableInstant) {
+            setMillis(((ReadableInstant) instant).getMillis());
+        } else {
+            InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
+            setMillis(converter.getInstantMillis(instant));
         }
-        return new TimeOnly(this);
     }
-    */
 
     /**
-     * Get this object as a TimeOnly.
+     * Set the chronology of the datetime.
+     * <p>
+     * Subclasses that wish to be immutable should override this method with an
+     * empty implementation that is protected and final. This also ensures that
+     * all lower subclasses are also immutable.
      * 
-     * @param chronology chronology to apply
-     * @return a TimeOnly using the same millis
-     * @throws IllegalArgumentException if the chronology is null
-     */
-    /*
-    public final TimeOnly toTimeOnly(Chronology chronology) {
-        if (chronology == null) {
-            throw new IllegalArgumentException("The Chronology must not be null");
-        }
-        chronology = chronology.withUTC();
-        if (this instanceof TimeOnly) {
-            TimeOnly t = (TimeOnly)this;
-            if (t.getChronology() == chronology) {
-                return t;
-            }
-        }
-        return new TimeOnly(this, chronology);
-    }
-    */
-
-    // Output
-    //-----------------------------------------------------------------------
-    /**
-     * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZ).
-     *
-     * @return ISO8601 time formatted string.
+     * @param chronology  the chronology to use, null means ISOChronology in default zone
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public String toString() {
-        return ISODateTimeFormat.getInstance(getChronology()).dateTime().print(this);
+    protected void setChronology(Chronology chronology) {
+        iChronology = selectChronology(chronology);
     }
 
     /**
-     * Output the instant using the specified format pattern.
+     * Sets the time zone of the datetime via the chronology. Setting the time
+     * zone does not affect the millisecond value of this instant.
      *
-     * @param pattern  the pattern specification
-     * @see org.joda.time.format.DateTimeFormatterBuilder#appendPattern(java.lang.String)
+     * @param zone  the time zone to use, null means default zone
+     * @throws IllegalArgumentException if the value is invalid
+     * @see #moveDateTimeZone
      */
-    public String toString(String pattern) throws IllegalArgumentException {
-        Chronology chrono = getChronology();
-        if (chrono == null) {
-            chrono = ISOChronology.getInstanceUTC();
+    protected void setDateTimeZone(DateTimeZone zone) {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        if (iChronology.getDateTimeZone() != zone) {
+            // Don't set iChronology directly, as it may provide a backdoor to
+            // immutable subclasses.
+            setChronology(iChronology.withDateTimeZone(zone));
         }
-        return DateTimeFormat.getInstance(chrono).forPattern(pattern).print(this);
     }
 
     /**
-     * Output the instant using the specified format pattern.
+     * Moves the time zone of the datetime via the chronology. Moving the time
+     * zone alters the millisecond value of this instant such that it is
+     * relative to the new time zone.
      *
-     * @param pattern  the pattern specification
-     * @param locale  the Locale to use, must not be null
-     * @see org.joda.time.format.DateTimeFormatterBuilder#appendPattern(java.lang.String)
-     * @throws IllegalArgumentException if the locale is null
+     * @param zone  the time zone to use, null means default zone
+     * @throws IllegalArgumentException if the value is invalid
+     * @see #setDateTimeZone
      */
-    public String toString(String pattern, Locale locale) throws IllegalArgumentException {
-        if (locale == null) {
-            throw new IllegalArgumentException("The Locale must not be null");
-        }
-        Chronology chrono = getChronology();
-        if (chrono == null) {
-            chrono = ISOChronology.getInstanceUTC();
+    protected void moveDateTimeZone(DateTimeZone zone) {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        DateTimeZone currentZone = iChronology.getDateTimeZone();
+        if (currentZone != zone) {
+            long millis = iMillis;
+            millis += currentZone.getOffset(millis);
+            millis -= zone.getOffsetFromLocal(millis);
+            // Don't set iChronology and iMillis directly, as it may provide a
+            // backdoor to immutable subclasses.
+            setChronology(iChronology.withDateTimeZone(zone));
+            setMillis(millis);
         }
-        return DateTimeFormat.getInstance(chrono, locale).forPattern(pattern).print(this);
     }
 
 }
diff --git a/JodaTime/src/java/org/joda/time/AbstractDateTimeFieldProperty.java b/JodaTime/src/java/org/joda/time/AbstractDateTimeFieldProperty.java
new file mode 100644
index 000000000..12192b1d3
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/AbstractDateTimeFieldProperty.java
@@ -0,0 +1,359 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+import java.util.Locale;
+import java.io.Serializable;
+
+/**
+ * AbstractDateTimeFieldProperty is a base class for binding a
+ * ReadableDateTime to a DateTimeField.
+ * <p>
+ * It allows the date and time manipulation code to be field based yet
+ * still easy to use.
+ * <p>
+ * AbstractDateTimeFieldPropery itself is thread-safe and immutable, but the
+ * ReadableDateTime being operated on may be mutable and not thread-safe.
+ *
+ * @see ReadableInstant
+ * @see DateTimeField
+ * 
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+public abstract class AbstractDateTimeFieldProperty implements Serializable {
+    
+    static final long serialVersionUID = 1971226328211649661L;
+
+    /**
+     * Constructor.
+     */
+    public AbstractDateTimeFieldProperty() {
+        super();
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the field being used.
+     * 
+     * @return the field
+     */
+    public abstract DateTimeField getField();
+
+    /**
+     * Gets the name of the field.
+     * 
+     * @return the field name
+     */
+    public String getName() {
+        return getField().getName();
+    }
+
+    /**
+     * Gets the instant being used.
+     * 
+     * @return the instant
+     */
+    public abstract ReadableDateTime getInstant();
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets a value from the instant.
+     * 
+     * @return the current value
+     * @see DateTimeField#get
+     */
+    public int get() {
+        return getField().get(getInstant().getMillis());
+    }
+
+    /**
+     * Gets a text value from the instant.
+     * 
+     * @param locale  optional locale to use for selecting a text symbol
+     * @return the current text value
+     * @see DateTimeField#getAsText
+     */
+    public String getAsText(Locale locale) {
+        return getField().getAsText(getInstant().getMillis(), locale);
+    }
+
+    /**
+     * Gets a text value from the instant.
+     * 
+     * @return the current text value
+     * @see DateTimeField#getAsText
+     */
+    public final String getAsText() {
+        return getField().getAsText(getInstant().getMillis(), null);
+    }
+
+    /**
+     * Gets a short text value from the instant.
+     * 
+     * @param locale  optional locale to use for selecting a text symbol
+     * @return the current text value
+     * @see DateTimeField#getAsShortText
+     */
+    public String getAsShortText(Locale locale) {
+        return getField().getAsShortText(getInstant().getMillis(), locale);
+    }
+
+    /**
+     * Gets a short text value from the instant.
+     * 
+     * @return the current text value
+     * @see DateTimeField#getAsShortText
+     */
+    public final String getAsShortText() {
+        return getAsShortText(null);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Returns the difference between this field property instant and the one
+     * passed in, in the units of this field. The sign of the difference
+     * matches that of compareTo. In other words, this field property's instant
+     * is the minuend.
+     *
+     * @param instant the subtrahend
+     * @return the difference in the units of this field
+     * @see DateTimeField#getDifference
+     */
+    public int getDifference(ReadableInstant instant) {
+        if (instant == null) {
+            throw new IllegalArgumentException("The instant must not be null");
+        }
+        return getField().getDifference(getInstant().getMillis(), instant.getMillis());
+    }
+
+    /**
+     * Returns the difference between this field property instant and the one
+     * passed in, in the units of this field. The sign of the difference
+     * matches that of compareTo. In other words, this field property's instant
+     * is the minuend.
+     *
+     * @param instant the subtrahend
+     * @return the difference in the units of this field
+     * @see DateTimeField#getDifference
+     */
+    public long getDifferenceAsLong(ReadableInstant instant) {
+        if (instant == null) {
+            throw new IllegalArgumentException("The instant must not be null");
+        }
+        return getField().getDifferenceAsLong(getInstant().getMillis(), instant.getMillis());
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Returns the duration per unit value of this field. For example, if this
+     * field represents "hour of day", then the duration is an hour.
+     *
+     * @return the duration of this field, or UnsupportedDurationField
+     */
+    public DurationField getDurationField() {
+        return getField().getDurationField();
+    }
+
+    /**
+     * Returns the range duration of this field. For example, if this field
+     * represents "hour of day", then the range duration is a day.
+     *
+     * @return the range duration of this field, or null if field has no range
+     */
+    public DurationField getRangeDurationField() {
+        return getField().getRangeDurationField();
+    }
+
+    /**
+     * Gets whether this field is leap.
+     * 
+     * @return true if a leap field
+     * @see DateTimeField#isLeap
+     */
+    public boolean isLeap() {
+        return getField().isLeap(getInstant().getMillis());
+    }
+
+    /**
+     * Gets the amount by which this field is leap.
+     * 
+     * @return the amount by which the field is leap
+     * @see DateTimeField#getLeapAmount
+     */
+    public int getLeapAmount() {
+        return getField().getLeapAmount(getInstant().getMillis());
+    }
+
+    /**
+     * If this field were to leap, then it would be in units described by the
+     * returned duration. If this field doesn't ever leap, null is returned.
+     */
+    public DurationField getLeapDurationField() {
+        return getField().getLeapDurationField();
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the minimum value for the field ignoring the current time.
+     * 
+     * @return the minimum value
+     * @see DateTimeField#getMinimumValue
+     */
+    public int getMinimumValueOverall() {
+        return getField().getMinimumValue();
+    }
+
+    /**
+     * Gets the minimum value for the field.
+     * 
+     * @return the minimum value
+     * @see DateTimeField#getMinimumValue
+     */
+    public int getMinimumValue() {
+        return getField().getMinimumValue(getInstant().getMillis());
+    }
+
+    /**
+     * Gets the maximum value for the field ignoring the current time.
+     * 
+     * @return the maximum value
+     * @see DateTimeField#getMaximumValue
+     */
+    public int getMaximumValueOverall() {
+        return getField().getMaximumValue();
+    }
+
+    /**
+     * Gets the maximum value for the field.
+     * 
+     * @return the maximum value
+     * @see DateTimeField#getMaximumValue
+     */
+    public int getMaximumValue() {
+        return getField().getMaximumValue(getInstant().getMillis());
+    }
+
+    /**
+     * Gets the maximum text length for the field.
+     * 
+     * @param locale  optional locale to use for selecting a text symbol
+     * @return the maximum length
+     * @see DateTimeField#getMaximumTextLength
+     */
+    public int getMaximumTextLength(Locale locale) {
+        return getField().getMaximumTextLength(locale);
+    }
+
+    /**
+     * Gets the maximum short text length for the field.
+     * 
+     * @param locale  optional locale to use for selecting a text symbol
+     * @return the maximum length
+     * @see DateTimeField#getMaximumShortTextLength
+     */
+    public int getMaximumShortTextLength(Locale locale) {
+        return getField().getMaximumShortTextLength(locale);
+    }
+
+
+    /**
+     * Returns the fractional duration milliseconds of this field.
+     *
+     * @see DateTimeField#remainder
+     * @return remainder duration, in milliseconds
+     */
+    public long remainder() {
+        return getField().remainder(getInstant().getMillis());
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Compare this field to the same field on another instant.
+     * <p>
+     * The {@link #get()} method is used to obtain the value to compare for
+     * this instant and the {@link ReadableInstant#get(DateTimeField)} method
+     * is used for the specified instant.
+     * 
+     * @param instant  the instant to compare to
+     * @return negative value if this is less, 0 if equal, or positive value if greater
+     * @throws IllegalArgumentException if the instant is null
+     */
+    public int compareTo(ReadableDateTime instant) {
+        if (instant == null) {
+            throw new IllegalArgumentException("The instant must not be null");
+        }
+        int thisValue = get();
+        int otherValue = instant.get(getField());
+        if (thisValue < otherValue) {
+            return -1;
+        } else if (thisValue > otherValue) {
+            return 1;
+        } else {
+            return 0;
+        }
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Output a debugging string.
+     * 
+     * @return debugging string
+     */
+    public String toString() {
+        return "Property[" + getName() + "]";
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/AbstractDuration.java b/JodaTime/src/java/org/joda/time/AbstractDuration.java
new file mode 100644
index 000000000..151ea1c2b
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/AbstractDuration.java
@@ -0,0 +1,1274 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+import java.io.Serializable;
+
+/**
+ * AbstractDuration provides the common behaviour for duration classes.
+ * <p>
+ * This class should generally not be used directly by API users. The 
+ * {@link ReadableDuration} interface should be used when different 
+ * kinds of durations are to be referenced.
+ * <p>
+ * AbstractDuration subclasses may be mutable and not thread-safe.
+ *
+ * @author Brian S O'Neill
+ * @author Stephen Colebourne
+ * @since 1.0
+ */
+public abstract class AbstractDuration implements ReadableDuration, Serializable {
+
+    static final long serialVersionUID = -2110953284060001145L;
+
+    private static void checkSupport(DurationField field, String name) {
+        if (!field.isSupported()) {
+            throw new UnsupportedOperationException
+                ("Duration does not support field \"" + name
+                 + "\". Supplied value must be zero.");
+        }
+    }
+
+    private static void checkPrecise(DurationField field, String name) {
+        if (!field.isPrecise()) {
+            throw new UnsupportedOperationException
+                ("The field \"" + name + "\" is imprecise");
+        }
+    }
+
+    private final DurationType iType;
+
+    private long iTotalMillis;
+    // 0=unknown, 1=imprecise, 2=precise
+    private int iTotalMillisState;
+
+    private int iYears;
+    private int iMonths;
+    private int iWeeks;
+    private int iDays;
+    private int iHours;
+    private int iMinutes;
+    private int iSeconds;
+    private int iMillis;
+
+    /**
+     * Copies another duration to this one.
+     *
+     * @throws UnsupportedOperationException if an unsupported field's value is
+     * non-zero
+     */
+    public AbstractDuration(ReadableDuration duration) {
+        // Only call a private method
+        setDuration(iType = duration.getDurationType(), duration);
+    }
+
+    /**
+     * Copies another duration to this one.
+     *
+     * @param type use a different DurationType
+     * @throws UnsupportedOperationException if an unsupported field's value is
+     * non-zero
+     */
+    public AbstractDuration(DurationType type, ReadableDuration duration) {
+        // Only call a private method
+        setDuration(iType = type, duration);
+    }
+
+    /**
+     * Create a duration from a set of field values.
+     *
+     * @param type determines which set of fields this duration supports
+     * @param years amount of years in this duration, which must be zero if
+     * unsupported.
+     * @param months amount of months in this duration, which must be zero if
+     * unsupported.
+     * @param weeks amount of weeks in this duration, which must be zero if
+     * unsupported.
+     * @param days amount of days in this duration, which must be zero if
+     * unsupported.
+     * @param hours amount of hours in this duration, which must be zero if
+     * unsupported.
+     * @param minutes amount of minutes in this duration, which must be zero if
+     * unsupported.
+     * @param seconds amount of seconds in this duration, which must be zero if
+     * unsupported.
+     * @param millis amount of milliseconds in this duration, which must be
+     * zero if unsupported.
+     * @throws UnsupportedOperationException if an unsupported field's value is
+     * non-zero
+     */
+    public AbstractDuration(DurationType type,
+                            int years, int months, int weeks, int days,
+                            int hours, int minutes, int seconds, int millis) {
+        // Only call a private method
+        setDuration(iType = type, years, months, weeks, days, hours, minutes, seconds, millis);
+    }
+
+    /**
+     * Creates a duration from the given interval endpoints.
+     *
+     * @param type determines which set of fields this duration supports
+     * @param startInstant interval start, in milliseconds
+     * @param endInstant interval end, in milliseconds
+     */
+    public AbstractDuration(DurationType type, long startInstant, long endInstant) {
+        // Only call a private method
+        setTotalMillis(iType = type, startInstant, endInstant);
+    }
+
+    /**
+     * Creates a duration from the given interval endpoints.
+     *
+     * @param type determines which set of fields this duration supports
+     * @param startInstant interval start
+     * @param endInstant interval end
+     */
+    public AbstractDuration(DurationType type,
+                            ReadableInstant startInstant, ReadableInstant  endInstant) {
+        // Only call a private method
+        setTotalMillis(iType = type, startInstant.getMillis(), endInstant.getMillis());
+    }
+
+    /**
+     * Creates a duration from the given millisecond duration. If any supported
+     * fields are imprecise, an UnsupportedOperationException is thrown. The
+     * exception to this is when the specified duration is zero.
+     *
+     * @param type determines which set of fields this duration supports
+     * @param duration  the duration, in milliseconds
+     * @throws UnsupportedOperationException if any fields are imprecise
+     */
+    public AbstractDuration(DurationType type, long duration) {
+        // Only call a private method
+        setTotalMillis(iType = type, duration);
+    }
+
+    /**
+     * Returns the object which defines which fields this duration supports.
+     */
+    public final DurationType getDurationType() {
+        return iType;
+    }
+
+    /**
+     * Gets the total length of this duration in milliseconds, 
+     * failing if the duration is imprecise.
+     *
+     * @return the total length of the duration in milliseconds.
+     * @throws IllegalStateException if the duration is imprecise
+     */
+    public final long getTotalMillis() {
+        int state = iTotalMillisState;
+        if (state == 0) {
+            state = updateTotalMillis();
+        }
+        if (state != 2) {
+            throw new IllegalStateException("Duration is imprecise");
+        }
+        return iTotalMillis;
+    }
+
+    /**
+     * Is this duration a precise length of time, or descriptive.
+     * <p>
+     * A precise duration could include millis, seconds, minutes or hours.
+     * However, days, weeks, months and years can vary in length, resulting in
+     * an imprecise duration.
+     * <p>
+     * An imprecise duration can be made precise by pairing it with a
+     * date in a {@link ReadableInterval}.
+     *
+     * @return true if the duration is precise
+     */
+    public final boolean isPrecise() {
+        int state = iTotalMillisState;
+        if (state == 0) {
+            state = updateTotalMillis();
+        }
+        return state == 2;
+    }
+
+    /**
+     * Walks through the field values, determining total millis and whether
+     * this duration is precise.
+     *
+     * @return new state
+     */
+    private int updateTotalMillis() {
+        final DurationType type = iType;
+
+        boolean isPrecise = true;
+        long totalMillis = 0;
+
+        DurationField field;
+        int value;
+
+        if ((value = iYears) != 0) {
+            field = type.years();
+            if (isPrecise &= field.isPrecise()) {
+                totalMillis += field.getMillis(value);
+            }
+        }
+        if ((value = iMonths) != 0) {
+            field = type.months();
+            if (isPrecise &= field.isPrecise()) {
+                totalMillis += field.getMillis(value);
+            }
+        }
+        if ((value = iWeeks) != 0) {
+            field = type.weeks();
+            if (isPrecise &= field.isPrecise()) {
+                totalMillis += field.getMillis(value);
+            }
+        }
+        if ((value = iDays) != 0) {
+            field = type.days();
+            if (isPrecise &= field.isPrecise()) {
+                totalMillis += field.getMillis(value);
+            }
+        }
+        if ((value = iHours) != 0) {
+            field = type.hours();
+            if (isPrecise &= field.isPrecise()) {
+                totalMillis += field.getMillis(value);
+            }
+        }
+        if ((value = iMinutes) != 0) {
+            field = type.minutes();
+            if (isPrecise &= field.isPrecise()) {
+                totalMillis += field.getMillis(value);
+            }
+        }
+        if ((value = iSeconds) != 0) {
+            field = type.seconds();
+            if (isPrecise &= field.isPrecise()) {
+                totalMillis += field.getMillis(value);
+            }
+        }
+        if ((value = iMillis) != 0) {
+            field = type.millis();
+            if (isPrecise &= field.isPrecise()) {
+                totalMillis += field.getMillis(value);
+            }
+        }
+
+        if (isPrecise) {
+            iTotalMillis = totalMillis;
+            return iTotalMillisState = 2;
+        } else {
+            iTotalMillis = totalMillis;
+            return iTotalMillisState = 1;
+        }
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Adds this duration to the given instant, returning a new value.
+     * <p>
+     * To add just once, pass in a scalar of one. To subtract once, pass
+     * in a scaler of minus one.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the
+     * duration to
+     * @param scalar  the number of times to add the duration, negative to subtract
+     * @return milliseconds value plus this duration times scalar
+     * @throws ArithmeticException if the result of the calculation is too large
+     */
+    public final long addTo(long instant, int scalar) {
+        return addTo(instant, scalar, null);
+    }
+
+    /**
+     * Adds this duration to the given instant, returning a new value.
+     * <p>
+     * To add just once, pass in a scalar of one. To subtract once, pass
+     * in a scaler of minus one.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the
+     * duration to
+     * @param scalar  the number of times to add the duration, negative to subtract
+     * @param chrono  override the duration's chronology, unless null is passed in
+     * @return milliseconds value plus this duration times scalar
+     * @throws ArithmeticException if the result of the calculation is too large
+     */
+    public final long addTo(long instant, int scalar, Chronology chrono) {
+        if (isPrecise()) {
+            return instant += getTotalMillis() * scalar;
+        }
+
+        DurationType type = iType;
+        if (chrono != null) {
+            type = type.withChronology(chrono);
+        }
+
+        int value;
+
+        if ((value = scaleValue(iYears, scalar)) != 0) {
+            instant = type.years().add(instant, value);
+        }
+        if ((value = scaleValue(iMonths, scalar)) != 0) {
+            instant = type.months().add(instant, value);
+        }
+        if ((value = scaleValue(iWeeks, scalar)) != 0) {
+            instant = type.weeks().add(instant, value);
+        }
+        if ((value = scaleValue(iDays, scalar)) != 0) {
+            instant = type.days().add(instant, value);
+        }
+        if ((value = scaleValue(iHours, scalar)) != 0) {
+            instant = type.hours().add(instant, value);
+        }
+        if ((value = scaleValue(iMinutes, scalar)) != 0) {
+            instant = type.minutes().add(instant, value);
+        }
+        if ((value = scaleValue(iSeconds, scalar)) != 0) {
+            instant = type.seconds().add(instant, value);
+        }
+        if ((value = scaleValue(iMillis, scalar)) != 0) {
+            instant = type.millis().add(instant, value);
+        }
+
+        return instant;
+    }
+
+    private static int scaleValue(int value, int scalar) {
+        switch (scalar) {
+        case -1:
+            return -value;
+        case 0:
+            return 0;
+        case 1:
+            return value;
+        default:
+            return value * scalar;
+        }
+    }
+
+    /**
+     * Adds this duration to the given instant, returning a new Instant.
+     * <p>
+     * To add just once, pass in a scalar of one. To subtract once, pass
+     * in a scaler of minus one.
+     *
+     * @param instant  the instant to add the duration to
+     * @param scalar  the number of times to add the duration, negative to subtract
+     * @return instant with the original value plus this duration times scalar
+     * @throws IllegalArgumentException if the instant is null
+     * @throws ArithmeticException if the result of the calculation is too large
+     */
+    public final ReadableInstant addTo(ReadableInstant instant, int scalar) {
+        return instant.toCopy(addTo(instant.getMillis(), scalar));
+    }
+
+    /**
+     * Adds this duration into the given mutable instant.
+     * <p>
+     * To add just once, pass in a scalar of one. To subtract once, pass
+     * in a scaler of minus one.
+     *
+     * @param instant  the instant to update with the added duration
+     * @param scalar  the number of times to add the duration, negative to subtract
+     * @throws IllegalArgumentException if the instant is null
+     * @throws ArithmeticException if the result of the calculation is too large
+     */
+    public final void addInto(ReadWritableInstant instant, int scalar) {
+        instant.setMillis(addTo(instant.getMillis(), scalar));
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the years field part of the duration.
+     * 
+     * @return the number of years in the duration, zero if unsupported
+     */
+    public final int getYears() {
+        return iYears;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the months field part of the duration.
+     * 
+     * @return the number of months in the duration, zero if unsupported
+     */
+    public final int getMonths() {
+        return iMonths;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the weeks field part of the duration.
+     * 
+     * @return the number of weeks in the duration, zero if unsupported
+     */
+    public final int getWeeks() {
+        return iWeeks;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the days field part of the duration.
+     * 
+     * @return the number of days in the duration, zero if unsupported
+     */
+    public final int getDays() {
+        return iDays;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the hours field part of the duration.
+     * 
+     * @return the number of hours in the duration, zero if unsupported
+     */
+    public final int getHours() {
+        return iHours;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the minutes field part of the duration.
+     * 
+     * @return the number of minutes in the duration, zero if unsupported
+     */
+    public final int getMinutes() {
+        return iMinutes;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the seconds field part of the duration.
+     * 
+     * @return the number of seconds in the duration, zero if unsupported
+     */
+    public final int getSeconds() {
+        return iSeconds;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the millis field part of the duration.
+     * 
+     * @return the number of millis in the duration, zero if unsupported
+     */
+    public final int getMillis() {
+        return iMillis;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Get this object as an immutable Duration. This can be useful if you
+     * don't trust the implementation of the interface to be well-behaved, or
+     * to get a guaranteed immutable object.
+     * 
+     * @return a Duration using the same field set and values
+     */
+    public final Duration toDuration() {
+        if (this instanceof Duration) {
+            return (Duration) this;
+        }
+        return new Duration(this);
+    }
+
+    /**
+     * Get this object as a MutableDuration.
+     * 
+     * @return a MutableDuration using the same field set and values
+     */
+    public final MutableDuration toMutableDuration() {
+        return new MutableDuration(this);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Compares this duration with the specified duration, which can only be
+     * performed if both are precise.
+     *
+     * @param obj  a precise duration to check against
+     * @return negative value if this is less, 0 if equal, or positive value if greater
+     * @throws NullPointerException if the object is null
+     * @throws ClassCastException if the given object is not supported
+     * @throws IllegalStateException if either duration is imprecise
+     */
+    public int compareTo(Object obj) {
+        ReadableDuration thisDuration = (ReadableDuration) this;
+        ReadableDuration otherDuration = (ReadableDuration) obj;
+
+        long thisMillis = thisDuration.getTotalMillis();
+        long otherMillis = otherDuration.getTotalMillis();
+        
+        // cannot do (thisMillis - otherMillis) as it can overflow
+        if (thisMillis < otherMillis) {
+            return -1;
+        }
+        if (thisMillis > otherMillis) {
+            return 1;
+        }
+        return 0;
+    }
+
+    /**
+     * Is the length of this duration equal to the duration passed in.
+     * Both durations must be precise.
+     *
+     * @param duration  another duration to compare to
+     * @return true if this duration is equal to than the duration passed in
+     * @throws IllegalArgumentException if the duration is null
+     * @throws IllegalStateException if either duration is imprecise
+     */
+    public boolean isEqual(ReadableDuration duration) {
+        if (duration == null) {
+            throw new IllegalArgumentException("The duration must not be null");
+        }
+        return compareTo(duration) == 0;
+    }
+
+    /**
+     * Is the length of this duration longer than the duration passed in.
+     * Both durations must be precise.
+     *
+     * @param duration  another duration to compare to
+     * @return true if this duration is equal to than the duration passed in
+     * @throws IllegalArgumentException if the duration is null
+     * @throws IllegalStateException if either duration is imprecise
+     */
+    public boolean isLongerThan(ReadableDuration duration) {
+        if (duration == null) {
+            throw new IllegalArgumentException("The duration must not be null");
+        }
+        return compareTo(duration) > 0;
+    }
+
+    /**
+     * Is the length of this duration shorter than the duration passed in.
+     * Both durations must be precise.
+     *
+     * @param duration  another duration to compare to
+     * @return true if this duration is equal to than the duration passed in
+     * @throws IllegalArgumentException if the duration is null
+     * @throws IllegalStateException if either duration is imprecise
+     */
+    public boolean isShorterThan(ReadableDuration duration) {
+        if (duration == null) {
+            throw new IllegalArgumentException("The duration must not be null");
+        }
+        return compareTo(duration) < 0;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Compares this object with the specified object for equality based
+     * on the value of each field. All ReadableDuration instances are accepted.
+     * <p>
+     * To compare two durations for absolute duration (ie. millisecond duration
+     * ignoring the fields), use {@link #isEqual(ReadableDuration)} or
+     * {@link #compareTo(Object)}.
+     *
+     * @param readableDuration  a readable duration to check against
+     * @return true if all the field values are equal, false if
+     *  not or the duration is null or of an incorrect type
+     */
+    public boolean equals(Object readableDuration) {
+        if (this == readableDuration) {
+            return true;
+        }
+        if (readableDuration instanceof ReadableDuration == false) {
+            return false;
+        }
+        ReadableDuration other = (ReadableDuration) readableDuration;
+        DurationType type = getDurationType();
+        if (type.equals(other.getDurationType()) == false) {
+            return false;
+        }
+        return getYears() == other.getYears()
+            && getMonths() == other.getMonths()
+            && getWeeks() == other.getWeeks()
+            && getDays() == other.getDays()
+            && getHours() == other.getHours()
+            && getMinutes() == other.getMinutes()
+            && getSeconds() == other.getSeconds()
+            && getMillis() == other.getMillis();
+    }
+
+    /**
+     * Gets a hash code for the duration that is compatable with the 
+     * equals method.
+     *
+     * @return a hash code
+     */
+    public int hashCode() {
+        int hash = getDurationType().hashCode();
+        hash = 53 * hash + getYears();
+        hash = 53 * hash + getMonths();
+        hash = 53 * hash + getWeeks();
+        hash = 53 * hash + getDays();
+        hash = 53 * hash + getHours();
+        hash = 53 * hash + getMinutes();
+        hash = 53 * hash + getSeconds();
+        hash = 53 * hash + getMillis();
+        return hash;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the value as a String in the ISO8601 duration format.
+     * <p>
+     * For example, "P6H3M5S" represents 6 hours, 3 minutes, 5 seconds.
+     *
+     * @return the value as an ISO8601 string
+     */
+    // TODO
+    //public String toString();
+
+    /**
+     * Sets all the fields in one go from another ReadableDuration.
+     * <p>
+     * Subclasses that wish to be immutable should override this method with an
+     * empty implementation that is protected and final. This also ensures that
+     * all lower subclasses are also immutable.
+     * 
+     * @param duration  the duration to set
+     * @throws IllegalArgumentException if duration is null
+     * @throws UnsupportedOperationException if an unsupported field's value is
+     * non-zero
+     */
+    protected void setDuration(ReadableDuration duration) {
+        setDuration(iType, duration);
+    }
+
+    /**
+     * This method is private to prevent subclasses from overriding.
+     */
+    private void setDuration(DurationType type, ReadableDuration duration) {
+        if (duration == null) {
+            throw new IllegalArgumentException("The duration must not be null");
+        }
+        setDuration(type,
+                    duration.getYears(), duration.getMonths(),
+                    duration.getWeeks(), duration.getDays(),
+                    duration.getHours(), duration.getMinutes(),
+                    duration.getSeconds(), duration.getMillis());
+    }
+
+    /**
+     * Sets all the fields in one go.
+     * <p>
+     * Subclasses that wish to be immutable should override this method with an
+     * empty implementation that is protected and final. This also ensures that
+     * all lower subclasses are also immutable.
+     * 
+     * @param years amount of years in this duration, which must be zero if
+     * unsupported.
+     * @param months amount of months in this duration, which must be zero if
+     * unsupported.
+     * @param weeks amount of weeks in this duration, which must be zero if
+     * unsupported.
+     * @param days amount of days in this duration, which must be zero if
+     * unsupported.
+     * @param hours amount of hours in this duration, which must be zero if
+     * unsupported.
+     * @param minutes amount of minutes in this duration, which must be zero if
+     * unsupported.
+     * @param seconds amount of seconds in this duration, which must be zero if
+     * unsupported.
+     * @param millis amount of milliseconds in this duration, which must be
+     * zero if unsupported.
+     * @throws UnsupportedOperationException if an unsupported field's value is
+     * non-zero
+     */
+    protected void setDuration(int years, int months, int weeks, int days,
+                               int hours, int minutes, int seconds, int millis) {
+        setDuration(iType, years, months, weeks, days, hours, minutes, seconds, millis);
+    }
+
+    /**
+     * This method is private to prevent subclasses from overriding.
+     */
+    private void setDuration(DurationType type,
+                             int years, int months, int weeks, int days,
+                             int hours, int minutes, int seconds, int millis) {
+
+        if (years != 0) {
+            checkSupport(type.years(), "years");
+        }
+        if (months != 0) {
+            checkSupport(type.months(), "months");
+        }
+        if (weeks != 0) {
+            checkSupport(type.weeks(), "weeks");
+        }
+        if (days != 0) {
+            checkSupport(type.days(), "days");
+        }
+        if (hours != 0) {
+            checkSupport(type.hours(), "hours");
+        }
+        if (minutes != 0) {
+            checkSupport(type.minutes(), "minutes");
+        }
+        if (seconds != 0) {
+            checkSupport(type.seconds(), "seconds");
+        }
+        if (millis != 0) {
+            checkSupport(type.millis(), "millis");
+        }
+
+        iYears = years;
+        iMonths = months;
+        iWeeks = weeks;
+        iDays = days;
+        iHours = hours;
+        iMinutes = minutes;
+        iSeconds = seconds;
+        iMillis = millis;
+
+        iTotalMillisState = 0;
+    }
+
+    /**
+     * Sets all the fields in one go from a millisecond interval.
+     * <p>
+     * Subclasses that wish to be immutable should override this method with an
+     * empty implementation that is protected and final. This also ensures that
+     * all lower subclasses are also immutable.
+     * 
+     * @param startInstant interval start, in milliseconds
+     * @param endInstant interval end, in milliseconds
+     */
+    protected void setTotalMillis(long startInstant, long endInstant) {
+        setTotalMillis(iType, startInstant, endInstant);
+    }
+
+    /**
+     * This method is private to prevent subclasses from overriding.
+     *
+     * @param startInstant interval start, in milliseconds
+     * @param endInstant interval end, in milliseconds
+     */
+    private void setTotalMillis(DurationType type, long startInstant, long endInstant) {
+        iTotalMillis = endInstant - startInstant;
+
+        boolean isPrecise = true;
+
+        DurationField field;
+
+        if (!(field = type.years()).isSupported()) {
+            iYears = 0;
+        } else if ((iYears = field.getDifference(endInstant, startInstant)) != 0) {
+            isPrecise &= field.isPrecise();
+            startInstant = field.add(startInstant, iYears);
+        }
+
+        if (!(field = type.months()).isSupported()) {
+            iMonths = 0;
+        } else if ((iMonths = field.getDifference(endInstant, startInstant)) != 0) {
+            isPrecise &= field.isPrecise();
+            startInstant = field.add(startInstant, iMonths);
+        }
+    
+        if (!(field = type.weeks()).isSupported()) {
+            iWeeks = 0;
+        } else if ((iWeeks = field.getDifference(endInstant, startInstant)) != 0) {
+            isPrecise &= field.isPrecise();
+            startInstant = field.add(startInstant, iWeeks);
+        }
+
+        if (!(field = type.days()).isSupported()) {
+            iDays = 0;
+        } else if ((iDays = field.getDifference(endInstant, startInstant)) != 0) {
+            isPrecise &= field.isPrecise();
+            startInstant = field.add(startInstant, iDays);
+        }
+
+        if (!(field = type.hours()).isSupported()) {
+            iHours = 0;
+        } else if ((iHours = field.getDifference(endInstant, startInstant)) != 0) {
+            isPrecise &= field.isPrecise();
+            startInstant = field.add(startInstant, iHours);
+        }
+        
+        if (!(field = type.minutes()).isSupported()) {
+            iMinutes = 0;
+        } else if ((iMinutes = field.getDifference(endInstant, startInstant)) != 0) {
+            isPrecise &= field.isPrecise();
+            startInstant = field.add(startInstant, iMinutes);
+        }
+        
+        if (!(field = type.seconds()).isSupported()) {
+            iSeconds = 0;
+        } else if ((iSeconds = field.getDifference(endInstant, startInstant)) != 0) {
+            isPrecise &= field.isPrecise();
+            startInstant = field.add(startInstant, iSeconds);
+        }
+
+        if (!(field = type.millis()).isSupported()) {
+            iMillis = 0;
+        } else if ((iMillis = field.getDifference(endInstant, startInstant)) != 0) {
+            isPrecise &= field.isPrecise();
+            startInstant = field.add(startInstant, iMillis);
+        }
+
+        iTotalMillisState = isPrecise ? 2 : 1;
+    }
+
+    /**
+     * Sets all the fields in one go from a millisecond duration. If any
+     * supported fields are imprecise, an UnsupportedOperationException is
+     * thrown. The exception to this is when the specified duration is zero.
+     * <p>
+     * Subclasses that wish to be immutable should override this method with an
+     * empty implementation that is protected and final. This also ensures that
+     * all lower subclasses are also immutable.
+     * 
+     * @param duration  the duration, in milliseconds
+     * @throws UnsupportedOperationException if any fields are imprecise
+     */
+    protected void setTotalMillis(long duration) {
+        setTotalMillis(iType, duration);
+    }
+
+    /**
+     * This method is private to prevent subclasses from overriding.
+     *
+     * @param duration  the duration, in milliseconds
+     * @throws UnsupportedOperationException if any fields are imprecise
+     */
+    private void setTotalMillis(DurationType type, final long duration) {
+        if (duration == 0) {
+            iTotalMillis = duration;
+            iTotalMillisState = 2;
+
+            iYears = 0;
+            iMonths = 0;
+            iWeeks = 0;
+            iDays = 0;
+            iHours = 0;
+            iMinutes = 0;
+            iSeconds = 0;
+            iMillis = 0;
+
+            return;
+        }
+
+        long startInstant = 0;
+
+        int years, months, weeks, days, hours, minutes, seconds, millis;
+        DurationField field;
+
+        if (!(field = type.years()).isSupported()) {
+            years = 0;
+        } else {
+            checkPrecise(field, "years");
+            years = field.getDifference(duration, startInstant);
+            startInstant = field.add(startInstant, years);
+        }
+
+        if (!(field = type.months()).isSupported()) {
+            months = 0;
+        } else {
+            checkPrecise(field, "months");
+            months = field.getDifference(duration, startInstant);
+            startInstant = field.add(startInstant, months);
+        }
+
+        if (!(field = type.weeks()).isSupported()) {
+            weeks = 0;
+        } else {
+            checkPrecise(field, "weeks");
+            weeks = field.getDifference(duration, startInstant);
+            startInstant = field.add(startInstant, weeks);
+        }
+
+        if (!(field = type.days()).isSupported()) {
+            days = 0;
+        } else {
+            checkPrecise(field, "days");
+            days = field.getDifference(duration, startInstant);
+            startInstant = field.add(startInstant, days);
+        }
+
+        if (!(field = type.hours()).isSupported()) {
+            hours = 0;
+        } else {
+            checkPrecise(field, "hours");
+            hours = field.getDifference(duration, startInstant);
+            startInstant = field.add(startInstant, hours);
+        }
+
+        if (!(field = type.minutes()).isSupported()) {
+            minutes = 0;
+        } else {
+            checkPrecise(field, "minutes");
+            minutes = field.getDifference(duration, startInstant);
+            startInstant = field.add(startInstant, minutes);
+        }
+
+        if (!(field = type.seconds()).isSupported()) {
+            seconds = 0;
+        } else {
+            checkPrecise(field, "seconds");
+            seconds = field.getDifference(duration, startInstant);
+            startInstant = field.add(startInstant, seconds);
+        }
+
+        if (!(field = type.millis()).isSupported()) {
+            millis = 0;
+        } else {
+            checkPrecise(field, "millis");
+            millis = field.getDifference(duration, startInstant);
+            startInstant = field.add(startInstant, millis);
+        }
+
+        iTotalMillis = duration;
+        iTotalMillisState = 2;
+
+        iYears = years;
+        iMonths = months;
+        iWeeks = weeks;
+        iDays = days;
+        iHours = hours;
+        iMinutes = minutes;
+        iSeconds = seconds;
+        iMillis = millis;
+    }
+    
+    //-----------------------------------------------------------------------
+    /**
+     * Adds a millisecond duration to this one. As a side-effect, all field
+     * values are normalized.
+     * 
+     * @param duration  the duration, in milliseconds
+     * @throws IllegalStateException if the duration is imprecise
+     */
+    protected void add(long duration) {
+        setTotalMillis(getTotalMillis() + duration);
+    }
+    
+    /**
+     * Adds a duration to this one.
+     * 
+     * @param duration  the duration to add
+     * @throws IllegalArgumentException if the duration is null
+     * @throws IllegalStateException if the duration is imprecise
+     */
+    protected void add(ReadableDuration duration) {
+        if (duration == null) {
+            throw new IllegalArgumentException("The duration must not be null");
+        }
+        add(duration.getTotalMillis());
+    }
+    
+    /**
+     * Normalizes all the field values in this duration.
+     * <p>
+     * Subclasses that wish to be immutable should override this method with an
+     * empty implementation that is protected and final. This also ensures that
+     * all lower subclasses are also immutable.
+     *
+     * @throws IllegalStateException if this duration is imprecise
+     */
+    protected void normalize() {
+        setTotalMillis(getTotalMillis());
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the number of years of the duration.
+     * <p>
+     * Subclasses that wish to be immutable should override this method with an
+     * empty implementation that is protected and final. This also ensures that
+     * all lower subclasses are also immutable.
+     * 
+     * @param years  the number of years
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    protected void setYears(int years) {
+        if (years != iYears) {
+            if (years != 0) {
+                checkSupport(iType.years(), "years");
+            }
+            iYears = years;
+            iTotalMillisState = 0;
+        }
+    }
+
+    /**
+     * Adds the specified years to the number of years in the duration.
+     * 
+     * @param years  the number of years
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    protected void addYears(int years) {
+        setYears(getYears() + years);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the number of months of the duration.
+     * <p>
+     * Subclasses that wish to be immutable should override this method with an
+     * empty implementation that is protected and final. This also ensures that
+     * all lower subclasses are also immutable.
+     * 
+     * @param months  the number of months
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    protected void setMonths(int months) {
+        if (months != iMonths) {
+            if (months != 0) {
+                checkSupport(iType.months(), "months");
+            }
+            iMonths = months;
+            iTotalMillisState = 0;
+        }
+    }
+
+    /**
+     * Adds the specified months to the number of months in the duration.
+     * 
+     * @param months  the number of months
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    protected void addMonths(int months) {
+        setMonths(getMonths() + months);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the number of weeks of the duration.
+     * <p>
+     * Subclasses that wish to be immutable should override this method with an
+     * empty implementation that is protected and final. This also ensures that
+     * all lower subclasses are also immutable.
+     * 
+     * @param weeks  the number of weeks
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    protected void setWeeks(int weeks) {
+        if (weeks != iWeeks) {
+            if (weeks != 0) {
+                checkSupport(iType.weeks(), "weeks");
+            }
+            iWeeks = weeks;
+            iTotalMillisState = 0;
+        }
+    }
+
+    /**
+     * Adds the specified weeks to the number of weeks in the duration.
+     * 
+     * @param weeks  the number of weeks
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    protected void addWeeks(int weeks) {
+        setWeeks(getWeeks() + weeks);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the number of days of the duration.
+     * <p>
+     * Subclasses that wish to be immutable should override this method with an
+     * empty implementation that is protected and final. This also ensures that
+     * all lower subclasses are also immutable.
+     * 
+     * @param days  the number of days
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    protected void setDays(int days) {
+        if (days != iDays) {
+            if (days != 0) {
+                checkSupport(iType.days(), "days");
+            }
+            iDays = days;
+            iTotalMillisState = 0;
+        }
+    }
+
+    /**
+     * Adds the specified days to the number of days in the duration.
+     * 
+     * @param days  the number of days
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    protected void addDays(int days) {
+        setDays(getDays() + days);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the number of hours of the duration.
+     * <p>
+     * Subclasses that wish to be immutable should override this method with an
+     * empty implementation that is protected and final. This also ensures that
+     * all lower subclasses are also immutable.
+     * 
+     * @param hours  the number of hours
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    protected void setHours(int hours) {
+        if (hours != iHours) {
+            if (hours != 0) {
+                checkSupport(iType.hours(), "hours");
+            }
+            iHours = hours;
+            iTotalMillisState = 0;
+        }
+    }
+
+    /**
+     * Adds the specified hours to the number of hours in the duration.
+     * 
+     * @param hours  the number of hours
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    protected void addHours(int hours) {
+        setHours(getHours() + hours);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the number of minutes of the duration.
+     * <p>
+     * Subclasses that wish to be immutable should override this method with an
+     * empty implementation that is protected and final. This also ensures that
+     * all lower subclasses are also immutable.
+     * 
+     * @param minutes  the number of minutes
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    protected void setMinutes(int minutes) {
+        if (minutes != iMinutes) {
+            if (minutes != 0) {
+                checkSupport(iType.minutes(), "minutes");
+            }
+            iMinutes = minutes;
+            iTotalMillisState = 0;
+        }
+    }
+
+    /**
+     * Adds the specified minutes to the number of minutes in the duration.
+     * 
+     * @param minutes  the number of minutes
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    protected void addMinutes(int minutes) {
+        setMinutes(getMinutes() + minutes);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the number of seconds of the duration.
+     * <p>
+     * Subclasses that wish to be immutable should override this method with an
+     * empty implementation that is protected and final. This also ensures that
+     * all lower subclasses are also immutable.
+     * 
+     * @param seconds  the number of seconds
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    protected void setSeconds(int seconds) {
+        if (seconds != iSeconds) {
+            if (seconds != 0) {
+                checkSupport(iType.seconds(), "seconds");
+            }
+            iSeconds = seconds;
+            iTotalMillisState = 0;
+        }
+    }
+
+    /**
+     * Adds the specified seconds to the number of seconds in the duration.
+     * 
+     * @param seconds  the number of seconds
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    protected void addSeconds(int seconds) {
+        setSeconds(getSeconds() + seconds);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the number of millis of the duration.
+     * <p>
+     * Subclasses that wish to be immutable should override this method with an
+     * empty implementation that is protected and final. This also ensures that
+     * all lower subclasses are also immutable.
+     * 
+     * @param millis  the number of millis
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    protected void setMillis(int millis) {
+        if (millis != iMillis) {
+            if (millis != 0) {
+                checkSupport(iType.millis(), "millis");
+            }
+            iMillis = millis;
+            iTotalMillisState = 0;
+        }
+    }
+
+    /**
+     * Adds the specified millis to the number of millis in the duration.
+     * 
+     * @param millis  the number of millis
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    protected void addMillis(int millis) {
+        setMillis(getMillis() + millis);
+    }
+
+}
+
diff --git a/JodaTime/src/java/org/joda/time/AbstractInstant.java b/JodaTime/src/java/org/joda/time/AbstractInstant.java
index 0120e2205..808317662 100644
--- a/JodaTime/src/java/org/joda/time/AbstractInstant.java
+++ b/JodaTime/src/java/org/joda/time/AbstractInstant.java
@@ -53,14 +53,14 @@
  */
 package org.joda.time;
 
-import java.io.Serializable;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.GregorianCalendar;
 import java.util.Locale;
+import org.joda.time.chrono.iso.ISOChronology;
 
 /**
- * AbstractInstant provides the common behaviour for immutable time classes.
+ * AbstractInstant provides the common behaviour for instant classes.
  * <p>
  * This class has no concept of a chronology, all methods work on the
  * millisecond instant.
@@ -68,18 +68,20 @@
  * This class should generally not be used directly by API users. The 
  * {@link ReadableInstant} interface should be used when different 
  * kinds of date/time objects are to be referenced.
+ * <p>
+ * AbstractInstant itself is thread-safe and immutable, but subclasses may be
+ * mutable and not thread-safe.
  *
  * @author Stephen Colebourne
  * @author Brian S O'Neill
  * @since 1.0
  */
-public abstract class AbstractInstant
-        implements ReadableInstant, Serializable {
+public abstract class AbstractInstant implements ReadableInstant {
 
     /**
      * Constructor.
      */
-    public AbstractInstant() {
+    protected AbstractInstant() {
         super();
     }
 
@@ -90,7 +92,7 @@ public AbstractInstant() {
      */
     public final DateTimeZone getDateTimeZone() {
         Chronology chrono = getChronology();
-        return chrono != null ? chrono.getDateTimeZone() : null;
+        return (chrono != null ? chrono.getDateTimeZone() : null);
     }
 
     /**
@@ -99,12 +101,11 @@ public final DateTimeZone getDateTimeZone() {
      * The returned object will be a new instance of the implementation.
      * Immutable subclasses may return <code>this</code> if appropriate.
      *
-     * @param millis  the new millis, from 1970-01-01T00:00:00Z
+     * @param instant  the new instant, from 1970-01-01T00:00:00Z
      * @param chrono  the new chronology
      * @return a new instance of this class
-     * @throws IllegalArgumentException if the chronology is null
      */
-    protected abstract ReadableInstant create(long millis, Chronology chrono);
+    protected abstract ReadableInstant create(long instant, Chronology chrono);
     
     // Accessors
     //-----------------------------------------------------------------------
@@ -134,7 +135,7 @@ public final int get(DateTimeField field) {
     /**
      * Gets a copy of this instant with different millis.
      * <p>
-     * The returned object will be a new instance of <code>DateTime</code>.
+     * The returned object will be a new instance of this type.
      * Only the millis will change, the chronology and time zone are kept.
      * If the millis is the same, <code>this</code> will be returned.
      *
@@ -148,24 +149,23 @@ public final ReadableInstant toCopy(long newMillis) {
     /**
      * Gets a copy of this instant with a different chronology.
      * <p>
-     * The returned object will be a new instance of <code>DateTime</code>.
+     * The returned object will be a new instance of this type.
      * Only the chronology will change, the millis are kept.
      * If the chronology is the same, <code>this</code> will be returned.
      *
      * @param newChronology  the new chronology
      * @return a copy of this instant with a different chronology
-     * @throws IllegalArgumentException if the chronology is null
      */
     public final ReadableInstant toCopy(Chronology newChronology) {
         return create(getMillis(), newChronology);
     }
-    
+
     // Conversion
     //-----------------------------------------------------------------------
     /**
      * Get this object as an Instant.
      * 
-     * @return an Instant using the same millis
+     * @return an Instant using the same millis, unless partially specified
      */
     public final Instant toInstant() {
         if (this instanceof Instant) {
@@ -174,6 +174,301 @@ public final Instant toInstant() {
         return new Instant(this);
     }
 
+    /**
+     * Get this object as an Instant, using the given base instant to supply
+     * missing field values.
+     * 
+     * @param base source of missing fields
+     * @return a new Instant
+     */
+    public final Instant toInstant(ReadableInstant base) {
+        return new Instant(getMillis(base, null));
+    }
+
+    /**
+     * Get this object as a DateTime.
+     * 
+     * @return a DateTime using the same millis, unless partially specified
+     */
+    public final DateTime toDateTime() {
+        if (this instanceof DateTime) {
+            return (DateTime) this;
+        }
+        return new DateTime(this);
+    }
+
+    /**
+     * Get this object as a DateTime.
+     * 
+     * @param zone time zone to apply, or default if null
+     * @return a DateTime using the same millis, unless partially specified
+     */
+    public final DateTime toDateTime(DateTimeZone zone) {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        if (this instanceof DateTime && getDateTimeZone() == zone) {
+            return (DateTime) this;
+        }
+        return new DateTime(this, zone);
+    }
+
+    /**
+     * Get this object as a DateTime.
+     * 
+     * @param chronology chronology to apply, or ISOChronology if null
+     * @return a DateTime using the same millis, unless partially specified
+     */
+    public final DateTime toDateTime(Chronology chronology) {
+        if (chronology == null) {
+            chronology = ISOChronology.getInstance();
+        }
+        if (this instanceof DateTime && getChronology() == chronology) {
+            return (DateTime) this;
+        }
+        return new DateTime(this, chronology);
+    }
+
+    /**
+     * Convert this object into a DateTime, using the given base instant to
+     * supply missing field values and time zone.
+     * 
+     * @param base source of missing fields
+     * @return a new DateTime
+     */
+    public final DateTime toDateTime(ReadableInstant base) {
+        if (base == null) {
+            return new DateTime(this);
+        }
+        DateTimeZone zone = base.getDateTimeZone();
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        return new DateTime(getMillis(base), getChronology().withDateTimeZone(zone));
+    }
+
+    /**
+     * Convert this object into a DateTime, using the given base instant to
+     * supply missing field values.
+     * 
+     * @param base source of missing fields
+     * @param zone  time zone to apply, or default if null
+     * @return a new DateTime
+     */
+    public final DateTime toDateTime(ReadableInstant base, DateTimeZone zone) {
+        if (base == null) {
+            return new DateTime(this, zone);
+        }
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        return new DateTime(getMillis(base, zone), getChronology().withDateTimeZone(zone));
+    }
+
+    /**
+     * Convert this object into a DateTime, using the given base instant to
+     * supply missing field values.
+     * 
+     * @param base source of missing fields
+     * @param chronology  chronology to apply, or ISOChronology if null
+     * @return a new DateTime
+     */
+    public final DateTime toDateTime(ReadableInstant base, Chronology chronology) {
+        if (base == null) {
+            return new DateTime(this, chronology);
+        }
+        if (chronology == null) {
+            chronology = ISOChronology.getInstance();
+        }
+        return new DateTime(getMillis(base, chronology.getDateTimeZone()), chronology);
+    }
+
+    /**
+     * Get this object as a trusted ISO immutable DateTime. The purpose of
+     * this method is to guarantee that an externally received DateTime
+     * object does not have any backdoors that allow it to be modified.
+     * <p>
+     * If this object is already a DateTime, whose chronology is
+     * {@link ISOChronology ISO}, and the time zone came from the default
+     * {@link org.joda.time.tz.Provider provider}, then this object is cast to
+     * a DateTime and returned. Otherwise, a new trusted DateTime is returned.
+     * 
+     * @return a trusted ISO DateTime using the same millis, unless partially specified
+     * @throws IllegalArgumentException if the time zone is not trusted, and
+     * no matching trusted time zone can be found.
+     */
+    public final DateTime toTrustedISODateTime() {
+        DateTimeZone zone = getDateTimeZone();
+        if (zone == null) {
+            return new DateTime(this, (Chronology)null);
+        }
+
+        DateTimeZone trusted = DateTimeZone.getInstance(zone.getID());
+        
+        if (zone == trusted && this instanceof DateTime
+            && getChronology() instanceof ISOChronology) {
+            return (DateTime) this;
+        }
+        
+        return new DateTime(this, ISOChronology.getInstance(trusted));
+    }
+
+    // NOTE: Although the toMutableDateTime methods could check to see if this
+    // is already a MutableDateTime and return this casted, it makes it too
+    // easy to mistakenly modify ReadableDateTime input parameters. Always
+    // returning a copy prevents this.
+
+    /**
+     * Get this object as a MutableDateTime.
+     * 
+     * @return a MutableDateTime using the same millis, unless partially specified
+     */
+    public final MutableDateTime toMutableDateTime() {
+        return new MutableDateTime(this);
+    }
+
+    /**
+     * Get this object as a MutableDateTime.
+     * 
+     * @param zone time zone to apply, or default if null
+     * @return a MutableDateTime using the same millis, unless partially specified
+     */
+    public final MutableDateTime toMutableDateTime(DateTimeZone zone) {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        return new MutableDateTime(this, zone);
+    }
+
+    /**
+     * Get this object as a MutableDateTime.
+     * 
+     * @param chronology chronology to apply, or ISOChronology if null
+     * @return a MutableDateTime using the same millis, unless partially specified
+     */
+    public final MutableDateTime toMutableDateTime(Chronology chronology) {
+        if (chronology == null) {
+            chronology = ISOChronology.getInstance();
+        }
+        return new MutableDateTime(this, chronology);
+    }
+
+    /**
+     * Convert this object into a MutableDateTime, using the given base instant
+     * to supply missing field values and time zone.
+     * 
+     * @param base source of missing fields
+     * @return a new MutableDateTime
+     */
+    public final MutableDateTime toMutableDateTime(ReadableInstant base) {
+        if (base == null) {
+            return new MutableDateTime(this);
+        }
+        DateTimeZone zone = base.getDateTimeZone();
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        return new MutableDateTime(getMillis(base), getChronology().withDateTimeZone(zone));
+    }
+
+    /**
+     * Convert this object into a MutableDateTime, using the given base instant
+     * to supply missing field values.
+     * 
+     * @param base source of missing fields
+     * @param zone  time zone to apply, or default if null
+     * @return a new MutableDateTime
+     */
+    public final MutableDateTime toMutableDateTime(ReadableInstant base, DateTimeZone zone) {
+        if (base == null) {
+            return new MutableDateTime(this, zone);
+        }
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        return new MutableDateTime(getMillis(base, zone), getChronology().withDateTimeZone(zone));
+    }
+
+    /**
+     * Convert this object into a MutableDateTime, using the given base instant
+     * to supply missing field values.
+     * 
+     * @param base source of missing fields
+     * @param chronology  chronology to apply, or ISOChronology if null
+     * @return a new MutableDateTime
+     */
+    public final MutableDateTime toMutableDateTime(ReadableInstant base, Chronology chronology) {
+        if (base == null) {
+            return new MutableDateTime(this, chronology);
+        }
+        if (chronology == null) {
+            chronology = ISOChronology.getInstance();
+        }
+        return new MutableDateTime(getMillis(base, chronology.getDateTimeZone()), chronology);
+    }
+
+    /**
+     * Get this object as a DateOnly.
+     * 
+     * @return a DateOnly using the same millis, unless partially specified
+     */
+    public final DateOnly toDateOnly() {
+        if (this instanceof DateOnly) {
+            return (DateOnly) this;
+        }
+        return new DateOnly(this);
+    }
+
+    /**
+     * Get this object as a DateOnly.
+     * 
+     * @param chronology chronology to apply, or ISOChronology if null
+     * @return a DateOnly using the same millis, unless partially specified
+     */
+    public final DateOnly toDateOnly(Chronology chronology) {
+        if (chronology == null) {
+            chronology = ISOChronology.getInstance();
+        }
+        if (this instanceof DateOnly) {
+            DateOnly d = (DateOnly) this;
+            if (d.getChronology() == chronology.withUTC()) {
+                return d;
+            }
+        }
+        return new DateOnly(this, chronology);
+    }
+
+    /**
+     * Get this object as a TimeOnly.
+     * 
+     * @return a TimeOnly using the same millis, unless partially specified
+     */
+    public final TimeOnly toTimeOnly() {
+        if (this instanceof TimeOnly) {
+            return (TimeOnly) this;
+        }
+        return new TimeOnly(this);
+    }
+
+    /**
+     * Get this object as a TimeOnly.
+     * 
+     * @param chronology chronology to apply, or ISOChronology if null
+     * @return a TimeOnly using the same millis, unless partially specified
+     */
+    public final TimeOnly toTimeOnly(Chronology chronology) {
+        if (chronology == null) {
+            chronology = ISOChronology.getInstance();
+        }
+        if (this instanceof TimeOnly) {
+            TimeOnly t = (TimeOnly) this;
+            if (t.getChronology() == chronology.withUTC()) {
+                return t;
+            }
+        }
+        return new TimeOnly(this, chronology);
+    }
+
     /**
      * Get the date time as a <code>java.util.Date</code>.
      * 
@@ -188,13 +483,12 @@ public final Date toDate() {
      * The locale is passed in, enabling Calendar to select the correct
      * localized subclass.
      * 
-     * @param locale  the locale to get the Calendar for
+     * @param locale  the locale to get the Calendar for, or default if null
      * @return a localized Calendar initialised with this datetime
-     * @throws IllegalArgumentException if the locale is null
      */
     public final Calendar toCalendar(Locale locale) {
         if (locale == null) {
-            throw new IllegalArgumentException("The Locale must not be null");
+            locale = Locale.getDefault();
         }
         Calendar cal = Calendar.getInstance(locale);
         cal.setTime(toDate());
@@ -227,7 +521,10 @@ public final GregorianCalendar toGregorianCalendar() {
      * @return true if millisecond and chronology are equal, false if
      *  not or the instant is null or of an incorrect type
      */
-    public final boolean equals(Object readableInstant) {
+    public boolean equals(Object readableInstant) {
+        if (this == readableInstant) {
+            return true;
+        }
         if (readableInstant instanceof ReadableInstant) {
             ReadableInstant otherInstant = (ReadableInstant) readableInstant;
             if (getMillis() == otherInstant.getMillis()) {
@@ -249,7 +546,7 @@ public final boolean equals(Object readableInstant) {
      *
      * @return a suitable hash code
      */
-    public final int hashCode() {
+    public int hashCode() {
         // following rules in [Bloch02]
         int result = 317;
         result = 59 * result + ((int) (getMillis() ^ (getMillis() >>> 32)));
@@ -265,14 +562,22 @@ public final int hashCode() {
      * All ReadableInstant instances are accepted.
      *
      * @param readableInstant  a readable instant to check against
-     * @return -1 if this is less, 0 if equal or +1 if greater
+     * @return negative value if this is less, 0 if equal, or positive value if greater
      * @throws NullPointerException if the object is null
      * @throws ClassCastException if the object type is not supported
      */
     public final int compareTo(Object readableInstant) {
+        if (this == readableInstant) {
+            return 0;
+        }
+
         ReadableInstant otherInstant = (ReadableInstant) readableInstant;
-        long otherMillis = otherInstant.getMillis();
-        long thisMillis = getMillis();
+
+        // If instants are partial, then they can use each other to fill in
+        // missing fields.
+        long otherMillis = otherInstant.getMillis(this);
+        long thisMillis = getMillis(otherInstant);
+
         // cannot do (thisMillis - otherMillis) as can overflow
         if (thisMillis == otherMillis) {
             return 0;
@@ -295,7 +600,9 @@ public final boolean isAfter(ReadableInstant readableInstant) {
         if (readableInstant == null) {
             throw new IllegalArgumentException("The instant must not be null");
         }
-        return (getMillis() > readableInstant.getMillis());
+        // If instants are partial, then they can use each other to fill in
+        // missing fields.
+        return (getMillis(readableInstant) > readableInstant.getMillis(this));
     }
 
     /**
@@ -309,7 +616,9 @@ public final boolean isBefore(ReadableInstant readableInstant) {
         if (readableInstant == null) {
             throw new IllegalArgumentException("The instant must not be null");
         }
-        return (getMillis() < readableInstant.getMillis());
+        // If instants are partial, then they can use each other to fill in
+        // missing fields.
+        return (getMillis(readableInstant) < readableInstant.getMillis(this));
     }
 
     /**
@@ -323,7 +632,9 @@ public final boolean isEqual(ReadableInstant readableInstant) {
         if (readableInstant == null) {
             throw new IllegalArgumentException("The instant must not be null");
         }
-        return (getMillis() == readableInstant.getMillis());
+        // If instants are partial, then they can use each other to fill in
+        // missing fields.
+        return (getMillis(readableInstant) == readableInstant.getMillis(this));
     }
 
     // Output    
diff --git a/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java b/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
new file mode 100644
index 000000000..fa84346b7
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
@@ -0,0 +1,452 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+import java.io.Serializable;
+import java.util.Locale;
+
+import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.convert.ConverterManager;
+import org.joda.time.convert.InstantConverter;
+import org.joda.time.format.DateTimeFormat;
+
+/**
+ * AbstractPartialInstant provides the common behaviour for partial instant
+ * classes.
+ * <p>
+ * This class should generally not be used directly by API users. The 
+ * {@link PartialInstant} interface should be used when different 
+ * kinds of partial instants are to be referenced.
+ * <p>
+ * AbstractPartialInstant subclasses may be mutable and not thread-safe.
+ *
+ * @author Brian S O'Neill
+ */
+public abstract class AbstractPartialInstant extends AbstractInstant
+    implements PartialInstant, Serializable {
+
+    static final long serialVersionUID = -8202208243769478085L;
+
+    /**
+     * Converts the given instant to local time.
+     *
+     * @param instant instant to convert
+     * @param original original chronology
+     * @param chronoUTC chronology with no time zone
+     */
+    private static long toLocalTime(long instant, Chronology original, Chronology chronoUTC) {
+        if (original != chronoUTC) {
+            DateTimeZone zone = original.getDateTimeZone();
+            if (zone != null) {
+                instant += zone.getOffset(instant);
+            }
+        }
+        return instant;
+    }
+
+    /**
+     * Returns a chronology that is UTC, defaulting to ISO if given chronology
+     * is null.
+     */
+    private static Chronology selectChronologyUTC(final Chronology chronology) {
+        if (chronology == null) {
+            return ISOChronology.getInstanceUTC();
+        } else {
+            Chronology utc = chronology.withUTC();
+            if (utc != null) {
+                return utc;
+            }
+            DateTimeZone zone = chronology.getDateTimeZone();
+            if (zone == null || zone == DateTimeZone.UTC) {
+                return chronology;
+            }
+            throw new IllegalArgumentException("Chronology does not support UTC: " + chronology);
+        }
+    }
+
+    private Chronology iChronology;
+
+    /** The millis from 1970-01-01T00:00:00Z */
+    private long iMillis;
+
+    // Constructors
+    //-----------------------------------------------------------------------
+    /**
+     * Constructs with the current instant in the default time zone.
+     */
+    protected AbstractPartialInstant() {
+        this(ISOChronology.getInstance());
+    }
+
+    /**
+     * Constructs with the current instant in the given time zone.
+     *
+     * @param zone  the time zone, null means default zone
+     */
+    protected AbstractPartialInstant(DateTimeZone zone) {
+        this(ISOChronology.getInstance(zone));
+    }
+
+    /**
+     * Constructs with the current instant in the time zone of the given
+     * chronology.
+     *
+     * @param chronology  the chronology, null means ISOChronology in default zone
+     */
+    protected AbstractPartialInstant(final Chronology chronology) {
+        iChronology = selectChronologyUTC(chronology);
+        iMillis = resetUnsupportedFields
+            (toLocalTime(System.currentTimeMillis(), chronology, iChronology));
+    }
+
+    /**
+     * Constructs with milliseconds from 1970-01-01T00:00:00Z.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
+     */
+    protected AbstractPartialInstant(long instant) {
+        iChronology = ISOChronology.getInstanceUTC();
+        iMillis = resetUnsupportedFields(instant);
+    }
+
+    /**
+     * Constructs with milliseconds from 1970-01-01T00:00:00Z. If the time zone
+     * of the given chronology is not null or UTC, then the instant is
+     * converted to local time.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
+     * @param chronology  the chronology, null means ISOChronology
+     */
+    protected AbstractPartialInstant(long instant, final Chronology chronology) {
+        iChronology = selectChronologyUTC(chronology);
+        iMillis = resetUnsupportedFields
+            (toLocalTime(instant, chronology, iChronology));
+    }
+
+    /**
+     * Constructs an instance from an Object that represents a date.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     *
+     * @param instant  the datetime object, must not be null
+     * @throws IllegalArgumentException if the date is null
+     */
+    protected AbstractPartialInstant(Object instant) {
+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
+        final Chronology chronology = converter.getChronology(instant);
+        iChronology = selectChronologyUTC(chronology);
+        iMillis = resetUnsupportedFields
+            (toLocalTime(converter.getInstantMillis(instant), chronology, iChronology));
+    }
+
+    /**
+     * Constructs an instance from an Object that represents a date, using the
+     * specified chronology.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     *
+     * @param instant  the datetime object, must not be null
+     * @param chronology  the chronology, must not be null
+     * @throws IllegalArgumentException if the date or chronology is null
+     */
+    protected AbstractPartialInstant(Object instant, final Chronology chronology) {
+        iChronology = selectChronologyUTC(chronology);
+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
+        iMillis = resetUnsupportedFields
+            (toLocalTime(converter.getInstantMillis(instant),
+                         converter.getChronology(instant), iChronology));
+    }
+
+    /**
+     * Get the value as the number of milliseconds since the epoch,
+     * 1970-01-01T00:00:00Z, with unsupported field values reset.
+     *
+     * @return the value as milliseconds
+     */
+    public final long getMillis() {
+        return iMillis;
+    }
+
+    /**
+     * Get the value as the number of milliseconds since the epoch,
+     * 1970-01-01T00:00:00Z, with unsupported field values and time zone filled
+     * in by the given base instant.
+     *
+     * @param base source of missing fields
+     * @return the value as milliseconds
+     */
+    public final long getMillis(ReadableInstant base) {
+        if (base == null || isMatchingType(base)) {
+            return getMillis();
+        }
+        return getMillis(base, base.getDateTimeZone());
+    }
+
+    /**
+     * Get the value as the number of milliseconds since the epoch,
+     * 1970-01-01T00:00:00Z, with unsupported field values filled in by the
+     * given base instant.
+     *
+     * @param base source of missing fields
+     * @param zone override the base time zone, null implies override with no
+     * time zone
+     * @return the value as milliseconds
+     */
+    public final long getMillis(ReadableInstant base, DateTimeZone zone) {
+        if (base == null || isMatchingType(base)) {
+            return getMillis();
+        }
+
+        long millis = getMillis();
+        long baseMillis = base.getMillis();
+
+        DateTimeZone baseZone = base.getDateTimeZone();
+        if (baseZone != null) {
+            // Strip zone from base such that sum can be performed.
+            baseMillis += baseZone.getOffset(baseMillis);
+        }
+
+        millis += resetSupportedFields(baseMillis);
+
+        if (zone != null) {
+            // Apply new zone.
+            millis -= zone.getOffsetFromLocal(millis);
+        }
+
+        return millis;
+    }
+
+    /**
+     * Gets the chronology of the instant, null if not applicable. The time
+     * zone of the chronology is either null or UTC.
+     * <p>
+     * The {@link Chronology} provides conversion from the millisecond
+     * value to meaningful fields in a particular calendar system.
+     * 
+     * @return the Chronology
+     */
+    public final Chronology getChronology() {
+        return iChronology;
+    }
+
+    /**
+     * Returns the lower limiting field, where the lower limit field itself is
+     * supported. In other words, for the range described by the lower and
+     * upper limits, the lower limit is inclusive.
+     *
+     * @return lower limit or null if none
+     */
+    public abstract DateTimeField getLowerLimit();
+
+    /**
+     * Returns the upper limiting field, where the upper limit field itself is
+     * not supported. In other words, for the range described by the lower and
+     * upper limits, the upper limit is exclusive.
+     *
+     * @return upper limit or null if none
+     */
+    public abstract DateTimeField getUpperLimit();
+
+    /**
+     * Returns true if the given instant is a PartialDateTime that supports the
+     * same exact set of fields. Implementations may simply do the following:
+     * <pre>
+     *     return instant instanceof &lt;this class&gt;;
+     * </pre>
+     *
+     * @return true if instant is same type as this
+     */
+    public abstract boolean isMatchingType(ReadableInstant instant);
+
+    /**
+     * Returns the given instant, except with lower and upper limits
+     * applied. Field values are reset below the lower limit and at or above
+     * the upper limit.
+     *
+     * @param instant milliseconds from 1970-01-01T00:00:00
+     */
+    public final long resetUnsupportedFields(long instant) {
+        DateTimeField field;
+        if ((field = getLowerLimit()) != null) {
+            instant = field.roundFloor(instant);
+        }
+        if ((field = getUpperLimit()) != null) {
+            instant = field.remainder(instant);
+        }
+        return instant;
+    }
+
+    /**
+     * Returns the given instant, except with lower and upper limits
+     * applied. Field values are reset below the upper limit and at or above
+     * the lower limit.
+     *
+     * @param instant milliseconds from 1970-01-01T00:00:00
+     */
+    public final long resetSupportedFields(final long instant) {
+        long newInstant = 0;
+        DateTimeField field;
+        if ((field = getUpperLimit()) != null) {
+            newInstant = field.roundFloor(instant);
+        }
+        if ((field = getLowerLimit()) != null) {
+            newInstant += field.remainder(instant);
+        }
+        return newInstant;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Compares this object with the specified object for equality based
+     * on the millisecond instant, the Chronology, and the limiting fields.
+     * <p>
+     * To compare two instants for absolute time (ie. UTC milliseconds ignoring
+     * the chronology), use {@link #isEqual(ReadableInstant)} or
+     * {@link #compareTo(Object)}.
+     *
+     * @param readableInstant  a readable instant to check against
+     * @return true if millisecond and chronology are equal, false if
+     *  not or the instant is null or of an incorrect type
+     */
+    public boolean equals(Object readableInstant) {
+        return super.equals(readableInstant) && isMatchingType((ReadableInstant) readableInstant);
+    }
+
+    private static boolean equals(Object a, Object b) {
+        return (a == b) || (a != null && a.equals(b));
+    }
+
+    /**
+     * Gets a hash code for the instant that is compatable with the 
+     * equals method.
+     *
+     * @return a suitable hash code
+     */
+    public int hashCode() {
+        int result = super.hashCode();
+        DateTimeField field;
+        if ((field = getLowerLimit()) != null) {
+            result = 31 * result + field.hashCode();
+        }
+        if ((field = getUpperLimit()) != null) {
+            result = 31 * result + field.hashCode();
+        }
+        return result;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Get the value as a String in a recognisable ISO8601 format, only
+     * displaying supported fields.
+     * <p>
+     * The string output is in ISO8601 format to enable the String
+     * constructor to correctly parse it.
+     *
+     * @return the value as an ISO8601 string
+     */
+    public abstract String toString();
+
+    /**
+     * Set the value as the number of miliseconds since the epoch,
+     * 1970-01-01T00:00:00Z.
+     * <p>
+     * Subclasses that wish to be immutable should override this method with an
+     * empty implementation that is protected and final. This also ensures that
+     * all lower subclasses are also immutable.
+     *
+     * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the
+     * instant to
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    protected void setMillis(long instant) {
+        iMillis = resetUnsupportedFields(instant);
+    }
+
+    /**
+     * Set the value from an Object representing an instant.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     * 
+     * @param instant  an object representing an instant
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    protected void setMillis(Object instant) {
+        // Don't set iMillis directly, as it may provide a backdoor to
+        // immutable subclasses.
+        if (instant instanceof ReadableInstant) {
+            setMillis(((ReadableInstant) instant).getMillis());
+        } else {
+            InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
+            setMillis(converter.getInstantMillis(instant));
+        }
+    }
+
+    /**
+     * Set the chronology of the instant.
+     * <p>
+     * Subclasses that wish to be immutable should override this method with an
+     * empty implementation that is protected and final. This also ensures that
+     * all lower subclasses are also immutable.
+     * 
+     * @param chronology  the chronology to use, null means ISOChronology/UTC
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    protected void setChronology(Chronology chronology) {
+        iChronology = selectChronologyUTC(chronology);
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/Chronology.java b/JodaTime/src/java/org/joda/time/Chronology.java
index d85201289..917b294e7 100644
--- a/JodaTime/src/java/org/joda/time/Chronology.java
+++ b/JodaTime/src/java/org/joda/time/Chronology.java
@@ -54,27 +54,35 @@
 package org.joda.time;
 
 import java.io.Serializable;
+import org.joda.time.chrono.UnsupportedDateTimeField;
+import org.joda.time.chrono.UnsupportedDurationField;
 
 /**
  * Chronology provides access to the individual date time fields for
  * a chronological calendar system.
- * <p>
- * Chronology subclasses <em>must</em> be immutable.
- * <p>
  * Various chronologies are supported by subclasses including ISO and 
  * GregorianJulian. 
  * <p>
- * This class does not strongly define each field. Subclasses may interpret
- * the fields differently.
+ * This class defines a number of fields with names from the ISO8601 standard.
+ * Chronology does not 'strongly' define these fields however, thus subclasses
+ * are free to interpret the field names as they wish. For example, a week
+ * could be defined as 10 days and a month as 40 days in a special
+ * WeirdChronology subclass. Clearly the GJ and ISO implementations provided
+ * use the field names as you would expect.
+ * <p>
+ * Chronology is thread-safe and immutable, and all subclasses must be as well.
  * 
  * @see org.joda.time.chrono.iso.ISOChronology
  * @see org.joda.time.chrono.gj.GJChronology
  *
  * @author Stephen Colebourne
+ * @author Brian S O'Neill
  * @since 1.0
  */
 public abstract class Chronology implements Serializable {
     
+    static final long serialVersionUID = -7310865996721419676L;
+
     /**
      * Restricted constructor
      */
@@ -103,270 +111,495 @@ protected Chronology() {
      * Returns an instance of this Chronology that operates in any time zone.
      *
      * @return a version of this chronology with a specific time zone
-     * @throws IllegalArgumentException if zone is null
+     * @param zone to use, or default if null
      * @see org.joda.time.chrono.ZonedChronology
      */
     public abstract Chronology withDateTimeZone(DateTimeZone zone);
 
     /**
-     * Get the millis for a time only field. The default implementation simply
-     * returns <code>dayOfYear().remainder(millis)</code>.
+     * Returns a date-only millisecond instant, by clearing the time fields
+     * from the given instant.
+     * <p>
+     * The default implementation simply returns
+     * <code>dayOfYear().roundFloor(instant)</code>.
      * 
-     * @param millis  the millis to convert to time only
-     * @return millis with the date part stripped
+     * @param instant the milliseconds from 1970-01-01T00:00:00Z
+     * @return millisecond instant from 1970-01-01T00:00:00Z with the time part
+     * cleared
      */
-    public long getTimeOnlyMillis(long millis) {
-        return dayOfYear().remainder(millis);
+    public long getDateOnlyMillis(long instant) {
+        return dayOfYear().roundFloor(instant);
     }
 
     /**
-     * Get the millis for a date only field. The default implementation simply
-     * returns <code>dayOfYear().roundFloor(millis)</code>.
+     * Returns a date-only millisecond instant, formed from the given year,
+     * month, and day values. The set of given values must refer to a valid
+     * date, or else an IllegalArgumentException is thrown.
+     * <p>
+     * The default implementation simply returns
+     * <code>getDateTimeMillis(year, monthOfYear, dayOfMonth, 0)</code>.
+     *
+     * @param year year to use
+     * @param monthOfYear month to use
+     * @param dayOfMonth day of month to use
+     * @return millisecond instant from 1970-01-01T00:00:00Z without any time
+     * part
+     */
+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
+        throws IllegalArgumentException
+    {
+        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);
+    }
+
+    /**
+     * Returns a time-only millisecond instant, by clearing the date fields
+     * from the given instant.
+     * <p>
+     * The default implementation simply returns
+     * <code>dayOfYear().remainder(instant)</code>.
      * 
-     * @param millis  the millis to convert to date only
-     * @return millis with the time part stripped
+     * @param instant the milliseconds from 1970-01-01T00:00:00Z
+     * @return millisecond instant from 1970-01-01T00:00:00Z with the date part
+     * cleared
+     */
+    public long getTimeOnlyMillis(long instant) {
+        return dayOfYear().remainder(instant);
+    }
+
+    /**
+     * Returns a time-only millisecond instant, formed from the given hour,
+     * minute, second, and millisecond values. The set of given values must
+     * refer to a valid time, or else an IllegalArgumentException is thrown.
+     * <p>
+     * The default implementation calls upon separate DateTimeFields to
+     * determine the result. Subclasses are encouraged to provide a more
+     * efficient implementation.
+     *
+     * @param hourOfDay hour to use
+     * @param minuteOfHour minute to use
+     * @param secondOfMinute second to use
+     * @param millisOfSecond millisecond to use
+     * @return millisecond instant from 1970-01-01T00:00:00Z without any date
+     * part
+     */
+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        long instant = hourOfDay().set(0, hourOfDay);
+        instant = minuteOfHour().set(instant, minuteOfHour);
+        instant = secondOfMinute().set(instant, secondOfMinute);
+        return millisOfSecond().set(instant, millisOfSecond);
+    }
+
+    /**
+     * Returns a datetime millisecond instant, formed from the given year,
+     * month, day, and millisecond values. The set of given values must refer
+     * to a valid datetime, or else an IllegalArgumentException is thrown.
+     * <p>
+     * The default implementation calls upon separate DateTimeFields to
+     * determine the result. Subclasses are encouraged to provide a more
+     * efficient implementation.
+     *
+     * @param year year to use
+     * @param monthOfYear month to use
+     * @param dayOfMonth day of month to use
+     * @param millisOfDay millisecond to use
+     * @return millisecond instant from 1970-01-01T00:00:00Z
+     */
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int millisOfDay)
+        throws IllegalArgumentException
+    {
+        long instant = year().set(0, year);
+        instant = monthOfYear().set(instant, monthOfYear);
+        instant = dayOfMonth().set(instant, dayOfMonth);
+        return millisOfDay().set(instant, millisOfDay);
+    }
+
+    /**
+     * Returns a datetime millisecond instant, from from the given instant,
+     * hour, minute, second, and millisecond values. The set of given values
+     * must refer to a valid datetime, or else an IllegalArgumentException is
+     * thrown.
+     * <p>
+     * The default implementation calls upon separate DateTimeFields to
+     * determine the result. Subclasses are encouraged to provide a more
+     * efficient implementation.
+     *
+     * @param instant instant to start from
+     * @param hourOfDay hour to use
+     * @param minuteOfHour minute to use
+     * @param secondOfMinute second to use
+     * @param millisOfSecond millisecond to use
+     * @return millisecond instant from 1970-01-01T00:00:00Z
      */
-    public long getDateOnlyMillis(long millis) {
-        return dayOfYear().roundFloor(millis);
+    public long getDateTimeMillis(long instant,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        instant = hourOfDay().set(instant, hourOfDay);
+        instant = minuteOfHour().set(instant, minuteOfHour);
+        instant = secondOfMinute().set(instant, secondOfMinute);
+        return millisOfSecond().set(instant, millisOfSecond);
+    }
+
+    /**
+     * Returns a datetime millisecond instant, formed from the given year,
+     * month, day, hour, minute, second, and millisecond values. The set of
+     * given values must refer to a valid datetime, or else an
+     * IllegalArgumentException is thrown.
+     * <p>
+     * The default implementation calls upon separate DateTimeFields to
+     * determine the result. Subclasses are encouraged to provide a more
+     * efficient implementation.
+     *
+     * @param year year to use
+     * @param monthOfYear month to use
+     * @param dayOfMonth day of month to use
+     * @param hourOfDay hour to use
+     * @param minuteOfHour minute to use
+     * @param secondOfMinute second to use
+     * @param millisOfSecond millisecond to use
+     * @return millisecond instant from 1970-01-01T00:00:00Z
+     */
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        long instant = year().set(0, year);
+        instant = monthOfYear().set(instant, monthOfYear);
+        instant = dayOfMonth().set(instant, dayOfMonth);
+        instant = hourOfDay().set(instant, hourOfDay);
+        instant = minuteOfHour().set(instant, minuteOfHour);
+        instant = secondOfMinute().set(instant, secondOfMinute);
+        return millisOfSecond().set(instant, millisOfSecond);
     }
 
     // Millis
     //-----------------------------------------------------------------------
+    /**
+     * Get the millis duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField millis() {
+        return UnsupportedDurationField.getInstance("millis");
+    }
+
     /**
      * Get the millis of second field for this chronology.
      * 
-     * @return DateTimeField
-     * @throws UnsupportedOperationException if unsupported
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
     public DateTimeField millisOfSecond() {
-        throw new UnsupportedOperationException("millisOfSecond is unsupported for " + getClass().getName());
+        return UnsupportedDateTimeField.getInstance("millisOfSecond", millis());
     }
 
     /**
      * Get the millis of day field for this chronology.
      * 
-     * @return DateTimeField
-     * @throws UnsupportedOperationException if unsupported
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
     public DateTimeField millisOfDay() {
-        throw new UnsupportedOperationException("millisOfDay is unsupported for " + getClass().getName());
+        return UnsupportedDateTimeField.getInstance("millisOfDay", millis());
     }
 
     // Second
     //-----------------------------------------------------------------------
+    /**
+     * Get the seconds duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField seconds() {
+        return UnsupportedDurationField.getInstance("seconds");
+    }
+
     /**
      * Get the second of minute field for this chronology.
      * 
-     * @return DateTimeField
-     * @throws UnsupportedOperationException if unsupported
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
     public DateTimeField secondOfMinute() {
-        throw new UnsupportedOperationException("secondOfMinute is unsupported for " + getClass().getName());
+        return UnsupportedDateTimeField.getInstance("secondOfMinute", seconds());
     }
 
     /**
      * Get the second of day field for this chronology.
      * 
-     * @return DateTimeField
-     * @throws UnsupportedOperationException if unsupported
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
     public DateTimeField secondOfDay() {
-        throw new UnsupportedOperationException("secondOfDay is unsupported for " + getClass().getName());
+        return UnsupportedDateTimeField.getInstance("secondOfDay", seconds());
     }
 
     // Minute
     //-----------------------------------------------------------------------
+    /**
+     * Get the minutes duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField minutes() {
+        return UnsupportedDurationField.getInstance("minutes");
+    }
+
     /**
      * Get the minute of hour field for this chronology.
      * 
-     * @return DateTimeField
-     * @throws UnsupportedOperationException if unsupported
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
     public DateTimeField minuteOfHour() {
-        throw new UnsupportedOperationException("minuteOfHour is unsupported for " + getClass().getName());
+        return UnsupportedDateTimeField.getInstance("minuteOfHour", minutes());
     }
 
     /**
      * Get the minute of day field for this chronology.
      * 
-     * @return DateTimeField
-     * @throws UnsupportedOperationException if unsupported
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
     public DateTimeField minuteOfDay() {
-        throw new UnsupportedOperationException("minuteOfDay is unsupported for " + getClass().getName());
+        return UnsupportedDateTimeField.getInstance("minuteOfDay", minutes());
     }
 
     // Hour
     //-----------------------------------------------------------------------
+    /**
+     * Get the hours duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField hours() {
+        return UnsupportedDurationField.getInstance("hours");
+    }
+
     /**
      * Get the hour of day (0-23) field for this chronology.
      * 
-     * @return DateTimeField
-     * @throws UnsupportedOperationException if unsupported
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
     public DateTimeField hourOfDay() {
-        throw new UnsupportedOperationException("hourOfDay is unsupported for " + getClass().getName());
+        return UnsupportedDateTimeField.getInstance("hourOfDay", hours());
     }
 
     /**
      * Get the hour of day (offset to 1-24) field for this chronology.
      * 
-     * @return DateTimeField
-     * @throws UnsupportedOperationException if unsupported
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
     public DateTimeField clockhourOfDay() {
-        throw new UnsupportedOperationException("clockhourOfDay is unsupported for " + getClass().getName());
+        return UnsupportedDateTimeField.getInstance("clockhourOfDay", hours());
     }
 
     /**
      * Get the hour of am/pm (0-11) field for this chronology.
      * 
-     * @return DateTimeField
-     * @throws UnsupportedOperationException if unsupported
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
     public DateTimeField hourOfHalfday() {
-        throw new UnsupportedOperationException("hourOfHalfday is unsupported for " + getClass().getName());
+        return UnsupportedDateTimeField.getInstance("hourOfHalfday", hours());
     }
 
     /**
      * Get the hour of am/pm (offset to 1-12) field for this chronology.
      * 
-     * @return DateTimeField
-     * @throws UnsupportedOperationException if unsupported
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
     public DateTimeField clockhourOfHalfday() {
-        throw new UnsupportedOperationException("clockhourOfHalfday is unsupported for " + getClass().getName());
+        return UnsupportedDateTimeField.getInstance("clockhourOfHalfday", hours());
     }
 
     /**
      * Get the AM(0) PM(1) field for this chronology.
      * 
-     * @return DateTimeField
-     * @throws UnsupportedOperationException if unsupported
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
     public DateTimeField halfdayOfDay() {
-        throw new UnsupportedOperationException("halfdayOfDay is unsupported for " + getClass().getName());
+        return UnsupportedDateTimeField.getInstance
+            ("halfdayOfDay", UnsupportedDurationField.getInstance("halfdays"));
     }
 
     // Day
     //-----------------------------------------------------------------------
+    /**
+     * Get the days duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField days() {
+        return UnsupportedDurationField.getInstance("days");
+    }
+
     /**
      * Get the day of week field for this chronology.
      *
      * <p>DayOfWeek values are defined in {@link DateTimeConstants}.
      * They use the ISO definitions, where 1 is Monday and 7 is Sunday.
      * 
-     * @return DateTimeField
-     * @throws UnsupportedOperationException if unsupported
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
     public DateTimeField dayOfWeek() {
-        throw new UnsupportedOperationException("dayOfWeek is unsupported for " + getClass().getName());
+        return UnsupportedDateTimeField.getInstance("dayOfWeek", days());
     }
 
     /**
      * Get the day of month field for this chronology.
      * 
-     * @return DateTimeField
-     * @throws UnsupportedOperationException if unsupported
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
     public DateTimeField dayOfMonth() {
-        throw new UnsupportedOperationException("dayOfMonth is unsupported for " + getClass().getName());
+        return UnsupportedDateTimeField.getInstance("dayOfMonth", days());
     }
 
     /**
      * Get the day of year field for this chronology.
      * 
-     * @return DateTimeField
-     * @throws UnsupportedOperationException if unsupported
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
     public DateTimeField dayOfYear() {
-        throw new UnsupportedOperationException("dayOfYear is unsupported for " + getClass().getName());
+        return UnsupportedDateTimeField.getInstance("dayOfYear", days());
     }
 
     // Week
     //-----------------------------------------------------------------------
+    /**
+     * Get the weeks duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField weeks() {
+        return UnsupportedDurationField.getInstance("weeks");
+    }
+
     /**
      * Get the week of a week based year field for this chronology.
      * 
-     * @return DateTimeField
-     * @throws UnsupportedOperationException if unsupported
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
     public DateTimeField weekOfWeekyear() {
-        throw new UnsupportedOperationException("weekOfWeekyear is unsupported for " + getClass().getName());
+        return UnsupportedDateTimeField.getInstance("weekOfWeekyear", weeks());
+    }
+
+    /**
+     * Get the weekyears duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField weekyears() {
+        return UnsupportedDurationField.getInstance("weekyears");
     }
 
     /**
      * Get the year of a week based year field for this chronology.
      * 
-     * @return DateTimeField
-     * @throws UnsupportedOperationException if unsupported
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
     public DateTimeField weekyear() {
-        throw new UnsupportedOperationException("weekyear is unsupported for " + getClass().getName());
+        return UnsupportedDateTimeField.getInstance("weekyear", weekyears());
     }
 
     // Month
     //-----------------------------------------------------------------------
+    /**
+     * Get the months duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField months() {
+        return UnsupportedDurationField.getInstance("months");
+    }
+
     /**
      * Get the month of year field for this chronology.
      * 
-     * @return DateTimeField
-     * @throws UnsupportedOperationException if unsupported
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
     public DateTimeField monthOfYear() {
-        throw new UnsupportedOperationException("monthOfYear is unsupported for " + getClass().getName());
+        return UnsupportedDateTimeField.getInstance("monthOfYear", months());
     }
 
     // Year
     //-----------------------------------------------------------------------
+    /**
+     * Get the years duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField years() {
+        return UnsupportedDurationField.getInstance("years");
+    }
+
     /**
      * Get the year field for this chronology.
      * 
-     * @return DateTimeField
-     * @throws UnsupportedOperationException if unsupported
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
     public DateTimeField year() {
-        throw new UnsupportedOperationException("year is unsupported for " + getClass().getName());
+        return UnsupportedDateTimeField.getInstance("year", years());
     }
 
     /**
      * Get the year of era field for this chronology.
      * 
-     * @return DateTimeField
-     * @throws UnsupportedOperationException if unsupported
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
     public DateTimeField yearOfEra() {
-        throw new UnsupportedOperationException("yearOfEra is unsupported for " + getClass().getName());
+        return UnsupportedDateTimeField.getInstance("yearOfEra", years());
     }
 
     /**
      * Get the year of century field for this chronology.
      * 
-     * @return DateTimeField
-     * @throws UnsupportedOperationException if unsupported
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
     public DateTimeField yearOfCentury() {
-        throw new UnsupportedOperationException("yearOfCentury is unsupported for " + getClass().getName());
+        return UnsupportedDateTimeField.getInstance("yearOfCentury", years());
+    }
+
+    /**
+     * Get the centuries duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField centuries() {
+        return UnsupportedDurationField.getInstance("centuries");
     }
 
     /**
      * Get the century of era field for this chronology.
      * 
-     * @return DateTimeField
-     * @throws UnsupportedOperationException if unsupported
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
     public DateTimeField centuryOfEra() {
-        throw new UnsupportedOperationException("centuryOfEra is unsupported for " + getClass().getName());
+        return UnsupportedDateTimeField.getInstance("centuryOfEra", centuries());
+    }
+
+    /**
+     * Get the eras duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField eras() {
+        return UnsupportedDurationField.getInstance("eras");
     }
 
     /**
      * Get the era field for this chronology.
      * 
-     * @return DateTimeField
-     * @throws UnsupportedOperationException if unsupported
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
     public DateTimeField era() {
-        throw new UnsupportedOperationException("era is unsupported for " + getClass().getName());
+        return UnsupportedDateTimeField.getInstance("era", eras());
     }
 
+    /**
+     * Gets a debugging toString.
+     * 
+     * @return a debugging string
+     */
+    public abstract String toString();
+
 }
diff --git a/JodaTime/src/java/org/joda/time/DateOnly.java b/JodaTime/src/java/org/joda/time/DateOnly.java
new file mode 100644
index 000000000..9df6fb7c7
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/DateOnly.java
@@ -0,0 +1,486 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+import java.io.Serializable;
+
+import org.joda.time.chrono.iso.ISOChronology;
+// Import for @link support
+import org.joda.time.convert.ConverterManager;
+import org.joda.time.format.ISODateTimeFormat;
+
+/*
+ * <p>Each individual field can be queried in two ways:
+ * <ul>
+ * <li><code>getYear()</code>
+ * <li><code>year().get()</code>
+ * </ul>
+ * The second technique also provides access to other useful methods on the
+ * field:
+ * <ul>
+ * <li>numeric value
+ * <li>text value
+ * <li>short text value
+ * <li>maximum value
+ * <li>minimum value
+ * </ul>
+ */
+
+/**
+ * DateOnly is the basic implementation of a date only class supporting
+ * chronologies. It holds the date as milliseconds from the Java epoch of
+ * 1970-01-01. The time component and time zone is fixed at T00:00:00Z.
+ * <p>
+ * DateOnly is thread-safe and immutable, provided that the Chronology is as
+ * well. All standard Chronology classes supplied are thread-safe and
+ * immutable.
+ *
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ * @since 1.0
+ * @see TimeOnly
+ * @see DateTime
+ */
+public class DateOnly extends AbstractPartialInstant implements Serializable {
+
+    static final long serialVersionUID = -5796551185494585279L;
+
+    // Constructors
+    //-----------------------------------------------------------------------
+    /**
+     * Constructs a DateOnly to the current date in the default time zone.
+     */
+    public DateOnly() {
+        super();
+    }
+
+    /**
+     * Constructs a DateOnly to the current date in the given time zone.
+     *
+     * @param zone  the time zone, null means default zone
+     */
+    public DateOnly(DateTimeZone zone) {
+        super(zone);
+    }
+
+    /**
+     * Constructs a DateOnly to the current date in the time zone of the given
+     * chronology.
+     *
+     * @param chronology  the chronology, null means ISOChronology in default zone
+     */
+    public DateOnly(Chronology chronology) {
+        super(chronology);
+    }
+
+    /**
+     * Constructs a DateOnly set to the milliseconds from 1970-01-01T00:00:00Z.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
+     */
+    public DateOnly(long instant) {
+        super(instant);
+    }
+
+    /**
+     * Constructs a DateOnly set to the milliseconds from
+     * 1970-01-01T00:00:00Z. If the time zone of the given chronology is not
+     * null or UTC, then the instant is converted to local time.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
+     * @param chronology  the chronology, null means ISOChronology
+     */
+    public DateOnly(long instant, Chronology chronology) {
+        super(instant, chronology);
+    }
+
+    /**
+     * Constructs an instance from an Object that represents a date.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     *
+     * @param instant  the datetime object, must not be null
+     * @throws IllegalArgumentException if the date is null
+     */
+    public DateOnly(Object instant) {
+        super(instant);
+    }
+
+    /**
+     * Constructs an instance from an Object that represents a date, using the
+     * specified chronology.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     *
+     * @param instant  the datetime object, must not be null
+     * @param chronology  the chronology, must not be null
+     * @throws IllegalArgumentException if the date or chronology is null
+     */
+    public DateOnly(Object instant, Chronology chronology) {
+        super(instant, chronology);
+    }
+
+    /**
+     * Constructs an instance from date field values using
+     * <code>ISOChronology</code>.
+     *
+     * @param year  the year
+     * @param monthOfYear  the month of the year
+     * @param dayOfMonth  the day of the month
+     */
+    public DateOnly(
+            final int year,
+            final int monthOfYear,
+            final int dayOfMonth) {
+
+        super(ISOChronology.getInstanceUTC()
+              .getDateOnlyMillis(year, monthOfYear, dayOfMonth),
+              ISOChronology.getInstanceUTC());
+    }
+
+    /**
+     * Constructs an instance from date field values
+     * using the specified chronology.
+     * <p>
+     * If the chronology is null, <code>ISOChronology</code>
+     * is used.
+     *
+     * @param year  the year
+     * @param monthOfYear  the month of the year
+     * @param dayOfMonth  the day of the month
+     * @param chronology  the chronology, null means ISOChronology
+     */
+    public DateOnly(
+            final int year,
+            final int monthOfYear,
+            final int dayOfMonth,
+            Chronology chronology) {
+
+        super((chronology == null ? (chronology = ISOChronology.getInstanceUTC()) : chronology)
+              .getDateOnlyMillis(year, monthOfYear, dayOfMonth),
+              chronology);
+    }
+
+    /**
+     * Returns the lower limiting field, dayOfYear.
+     *
+     * @return dayOfYear field
+     */
+    public final DateTimeField getLowerLimit() {
+        return getChronology().dayOfYear();
+    }
+
+    /**
+     * Returns the upper limiting field, null.
+     *
+     * @return null
+     */
+    public final DateTimeField getUpperLimit() {
+        return null;
+    }
+
+    public final boolean isMatchingType(ReadableInstant instant) {
+        return instant instanceof DateOnly;
+    }
+
+    // Date field access
+    //-----------------------------------------------------------------------
+    /**
+     * Get the era field value.
+     * 
+     * @return the era
+     */
+    public final int getEra() {
+        return getChronology().era().get(getMillis());
+    }
+
+    /**
+     * Get the year of era field value.
+     * 
+     * @return the year of era
+     */
+    public final int getCenturyOfEra() {
+        return getChronology().centuryOfEra().get(getMillis());
+    }
+
+    /**
+     * Get the year of era field value.
+     * 
+     * @return the year of era
+     */
+    public final int getYearOfEra() {
+        return getChronology().yearOfEra().get(getMillis());
+    }
+
+    /**
+     * Get the year of century field value.
+     * 
+     * @return the year of century
+     */
+    public final int getYearOfCentury() {
+        return getChronology().yearOfCentury().get(getMillis());
+    }
+
+    /**
+     * Get the year field value.
+     * 
+     * @return the year
+     */
+    public final int getYear() {
+        return getChronology().year().get(getMillis());
+    }
+
+    /**
+     * Get the weekyear field value.
+     * 
+     * @return the year of a week based year
+     */
+    public final int getWeekyear() {
+        return getChronology().weekyear().get(getMillis());
+    }
+
+    /**
+     * Get the month of year field value.
+     * 
+     * @return the month of year
+     */
+    public final int getMonthOfYear() {
+        return getChronology().monthOfYear().get(getMillis());
+    }
+
+    /**
+     * Get the week of weekyear field value.
+     * 
+     * @return the week of a week based year
+     */
+    public final int getWeekOfWeekyear() {
+        return getChronology().weekOfWeekyear().get(getMillis());
+    }
+
+    /**
+     * Get the day of year field value.
+     * 
+     * @return the day of year
+     */
+    public final int getDayOfYear() {
+        return getChronology().dayOfYear().get(getMillis());
+    }
+
+    /**
+     * Get the day of month field value.
+     * <p>
+     * The values for the day of month are defined in {@link DateTimeConstants}.
+     * 
+     * @return the day of month
+     */
+    public final int getDayOfMonth() {
+        return getChronology().dayOfMonth().get(getMillis());
+    }
+
+    /**
+     * Get the day of week field value.
+     * <p>
+     * The values for the day of week are defined in {@link DateTimeConstants}.
+     * 
+     * @return the day of week
+     */
+    public final int getDayOfWeek() {
+        return getChronology().dayOfWeek().get(getMillis());
+    }
+
+    // TODO: DateTimeFieldProperty cannot be constructed with anything but
+    // DateTime.
+
+    // Properties
+    //-----------------------------------------------------------------------
+    /**
+     * Get the day of week property.
+     * <p>
+     * The values for day of week are defined in {@link DateTimeConstants}.
+     * 
+     * @return the day of week property
+     * /
+    public final DateTimeFieldProperty dayOfWeek() {
+        return new DateTimeFieldProperty(this, getChronology().dayOfWeek());
+    }
+
+    /**
+     * Get the day of month property.
+     * 
+     * @return the day of month property
+     * /
+    public final DateTimeFieldProperty dayOfMonth() {
+        return new DateTimeFieldProperty(this, getChronology().dayOfMonth());
+    }
+
+    /**
+     * Get the day of year property.
+     * 
+     * @return the day of year property
+     * /
+    public final DateTimeFieldProperty dayOfYear() {
+        return new DateTimeFieldProperty(this, getChronology().dayOfYear());
+    }
+
+    /**
+     * Get the week of a week based year property.
+     * 
+     * @return the week of a week based year property
+     * /
+    public final DateTimeFieldProperty weekOfWeekyear() {
+        return new DateTimeFieldProperty(this, getChronology().weekOfWeekyear());
+    }
+
+    /**
+     * Get the year of a week based year property.
+     * 
+     * @return the year of a week based year property
+     * /
+    public final DateTimeFieldProperty weekyear() {
+        return new DateTimeFieldProperty(this, getChronology().weekyear());
+    }
+
+    /**
+     * Get the month of year property.
+     * 
+     * @return the month of year property
+     * /
+    public final DateTimeFieldProperty monthOfYear() {
+        return new DateTimeFieldProperty(this, getChronology().monthOfYear());
+    }
+
+    /**
+     * Get the year property.
+     * 
+     * @return the year property
+     * /
+    public final DateTimeFieldProperty year() {
+        return new DateTimeFieldProperty(this, getChronology().year());
+    }
+
+    /**
+     * Get the year of era property.
+     * 
+     * @return the year of era property
+     * /
+    public final DateTimeFieldProperty yearOfEra() {
+        return new DateTimeFieldProperty(this, getChronology().yearOfEra());
+    }
+
+    /**
+     * Get the year of century property.
+     * 
+     * @return the year of era property
+     * /
+    public final DateTimeFieldProperty yearOfCentury() {
+        return new DateTimeFieldProperty(this, getChronology().yearOfCentury());
+    }
+
+    /**
+     * Get the century of era property.
+     * 
+     * @return the year of era property
+     * /
+    public final DateTimeFieldProperty centuryOfEra() {
+        return new DateTimeFieldProperty(this, getChronology().centuryOfEra());
+    }
+
+    /**
+     * Get the era property.
+     * 
+     * @return the era property
+     * /
+    public final DateTimeFieldProperty era() {
+        return new DateTimeFieldProperty(this, getChronology().era());
+    }
+    */
+
+    // Output
+    //-----------------------------------------------------------------------
+    /**
+     * Output the date in ISO8601 date only format (yyyy-MM-dd).
+     * 
+     * @return ISO8601 date formatted string
+     */
+    public final String toString() {
+        return ISODateTimeFormat.getInstance(getChronology()).date().print(getMillis());
+    }
+
+    protected ReadableInstant create(long millis, Chronology chronology) {
+        if (chronology == null) {
+            throw new IllegalArgumentException("The Chronology must not be null");
+        }
+        if (millis == getMillis() && chronology == getChronology()) {
+            return this;
+        }
+        return new DateOnly(millis, chronology);
+    }
+
+    /**
+     * Overridden to do nothing, ensuring this class and all subclasses are
+     * immutable.
+     */
+    protected final void setMillis(long millis) {
+    }
+
+    /**
+     * Overridden to do nothing, ensuring this class and all subclasses are
+     * immutable.
+     */
+    protected final void setChronology(Chronology chronology) {
+    }
+    
+}
diff --git a/JodaTime/src/java/org/joda/time/DateTime.java b/JodaTime/src/java/org/joda/time/DateTime.java
index 41f2839cd..b29d0ef5e 100644
--- a/JodaTime/src/java/org/joda/time/DateTime.java
+++ b/JodaTime/src/java/org/joda/time/DateTime.java
@@ -53,18 +53,20 @@
  */
 package org.joda.time;
 
-import java.text.ParseException;
-import java.util.Calendar;
-import java.util.Date;
+import java.io.Serializable;
 
-import org.joda.time.chrono.iso.ISOChronology;
-import org.joda.time.format.DateTimeParser;
+// Import for @link support
+import org.joda.time.convert.ConverterManager;
 import org.joda.time.format.ISODateTimeFormat;
 
 /**
- * DateTime is the basic implementation of a datetime class supporting
- * chronologies and time zones. It holds the time as milliseconds from the Java
- * epoch of 1970-01-01T00:00:00Z.
+ * DateTime is the standard implementation of an unmodifiable datetime class.
+ * It holds the datetime as milliseconds from the Java epoch of 1970-01-01T00:00:00Z.
+ * <p>
+ * This class uses a Chronology internally. The Chronology determines how the
+ * millisecond instant value is converted into the date time fields.
+ * The default Chronology is <code>ISOChronology</code> which is the agreed
+ * international standard and compatable with the modern Gregorian calendar.
  *
  * <p>Each individual field can be queried in two ways:
  * <ul>
@@ -81,342 +83,312 @@
  * <li>minimum value
  * </ul>
  *
- * <p>This class is immutable provided that the Chronology is immutable. All 
- * Chronology classes supplied are immutable.
+ * <p>
+ * DateTime is thread-safe and immutable, provided that the Chronology is as
+ * well. All standard Chronology classes supplied are thread-safe and
+ * immutable.
  *
  * @author Stephen Colebourne
  * @author Kandarp Shah
  * @author Brian S O'Neill
  * @since 1.0
+ * @see MutableDateTime
+ * @see DateOnly
+ * @see TimeOnly
  */
-public class DateTime extends AbstractDateTime implements ReadableDateTime {
+public class DateTime extends AbstractDateTime
+        implements ReadableDateTime, Serializable {
     
-    /** The millis from 1970-01-01T00:00:00Z */
-    private final long iMillis;
-    /** The chronology to use */
-    private final Chronology iChronology;
+    static final long serialVersionUID = -5171125899451703815L;
 
     // Constructors
     //-----------------------------------------------------------------------
     /**
-     * Constructs a DateTime to the current datetime, as reported by the system
-     * clock. The chronology used is ISO, in the
-     * {@link DateTimeZone#getDefault() default} time zone.
+     * Constructs an instance set to the current system millisecond time
+     * using <code>ISOChronology</code> in the default time zone.
      */
     public DateTime() {
-        iChronology = ISOChronology.getInstance();
-        iMillis = System.currentTimeMillis();
+        super();
     }
 
     /**
-     * Constructs a DateTime to the current datetime, as reported by the system
-     * clock. The chronology used is ISO, in the supplied time zone.
+     * Constructs an instance set to the current system millisecond time
+     * using <code>ISOChronology</code> in the specified time zone.
+     * <p>
+     * If the specified time zone is null, the default zone is used.
      *
-     * @param zone  the time zone, must not be null
-     * @throws IllegalArgumentException if the zone is null
+     * @param zone  the time zone, null means default zone
      */
     public DateTime(DateTimeZone zone) {
-        iChronology = ISOChronology.getInstance(zone);
-        iMillis = System.currentTimeMillis();
+        super(zone);
     }
 
     /**
-     * Constructs a DateTime to the current datetime, as reported by the system
-     * clock.
+     * Constructs an instance set to the current system millisecond time
+     * using the specified chronology.
+     * <p>
+     * If the chronology is null, <code>ISOChronology</code>
+     * in the default time zone is used.
      *
-     * @param chronology  the chronology, must not be null
-     * @throws IllegalArgumentException if the chronology is null
+     * @param chronology  the chronology, null means ISOChronology in default zone
      */
     public DateTime(Chronology chronology) {
-        iChronology = selectChronology(chronology);
-        iMillis = System.currentTimeMillis();
-    }
-
-    /**
-     * Constructs a DateTime set to the milliseconds from 1970-01-01T00:00:00Z,
-     * using the ISO chronology, in the
-     * {@link DateTimeZone#getDefault() default} time zone.
-     *
-     * @param millis  the milliseconds
-     */
-    public DateTime(long millis) {
-        iChronology = ISOChronology.getInstance();
-        iMillis = millis;
-    }
-
-    /**
-     * Constructs a DateTime set to the milliseconds from 1970-01-01T00:00:00Z,
-     * using the ISO chronology, in the supplied time zone.
-     *
-     * @param millis  the milliseconds
-     * @param zone  the time zone, must not be null
-     * @throws IllegalArgumentException if the zone is null
-     */
-    public DateTime(long millis, DateTimeZone zone) {
-        iChronology = ISOChronology.getInstance(zone);
-        iMillis = millis;
-    }
-
-    /**
-     * Constructs a DateTime set to the milliseconds from 1970-01-01T00:00:00Z,
-     * using the supplied chronology.
-     *
-     * @param millis  the milliseconds
-     * @param chronology  the chronology, must not be null
-     * @throws IllegalArgumentException if the chronology is null
-     */
-    public DateTime(long millis, Chronology chronology) {
-        iChronology = selectChronology(chronology);
-        iMillis = millis;
-    }
-
-    /**
-     * Constructs a DateTime from a ReadableInstant, using its chronology. If
-     * its chronology null, then the chronology is set to ISO, in the
-     * {@link DateTimeZone#getDefault() default} time zone.
-     *
-     * @param instant  the ReadableInstant, must not be null
-     * @throws IllegalArgumentException if the instant is null
-     */
-    public DateTime(ReadableInstant instant) {
-        iChronology = selectChronology(instant);
-        iMillis = instant.getMillis();
-    }
-
-    /**
-     * Constructs a DateTime from a ReadableInstant, using its chronology
-     * against a different time zone. If its chronology is null, then the
-     * chronology is set to ISO. If the selected chronology is not in the
-     * supplied time zone, a new chronology is created that is.
-     *
-     * @param instant  the ReadableInstant, must not be null
-     * @param zone  the time zone, must not be null
-     * @throws IllegalArgumentException if the instant or zone is null
-     */
-    public DateTime(ReadableInstant instant, DateTimeZone zone) {
-        iChronology = selectChronology(instant, zone);
-        iMillis = instant.getMillis();
+        super(chronology);
     }
 
+    //-----------------------------------------------------------------------
     /**
-     * Constructs a DateTime from a ReadableInstant, using the supplied
-     * chronology.
+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z
+     * using <code>ISOChronology</code> in the default time zone.
      *
-     * @param instant  the ReadableInstant, must not be null
-     * @param chronology  the chronology, must not be null
-     * @throws IllegalArgumentException if the instant or chronology is null
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
      */
-    public DateTime(ReadableInstant instant, Chronology chronology) {
-        iChronology = selectChronology(instant, chronology);
-        iMillis = instant.getMillis();
+    public DateTime(long instant) {
+        super(instant);
     }
 
     /**
-     * Constructs a DateTime from a Date, using the ISO chronology, in the
-     * {@link DateTimeZone#getDefault() default} time zone.
+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z
+     * using <code>ISOChronology</code> in the specified time zone.
+     * <p>
+     * If the specified time zone is null, the default zone is used.
      *
-     * @param date  the Date, must not be null
-     * @throws IllegalArgumentException if the date is null
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
+     * @param zone  the time zone, null means default zone
      */
-    public DateTime(Date date) {
-        iChronology = selectChronology(date);
-        iMillis = date.getTime();
+    public DateTime(long instant, DateTimeZone zone) {
+        super(instant, zone);
     }
 
     /**
-     * Constructs a DateTime from a Date, using the ISO chronology, in the
-     * supplied time zone.
+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z
+     * using the specified chronology.
+     * <p>
+     * If the chronology is null, <code>ISOChronology</code>
+     * in the default time zone is used.
      *
-     * @param date  the Date, must not be null
-     * @param zone  the time zone, must not be null
-     * @throws IllegalArgumentException if the date or zone is null
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
+     * @param chronology  the chronology, null means ISOChronology in default zone
      */
-    public DateTime(Date date, DateTimeZone zone) {
-        iChronology = selectChronology(date, zone);
-        iMillis = date.getTime();
+    public DateTime(long instant, Chronology chronology) {
+        super(instant, chronology);
     }
 
+    //-----------------------------------------------------------------------
     /**
-     * Constructs a DateTime from a Date, using the supplied chronology.
+     * Constructs an instance from an Object that represents a datetime.
+     * <p>
+     * If the object contains no chronology, <code>ISOChronology</code>
+     * in the default time zone is used.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
      *
-     * @param date  the Date, must not be null
-     * @param chronology  the chronology, must not be null
-     * @throws IllegalArgumentException if the date or chronology is null
+     * @param instant  the datetime object, must not be null
+     * @throws IllegalArgumentException if the instant is null or invalid
      */
-    public DateTime(Date date, Chronology chronology) {
-        iChronology = selectChronology(date, chronology);
-        iMillis = date.getTime();
+    public DateTime(Object instant) {
+        super(instant);
     }
 
     /**
-     * Constructs a DateTime from a Calendar, using its closest mapped
-     * chronology and time zone.
-     *
-     * <p>When converting calendars to chronologies, the constructor is aware
-     * of GregorianCalendar and BuddhistCalendar and maps them to the
-     * equivalent chronology. Other calendars map to ISOChronology.
+     * Constructs an instance from an Object that represents a datetime,
+     * forcing the time zone to that specified.
+     * <p>
+     * If the object contains no chronology, <code>ISOChronology</code> is used.
+     * If the specified time zone is null, the default zone is used.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
      *
-     * @param calendar  the Calendar, must not be null
-     * @throws IllegalArgumentException if the calendar is null
+     * @param instant  the datetime object, must not be null
+     * @param zone  the time zone, null means default time zone
+     * @throws IllegalArgumentException if the instant is null or invalid
      */
-    public DateTime(Calendar calendar) {
-        iChronology = selectChronology(calendar);
-        iMillis = calendar.getTime().getTime();
+    public DateTime(Object instant, DateTimeZone zone) {
+        super(instant, zone);
     }
 
     /**
-     * Constructs a DateTime from a Calendar, using its closest mapped
-     * chronology against a different time zone.
-     *
-     * <p>When converting calendars to chronologies, the constructor is aware
-     * of GregorianCalendar and BuddhistCalendar and maps them to the
-     * equivalent chronology. Other calendars map to ISOChronology.
+     * Constructs an instance from an Object that represents a datetime,
+     * using the specified chronology.
+     * <p>
+     * If the chronology is null, ISOChronology in the default time zone is used.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
      *
-     * @param calendar  the Calendar, must not be null
-     * @param chronology  the chronology, must not be null
-     * @throws IllegalArgumentException if the calendar or zone is null
+     * @param instant  the datetime object, must not be null
+     * @param chronology  the chronology, null means ISOChronology in default zone
+     * @throws IllegalArgumentException if the instant is null or invalid
      */
-    public DateTime(Calendar calendar, DateTimeZone zone) {
-        iChronology = selectChronology(calendar, zone);
-        iMillis = calendar.getTime().getTime();
+    public DateTime(Object instant, Chronology chronology) {
+        super(instant, chronology);
     }
 
+    //-----------------------------------------------------------------------
     /**
-     * Constructs a DateTime from a Calendar, using the supplied chronology.
+     * Constructs an instance from datetime field values
+     * using <code>ISOChronology</code> in the default time zone.
      *
-     * @param calendar  the Calendar, must not be null
-     * @param chronology  the chronology, must not be null
-     * @throws IllegalArgumentException if the calendar or chronology is null
-     */
-    public DateTime(Calendar calendar, Chronology chronology) {
-        iChronology = selectChronology(calendar, chronology);
-        iMillis = calendar.getTime().getTime();
-    }
-
-    /**
-     * Constructs a DateTime from an ISO formatted String, using the ISO
-     * chronology, in the {@link DateTimeZone#getDefault() default} time zone.
+     * @param year  the year
+     * @param monthOfYear  the month of the year
+     * @param dayOfMonth  the day of the month
+     * @param hourOfDay  the hour of the day
+     * @param minuteOfHour  the minute of the hour
+     * @param secondOfMinute  the second of the minute
+     * @param millisOfSecond  the milisecond of the second
+     */
+    public DateTime(
+            int year,
+            int monthOfYear,
+            int dayOfMonth,
+            int hourOfDay,
+            int minuteOfHour,
+            int secondOfMinute,
+            int millisOfSecond) {
+        super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+    }
+
+    /**
+     * Constructs an instance from datetime field values
+     * using <code>ISOChronology</code> in the specified time zone.
+     * <p>
+     * If the specified time zone is null, the default zone is used.
      *
-     * @param str  the string to parse, must not be null
-     * @throws IllegalArgumentException if the string is null
-     * @throws ParseException if parsing fails
-     */
-    public DateTime(String str) throws ParseException {
-        iChronology = selectChronology(str);
-        DateTimeParser p = ISODateTimeFormat.getInstance(iChronology).dateTimeParser();
-        iMillis = p.parseMillis(str);
-    }
-
-    /**
-     * Constructs a DateTime from an ISO formatted String, using the ISO
-     * chronology, in the supplied time zone.
+     * @param year  the year
+     * @param monthOfYear  the month of the year
+     * @param dayOfMonth  the day of the month
+     * @param hourOfDay  the hour of the day
+     * @param minuteOfHour  the minute of the hour
+     * @param secondOfMinute  the second of the minute
+     * @param millisOfSecond  the milisecond of the second
+     * @param zone  the time zone, null means default time zone
+     */
+    public DateTime(
+            int year,
+            int monthOfYear,
+            int dayOfMonth,
+            int hourOfDay,
+            int minuteOfHour,
+            int secondOfMinute,
+            int millisOfSecond,
+            DateTimeZone zone) {
+        super(year, monthOfYear, dayOfMonth,
+              hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone);
+    }
+
+    /**
+     * Constructs an instance from datetime field values
+     * using the specified chronology.
+     * <p>
+     * If the chronology is null, <code>ISOChronology</code>
+     * in the default time zone is used.
      *
-     * @param str  the string to parse, must not be null
-     * @param zone the time zone, must not be null
-     * @throws IllegalArgumentException if the string or zone is null
-     * @throws ParseException if parsing fails
-     */
-    public DateTime(String str, DateTimeZone zone) throws ParseException {
-        iChronology = selectChronology(str, zone);
-        DateTimeParser p = ISODateTimeFormat.getInstance(iChronology).dateTimeParser();
-        iMillis = p.parseMillis(str);
+     * @param year  the year
+     * @param monthOfYear  the month of the year
+     * @param dayOfMonth  the day of the month
+     * @param hourOfDay  the hour of the day
+     * @param minuteOfHour  the minute of the hour
+     * @param secondOfMinute  the second of the minute
+     * @param millisOfSecond  the milisecond of the second
+     * @param chronology  the chronology, null means ISOChronology in default zone
+     */
+    public DateTime(
+            int year,
+            int monthOfYear,
+            int dayOfMonth,
+            int hourOfDay,
+            int minuteOfHour,
+            int secondOfMinute,
+            int millisOfSecond,
+            Chronology chronology) {
+        super(year, monthOfYear, dayOfMonth,
+              hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology);
     }
 
+    //-----------------------------------------------------------------------
     /**
-     * Constructs a DateTime from an ISO formatted String, using the supplied
-     * chronology.
+     * Creates a new instance of this class.
+     * <p>
+     * The returned object will be a new instance of the implementation.
+     * Immutable subclasses may return <code>this</code> if appropriate.
      *
-     * @param str  the string to parse, must not be null
-     * @param chronology  the chronology, must not be null
-     * @throws IllegalArgumentException if the string or chronology is null
-     * @throws ParseException if parsing fails
+     * @param instant  the new instant, from 1970-01-01T00:00:00Z
+     * @param chrono  the new chronology
+     * @return a new instance of this class
+     * @throws IllegalArgumentException if the chronology is null
      */
-    public DateTime(String str, Chronology chronology) throws ParseException {
-        iChronology = selectChronology(str, chronology);
-        DateTimeParser p = ISODateTimeFormat.getInstance(iChronology).dateTimeParser();
-        iMillis = p.parseMillis(str);
+    protected final ReadableInstant create(final long instant, final Chronology chrono) {
+        return createDateTime(instant, chrono);
     }
-
+    
     /**
      * Creates a new instance of this class.
      * <p>
-     * The returned object will be a new instance of the implementation.
+     * The returned object will be a new instance of DateTime, or a subclass.
      * Immutable subclasses may return <code>this</code> if appropriate.
      *
-     * @param millis  the new millis, from 1970-01-01T00:00:00Z
+     * @param instant  the new instant, from 1970-01-01T00:00:00Z
      * @param chrono  the new chronology
      * @return a new instance of this class
      * @throws IllegalArgumentException if the chronology is null
      */
-    protected ReadableInstant create(long millis, Chronology chrono) {
+    protected DateTime createDateTime(final long instant, final Chronology chrono) {
         if (chrono == null) {
             throw new IllegalArgumentException("The Chronology must not be null");
         }
-        if (millis == getMillis() && chrono == getChronology()) {
+        if (instant == getMillis() && chrono == getChronology()) {
             return this;
         }
-        return new DateTime(millis, chrono);
+        return new DateTime(instant, chrono);
     }
     
-    // Accessors
+    // Date properties
     //-----------------------------------------------------------------------
     /**
-     * Gets the milliseconds of the datetime instant from the Java epoch
-     * of 1970-01-01T00:00:00Z.
+     * Get the era property.
      * 
-     * @return the number of milliseconds since 1970-01-01T00:00:00Z
+     * @return the era property
      */
-    public final long getMillis() {
-        return iMillis;
+    public final DateTimeFieldProperty era() {
+        return new DateTimeFieldProperty(this, getChronology().era());
     }
 
     /**
-     * Gets the chronology of the datetime.
-     * 
-     * @return the Chronology that the datetime is using
-     */
-    public final Chronology getChronology() {
-        return iChronology;
-    }
-
-    // Date properties
-    //-----------------------------------------------------------------------
-    /**
-     * Get the day of week property.
-     * <p>
-     * The values for day of week are defined in {@link DateTimeConstants}.
+     * Get the century of era property.
      * 
-     * @return the day of week property
+     * @return the year of era property
      */
-    public final DateTimeFieldProperty dayOfWeek() {
-        return new DateTimeFieldProperty(this, getChronology().dayOfWeek());
+    public final DateTimeFieldProperty centuryOfEra() {
+        return new DateTimeFieldProperty(this, getChronology().centuryOfEra());
     }
 
     /**
-     * Get the day of month property.
+     * Get the year of century property.
      * 
-     * @return the day of month property
+     * @return the year of era property
      */
-    public final DateTimeFieldProperty dayOfMonth() {
-        return new DateTimeFieldProperty(this, getChronology().dayOfMonth());
+    public final DateTimeFieldProperty yearOfCentury() {
+        return new DateTimeFieldProperty(this, getChronology().yearOfCentury());
     }
 
     /**
-     * Get the day of year property.
+     * Get the year of era property.
      * 
-     * @return the day of year property
+     * @return the year of era property
      */
-    public final DateTimeFieldProperty dayOfYear() {
-        return new DateTimeFieldProperty(this, getChronology().dayOfYear());
+    public final DateTimeFieldProperty yearOfEra() {
+        return new DateTimeFieldProperty(this, getChronology().yearOfEra());
     }
 
     /**
-     * Get the week of a week based year property.
+     * Get the year property.
      * 
-     * @return the week of a week based year property
+     * @return the year property
      */
-    public final DateTimeFieldProperty weekOfWeekyear() {
-        return new DateTimeFieldProperty(this, getChronology().weekOfWeekyear());
+    public final DateTimeFieldProperty year() {
+        return new DateTimeFieldProperty(this, getChronology().year());
     }
 
     /**
@@ -438,81 +410,76 @@ public final DateTimeFieldProperty monthOfYear() {
     }
 
     /**
-     * Get the year property.
-     * 
-     * @return the year property
-     */
-    public final DateTimeFieldProperty year() {
-        return new DateTimeFieldProperty(this, getChronology().year());
-    }
-
-    /**
-     * Get the year of era property.
+     * Get the week of a week based year property.
      * 
-     * @return the year of era property
+     * @return the week of a week based year property
      */
-    public final DateTimeFieldProperty yearOfEra() {
-        return new DateTimeFieldProperty(this, getChronology().yearOfEra());
+    public final DateTimeFieldProperty weekOfWeekyear() {
+        return new DateTimeFieldProperty(this, getChronology().weekOfWeekyear());
     }
 
     /**
-     * Get the year of century property.
+     * Get the day of year property.
      * 
-     * @return the year of era property
+     * @return the day of year property
      */
-    public final DateTimeFieldProperty yearOfCentury() {
-        return new DateTimeFieldProperty(this, getChronology().yearOfCentury());
+    public final DateTimeFieldProperty dayOfYear() {
+        return new DateTimeFieldProperty(this, getChronology().dayOfYear());
     }
 
     /**
-     * Get the century of era property.
+     * Get the day of month property.
+     * <p>
+     * The values for day of month are defined in {@link DateTimeConstants}.
      * 
-     * @return the year of era property
+     * @return the day of month property
      */
-    public final DateTimeFieldProperty centuryOfEra() {
-        return new DateTimeFieldProperty(this, getChronology().centuryOfEra());
+    public final DateTimeFieldProperty dayOfMonth() {
+        return new DateTimeFieldProperty(this, getChronology().dayOfMonth());
     }
 
     /**
-     * Get the era property.
+     * Get the day of week property.
+     * <p>
+     * The values for day of week are defined in {@link DateTimeConstants}.
      * 
-     * @return the era property
+     * @return the day of week property
      */
-    public final DateTimeFieldProperty era() {
-        return new DateTimeFieldProperty(this, getChronology().era());
+    public final DateTimeFieldProperty dayOfWeek() {
+        return new DateTimeFieldProperty(this, getChronology().dayOfWeek());
     }
 
     // Time properties
     //-----------------------------------------------------------------------
     /**
-     * Get the millis of second property.
+     * Get the hour of day field property
      * 
-     * @return the millis of second property
+     * @return the hour of day property
      */
-    public final DateTimeFieldProperty millisOfSecond() {
-        return new DateTimeFieldProperty(this, getChronology().millisOfSecond());
+    public final DateTimeFieldProperty hourOfDay() {
+        return new DateTimeFieldProperty(this, getChronology().hourOfDay());
     }
 
     /**
-     * Get the millis of day property.
+     * Get the minute of day property
      * 
-     * @return the millis of day property
+     * @return the minute of day property
      */
-    public final DateTimeFieldProperty millisOfDay() {
-        return new DateTimeFieldProperty(this, getChronology().millisOfDay());
+    public final DateTimeFieldProperty minuteOfDay() {
+        return new DateTimeFieldProperty(this, getChronology().minuteOfDay());
     }
 
     /**
-     * Get the second of minute field property.
+     * Get the minute of hour field property
      * 
-     * @return the second of minute property
+     * @return the minute of hour property
      */
-    public final DateTimeFieldProperty secondOfMinute() {
-        return new DateTimeFieldProperty(this, getChronology().secondOfMinute());
+    public final DateTimeFieldProperty minuteOfHour() {
+        return new DateTimeFieldProperty(this, getChronology().minuteOfHour());
     }
 
     /**
-     * Get the second of day property.
+     * Get the second of day property
      * 
      * @return the second of day property
      */
@@ -521,30 +488,30 @@ public final DateTimeFieldProperty secondOfDay() {
     }
 
     /**
-     * Get the minute of hour field property.
+     * Get the second of minute field property
      * 
-     * @return the minute of hour property
+     * @return the second of minute property
      */
-    public final DateTimeFieldProperty minuteOfHour() {
-        return new DateTimeFieldProperty(this, getChronology().minuteOfHour());
+    public final DateTimeFieldProperty secondOfMinute() {
+        return new DateTimeFieldProperty(this, getChronology().secondOfMinute());
     }
 
     /**
-     * Get the minute of day property.
+     * Get the millis of day property
      * 
-     * @return the minute of day property
+     * @return the millis of day property
      */
-    public final DateTimeFieldProperty minuteOfDay() {
-        return new DateTimeFieldProperty(this, getChronology().minuteOfDay());
+    public final DateTimeFieldProperty millisOfDay() {
+        return new DateTimeFieldProperty(this, getChronology().millisOfDay());
     }
 
     /**
-     * Get the hour of day field property.
+     * Get the millis of second property
      * 
-     * @return the hour of day property
+     * @return the millis of second property
      */
-    public final DateTimeFieldProperty hourOfDay() {
-        return new DateTimeFieldProperty(this, getChronology().hourOfDay());
+    public final DateTimeFieldProperty millisOfSecond() {
+        return new DateTimeFieldProperty(this, getChronology().millisOfSecond());
     }
 
     // Output
@@ -558,4 +525,18 @@ public final String toString() {
         return ISODateTimeFormat.getInstance(getChronology()).dateTime().print(this);
     }
 
+    /**
+     * Overridden to do nothing, ensuring this class and all subclasses are
+     * immutable.
+     */
+    protected final void setMillis(long millis) {
+    }
+
+    /**
+     * Overridden to do nothing, ensuring this class and all subclasses are
+     * immutable.
+     */
+    protected final void setChronology(Chronology chronology) {
+    }
+
 }
diff --git a/JodaTime/src/java/org/joda/time/DateTimeComparator.java b/JodaTime/src/java/org/joda/time/DateTimeComparator.java
index 3d71f7d5e..ed897393d 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeComparator.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeComparator.java
@@ -53,7 +53,9 @@
  */
 package org.joda.time;
 
+import java.io.Serializable;
 import java.util.Comparator;
+import org.joda.time.convert.ConverterManager;
 
 /**
  * DateTimeComparator is the standard implementation of the Comparator
@@ -66,12 +68,17 @@
  * <li>java.util.Long (milliseconds)
  * </ul>
  *
+ * <p>
+ * DateTimeComparator is thread-safe and immutable.
+ *
  * @author Guy Allard
  * @author Stephen Colebourne
  * @author Brian S O'Neill
  * @since 1.0
  */
-public class DateTimeComparator implements Comparator {
+public class DateTimeComparator implements Comparator, Serializable {
+
+    static final long serialVersionUID = -6097339773320178364L;
 
     private static final DateTimeComparator INSTANCE = new DateTimeComparator(null, null);
 
@@ -132,6 +139,20 @@ private DateTimeComparator(DateTimeField lowerLimit, DateTimeField upperLimit) {
         iUpperLimit = upperLimit;
     }
 
+    /**
+     * @return null if no lower limit
+     */
+    public DateTimeField getLowerLimit() {
+        return iLowerLimit;
+    }
+
+    /**
+     * @return null if no upper limit
+     */
+    public DateTimeField getUpperLimit() {
+        return iUpperLimit;
+    }
+
     /**
      * Compare two objects against only the range of date time fields as
      * specified in the constructor.
@@ -140,35 +161,64 @@ private DateTimeComparator(DateTimeField lowerLimit, DateTimeField upperLimit) {
      * comparison
      * @param rhsObj The second object, logically on the right of a &lt;
      * comparison
-     * @return 0 if order does not matter, -1 if lhsObj &lt; rhsObj, 1
-     * otherwise.
-     * @throws IllegalArgumentException if either argument is null
-     * @throws ClassCastException if either argument is one of the support
-     * types
+     * @return zero if order does not matter, negative value if lhsObj &lt;
+     * rhsObj, positive value otherwise.
+     * @throws IllegalArgumentException if either argument is not supported
      */
     public int compare(Object lhsObj, Object rhsObj) {
-        long lhs = getMillisFromObject(lhsObj);
-        long rhs = getMillisFromObject(rhsObj);
+        long lhsMillis, rhsMillis;
+
+        if (lhsObj instanceof ReadableInstant) {
+            ReadableInstant lhsInstant = (ReadableInstant) lhsObj;
+
+            if (rhsObj instanceof ReadableInstant) {
+                ReadableInstant rhsInstant = (ReadableInstant) rhsObj;
+
+                // If instants are partial, then they can use each other to
+                // fill in missing fields.
+                lhsMillis = lhsInstant.getMillis(rhsInstant);
+                rhsMillis = rhsInstant.getMillis(lhsInstant);
+            } else {
+                lhsMillis = lhsInstant.getMillis();
+                rhsMillis = getMillisFromObject(rhsObj);
+            }
+        } else {
+            lhsMillis = getMillisFromObject(lhsObj);
+
+            if (rhsObj instanceof ReadableInstant) {
+                rhsMillis = ((ReadableInstant) rhsObj).getMillis();
+            } else {
+                rhsMillis = getMillisFromObject(rhsObj);
+            }
+        }
 
-        if (iLowerLimit != null) {
-            lhs = iLowerLimit.roundFloor(lhs);
-            rhs = iLowerLimit.roundFloor(rhs);
+        DateTimeField field;
+        if ((field = iLowerLimit) != null) {
+            lhsMillis = field.roundFloor(lhsMillis);
+            rhsMillis = field.roundFloor(rhsMillis);
         }
 
-        if (iUpperLimit != null) {
-            lhs = iUpperLimit.remainder(lhs);
-            rhs = iUpperLimit.remainder(rhs);
+        if ((field = iUpperLimit) != null) {
+            lhsMillis = field.remainder(lhsMillis);
+            rhsMillis = field.remainder(rhsMillis);
         }
 
-        if (lhs < rhs) {
+        if (lhsMillis < rhsMillis) {
             return -1;
-        } else if (lhs > rhs) {
+        } else if (lhsMillis > rhsMillis) {
             return 1;
         } else {
             return 0;
         }
     }
 
+    /**
+     * Support serialization singletons
+     */
+    private Object readResolve() {
+        return getInstance(iLowerLimit, iUpperLimit);
+    }
+
     /*
      * Developer's note: The 'equals' method specified by the interface is not
      * overridden here. It does not make sense to do so, since 'this' is a
@@ -179,29 +229,10 @@ public int compare(Object lhsObj, Object rhsObj) {
 
     /*
      * @param obj
-     * @throws ClassCastException
      * @return millis since the epoch
      */
-    private long getMillisFromObject(Object obj) {
-        if (obj instanceof ReadableInstant) {
-            return ((ReadableInstant)obj).getMillis();
-        }
-        if (obj instanceof java.util.Date) {
-            return ((java.util.Date)obj).getTime();
-        }
-        if (obj instanceof java.util.Calendar) {
-            return ((java.util.Calendar)obj).getTime().getTime();
-        }
-        if (obj instanceof Long) {
-            return ((Long)obj).longValue();
-        }
-
-        if (obj == null) {
-            throw new IllegalArgumentException("Object to compare must not be null");
-        }
-
-        throw new ClassCastException
-            ("Invalid class for DateTimeComparator: " + obj.getClass());
+    private static long getMillisFromObject(Object obj) {
+        return ConverterManager.getInstance().getInstantConverter(obj).getInstantMillis(obj);
     }
 
 }
diff --git a/JodaTime/src/java/org/joda/time/DateTimeConstants.java b/JodaTime/src/java/org/joda/time/DateTimeConstants.java
index dc42681c2..ac8521d92 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeConstants.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeConstants.java
@@ -53,12 +53,12 @@
  */
 package org.joda.time;
 
-import java.util.*;
-
 /**
  * DateTimeConstants is a non-instantiable class of constants used in
  * the date time system. These are the ISO8601 constants, but should be
  * used by all chronologies.
+ * <p>
+ * DateTimeConstants is thread-safe and immutable.
  *
  * @author Stephen Colebourne
  * @author Brian S O'Neill
@@ -103,55 +103,6 @@
     /** Constant (12) representing December, the twelfth month */
     public static final int DECEMBER = 12;
 
-
-    /**
-     * Constant list of the number of days in the month. The index into
-     * the list is the month constant as defined in ReadableDate, thus 
-     * MAX_DAYS_IN_MONTH.get(0) has no meaning and returns null. This is a 
-     * list rather than an array as it must be unmodifiable.
-     */
-    public static final List MAX_DAYS_PER_MONTH =
-        Collections.unmodifiableList(
-            Arrays.asList(
-                new Integer[] {
-                    null,
-                    new Integer(31),
-                    new Integer(29),
-                    new Integer(31),
-                    new Integer(30),
-                    new Integer(31),
-                    new Integer(30),
-                    new Integer(31),
-                    new Integer(31),
-                    new Integer(30),
-                    new Integer(31),
-                    new Integer(30),
-                    new Integer(31)}));
-    /**
-     * Constant list of the number of days in the month. The index into
-     * the list is the month constant as defined in ReadableDate, thus 
-     * MIN_DAYS_IN_MONTH.get(0) has no meaning and returns null. This is a 
-     * list rather than an array as it must be unmodifiable.
-     */
-    public static final List MIN_DAYS_PER_MONTH =
-        Collections.unmodifiableList(
-            Arrays.asList(
-                new Integer[] {
-                    null,
-                    new Integer(31),
-                    new Integer(28),
-                    new Integer(31),
-                    new Integer(30),
-                    new Integer(31),
-                    new Integer(30),
-                    new Integer(31),
-                    new Integer(31),
-                    new Integer(30),
-                    new Integer(31),
-                    new Integer(30),
-                    new Integer(31)}));
-
-
     // These are ints not enumerations as they represent genuine int values
     /** Constant (1) representing Monday, the first day of the week (ISO) */
     public static final int MONDAY = 1;
diff --git a/JodaTime/src/java/org/joda/time/DateTimeField.java b/JodaTime/src/java/org/joda/time/DateTimeField.java
index 24bf91a01..0378cf31e 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeField.java
@@ -53,118 +53,92 @@
  */
 package org.joda.time;
 
-import java.io.Serializable;
 import java.util.Locale;
 
 /**
- * DateTimeField is an abstract class which allows the date and time
- * manipulation code to be field based. Each field within a datetime
- * can be accessed and manipulated using a dedicated subclass of this
- * one.
+ * Defines the calculation engine for date and time fields.
+ * The interface defines a set of methods that manipulate a millisecond datetime
+ * with regards to a single field, such as monthOfYear or secondOfMinute.
  * <p>
- * This design is extensible, so if you wish to extract a different 
- * field from the milliseconds, you can do, simply by implementing
- * your own subclass.
+ * This design is extensible so, if you wish, you can extract a different field from
+ * the milliseconds. A number of standard implementations are provided to assist.
  *
  * @author Guy Allard
  * @author Stephen Colebourne
  * @author Brian S O'Neill
  * @since 1.0
  */
-public abstract class DateTimeField implements Serializable {
+public interface DateTimeField {
 
-    /** A desriptive name for the field */
-    private final String iName;
+    /**
+     * Get the name of the field.
+     * 
+     * @return field name
+     */
+    public String getName();
 
     /**
-     * Constructor.
+     * Returns true if this field is supported.
      * 
-     * @param name a short descriptive name for the field, such as
-     * millisOfSecond
-     */
-    protected DateTimeField(String name) {
-        super();
-        
-        iName = name;
-    }
-    
+     * @return true if this field is supported
+     */
+    public boolean isSupported();
+
     /**
-     * Get the name of the field.
+     * Returns true if the set method is lenient. If so, it accepts values that
+     * are out of bounds. For example, a lenient day of month field accepts 32
+     * for January, converting it to February 1.
      * 
-     * @return field name
+     * @return true if this field is lenient
      */
-    public String getName() {
-        return iName;
-    }
+    public boolean isLenient();
 
     // Main access API
     //------------------------------------------------------------------------
     /**
      * Get the value of this field from the milliseconds.
      * 
-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to query
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
      * @return the value of the field, in the units of the field
      */
-    public abstract int get(long millis);
+    public int get(long instant);
 
     /**
      * Get the human-readable, text value of this field from the milliseconds.
      * If the specified locale is null, the default locale is used.
-     * <p>
-     * The default implementation returns Integer.toString(get(millis)).
-     * <p>
-     * Note: subclasses that override this method should also override
-     * getMaximumTextLength.
      *
-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to query
-     * @param locale the locale to use for selecting a text symbol, null for
-     * default
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
+     * @param locale the locale to use for selecting a text symbol, null for default
      * @return the text value of the field
      */
-    public String getAsText(long millis, Locale locale) {
-        return Integer.toString(get(millis));
-    }
+    public String getAsText(long instant, Locale locale);
 
     /**
      * Get the human-readable, text value of this field from the milliseconds.
-     * This implementation returns getAsText(millis, null).
      * 
-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to query
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
      * @return the text value of the field
      */
-    public final String getAsText(long millis) {
-        return getAsText(millis, null);
-    }
+    public String getAsText(long instant);
 
     /**
      * Get the human-readable, short text value of this field from the
-     * milliseconds.  If the specified locale is null, the default locale is
-     * used.
-     * <p>
-     * The default implementation returns getAsText(millis, locale).
-     * <p>
-     * Note: subclasses that override this method should also override
-     * getMaximumShortTextLength.
+     * milliseconds.  If the specified locale is null, the default locale is used.
      *
-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to query
-     * @param locale the locale to use for selecting a text symbol, null for
-     * default
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
+     * @param locale the locale to use for selecting a text symbol, null for default
      * @return the short text value of the field
      */
-    public String getAsShortText(long millis, Locale locale) {
-        return getAsText(millis, locale);
-    }
+    public String getAsShortText(long instant, Locale locale);
 
     /**
      * Get the human-readable, short text value of this field from the
-     * milliseconds.  This implementation returns getAsShortText(millis, null).
+     * milliseconds.
      * 
-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to query
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
      * @return the short text value of the field
      */
-    public final String getAsShortText(long millis) {
-        return getAsShortText(millis, null);
-    }
+    public String getAsShortText(long instant);
 
     /**
      * Adds a value (which may be negative) to the millis value,
@@ -183,23 +157,23 @@ public final String getAsShortText(long millis) {
      * 2001-01-31 add one month  is 2001-02-28<br>
      * 2001-01-31 add two months is 2001-03-31<br>
      * 
-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to add to
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
      * @param value  the value to add, in the units of the field
      * @return the updated milliseconds
      */
-    public abstract long add(long millis, int value);
+    public long add(long instant, int value);
 
     /**
      * Adds a value (which may be negative) to the millis value,
      * overflowing into larger fields if necessary.
      * 
-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to add to
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
      * @param value  the long value to add, in the units of the field
      * @return the updated milliseconds
      * @throws IllegalArgumentException if value is too large
      * @see #add(long,int)
      */
-    public abstract long add(long millis, long value);
+    public long add(long instant, long value);
 
     /**
      * Adds a value (which may be negative) to the millis value,
@@ -218,16 +192,11 @@ public final String getAsShortText(long millis) {
      * 2001-01-31 addWrapped one month  is 2001-02-28<br>
      * 2001-01-31 addWrapped two months is 2001-03-31<br>
      * 
-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to add to
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
      * @param value  the value to add, in the units of the field
      * @return the updated milliseconds
      */
-    public long addWrapped(long millis, int value) {
-        int current = get(millis);
-        int wrapped = getWrappedValue
-            (current, value, getMinimumValue(millis), getMaximumValue(millis));
-        return set(millis, wrapped);
-    }
+    public long addWrapped(long instant, int value) ;
 
     /**
      * Computes the difference between two instants, as measured in the units
@@ -235,41 +204,41 @@ public long addWrapped(long millis, int value) {
      * getDifference reverses the effect of calling add. In the following code:
      *
      * <pre>
-     * long millis = ...
+     * long instant = ...
      * int v = ...
-     * long age = getDifference(add(millis, v), millis);
+     * int age = getDifference(add(instant, v), instant);
      * </pre>
      *
      * The value 'age' is the same as the value 'v'.
-     * <p>
-     * The default implementation performs a guess-and-check algorithm using
-     * the getUnitMillis and add methods. Subclasses are encouraged to provide
-     * a more efficient implementation.
      *
-     * @param minuendMillis the milliseconds from 1970-01-01T00:00:00Z to
+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to
+     * subtract from
+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to
+     * subtract off the minuend
+     * @return the difference in the units of this field
+     */
+    public int getDifference(long minuendInstant, long subtrahendInstant);
+
+    /**
+     * Computes the difference between two instants, as measured in the units
+     * of this field. Any fractional units are dropped from the result. Calling
+     * getDifference reverses the effect of calling add. In the following code:
+     *
+     * <pre>
+     * long instant = ...
+     * long v = ...
+     * long age = getDifferenceAsLong(add(instant, v), instant);
+     * </pre>
+     *
+     * The value 'age' is the same as the value 'v'.
+     *
+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to
      * subtract from
-     * @param subtrahendMillis the milliseconds from 1970-01-01T00:00:00Z to
+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to
      * subtract off the minuend
      * @return the difference in the units of this field
      */
-    public long getDifference(long minuendMillis, long subtrahendMillis) {
-        if (minuendMillis < subtrahendMillis) {
-            return -getDifference(subtrahendMillis, minuendMillis);
-        }
-
-        long difference = (minuendMillis - subtrahendMillis) / getUnitMillis();
-        if (add(subtrahendMillis, difference) < minuendMillis) {
-            do {
-                difference++;
-            } while (add(subtrahendMillis, difference) <= minuendMillis);
-            difference--;
-        } else if (add(subtrahendMillis, difference) > minuendMillis) {
-            do {
-                difference--;
-            } while (add(subtrahendMillis, difference) > minuendMillis);
-        }
-        return difference;
-    }
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant);
 
     /**
      * Sets a value in the milliseconds supplied.
@@ -277,103 +246,79 @@ public long getDifference(long minuendMillis, long subtrahendMillis) {
      * The value of this field will be set. If the value is invalid, an
      * exception if thrown. Other fields are always unaffected.
      * 
-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to set in
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in
      * @param value  the value to set, in the units of the field
      * @return the updated milliseconds
      * @throws IllegalArgumentException if the value is invalid
      */
-    public abstract long set(long millis, int value);
+    public long set(long instant, int value);
 
     /**
      * Sets a value in the milliseconds supplied from a human-readable, text
      * value. If the specified locale is null, the default locale is used.
-     * <p>
-     * The default implementation returns set(millis,
-     * Integer.parseInt(millis)).
-     * <p>
-     * Note: subclasses that override this method should also override
-     * getAsText.
      *
-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to set in
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in
      * @param text  the text value to set
      * @param locale the locale to use for selecting a text symbol, null for
      * default
      * @return the updated milliseconds
      * @throws IllegalArgumentException if the text value is invalid
      */
-    public long set(long millis, String text, Locale locale) {
-        try {
-            return set(millis, Integer.parseInt(text));
-        } catch (NumberFormatException ex) {
-            throw new IllegalArgumentException("Invalid " + getName() + " text: " + text);
-        }
-    }
+    public long set(long instant, String text, Locale locale);
 
     /**
      * Sets a value in the milliseconds supplied from a human-readable, text
-     * value. This implementation returns set(millis, text, null).
+     * value.
      * 
-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to set in
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in
      * @param text  the text value to set
      * @return the updated milliseconds
      * @throws IllegalArgumentException if the text value is invalid
      */
-    public final long set(long millis, String text) {
-        return set(millis, text, null);
-    }
+    public long set(long instant, String text);
 
     // Extra information API
     //------------------------------------------------------------------------
     /**
-     * Returns whether this field is 'leap' for the specified millis.
+     * Returns the duration per unit value of this field. For example, if this
+     * field represents "hour of day", then the duration is an hour.
+     *
+     * @return the duration of this field, or UnsupportedDurationField if field
+     * has no duration
+     */
+    public DurationField getDurationField();
+
+    /**
+     * Returns the range duration of this field. For example, if this field
+     * represents "hour of day", then the range duration is a day.
+     *
+     * @return the range duration of this field, or null if field has no range
+     */
+    public DurationField getRangeDurationField();
+
+    /**
+     * Returns whether this field is 'leap' for the specified instant.
      * <p>
      * For example, a leap year would return true, a non leap year would return
      * false.
-     * <p>
-     * This implementation returns false.
      * 
      * @return true if the field is 'leap'
      */
-    public boolean isLeap(long millis) {
-        return false;
-    }
+    public boolean isLeap(long instant);
 
     /**
-     * Gets the amount by which this field is 'leap' for the specified millis.
+     * Gets the amount by which this field is 'leap' for the specified instant.
      * <p>
      * For example, a leap year would return one, a non leap year would return
      * zero.
-     * <p>
-     * This implementation returns zero.
      */
-    public int getLeapAmount(long millis) {
-        return 0;
-    }
+    public int getLeapAmount(long instant);
 
     /**
-     * Returns the amount of milliseconds per unit value of this field. For
-     * example, if this field represents "hour of day", then the unit is the
-     * amount of milliseconds per one hour.
-     * <p>
-     * For fields with a variable unit size, this method returns a suitable
-     * average value.
-     *
-     * @return the unit size of this field, in milliseconds
-     */
-    public abstract long getUnitMillis();
-
-    /**
-     * Returns the range of this field, in milliseconds. For example, if this
-     * field represents "hour of day", then the range is the amount of
-     * milliseconds per one day.
-     * <p>
-     * For fields with a variable range, this method returns a suitable average
-     * value. If the range is too large to fit in a long, Long.MAX_VALUE is
-     * returned.
-     *
-     * @return the range of this field, in milliseconds
+     * If this field were to leap, then it would be in units described by the
+     * returned duration. If this field doesn't ever leap, null is returned.
      */
-    public abstract long getRangeMillis();
+    public DurationField getLeapDurationField();
 
     /**
      * Get the minimum allowable value for this field.
@@ -381,19 +326,15 @@ public int getLeapAmount(long millis) {
      * @return the minimum valid value for this field, in the units of the
      * field
      */
-    public abstract int getMinimumValue();
+    public int getMinimumValue();
 
     /**
      * Get the minimum value for this field evaluated at the specified time.
-     * <p>
-     * This implementation returns the same as {@link #getMinimumValue()}.
      * 
-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to query
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
      * @return the minimum value for this field, in the units of the field
      */
-    public int getMinimumValue(long millis) {
-        return getMinimumValue();
-    }
+    public int getMinimumValue(long instant);
 
     /**
      * Get the maximum allowable value for this field.
@@ -401,51 +342,31 @@ public int getMinimumValue(long millis) {
      * @return the maximum valid value for this field, in the units of the
      * field
      */
-    public abstract int getMaximumValue();
+    public int getMaximumValue();
 
     /**
      * Get the maximum value for this field evaluated at the specified time.
-     * <p>
-     * This implementation returns the same as {@link #getMaximumValue()}.
      * 
-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to query
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
      * @return the maximum value for this field, in the units of the field
      */
-    public int getMaximumValue(long millis) {
-        return getMaximumValue();
-    }
+    public int getMaximumValue(long instant);
 
     /**
-     * Get the maximum text value for this field. The default implementation
-     * returns the equivalent of Integer.toString(getMaximumValue()).length().
+     * Get the maximum text value for this field.
      * 
      * @param locale  the locale to use for selecting a text symbol
      * @return the maximum text length
      */
-    public int getMaximumTextLength(Locale locale) {
-        int max = getMaximumValue();
-        if (max >= 0) {
-            if (max < 10) {
-                return 1;
-            } else if (max < 100) {
-                return 2;
-            } else if (max < 1000) {
-                return 3;
-            }
-        }
-        return Integer.toString(max).length();
-    }
-
-    /**
-     * Get the maximum short text value for this field. The default
-     * implementation returns getMaximumTextLength().
+    public int getMaximumTextLength(Locale locale);
+
+    /**
+     * Get the maximum short text value for this field.
      * 
      * @param locale  the locale to use for selecting a text symbol
      * @return the maximum short text length
      */
-    public int getMaximumShortTextLength(Locale locale) {
-        return getMaximumTextLength(locale);
-    }
+    public int getMaximumShortTextLength(Locale locale);
 
     // Calculation API
     //------------------------------------------------------------------------
@@ -458,10 +379,10 @@ public int getMaximumShortTextLength(Locale locale) {
      * For example, a datetime of 2002-11-02T23:34:56.789, rounded to the
      * lowest whole hour is 2002-11-02T23:00:00.000.
      *
-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to round
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
      * @return rounded milliseconds
      */
-    public abstract long roundFloor(long millis);
+    public long roundFloor(long instant);
 
     /**
      * Round to the highest whole unit of this field. The value of this field
@@ -471,21 +392,11 @@ public int getMaximumShortTextLength(Locale locale) {
      * <p>
      * For example, a datetime of 2002-11-02T23:34:56.789, rounded to the
      * highest whole hour is 2002-11-03T00:00:00.000.
-     * <p>
-     * The default implementation calls roundFloor, and if the millis is
-     * modified as a result, adds one field unit. Subclasses are encouraged to
-     * provide a more efficient implementation.
      *
-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to round
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
      * @return rounded milliseconds
      */
-    public long roundCeiling(long millis) {
-        long newMillis = roundFloor(millis);
-        if (newMillis != millis) {
-            millis = add(newMillis, 1);
-        }
-        return millis;
-    }
+    public long roundCeiling(long instant);
 
     /**
      * Round to the nearest whole unit of this field. If the given millisecond
@@ -493,23 +404,10 @@ public long roundCeiling(long millis) {
      * behaves like roundFloor. If the millisecond value is closer to the
      * ceiling, this function behaves like roundCeiling.
      *
-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to round
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
      * @return rounded milliseconds
      */
-    public long roundHalfFloor(long millis) {
-        long floor = roundFloor(millis);
-        long ceiling = roundCeiling(millis);
-
-        long diffFromFloor = millis - floor;
-        long diffToCeiling = ceiling - millis;
-
-        if (diffFromFloor <= diffToCeiling) {
-            // Closer to the floor, or halfway - round floor
-            return floor;
-        } else {
-            return ceiling;
-        }
-    }
+    public long roundHalfFloor(long instant);
 
     /**
      * Round to the nearest whole unit of this field. If the given millisecond
@@ -517,23 +415,10 @@ public long roundHalfFloor(long millis) {
      * the millisecond value is closer to the ceiling or is exactly halfway,
      * this function behaves like roundCeiling.
      *
-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to round
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
      * @return rounded milliseconds
      */
-    public long roundHalfCeiling(long millis) {
-        long floor = roundFloor(millis);
-        long ceiling = roundCeiling(millis);
-
-        long diffFromFloor = millis - floor;
-        long diffToCeiling = ceiling - millis;
-
-        if (diffToCeiling <= diffFromFloor) {
-            // Closer to the ceiling, or halfway - round ceiling
-            return ceiling;
-        } else {
-            return floor;
-        }
-    }
+    public long roundHalfCeiling(long instant);
 
     /**
      * Round to the nearest whole unit of this field. If the given millisecond
@@ -545,154 +430,30 @@ public long roundHalfCeiling(long millis) {
      * ceiling, the ceiling is chosen over the floor only if it makes this
      * field's value even.
      *
-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to round
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
      * @return rounded milliseconds
      */
-    public long roundHalfEven(long millis) {
-        long floor = roundFloor(millis);
-        long ceiling = roundCeiling(millis);
-
-        long diffFromFloor = millis - floor;
-        long diffToCeiling = ceiling - millis;
-
-        if (diffFromFloor < diffToCeiling) {
-            // Closer to the floor - round floor
-            return floor;
-        } else if (diffToCeiling < diffFromFloor) {
-            // Closer to the ceiling - round ceiling
-            return ceiling;
-        } else {
-            // Round to the millis that makes this field even. If both values
-            // make this field even (unlikely), favor the ceiling.
-            if ((get(ceiling) & 1) == 0) {
-                return ceiling;
-            }
-            return floor;
-        }
-    }
-
-    /**
-     * Retains only the fractional units of this field. This field value and
-     * all fields of higher magnitude are reset. In other words, calling
-     * remainder retains the part of the instant that roundFloor dropped.
-     * <p>
-     * For example, a datetime of 2002-11-02T23:34:56.789, the remainder by
-     * hour is 1970-01-01T00:34:56.789.
-     * <p>
-     * The default implementation computes
-     * <code>millis - roundFloor(millis)</code>. Subclasses are encouraged to
-     * provide a more efficient implementation.
-     *
-     * @param millis the milliseconds from 1970-01-01T00:00:00Z to get the
-     * remainder
-     * @return remainder milliseconds
-     */
-    public long remainder(long millis) {
-        return millis - roundFloor(millis);
-    }
-
-    // Implementation helper methods
-    //------------------------------------------------------------------------
-    /**
-     * Verify that input values are within specified bounds.
-     * 
-     * @param value  the value to check
-     * @param lowerBound  the lower bound allowed for value
-     * @param upperBound  the upper bound allowed for value
-     * @throws IllegalArgumentException if value is not in the specified bounds
-     */
-    protected void verifyValueBounds(int value, int lowerBound, int upperBound) {
-        if ((value < lowerBound) || (value > upperBound)) {
-            throw new IllegalArgumentException(
-                "Value: "
-                    + value
-                    + " for "
-                    + iName
-                    + " must be in the range ("
-                    + lowerBound
-                    + ','
-                    + upperBound
-                    + ')');
-        }
-    }
-
-    /**
-     * Utility method used by addWrapped implementations to ensure the new
-     * value lies within the field's legal value range.
-     *
-     * @param currentValue the current value of the data, which may lie outside
-     * the wrapped value range
-     * @param wrapValue  the value to add to current value before
-     *  wrapping.  This may be negative.
-     * @param minValue the wrap range minimum value.
-     * @param maxValue the wrap range maximum value.  This must be
-     *  greater than minValue (checked by the method).
-     * @return the wrapped value
-     * @throws IllegalArgumentException if minValue is greater
-     *  than or equal to maxValue
-     */
-    protected final int getWrappedValue(int currentValue, int wrapValue,
-                                        int minValue, int maxValue) {
-        return getWrappedValue(currentValue + wrapValue, minValue, maxValue);
-    }
-
-    /**
-     * Utility method that ensures the given value lies within the field's
-     * legal value range.
-     * 
-     * @param value  the value to fit into the wrapped value range
-     * @param minValue the wrap range minimum value.
-     * @param maxValue the wrap range maximum value.  This must be
-     *  greater than minValue (checked by the method).
-     * @return the wrapped value
-     * @throws IllegalArgumentException if minValue is greater
-     *  than or equal to maxValue
-     */
-    protected final int getWrappedValue(int value, int minValue, int maxValue) {
-        if (minValue >= maxValue) {
-            throw new IllegalArgumentException("MIN > MAX");
-        }
-
-        int wrapRange = maxValue - minValue + 1;
-        value -= minValue;
-
-        if (value >= 0) {
-            return (value % wrapRange) + minValue;
-        }
-
-        int remByRange = (-value) % wrapRange;
-
-        if (remByRange == 0) {
-            return 0 + minValue;
-        }
-        return (wrapRange - remByRange) + minValue;
-    }
+    public long roundHalfEven(long instant);
 
     /**
-     * If value can be safely cast to an int, then add(long, int) is called,
-     * returning its result. Otherwise, an IllegalArgumentException is thrown.
+     * Returns the fractional duration milliseconds of this field. In other
+     * words, calling remainder returns the duration that roundFloor would
+     * subtract.
+     * <p>
+     * For example, on a datetime of 2002-11-02T23:34:56.789, the remainder by
+     * hour is 34 minutes and 56.789 seconds.
      *
-     * @param millis  the milliseconds from 1970-01-01T00:00:00Z to add to
-     * @param value  the value to add, in the units of the field
-     * @return the updated milliseconds
-     * @throws IllegalArgumentException if value is too large
+     * @param instant the milliseconds from 1970-01-01T00:00:00Z to get the
+     * remainder
+     * @return remainder duration, in milliseconds
      */
-    protected long addLong(long millis, long value) {
-        int i_value = (int)value;
-        if (i_value == value) {
-            return add(millis, i_value);
-        }
-        throw new IllegalArgumentException
-            ("Magnitude of add amount is too large: " + value);
-    }
+    public long remainder(long instant);
 
     /**
      * Get a suitable debug string.
      * 
      * @return debug string
      */
-    public String toString() {
-        return "DateTimeField[" + iName + ']';
-    }
+    public String toString();
     
 }
diff --git a/JodaTime/src/java/org/joda/time/DateTimeFieldProperty.java b/JodaTime/src/java/org/joda/time/DateTimeFieldProperty.java
index 2da562ef9..79af26ca7 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeFieldProperty.java
@@ -54,13 +54,31 @@
 package org.joda.time;
 
 import java.util.Locale;
-import java.io.Serializable;
 
 /**
- * DateTimeFieldProperty binds a ReadableInstant to a DateTimeField.
+ * DateTimeFieldProperty binds a DateTime to a DateTimeField allowing powerful
+ * datetime functionality to be easily accessed.
  * <p>
- * DateTimeFieldProperty allows the date and time manipulation code to be 
- * field based yet still easy to use.
+ * The simplest use of this class is as an alternative get method, here used to
+ * get the year '1972' (as an int) and the month 'December' (as a String).
+ * <pre>
+ * DateTime dt = new DateTime(1972, 12, 3, 0, 0, 0, 0);
+ * int year = dt.year().get();
+ * String monthStr = dt.month().getAsText();
+ * </pre>
+ * <p>
+ * Methods are also provided that allow date modification. These return new instances
+ * of DateTime - they do not modify the original. The example below yields two
+ * independent immutable date objects 20 years apart.
+ * <pre>
+ * DateTime dt = new DateTime(1972, 12, 3, 0, 0, 0, 0);
+ * DateTime dt20 = dt.year().addToCopy(20);
+ * </pre>
+ * Serious modification of dates (ie. more than just changing one or two fields)
+ * should use the {@link MutableDateTime} class.
+ * <p>
+ * DateTimeFieldPropery itself is thread-safe and immutable, as well as the
+ * DateTime being operated on.
  *
  * @see ReadableInstant
  * @see DateTimeField
@@ -69,10 +87,12 @@
  * @author Brian S O'Neill
  * @since 1.0
  */
-public class DateTimeFieldProperty implements Serializable {
+public class DateTimeFieldProperty extends AbstractDateTimeFieldProperty {
     
+    static final long serialVersionUID = -6983323811635733510L;
+
     /** The instant this property is working against */
-    private final ReadableInstant iInstant;
+    private final DateTime iInstant;
     /** The field this property is working against */
     private final DateTimeField iField;
 
@@ -82,7 +102,7 @@
      * @param instant  the instant to set
      * @param field  the field to use
      */
-    public DateTimeFieldProperty(ReadableInstant instant, DateTimeField field) {
+    public DateTimeFieldProperty(DateTime instant, DateTimeField field) {
         super();
         iInstant = instant;
         iField = field;
@@ -99,12 +119,12 @@ public DateTimeField getField() {
     }
 
     /**
-     * Gets the name of the field.
+     * Gets the instant being used.
      * 
-     * @return the field name
+     * @return the instant
      */
-    public String getName() {
-        return iField.getName();
+    public ReadableDateTime getInstant() {
+        return iInstant;
     }
 
     /**
@@ -112,229 +132,168 @@ public String getName() {
      * 
      * @return the instant
      */
-    public ReadableInstant getInstant() {
+    public DateTime getDateTime() {
         return iInstant;
     }
 
     //-----------------------------------------------------------------------
     /**
-     * Gets a value from the instant.
-     * 
-     * @return the current value
-     * @see DateTimeField#get
-     */
-    public int get() {
-        return iField.get(iInstant.getMillis());
-    }
-
-    /**
-     * Gets a text value from the instant.
-     * 
-     * @param locale  optional locale to use for selecting a text symbol
-     * @return the current text value
-     * @see DateTimeField#getAsText
-     */
-    public String getAsText(Locale locale) {
-        return iField.getAsText(iInstant.getMillis(), locale);
-    }
-
-    /**
-     * Gets a text value from the instant.
-     * 
-     * @return the current text value
-     * @see DateTimeField#getAsText
-     */
-    public final String getAsText() {
-        return iField.getAsText(iInstant.getMillis(), null);
-    }
-
-    /**
-     * Gets a short text value from the instant.
-     * 
-     * @param locale  optional locale to use for selecting a text symbol
-     * @return the current text value
-     * @see DateTimeField#getAsShortText
-     */
-    public String getAsShortText(Locale locale) {
-        return iField.getAsShortText(iInstant.getMillis(), locale);
-    }
-
-    /**
-     * Gets a short text value from the instant.
+     * Adds to this field in a copy of this DateTime.
+     * <p>
+     * The DateTime attached to this property is unchanged by this call.
+     * This operation is faster than converting a DateTime to a MutableDateTime
+     * and back again when setting one field. When setting multiple fields,
+     * it is generally quicker to make the conversion to MutableDateTime.
      * 
-     * @return the current text value
-     * @see DateTimeField#getAsShortText
-     */
-    public final String getAsShortText() {
-        return getAsShortText(null);
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Returns the difference between this field property instant and the one
-     * passed in, in the units of this field. The sign of the difference
-     * matches that of compareTo. In other words, this field property's instant
-     * is the minuend.
-     *
-     * @param instant the subtrahend
-     * @return the difference in the units of this field
-     * @see DateTimeField#getDifference
+     * @param value  the value to add to the field in the copy
+     * @return a copy of the DateTime with the field value changed
+     * @throws IllegalArgumentException if the value isn't valid
      */
-    public long getDifference(ReadableInstant instant) {
-        if (instant == null) {
-            throw new IllegalArgumentException("The instant must not be null");
-        }
-        return iField.getDifference(iInstant.getMillis(), instant.getMillis());
+    public DateTime addToCopy(int value) {
+        long newMillis = iField.add(iInstant.getMillis(), value);
+        return iInstant.createDateTime(newMillis, iInstant.getChronology());
     }
 
     /**
-     * Gets whether this field is leap.
+     * Adds to this field in a copy of this DateTime.
+     * <p>
+     * The DateTime attached to this property is unchanged by this call.
+     * This operation is faster than converting a DateTime to a MutableDateTime
+     * and back again when setting one field. When setting multiple fields,
+     * it is generally quicker to make the conversion to MutableDateTime.
      * 
-     * @return true if a leap field
-     * @see DateTimeField#isLeap
+     * @param value  the value to add to the field in the copy
+     * @return a copy of the DateTime with the field value changed
+     * @throws IllegalArgumentException if the value isn't valid
      */
-    public boolean isLeap() {
-        return iField.isLeap(iInstant.getMillis());
+    public DateTime addToCopy(long value) {
+        long newMillis = iField.add(iInstant.getMillis(), value);
+        return iInstant.createDateTime(newMillis, iInstant.getChronology());
     }
 
     /**
-     * Gets the amount by which this field is leap.
+     * Adds to this field, possibly wrapped, in a copy of this DateTime.
+     * A wrapped operation only changes this field.
+     * Thus 31st January addWrapped one day goes to the 1st January.
+     * <p>
+     * The DateTime attached to this property is unchanged by this call.
+     * This operation is faster than converting a DateTime to a MutableDateTime
+     * and back again when setting one field. When setting multiple fields,
+     * it is generally quicker to make the conversion to MutableDateTime.
      * 
-     * @return the amount by which the field is leap
-     * @see DateTimeField#getLeapAmount
+     * @param value  the value to add to the field in the copy
+     * @return a copy of the DateTime with the field value changed
+     * @throws IllegalArgumentException if the value isn't valid
      */
-    public int getLeapAmount() {
-        return iField.getLeapAmount(iInstant.getMillis());
+    public DateTime addWrappedToCopy(int value) {
+        long newMillis = iField.addWrapped(iInstant.getMillis(), value);
+        return iInstant.createDateTime(newMillis, iInstant.getChronology());
     }
 
     //-----------------------------------------------------------------------
     /**
-     * Gets the minimum value for the field ignoring the current time.
-     * 
-     * @return the minimum value
-     * @see DateTimeField#getMinimumValue
-     */
-    public int getMinimumValueOverall() {
-        return iField.getMinimumValue();
-    }
-
-    /**
-     * Gets the minimum value for the field.
+     * Sets this field in a copy of the DateTime.
+     * <p>
+     * The DateTime attached to this property is unchanged by this call.
+     * This operation is faster than converting a DateTime to a MutableDateTime
+     * and back again when setting one field. When setting multiple fields,
+     * it is generally quicker to make the conversion to MutableDateTime.
      * 
-     * @return the minimum value
-     * @see DateTimeField#getMinimumValue
+     * @param value  the value to set the field in the copy to
+     * @return a copy of the DateTime with the field value changed
+     * @throws IllegalArgumentException if the value isn't valid
      */
-    public int getMinimumValue() {
-        return iField.getMinimumValue(iInstant.getMillis());
+    public DateTime setCopy(int value) {
+        long newMillis = iField.set(iInstant.getMillis(), value);
+        return iInstant.createDateTime(newMillis, iInstant.getChronology());
     }
-
+    
     /**
-     * Gets the maximum value for the field ignoring the current time.
+     * Sets this field in a copy of the DateTime to a parsed text value.
+     * <p>
+     * The DateTime attached to this property is unchanged by this call.
+     * This operation is faster than converting a DateTime to a MutableDateTime
+     * and back again when setting one field. When setting multiple fields,
+     * it is generally quicker to make the conversion to MutableDateTime.
      * 
-     * @return the maximum value
-     * @see DateTimeField#getMaximumValue
+     * @param text  the text value to set
+     * @param locale  optional locale to use for selecting a text symbol
+     * @return a copy of the DateTime with the field value changed
+     * @throws IllegalArgumentException if the text value isn't valid
      */
-    public int getMaximumValueOverall() {
-        return iField.getMaximumValue();
+    public DateTime setCopy(String text, Locale locale) {
+        long newMillis = iField.set(iInstant.getMillis(), text, locale);
+        return iInstant.createDateTime(newMillis, iInstant.getChronology());
     }
 
     /**
-     * Gets the maximum value for the field.
+     * Sets this field in a copy of the DateTime to a parsed text value.
+     * <p>
+     * The DateTime attached to this property is unchanged by this call.
+     * This operation is faster than converting a DateTime to a MutableDateTime
+     * and back again when setting one field. When setting multiple fields,
+     * it is generally quicker to make the conversion to MutableDateTime.
      * 
-     * @return the maximum value
-     * @see DateTimeField#getMaximumValue
+     * @param text  the text value to set
+     * @return a copy of the DateTime with the field value changed
+     * @throws IllegalArgumentException if the text value isn't valid
      */
-    public int getMaximumValue() {
-        return iField.getMaximumValue(iInstant.getMillis());
+    public final DateTime setCopy(String text) {
+        return setCopy(text, null);
     }
 
+    //-----------------------------------------------------------------------
     /**
-     * Gets the maximum text length for the field.
-     * 
-     * @param locale  optional locale to use for selecting a text symbol
-     * @return the maximum length
-     * @see DateTimeField#getMaximumTextLength
+     * Rounds to the lowest whole unit of this field on a copy of this DateTime.
+     *
+     * @return a copy of the DateTime with the field value changed
      */
-    public int getMaximumTextLength(Locale locale) {
-        return iField.getMaximumTextLength(locale);
+    public DateTime roundFloorCopy() {
+        long newMillis = iField.roundFloor(iInstant.getMillis());
+        return iInstant.createDateTime(newMillis, iInstant.getChronology());
     }
 
     /**
-     * Gets the maximum short text length for the field.
-     * 
-     * @param locale  optional locale to use for selecting a text symbol
-     * @return the maximum length
-     * @see DateTimeField#getMaximumShortTextLength
+     * Rounds to the highest whole unit of this field on a copy of this DateTime.
+     *
+     * @return a copy of the DateTime with the field value changed
      */
-    public int getMaximumShortTextLength(Locale locale) {
-        return iField.getMaximumShortTextLength(locale);
+    public DateTime roundCeilingCopy() {
+        long newMillis = iField.roundCeiling(iInstant.getMillis());
+        return iInstant.createDateTime(newMillis, iInstant.getChronology());
     }
 
-    //-----------------------------------------------------------------------
     /**
-     * Returns the amount of milliseconds per unit value of this field. For
-     * example, if this field represents "hour of day", then the unit is the
-     * amount of milliseconds per one hour.
-     * <p>
-     * For fields with a variable unit size, this method returns a suitable
-     * average value.
+     * Rounds to the nearest whole unit of this field on a copy of this DateTime,
+     * favoring the floor if halfway.
      *
-     * @return the unit size of this field, in milliseconds
+     * @return a copy of the DateTime with the field value changed
      */
-    public long getUnitMillis() {
-        return iField.getUnitMillis();
+    public DateTime roundHalfFloorCopy() {
+        long newMillis = iField.roundHalfFloor(iInstant.getMillis());
+        return iInstant.createDateTime(newMillis, iInstant.getChronology());
     }
 
     /**
-     * Returns the range of this field, in milliseconds. For example, if this
-     * field represents "hour of day", then the range is the amount of
-     * milliseconds per one day.
-     * <p>
-     * For fields with a variable range, this method returns a suitable average
-     * value. If the range is too large to fit in a long, Long.MAX_VALUE is
-     * returned.
+     * Rounds to the nearest whole unit of this field on a copy of this DateTime,
+     * favoring the ceiling if halfway.
      *
-     * @return the range of this field, in milliseconds
+     * @return a copy of the DateTime with the field value changed
      */
-    public long getRangeMillis() {
-        return iField.getRangeMillis();
+    public DateTime roundHalfCeilingCopy() {
+        long newMillis = iField.roundHalfCeiling(iInstant.getMillis());
+        return iInstant.createDateTime(newMillis, iInstant.getChronology());
     }
 
-    //-----------------------------------------------------------------------
     /**
-     * Compare this field to the same field on another instant.
-     * <p>
-     * The {@link #get()} method is used to obtain the value to compare for
-     * this instant and the {@link ReadableInstant#get(DateTimeField)} method
-     * is used for the specified instant.
-     * 
-     * @param instant  the instant to compare to
-     * @return -1 if this is less, +1 if more and 0 if equal
-     * @throws IllegalArgumentException if the instant is null
-     */
-    public int compareTo(ReadableInstant instant) {
-        if (instant == null) {
-            throw new IllegalArgumentException("The instant must not be null");
-        }
-        int thisValue = get();
-        int otherValue = iField.get(instant.getMillis());
-        if (thisValue < otherValue) {
-            return -1;
-        } else if (thisValue > otherValue) {
-            return 1;
-        } else {
-            return 0;
-        }
-    }
-    
-    //-----------------------------------------------------------------------
-    /**
-     * Output a debugging string.
-     * 
-     * @return debugging string
+     * Rounds to the nearest whole unit of this field on a copy of this DateTime.
+     * If halfway, the ceiling is favored over the floor only if it makes this field's value even.
+     *
+     * @return a copy of the DateTime with the field value changed
      */
-    public String toString() {
-        return "DateTimeFieldProperty[" + getName() + "]";
+    public DateTime roundHalfEvenCopy() {
+        long newMillis = iField.roundHalfEven(iInstant.getMillis());
+        return iInstant.createDateTime(newMillis, iInstant.getChronology());
     }
 
 }
diff --git a/JodaTime/src/java/org/joda/time/DateTimeZone.java b/JodaTime/src/java/org/joda/time/DateTimeZone.java
index beaadfd47..a5f30cb9c 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeZone.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeZone.java
@@ -59,7 +59,6 @@
 import java.io.ObjectOutputStream;
 import java.io.ObjectStreamException;
 import java.io.Serializable;
-import java.text.ParseException;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Locale;
@@ -68,6 +67,7 @@
 
 import org.joda.time.format.DateTimeFormatter;
 import org.joda.time.format.DateTimeFormatterBuilder;
+import org.joda.time.tz.DateTimeZonePermission;
 import org.joda.time.tz.DefaultNameProvider;
 import org.joda.time.tz.FixedDateTimeZone;
 import org.joda.time.tz.NameProvider;
@@ -110,6 +110,8 @@
  * However, the factory that accepts a TimeZone will attempt to convert from
  * the old short id to a suitable long id.
  * <p>
+ * DateTimeZone is thread-safe and immutable, and all subclasses must be as
+ * well.
  * 
  * @author Brian S O'Neill
  * @author Stephen Colebourne
@@ -117,6 +119,8 @@
  */
 public abstract class DateTimeZone implements Serializable {
     
+    static final long serialVersionUID = 5546345482340108586L;
+
     /** The UTC time zone */
     public static final DateTimeZone UTC = new FixedDateTimeZone("UTC", "UTC", 0, 0);
 
@@ -134,52 +138,8 @@
     private static Map cZoneIdConversion;
 
     static {
-        Provider provider = null;
-
-        String providerClass = System.getProperty("org.joda.time.DateTimeZone.Provider");
-        if (providerClass != null) {
-            try {
-                provider = (Provider)Class.forName(providerClass).newInstance();
-            }
-            catch (Exception e) {
-                Thread t = Thread.currentThread();
-                t.getThreadGroup().uncaughtException(t, e);
-            }
-        }
-
-        if (provider == null) {
-            try {
-                provider = new ZoneInfoProvider("org/joda/time/tz/data");
-            } catch (Exception e) {
-                Thread t = Thread.currentThread();
-                t.getThreadGroup().uncaughtException(t, e);
-            }
-        }
-
-        if (provider == null) {
-            provider = new UTCProvider();
-        }
-
-        setProvider(provider);
-
-        NameProvider nameProvider = null;
-
-        providerClass = System.getProperty("org.joda.time.DateTimeZone.NameProvider");
-        if (providerClass != null) {
-            try {
-                nameProvider = (NameProvider)Class.forName(providerClass).newInstance();
-            }
-            catch (Exception e) {
-                Thread t = Thread.currentThread();
-                t.getThreadGroup().uncaughtException(t, e);
-            }
-        }
-
-        if (nameProvider == null) {
-            nameProvider = new DefaultNameProvider();
-        }
-
-        setNameProvider(nameProvider);
+        setProvider0(null);
+        setNameProvider0(null);
 
         try {
             try {
@@ -211,7 +171,10 @@ public static DateTimeZone getDefault() {
      * @throws IllegalArgumentException if the zone is null
      */
     public static void setDefault(DateTimeZone zone) throws SecurityException {
-        // TODO: Put in a security check.
+        SecurityManager sm = System.getSecurityManager();
+        if (sm != null) {
+            sm.checkPermission(new DateTimeZonePermission("setDefault"));
+        }
         if (zone == null) {
             throw new IllegalArgumentException("The datetime zone must not be null");
         }
@@ -245,14 +208,10 @@ public static DateTimeZone getInstance(String id) throws IllegalArgumentExceptio
             return zone;
         }
         if (id.startsWith("+") || id.startsWith("-")) {
-            try {
-                int offset = -(int)offsetFormatter().parseMillis(id);
-                // Canonicalize the id.
-                id = offsetFormatter().print(0, UTC, offset);
-                return new FixedDateTimeZone(id, null, offset, offset);
-            } catch (ParseException e) {
-                throw new IllegalArgumentException(e.getMessage());
-            }
+            int offset = -(int)offsetFormatter().parseMillis(id);
+            // Canonicalize the id.
+            id = offsetFormatter().print(0, UTC, offset);
+            return new FixedDateTimeZone(id, null, offset, offset);
         }
         throw new IllegalArgumentException("The datetime zone id is not recognised: " + id);
     }
@@ -293,14 +252,10 @@ public static DateTimeZone getInstance(java.util.TimeZone zone) {
             convId = zone.getDisplayName();
             if (convId.startsWith("GMT+") || convId.startsWith("GMT-")) {
                 convId = convId.substring(3);
-                try {
-                    int offset = -(int)offsetFormatter().parseMillis(convId);
-                    // Canonicalize the id.
-                    convId = offsetFormatter().print(0, UTC, offset);
-                    return new FixedDateTimeZone(convId, null, offset, offset);
-                } catch (ParseException e) {
-                    throw new IllegalArgumentException(e.getMessage());
-                }
+                int offset = -(int)offsetFormatter().parseMillis(convId);
+                // Canonicalize the id.
+                convId = offsetFormatter().print(0, UTC, offset);
+                return new FixedDateTimeZone(convId, null, offset, offset);
             }
         }
 
@@ -343,10 +298,23 @@ public static Provider getProvider() {
         return cProvider;
     }
 
+    /**
+     * @param provider provider to use, or null for default
+     */
     public static void setProvider(Provider provider) throws SecurityException {
-        // TODO: Put in a security check.
+        SecurityManager sm = System.getSecurityManager();
+        if (sm != null) {
+            sm.checkPermission(new DateTimeZonePermission("setProvider"));
+        }
+        setProvider0(provider);
+    }
+
+    /**
+     * Doesn't perform a security check.
+     */
+    private static void setProvider0(Provider provider) {
         if (provider == null) {
-            throw new IllegalArgumentException("The provider must not be null");
+            provider = getDefaultProvider();
         }
         Set ids = provider.getAvailableIDs();
         if (ids == null || ids.size() == 0) {
@@ -367,10 +335,23 @@ public static NameProvider getNameProvider() {
         return cNameProvider;
     }
 
+    /**
+     * @param nameProvider provider to use, or null for default
+     */
     public static void setNameProvider(NameProvider nameProvider) throws SecurityException {
-        // TODO: Put in a security check.
+        SecurityManager sm = System.getSecurityManager();
+        if (sm != null) {
+            sm.checkPermission(new DateTimeZonePermission("setNameProvider"));
+        }
+        setNameProvider0(nameProvider);
+    }
+
+    /**
+     * Doesn't perform a security check.
+     */
+    private static void setNameProvider0(NameProvider nameProvider) {
         if (nameProvider == null) {
-            throw new IllegalArgumentException("The provider must not be null");
+            nameProvider = getDefaultNameProvider();
         }
         cNameProvider = nameProvider;
     }
@@ -426,6 +407,65 @@ private static synchronized DateTimeFormatter offsetFormatter() {
         return cOffsetFormatter;
     }
 
+    private static Provider getDefaultProvider() {
+        Provider provider = null;
+
+        try {
+            String providerClass =
+                System.getProperty("org.joda.time.DateTimeZone.Provider");
+            if (providerClass != null) {
+                try {
+                    provider = (Provider)Class.forName(providerClass).newInstance();
+                }
+                catch (Exception e) {
+                    Thread t = Thread.currentThread();
+                    t.getThreadGroup().uncaughtException(t, e);
+                }
+            }
+        } catch (SecurityException e) {
+        }
+
+        if (provider == null) {
+            try {
+                provider = new ZoneInfoProvider("org/joda/time/tz/data");
+            } catch (Exception e) {
+                Thread t = Thread.currentThread();
+                t.getThreadGroup().uncaughtException(t, e);
+            }
+        }
+
+        if (provider == null) {
+            provider = new UTCProvider();
+        }
+
+        return provider;
+    }
+
+    private static NameProvider getDefaultNameProvider() {
+        NameProvider nameProvider = null;
+
+        try {
+            String providerClass =
+                System.getProperty("org.joda.time.DateTimeZone.NameProvider");
+            if (providerClass != null) {
+                try {
+                    nameProvider = (NameProvider)Class.forName(providerClass).newInstance();
+                }
+                catch (Exception e) {
+                    Thread t = Thread.currentThread();
+                    t.getThreadGroup().uncaughtException(t, e);
+                }
+            }
+        } catch (SecurityException e) {
+        }
+
+        if (nameProvider == null) {
+            nameProvider = new DefaultNameProvider();
+        }
+
+        return nameProvider;
+    }
+
     // Instance fields and methods
     //--------------------------------------------------------------------
 
@@ -454,10 +494,10 @@ public final String getID() {
      * Returns a non-localized name that is unique to this time zone. It can be
      * combined with id to form a unique key for fetching localized names.
      *
-     * @param millis milliseconds from 1970-01-01T00:00:00Z to get the name for
+     * @param instant milliseconds from 1970-01-01T00:00:00Z to get the name for
      * @return name key or null if id should be used for names
      */
-    public abstract String getNameKey(long millis);
+    public abstract String getNameKey(long instant);
 
     /**
      * Gets the short name of this datetime zone suitable for display using
@@ -466,11 +506,11 @@ public final String getID() {
      * If the name is not available for the locale, then this method returns a
      * string in the format <code>[+-]hh:mm</code>.
      * 
-     * @param millis milliseconds from 1970-01-01T00:00:00Z to get the name for
+     * @param instant milliseconds from 1970-01-01T00:00:00Z to get the name for
      * @return the human-readable short name in the default locale
      */
-    public final String getShortName(long millis) {
-        return getShortName(millis, null);
+    public final String getShortName(long instant) {
+        return getShortName(instant, null);
     }
 
     /**
@@ -480,14 +520,14 @@ public final String getShortName(long millis) {
      * If the name is not available for the locale, then this method returns a
      * string in the format <code>[+-]hh:mm</code>.
      * 
-     * @param millis milliseconds from 1970-01-01T00:00:00Z to get the name for
+     * @param instant milliseconds from 1970-01-01T00:00:00Z to get the name for
      * @return the human-readable short name in the specified locale
      */
-    public String getShortName(long millis, Locale locale) {
+    public String getShortName(long instant, Locale locale) {
         if (locale == null) {
             locale = Locale.getDefault();
         }
-        String nameKey = getNameKey(millis);
+        String nameKey = getNameKey(instant);
         if (nameKey == null) {
             return iID;
         }
@@ -495,7 +535,7 @@ public String getShortName(long millis, Locale locale) {
         if (name != null) {
             return name;
         }
-        return offsetFormatter().print(millis, this);
+        return offsetFormatter().print(instant, this);
     }
 
     /**
@@ -505,11 +545,11 @@ public String getShortName(long millis, Locale locale) {
      * If the name is not available for the locale, then this method returns a
      * string in the format <code>[+-]hh:mm</code>.
      * 
-     * @param millis milliseconds from 1970-01-01T00:00:00Z to get the name for
+     * @param instant milliseconds from 1970-01-01T00:00:00Z to get the name for
      * @return the human-readable long name in the default locale
      */
-    public final String getName(long millis) {
-        return getName(millis, null);
+    public final String getName(long instant) {
+        return getName(instant, null);
     }
 
     /**
@@ -519,14 +559,14 @@ public final String getName(long millis) {
      * If the name is not available for the locale, then this method returns a
      * string in the format <code>[+-]hh:mm</code>.
      * 
-     * @param millis milliseconds from 1970-01-01T00:00:00Z to get the name for
+     * @param instant milliseconds from 1970-01-01T00:00:00Z to get the name for
      * @return the human-readable long name in the specified locale
      */
-    public String getName(long millis, Locale locale) {
+    public String getName(long instant, Locale locale) {
         if (locale == null) {
             locale = Locale.getDefault();
         }
-        String nameKey = getNameKey(millis);
+        String nameKey = getNameKey(instant);
         if (nameKey == null) {
             return iID;
         }
@@ -534,16 +574,16 @@ public String getName(long millis, Locale locale) {
         if (name != null) {
             return name;
         }
-        return offsetFormatter().print(millis, this);
+        return offsetFormatter().print(instant, this);
     }
 
     /**
      * Gets the millisecond offset to add to UTC to get local time.
      * 
-     * @param millis milliseconds from 1970-01-01T00:00:00Z to get the offset for
+     * @param instant milliseconds from 1970-01-01T00:00:00Z to get the offset for
      * @return the millisecond offset to add to UTC to get local time
      */
-    public abstract int getOffset(long millis);
+    public abstract int getOffset(long instant);
 
     /**
      * Gets the millisecond offset to add to UTC to get local time.
@@ -563,10 +603,10 @@ public final int getOffset(ReadableInstant instant) {
      * Gets the standard millisecond offset to add to UTC to get local time,
      * when standard time is in effect.
      * 
-     * @param millis milliseconds from 1970-01-01T00:00:00Z to get the offset for
+     * @param instant milliseconds from 1970-01-01T00:00:00Z to get the offset for
      * @return the millisecond offset to add to UTC to get local time
      */
-    public abstract int getStandardOffset(long millis);
+    public abstract int getStandardOffset(long instant);
 
     /**
      * Gets the millisecond offset to subtract from local time to get UTC time.
@@ -581,33 +621,40 @@ public final int getOffset(ReadableInstant instant) {
      * offset transitions (due to DST or other historical changes), ranges of
      * local times may map to different UTC times.
      *
-     * @param millisLocal the millisecond instant, relative to this time zone, to
+     * @param instantLocal the millisecond instant, relative to this time zone, to
      * get the offset for
      * @return the millisceond offset to subtract from local time to get UTC time.
      */
-    public int getOffsetFromLocal(long millisLocal) {
-        return getOffset(millisLocal - getOffset(millisLocal));
+    public int getOffsetFromLocal(long instantLocal) {
+        return getOffset(instantLocal - getOffset(instantLocal));
     }
 
+    /**
+     * Returns true if this time zone has no transitions.
+     *
+     * @return true if no transitions
+     */
+    public abstract boolean isFixed();
+
     /**
      * Advances the given instant to where the time zone offset or name
      * changes. If the instant returned is exactly the same as passed in, then
      * no changes occur after the given instant.
      *
-     * @param millis milliseconds from 1970-01-01T00:00:00Z
+     * @param instant milliseconds from 1970-01-01T00:00:00Z
      * @return milliseconds from 1970-01-01T00:00:00Z
      */
-    public abstract long nextTransition(long millis);
+    public abstract long nextTransition(long instant);
 
     /**
      * Retreats the given instant to where the time zone offset or name
      * changes. If the instant returned is exactly the same as passed in, then
      * no changes occur before the given instant.
      *
-     * @param millis milliseconds from 1970-01-01T00:00:00Z
+     * @param instant milliseconds from 1970-01-01T00:00:00Z
      * @return milliseconds from 1970-01-01T00:00:00Z
      */
-    public abstract long previousTransition(long millis);
+    public abstract long previousTransition(long instant);
 
     // Basic methods
     //--------------------------------------------------------------------
@@ -627,7 +674,7 @@ public int getOffsetFromLocal(long millisLocal) {
      * @param object the object to compare with
      * @return true if equal, based on the ID and all internal rules
      */
-    public abstract boolean equals(Object obj);
+    public abstract boolean equals(Object object);
 
     /**
      * Gets a hash code compatable with equals.
@@ -671,6 +718,8 @@ public Set getAvailableIDs() {
      * Used to serialize DateTimeZones by id.
      */
     private static final class Stub implements Serializable {
+        static final long serialVersionUID = -6471952376487863581L;
+
         private transient String iID;
 
         Stub(String id) {
diff --git a/JodaTime/src/java/org/joda/time/Duration.java b/JodaTime/src/java/org/joda/time/Duration.java
new file mode 100644
index 000000000..96384504d
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/Duration.java
@@ -0,0 +1,255 @@
+/* 
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+import java.io.Serializable;
+
+/**
+ * Standard immutable duration implementation split on any set of fields.
+ * <p>
+ * A duration can be divided into a number of fields, such as hours and seconds.
+ * The way in which that divide occurs is controlled by the DurationType class.
+ * <p>
+ * Duration is thread-safe and immutable, provided that the DurationType is
+ * as well. All standard DurationType classes supplied are thread-safe and
+ * immutable.
+ *
+ * @author Brian S O'Neill
+ * @author Stephen Colebourne
+ * @since 1.0
+ * @see MutableDuration
+ */
+public class Duration extends AbstractDuration implements ReadableDuration, Serializable {
+
+    static final long serialVersionUID = 741052353876488155L;
+
+    /**
+     * Copies another duration to this one.
+     *
+     * @throws UnsupportedOperationException if an unsupported field's value is
+     * non-zero
+     */
+    public Duration(ReadableDuration duration) {
+        super(duration);
+    }
+
+    /**
+     * Copies another duration to this one.
+     *
+     * @param type use a different DurationType
+     * @throws UnsupportedOperationException if an unsupported field's value is
+     * non-zero
+     */
+    public Duration(DurationType type, ReadableDuration duration) {
+        super(type, duration);
+    }
+
+    /**
+     * Create a duration from a set of field values.
+     *
+     * @param type determines which set of fields this duration supports
+     * @param years amount of years in this duration, which must be zero if
+     * unsupported.
+     * @param months amount of months in this duration, which must be zero if
+     * unsupported.
+     * @param weeks amount of weeks in this duration, which must be zero if
+     * unsupported.
+     * @param days amount of days in this duration, which must be zero if
+     * unsupported.
+     * @param hours amount of hours in this duration, which must be zero if
+     * unsupported.
+     * @param minutes amount of minutes in this duration, which must be zero if
+     * unsupported.
+     * @param seconds amount of seconds in this duration, which must be zero if
+     * unsupported.
+     * @param millis amount of milliseconds in this duration, which must be
+     * zero if unsupported.
+     * @throws UnsupportedOperationException if an unsupported field's value is
+     * non-zero
+     */
+    public Duration(DurationType type,
+                    int years, int months, int weeks, int days,
+                    int hours, int minutes, int seconds, int millis) {
+        super(type, years, months, weeks, days, hours, minutes, seconds, millis);
+    }
+
+    /**
+     * Creates a duration from the given interval endpoints.
+     *
+     * @param type determines which set of fields this duration supports
+     * @param startInstant interval start, in milliseconds
+     * @param endInstant interval end, in milliseconds
+     */
+    public Duration(DurationType type, long startInstant, long endInstant) {
+        super(type, startInstant, endInstant);
+    }
+
+    /**
+     * Creates a duration from the given interval endpoints.
+     *
+     * @param type determines which set of fields this duration supports
+     * @param startInstant interval start
+     * @param endInstant interval end
+     */
+    public Duration(DurationType type,
+                    ReadableInstant startInstant, ReadableInstant endInstant) {
+        super(type, startInstant, endInstant);
+    }
+
+    /**
+     * Creates a duration from the given millisecond duration. If any supported
+     * fields are imprecise, an UnsupportedOperationException is thrown. The
+     * exception to this is when the specified duration is zero.
+     *
+     * @param type determines which set of fields this duration supports
+     * @param duration  the duration, in milliseconds
+     * @throws UnsupportedOperationException if any fields are imprecise
+     */
+    public Duration(DurationType type, long duration) {
+        super(type, duration);
+    }
+
+    /**
+     * Overridden to do nothing, ensuring this class and all subclasses are
+     * immutable.
+     */
+    protected final void setDuration(ReadableDuration duration) {
+    }
+
+    /**
+     * Overridden to do nothing, ensuring this class and all subclasses are
+     * immutable.
+     */
+    protected final void setDuration(int years, int months, int weeks, int days,
+                                     int hours, int minutes, int seconds, int millis) {
+    }
+
+    /**
+     * Overridden to do nothing, ensuring this class and all subclasses are
+     * immutable.
+     */
+    protected final void setTotalMillis(long startInstant, long endInstant) {
+    }
+
+    /**
+     * Overridden to do nothing, ensuring this class and all subclasses are
+     * immutable.
+     */
+    protected final void setTotalMillis(long duration) {
+    }
+
+    /**
+     * Overridden to do nothing, ensuring this class and all subclasses are
+     * immutable.
+     */
+    protected final void normalize() {
+    }
+
+    /**
+     * Overridden to do nothing, ensuring this class and all subclasses are
+     * immutable.
+     */
+    protected final void setYears(int years) {
+    }
+
+    /**
+     * Overridden to do nothing, ensuring this class and all subclasses are
+     * immutable.
+     */
+    protected final void setMonths(int months) {
+    }
+
+    /**
+     * Overridden to do nothing, ensuring this class and all subclasses are
+     * immutable.
+     */
+    protected final void setWeeks(int weeks) {
+    }
+
+    /**
+     * Overridden to do nothing, ensuring this class and all subclasses are
+     * immutable.
+     */
+    protected final void setDays(int days) {
+    }
+
+    /**
+     * Overridden to do nothing, ensuring this class and all subclasses are
+     * immutable.
+     */
+    protected final void setHours(int hours) {
+    }
+
+    /**
+     * Overridden to do nothing, ensuring this class and all subclasses are
+     * immutable.
+     */
+    protected final void setMinutes(int minutes) {
+    }
+
+    /**
+     * Overridden to do nothing, ensuring this class and all subclasses are
+     * immutable.
+     */
+    protected final void setSeconds(int seconds) {
+    }
+
+    /**
+     * Overridden to do nothing, ensuring this class and all subclasses are
+     * immutable.
+     */
+    protected final void setMillis(int millis) {
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/DurationField.java b/JodaTime/src/java/org/joda/time/DurationField.java
new file mode 100644
index 000000000..3febd5f22
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/DurationField.java
@@ -0,0 +1,317 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+/**
+ * Defines the calculation engine for duration fields.
+ * The interface defines a set of methods that manipulate a millisecond duration
+ * with regards to a single field, such as months or seconds.
+ * <p>
+ * This design is extensible so, if you wish, you can extract a different field from
+ * the millisecond duration. A number of standard implementations are provided to assist.
+ *
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+public interface DurationField extends Comparable {
+
+    /**
+     * Get the name of the field.
+     * 
+     * @return field name
+     */
+    public String getName();
+
+    /**
+     * Returns true if this field is supported.
+     * 
+     * @return true if this field is supported
+     */
+    public boolean isSupported();
+
+    /**
+     * Is this field precise. A precise field can calculate its value from
+     * milliseconds without needing a reference date. Put another way, a
+     * precise field's unit size is not variable.
+     * 
+     * @return true if precise
+     * @see #getUnitMillis()
+     */
+    public boolean isPrecise();
+    
+    /**
+     * Returns the amount of milliseconds per unit value of this field. For
+     * example, if this field represents "seconds", then this returns the
+     * milliseconds in one second.
+     * <p>
+     * For imprecise fields, the unit size is variable, and so this method
+     * returns a suitable average value.
+     *
+     * @return the unit size of this field, in milliseconds
+     * @see #isPrecise()
+     */
+    public long getUnitMillis();
+
+    //------------------------------------------------------------------------
+    /**
+     * Get the value of this field from the milliseconds, which is approximate
+     * if this field is imprecise.
+     *
+     * @param duration  the milliseconds to query, which may be negative
+     * @return the value of the field, in the units of the field, which may be
+     * negative
+     * @throws ArithmeticException if the value is too large for an int
+     */
+    public int getValue(long duration);
+
+    /**
+     * Get the value of this field from the milliseconds, which is approximate
+     * if this field is imprecise.
+     *
+     * @param duration  the milliseconds to query, which may be negative
+     * @return the value of the field, in the units of the field, which may be
+     * negative
+     */
+    public long getValueAsLong(long duration);
+
+    /**
+     * Get the value of this field from the milliseconds relative to an
+     * instant. For precise fields this method produces the same result as for
+     * the single argument get method.
+     * <p>
+     * If the millisecond duration is positive, then the instant is treated as a
+     * "start instant". If negative, the instant is treated as an "end instant".
+     * 
+     * @param duration  the milliseconds to query, which may be negative
+     * @param instant  the start instant to calculate relative to
+     * @return the value of the field, in the units of the field, which may be
+     * negative
+     * @throws ArithmeticException if the value is too large for an int
+     */
+    public int getValue(long duration, long instant);
+
+    /**
+     * Get the value of this field from the milliseconds relative to an
+     * instant. For precise fields this method produces the same result as for
+     * the single argument get method.
+     * <p>
+     * If the millisecond duration is positive, then the instant is treated as a
+     * "start instant". If negative, the instant is treated as an "end instant".
+     * 
+     * @param duration  the milliseconds to query, which may be negative
+     * @param instant  the start instant to calculate relative to
+     * @return the value of the field, in the units of the field, which may be
+     * negative
+     */
+    public long getValueAsLong(long duration, long instant);
+
+    //------------------------------------------------------------------------
+    /**
+     * Get the millisecond duration of this field from its value, which is
+     * approximate if this field is imprecise.
+     * 
+     * @param value  the value of the field, which may be negative
+     * @return the milliseconds that the field represents, which may be
+     * negative
+     */
+    public long getMillis(int value);
+
+    /**
+     * Get the millisecond duration of this field from its value, which is
+     * approximate if this field is imprecise.
+     * 
+     * @param value  the value of the field, which may be negative
+     * @return the milliseconds that the field represents, which may be
+     * negative
+     */
+    public long getMillis(long value);
+
+    /**
+     * Get the millisecond duration of this field from its value relative to an
+     * instant. For precise fields this method produces the same result as for
+     * the single argument getMillis method.
+     * <p>
+     * If the value is positive, then the instant is treated as a "start
+     * instant". If negative, the instant is treated as an "end instant".
+     *
+     * @param value  the value of the field, which may be negative
+     * @param instant  the instant to calculate relative to
+     * @return the millisecond duration that the field represents, which may be
+     * negative
+     */
+    public long getMillis(int value, long instant);
+
+    /**
+     * Get the millisecond duration of this field from its value relative to an
+     * instant. For precise fields this method produces the same result as for
+     * the single argument getMillis method.
+     * <p>
+     * If the value is positive, then the instant is treated as a "start
+     * instant". If negative, the instant is treated as an "end instant".
+     *
+     * @param value  the value of the field, which may be negative
+     * @param instant  the instant to calculate relative to
+     * @return the millisecond duration that the field represents, which may be
+     * negative
+     */
+    public long getMillis(long value, long instant);
+
+    /**
+     * Adds a duration value (which may be negative) to the instant.
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
+     * @param value  the value to add, in the units of the field
+     * @return the updated milliseconds
+     */
+    public long add(long instant, int value);
+
+    /**
+     * Adds a duration value (which may be negative) to the instant.
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
+     * @param value  the value to add, in the units of the field
+     * @return the updated milliseconds
+     */
+    public long add(long instant, long value);
+
+    /**
+     * Computes the difference between two instants, as measured in the units
+     * of this field. Any fractional units are dropped from the result. Calling
+     * getDifference reverses the effect of calling add. In the following code:
+     *
+     * <pre>
+     * long instant = ...
+     * int v = ...
+     * int age = getDifference(add(instant, v), instant);
+     * </pre>
+     *
+     * The value 'age' is the same as the value 'v'.
+     *
+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to
+     * subtract from
+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to
+     * subtract off the minuend
+     * @return the difference in the units of this field
+     */
+    public int getDifference(long minuendInstant, long subtrahendInstant);
+
+    /**
+     * Computes the difference between two instants, as measured in the units
+     * of this field. Any fractional units are dropped from the result. Calling
+     * getDifference reverses the effect of calling add. In the following code:
+     *
+     * <pre>
+     * long instant = ...
+     * long v = ...
+     * long age = getDifferenceAsLong(add(instant, v), instant);
+     * </pre>
+     *
+     * The value 'age' is the same as the value 'v'.
+     *
+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to
+     * subtract from
+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to
+     * subtract off the minuend
+     * @return the difference in the units of this field
+     */
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant);
+
+    /**
+     * Compares this duration field with another duration field for ascending
+     * unit millisecond order. This ordering is inconsistent with equals, as it
+     * ignores name and precision.
+     *
+     * @param durationField  a duration field to check against
+     * @return negative value if this is less, 0 if equal, or positive value if greater
+     * @throws NullPointerException if the object is null
+     * @throws ClassCastException if the object type is not supported
+     */
+    public int compareTo(Object durationField);
+
+    /**
+     * Returns a localized unit name of this field, using the given value as an
+     * aid. For example, the unit name may differ if it is plural.
+     *
+     * @param value the duration value to use for selecting a unit name
+     * @param locale the locale to use for selecting a name, null for default
+     */
+    //public String getUnitName(long value, Locale locale);
+
+    /**
+     * Returns a localized unit name of this field, using the given value as an
+     * aid. For example, the unit name may differ if it is plural.
+     *
+     * @param value the duration value to use for selecting a unit name
+     */
+    //public String getUnitName(long value);
+
+    /**
+     * Get the maximum length string returned by getUnitName.
+     * 
+     * @param locale the locale to use for selecting a unit name, null for
+     * default
+     * @return the maximum name length
+     */
+    //public int getMaximumUnitNameLength(Locale locale);
+
+    //------------------------------------------------------------------------
+    /**
+     * Get a suitable debug string.
+     * 
+     * @return debug string
+     */
+    public String toString();
+    
+}
diff --git a/JodaTime/src/java/org/joda/time/DurationType.java b/JodaTime/src/java/org/joda/time/DurationType.java
new file mode 100644
index 000000000..f74b9df72
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/DurationType.java
@@ -0,0 +1,723 @@
+/* 
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+import java.io.Serializable;
+import org.joda.time.chrono.MillisDurationField;
+import org.joda.time.chrono.ScaledDurationField;
+import org.joda.time.chrono.UnsupportedDurationField;
+import org.joda.time.chrono.iso.ISOChronology;
+
+/**
+ * Controls a duration implementation by specifying which duration fields are to be used.
+ * <p>
+ * The following implementations are provided:
+ * <ul>
+ * <li>Millis - the duration is defined only in terms of milliseconds, other
+ *  fields are not used
+ * <li>DayHour - the duration is expressed in terms of days, hours, minutes, seconds
+ *  and milliseconds
+ * <li>YearMonth - the duration is expressed using all fields except weeks
+ * <li>ISOYearMonth - as YearMonth, but with the month fixed at 30 days
+ * <li>YearWeek - the duration is expressed using all fields except months
+ * </ul>
+ *
+ * <p>
+ * DurationType is thread-safe and immutable, and all subclasses must be as
+ * well.
+ *
+ * @author Brian S O'Neill
+ */
+public abstract class DurationType implements Serializable {
+    static final long serialVersionUID = 2274324892792009998L;
+
+    // TODO: Many caching opportunities
+
+    /**
+     * Returns a DurationType of only a milliseconds field.
+     */
+    public static DurationType getMillisType() {
+        return new MillisType();
+    }
+
+    /**
+     * Returns a DurationType of:
+     *
+     * <ul>
+     * <li>days
+     * <li>hours
+     * <li>minutes
+     * <li>seconds
+     * <li>milliseconds
+     * </ul>
+     */
+    public static DurationType getDayHourType() {
+        return getDayHourType(null);
+    }
+
+    /**
+     * Returns a DurationType of:
+     *
+     * <ul>
+     * <li>days
+     * <li>hours
+     * <li>minutes
+     * <li>seconds
+     * <li>milliseconds
+     * </ul>
+     *
+     * This factory method returns a DurationType that calculates using any
+     * Chronology. For best results, the Chronology's time zone should
+     * be UTC or have fixed offsets.
+     *
+     * @param chrono Chronology to use for calculations.
+     */
+    public static DurationType getDayHourType(Chronology chrono) {
+        if (chrono == null) {
+            chrono = ISOChronology.getInstanceUTC();
+        }
+        return new DayHourType(chrono);
+    }
+
+    /**
+     * Returns a DurationType of:
+     *
+     * <ul>
+     * <li>years
+     * <li>months
+     * <li>days
+     * <li>hours
+     * <li>minutes
+     * <li>seconds
+     * <li>milliseconds
+     * </ul>
+     */
+    public static DurationType getYearMonthType() {
+        return getYearMonthType(null);
+    }
+
+    /**
+     * Returns a DurationType of:
+     *
+     * <ul>
+     * <li>years
+     * <li>months
+     * <li>days
+     * <li>hours
+     * <li>minutes
+     * <li>seconds
+     * <li>milliseconds
+     * </ul>
+     *
+     * This factory method returns a DurationType that calculates using any
+     * Chronology. For best results, the Chronology's time zone should
+     * be UTC or have fixed offsets.
+     *
+     * @param chrono Chronology to use for calculations.
+     */
+    public static DurationType getYearMonthType(Chronology chrono) {
+        if (chrono == null) {
+            chrono = ISOChronology.getInstanceUTC();
+        }
+        return new YearMonthType(chrono);
+    }
+
+    /**
+     * Returns a DurationType of:
+     *
+     * <ul>
+     * <li>years
+     * <li>months (fixed at 30 days)
+     * <li>days
+     * <li>hours
+     * <li>minutes
+     * <li>seconds
+     * <li>milliseconds
+     * </ul>
+     */
+    public static DurationType getISOYearMonthType() {
+        return getISOYearMonthType(null);
+    }
+
+    /**
+     * Returns a DurationType of:
+     *
+     * <ul>
+     * <li>years
+     * <li>months (fixed at 30 days)
+     * <li>days
+     * <li>hours
+     * <li>minutes
+     * <li>seconds
+     * <li>milliseconds
+     * </ul>
+     *
+     * This factory method returns a DurationType that calculates using any
+     * Chronology. For best results, the Chronology's time zone should
+     * be UTC or have fixed offsets.
+     *
+     * @param chrono Chronology to use for calculations.
+     */
+    public static DurationType getISOYearMonthType(Chronology chrono) {
+        if (chrono == null) {
+            chrono = ISOChronology.getInstanceUTC();
+        }
+        return new ISOYearMonthType(chrono);
+    }
+
+    /**
+     * Returns a DurationType of:
+     *
+     * <ul>
+     * <li>years (weekyears)
+     * <li>weeks
+     * <li>days
+     * <li>hours
+     * <li>minutes
+     * <li>seconds
+     * <li>milliseconds
+     * </ul>
+     */
+    public static DurationType getYearWeekType() {
+        return getYearWeekType(null);
+    }
+
+    /**
+     * Returns a DurationType of:
+     *
+     * <ul>
+     * <li>years (weekyears)
+     * <li>weeks
+     * <li>days
+     * <li>hours
+     * <li>minutes
+     * <li>seconds
+     * <li>milliseconds
+     * </ul>
+     *
+     * This factory method returns a DurationType that calculates using any
+     * Chronology. For best results, the Chronology's time zone should
+     * be UTC or have fixed offsets.
+     *
+     * @param chrono Chronology to use for calculations.
+     */
+    public static DurationType getYearWeekType(Chronology chrono) {
+        if (chrono == null) {
+            chrono = ISOChronology.getInstanceUTC();
+        }
+        return new YearWeekType(chrono);
+    }
+
+    protected DurationType() {
+    }
+
+    /**
+     * Returns the chronology used, or null if none.
+     */
+    public abstract Chronology getChronology();
+
+    /**
+     * Returns a DurationType that uses the given chronology.
+     */
+    public abstract DurationType withChronology(Chronology chrono);
+
+    /**
+     * Returns a DurationField representing years.
+     *
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField years() {
+        return UnsupportedDurationField.INSTANCE;
+    }
+
+    /**
+     * Returns a DurationField representing months.
+     *
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField months() {
+        return UnsupportedDurationField.INSTANCE;
+    }
+
+    /**
+     * Returns a DurationField representing weeks.
+     *
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField weeks() {
+        return UnsupportedDurationField.INSTANCE;
+    }
+
+    /**
+     * Returns a DurationField representing days.
+     *
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField days() {
+        return UnsupportedDurationField.INSTANCE;
+    }
+
+    /**
+     * Returns a DurationField representing hours.
+     *
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField hours() {
+        return UnsupportedDurationField.INSTANCE;
+    }
+
+    /**
+     * Returns a DurationField representing minutes.
+     *
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField minutes() {
+        return UnsupportedDurationField.INSTANCE;
+    }
+
+    /**
+     * Returns a DurationField representing seconds.
+     *
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField seconds() {
+        return UnsupportedDurationField.INSTANCE;
+    }
+
+    /**
+     * Returns a DurationField representing milliseconds.
+     *
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField millis() {
+        return UnsupportedDurationField.INSTANCE;
+    }
+
+    /**
+     * Returns a version of this DurationType instance that does not support
+     * years.
+     */
+    public DurationType withYearsRemoved() {
+        if (!years().isSupported()) {
+            return this;
+        }
+        return MaskedType.mask(this, 1 << 0);
+    }
+
+    /**
+     * Returns a version of this DurationType instance that does not support
+     * months.
+     */
+    public DurationType withMonthsRemoved() {
+        if (!months().isSupported()) {
+            return this;
+        }
+        return MaskedType.mask(this, 1 << 1);
+    }
+
+    /**
+     * Returns a version of this DurationType instance that does not support
+     * weeks.
+     */
+    public DurationType withWeeksRemoved() {
+        if (!weeks().isSupported()) {
+            return this;
+        }
+        return MaskedType.mask(this, 1 << 2);
+    }
+
+    /**
+     * Returns a version of this DurationType instance that does not support
+     * days.
+     */
+    public DurationType withDaysRemoved() {
+        if (!days().isSupported()) {
+            return this;
+        }
+        return MaskedType.mask(this, 1 << 3);
+    }
+
+    /**
+     * Returns a version of this DurationType instance that does not support
+     * hours.
+     */
+    public DurationType withHoursRemoved() {
+        if (!hours().isSupported()) {
+            return this;
+        }
+        return MaskedType.mask(this, 1 << 4);
+    }
+
+    /**
+     * Returns a version of this DurationType instance that does not support
+     * minutes.
+     */
+    public DurationType withMinutesRemoved() {
+        if (!minutes().isSupported()) {
+            return this;
+        }
+        return MaskedType.mask(this, 1 << 5);
+    }
+
+    /**
+     * Returns a version of this DurationType instance that does not support
+     * seconds.
+     */
+    public DurationType withSecondsRemoved() {
+        if (!seconds().isSupported()) {
+            return this;
+        }
+        return MaskedType.mask(this, 1 << 6);
+    }
+
+    /**
+     * Returns a version of this DurationType instance that does not support
+     * milliseconds.
+     */
+    public DurationType withMillisRemoved() {
+        if (!millis().isSupported()) {
+            return this;
+        }
+        return MaskedType.mask(this, 1 << 7);
+    }
+
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (!(obj instanceof DurationType)) {
+            return false;
+        }
+        DurationType other = (DurationType)obj;
+        Chronology chrono = getChronology();
+        if (chrono == null) {
+            if (other.getChronology() != null) {
+                return false;
+            }
+        } else if (!chrono.equals(other.getChronology())) {
+            return false;
+        }
+        return years().equals(other.years())
+            && months().equals(other.months())
+            && weeks().equals(other.weeks())
+            && days().equals(other.days())
+            && hours().equals(other.hours())
+            && minutes().equals(other.minutes())
+            && seconds().equals(other.seconds())
+            && millis().equals(other.millis());
+    }
+
+    public int hashCode() {
+        int hash = 0;
+        Chronology chrono = getChronology();
+        if (chrono != null) {
+            hash += chrono.hashCode();
+        }
+        hash = hash
+            + years().hashCode()
+            + months().hashCode()
+            + weeks().hashCode()
+            + days().hashCode()
+            + hours().hashCode()
+            + minutes().hashCode()
+            + seconds().hashCode()
+            + millis().hashCode();
+        return hash;
+    }
+
+    private static final class MillisType extends DurationType {
+        static final long serialVersionUID = -4314867016852780422L;
+
+        public final DurationField millis() {
+            return MillisDurationField.INSTANCE;
+        }
+
+        public Chronology getChronology() {
+            return null;
+        }
+
+        public DurationType withChronology(Chronology chrono) {
+            return this;
+        }
+
+        private Object readResolve() {
+            return getMillisType();
+        }
+    }
+
+    private static class DayHourType extends DurationType {
+        static final long serialVersionUID = 1115025839896760481L;
+
+        protected final Chronology iChronology;
+
+        public DayHourType(Chronology chrono) {
+            iChronology = chrono;
+        }
+
+        public final Chronology getChronology() {
+            return iChronology;
+        }
+
+        public DurationType withChronology(Chronology chrono) {
+            if (chrono == iChronology) {
+                return this;
+            }
+            return new DayHourType(iChronology);
+        }
+
+        public final DurationField days() {
+            return iChronology.days();
+        }
+
+        public final DurationField hours() {
+            return iChronology.hours();
+        }
+
+        public final DurationField minutes() {
+            return iChronology.minutes();
+        }
+
+        public final DurationField seconds() {
+            return iChronology.seconds();
+        }
+
+        public final DurationField millis() {
+            return iChronology.millis();
+        }
+
+        private Object readResolve() {
+            return getDayHourType(iChronology);
+        }
+    }
+
+    private static final class YearMonthType extends DayHourType {
+        static final long serialVersionUID = -1336767257680877683L;
+
+        public YearMonthType(Chronology chrono) {
+            super(chrono);
+        }
+
+        public DurationType withChronology(Chronology chrono) {
+            if (chrono == iChronology) {
+                return this;
+            }
+            return new YearMonthType(iChronology);
+        }
+
+        public DurationField years() {
+            return iChronology.years();
+        }
+
+        public DurationField months() {
+            return iChronology.months();
+        }
+
+        private Object readResolve() {
+            return getYearMonthType(iChronology);
+        }
+    }
+
+    private static final class ISOYearMonthType extends DayHourType {
+        static final long serialVersionUID = 1203161678926193794L;
+
+        private final DurationField iMonths;
+        
+        public ISOYearMonthType(Chronology chrono) {
+            super(chrono);
+            iMonths = new ScaledDurationField(chrono.days(), "ISOMonths", 30);
+        }
+
+        public DurationType withChronology(Chronology chrono) {
+            if (chrono == iChronology) {
+                return this;
+            }
+            return new ISOYearMonthType(iChronology);
+        }
+
+        public DurationField years() {
+            return iChronology.years();
+        }
+
+        public DurationField months() {
+            return iMonths;
+        }
+
+        private Object readResolve() {
+            return getISOYearMonthType(iChronology);
+        }
+    }
+
+    private static final class YearWeekType extends DayHourType {
+        static final long serialVersionUID = 1347170237843447098L;
+
+        public YearWeekType(Chronology chrono) {
+            super(chrono);
+        }
+
+        public DurationType withChronology(Chronology chrono) {
+            if (chrono == iChronology) {
+                return this;
+            }
+            return new YearWeekType(iChronology);
+        }
+
+        public DurationField years() {
+            return iChronology.weekyears();
+        }
+
+        public DurationField weeks() {
+            return iChronology.weeks();
+        }
+
+        private Object readResolve() {
+            return getYearWeekType(iChronology);
+        }
+    }
+
+    private static final class MaskedType extends DurationType {
+        static final long serialVersionUID = 940106774669244586L;
+
+        public static DurationType mask(DurationType type, int mask) {
+            if (type instanceof MaskedType) {
+                MaskedType masked = (MaskedType)type;
+                if ((mask |= masked.iMask) == masked.iMask) {
+                    // No additional fields removed, so return original.
+                    return masked;
+                }
+                type = masked.iType;
+            }
+            return new MaskedType(type, mask);
+        }
+
+        private final DurationType iType;
+
+        // Bit 0: when set, years is unsupported
+        // Bit 1: when set, months is unsupported
+        // ...
+        private final int iMask;
+
+        private MaskedType(DurationType type, int mask) {
+            iType = type;
+            iMask = mask;
+        }
+
+        public Chronology getChronology() {
+            return iType.getChronology();
+        }
+
+        public DurationType withChronology(Chronology chrono) {
+            if (chrono == getChronology()) {
+                return this;
+            }
+            return mask(iType.withChronology(chrono), iMask);
+        }
+
+        public DurationField years() {
+            if ((iMask & (1 << 0)) != 0) {
+                return UnsupportedDurationField.INSTANCE;
+            }
+            return iType.years();
+        }
+
+        public DurationField months() {
+            if ((iMask & (1 << 1)) != 0) {
+                return UnsupportedDurationField.INSTANCE;
+            }
+            return iType.months();
+        }
+
+        public DurationField weeks() {
+            if ((iMask & (1 << 2)) != 0) {
+                return UnsupportedDurationField.INSTANCE;
+            }
+            return iType.weeks();
+        }
+
+        public DurationField days() {
+            if ((iMask & (1 << 3)) != 0) {
+                return UnsupportedDurationField.INSTANCE;
+            }
+            return iType.days();
+        }
+
+        public DurationField hours() {
+            if ((iMask & (1 << 4)) != 0) {
+                return UnsupportedDurationField.INSTANCE;
+            }
+            return iType.hours();
+        }
+
+        public DurationField minutes() {
+            if ((iMask & (1 << 5)) != 0) {
+                return UnsupportedDurationField.INSTANCE;
+            }
+            return iType.minutes();
+        }
+
+        public DurationField seconds() {
+            if ((iMask & (1 << 6)) != 0) {
+                return UnsupportedDurationField.INSTANCE;
+            }
+            return iType.seconds();
+        }
+
+        public DurationField millis() {
+            if ((iMask & (1 << 7)) != 0) {
+                return UnsupportedDurationField.INSTANCE;
+            }
+            return iType.millis();
+        }
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/Instant.java b/JodaTime/src/java/org/joda/time/Instant.java
index ea8141d9d..f90087c64 100644
--- a/JodaTime/src/java/org/joda/time/Instant.java
+++ b/JodaTime/src/java/org/joda/time/Instant.java
@@ -53,26 +53,29 @@
  */
 package org.joda.time;
 
-import java.text.ParseException;
-import java.util.Calendar;
-import java.util.Date;
+import java.io.Serializable;
 
+import org.joda.time.convert.InstantConverter;
+import org.joda.time.convert.ConverterManager;
 import org.joda.time.format.ISODateTimeFormat;
-import org.joda.time.format.DateTimeParser;
 
 /**
- * Instant is the standard implementation of a fully immutable instant in 
- * time. It holds the instant as milliseconds from the Java Epoch of 
- * 1970-01-01T00:00:00Z.
+ * Instant is the standard implementation of a fully immutable instant in time.
+ * It holds the instant as milliseconds from the Java Epoch of 1970-01-01T00:00:00Z.
  * <p>
- * There is no concept of a calendar system, chronology or time zone. In 
- * a fully internationalized program, methods should accept the ReadableInstant 
- * interface as input and return Instant objects.
+ * There is no concept of a calendar system, chronology or time zone.
+ * In a fully internationalized program, you may want to ensure methods accept the
+ * ReadableInstant interface as input and return Instant objects.
+ * <p>
+ * Instant is thread-safe and immutable.
  *
  * @author Stephen Colebourne
  * @since 1.0
  */
-public final class Instant extends AbstractInstant implements ReadableInstant {
+public final class Instant extends AbstractInstant
+        implements ReadableInstant, Serializable {
+
+    static final long serialVersionUID = 3299096530934209741L;
 
     /** The millis from 1970-01-01T00:00:00Z */
     private final long iMillis;
@@ -80,8 +83,7 @@
     // Constructors
     //-----------------------------------------------------------------------
     /**
-     * Constructor that sets the time to be the current time from the
-     * system clock.
+     * Constructs an instance set to the current system millisecond time.
      */
     public Instant() {
         super();
@@ -89,71 +91,39 @@ public Instant() {
     }
 
     /**
-     * Constructor that takes milliseconds from 1970-01-01T00:00:00Z.
+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z.
      * 
-     * @param millis  the milliseconds
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
      */
-    public Instant(long millis) {
+    public Instant(long instant) {
         super();
-        iMillis = millis;
+        iMillis = instant;
     }
 
     /**
-     * Constructor that takes a ReadableInstant.
+     * Constructs an instance from a <code>ReadableInstant</code>.
      * 
      * @param instant  the ReadableInstant
      * @throws IllegalArgumentException if the instant is null
      */
     public Instant(ReadableInstant instant) {
         super();
-        if (instant == null) {
-            throw new IllegalArgumentException("The ReadableInstant must not be null");
-        }
         iMillis = instant.getMillis();
     }
 
     /**
-     * Constructor that takes a Date.
-     * 
-     * @param date  the Date
-     * @throws IllegalArgumentException if the date is null
-     */
-    public Instant(Date date) {
-        super();
-        if (date == null) {
-            throw new IllegalArgumentException("The Date must not be null");
-        }
-        iMillis = date.getTime();
-    }
-
-    /**
-     * Constructor that takes a Calendar.
-     * 
-     * @param calendar  the Calendar
-     * @throws IllegalArgumentException if the calendar is null
-     */
-    public Instant(Calendar calendar) {
-        super();
-        if (calendar == null) {
-            throw new IllegalArgumentException("The Calendar must not be null");
-        }
-        iMillis = calendar.getTime().getTime();
-    }
-
-    /**
-     * Constructor that parses an ISO formatted string.
-     * 
-     * @param str  the string
-     * @throws IllegalArgumentException if the string is null
-     * @throws ParseException if the string is incorrectly formatted
+     * Constructs an instance from an Object that represents a datetime.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include String, Calendar and Date.
+     *
+     * @param instant  the datetime object, must not be null
+     * @throws IllegalArgumentException if the instant is null or invalid
      */
-    public Instant(String str) throws ParseException {
+    public Instant(Object instant) {
         super();
-        if (str == null) {
-            throw new IllegalArgumentException("The String must not be null");
-        }
-        DateTimeParser p = ISODateTimeFormat.getInstanceUTC().dateTimeParser();
-        iMillis = p.parseMillis(str);
+        InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
+        iMillis = converter.getInstantMillis(instant);
     }
 
     /**
@@ -162,17 +132,17 @@ public Instant(String str) throws ParseException {
      * The returned object will be a new instance of the implementation.
      * Immutable subclasses may return <code>this</code> if appropriate.
      *
-     * @param millis  the new millis, from 1970-01-01T00:00:00Z
+     * @param instant  the new instant, from 1970-01-01T00:00:00Z
      * @param chrono  the new chronology
      * @return a new instance of this class
      * @throws IllegalArgumentException if the chronology is null
      */
-    protected ReadableInstant create(long millis, Chronology chrono) {
+    protected ReadableInstant create(long instant, Chronology chrono) {
         // ignore chrono
-        if (millis == getMillis()) {
+        if (instant == getMillis()) {
             return this;
         }
-        return new Instant(millis);
+        return new Instant(instant);
     }
     
     // Accessors
@@ -186,6 +156,27 @@ public final long getMillis() {
         return iMillis;
     }
 
+    /**
+     * Gets the milliseconds of the instant.
+     *
+     * @param base ignored
+     * @return the number of milliseconds since 1970-01-01T00:00:00Z
+     */
+    public final long getMillis(ReadableInstant base) {
+        return iMillis;
+    }
+
+    /**
+     * Gets the milliseconds of the instant.
+     *
+     * @param base ignored
+     * @param zone ignored
+     * @return the number of milliseconds since 1970-01-01T00:00:00Z
+     */
+    public final long getMillis(ReadableInstant base, DateTimeZone zone) {
+        return iMillis;
+    }
+
     /**
      * Gets the chronology of the instant, which is null.
      * <p>
diff --git a/JodaTime/src/java/org/joda/time/MutableDateTime.java b/JodaTime/src/java/org/joda/time/MutableDateTime.java
index 1ae3f7aa3..1f8130da2 100644
--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java
+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java
@@ -54,22 +54,22 @@
 
 package org.joda.time;
 
-import java.text.ParseException;
-import java.util.Calendar;
-import java.util.Date;
+import java.io.Serializable;
 
 import org.joda.time.chrono.iso.ISOChronology;
-import org.joda.time.format.DateTimeParser;
+import org.joda.time.convert.ConverterManager;
+import org.joda.time.convert.DurationConverter;
+import org.joda.time.convert.InstantConverter;
 import org.joda.time.format.ISODateTimeFormat;
 
 /**
- * MutableDateTime is the standard implementation of a modifiable
- * datetime class.
- * It holds the date/time as milliseconds from the Java epoch of
- * 1970-01-01T00:00:00Z.
+ * MutableDateTime is the standard implementation of a modifiable datetime class.
+ * It holds the datetime as milliseconds from the Java epoch of 1970-01-01T00:00:00Z.
  * <p>
- * This class requires a Chronology to be specified. The Chronology determines
- * how the millisecond instant value is converted into the date time fields.
+ * This class uses a Chronology internally. The Chronology determines how the
+ * millisecond instant value is converted into the date time fields.
+ * The default Chronology is <code>ISOChronology</code> which is the agreed
+ * international standard and compatable with the modern Gregorian calendar.
  * <p>
  * Each individual field can be accessed in two ways:
  * <ul>
@@ -90,401 +90,363 @@
  * <li>field minimum value
  * </ul>
  *
+ * <p>
+ * MutableDateTime is mutable and not thread-safe, unless concurrent threads
+ * are not invoking mutator methods.
+ *
  * @author Guy Allard
  * @author Brian S O'Neill
  * @author Stephen Colebourne
  * @since 1.0
+ * @see DateTime
  */
 public class MutableDateTime extends AbstractDateTime
-    implements ReadableDateTime, ReadWritableInstant, Cloneable
-{
-    /** The millis from 1970-01-01T00:00:00Z. */
-    private long iMillis;
-    /** The chronology to use */
-    private Chronology iChronology;
-
-    // Constructors (same as DateTime)
-    //-----------------------------------------------------------
+        implements ReadWritableDateTime, Cloneable, Serializable {
+    
+    static final long serialVersionUID = 2852608688135209575L;
 
+    // Constructors
+    //-----------------------------------------------------------------------
     /**
-     * Constructs a MutableDateTime to the current datetime, as reported by the system
-     * clock. The chronology used is ISO, in the
-     * {@link DateTimeZone#getDefault() default} time zone.
+     * Constructs an instance set to the current system millisecond time
+     * using <code>ISOChronology</code> in the default time zone.
      */
     public MutableDateTime() {
-        iChronology = ISOChronology.getInstance();
-        iMillis = System.currentTimeMillis();
+        super();
     }
 
     /**
-     * Constructs a MutableDateTime to the current datetime, as reported by the system
-     * clock. The chronology used is ISO, in the supplied time zone.
+     * Constructs an instance set to the current system millisecond time
+     * using <code>ISOChronology</code> in the specified time zone.
+     * <p>
+     * If the specified time zone is null, the default zone is used.
      *
-     * @param zone  the time zone, must not be null
-     * @throws IllegalArgumentException if the zone is null
+     * @param zone  the time zone, null means default zone
      */
     public MutableDateTime(DateTimeZone zone) {
-        iChronology = ISOChronology.getInstance(zone);
-        iMillis = System.currentTimeMillis();
+        super(zone);
     }
 
     /**
-     * Constructs a MutableDateTime to the current datetime, as reported by the system
-     * clock.
+     * Constructs an instance set to the current system millisecond time
+     * using the specified chronology.
+     * <p>
+     * If the chronology is null, <code>ISOChronology</code>
+     * in the default time zone is used.
      *
-     * @param chronology  the chronology, must not be null
-     * @throws IllegalArgumentException if the chronology is null
+     * @param chronology  the chronology, null means ISOChronology in default zone
      */
     public MutableDateTime(Chronology chronology) {
-        iChronology = selectChronology(chronology);
-        iMillis = System.currentTimeMillis();
-    }
-
-    /**
-     * Constructs a MutableDateTime set to the milliseconds from 1970-01-01T00:00:00Z,
-     * using the ISO chronology, in the
-     * {@link DateTimeZone#getDefault() default} time zone.
-     *
-     * @param millis  the milliseconds
-     */
-    public MutableDateTime(long millis) {
-        iChronology = ISOChronology.getInstance();
-        iMillis = millis;
-    }
-
-    /**
-     * Constructs a MutableDateTime set to the milliseconds from 1970-01-01T00:00:00Z,
-     * using the ISO chronology, in the supplied time zone.
-     *
-     * @param millis  the milliseconds
-     * @param zone  the time zone, must not be null
-     * @throws IllegalArgumentException if the zone is null
-     */
-    public MutableDateTime(long millis, DateTimeZone zone) {
-        iChronology = ISOChronology.getInstance(zone);
-        iMillis = millis;
+        super(chronology);
     }
 
+    //-----------------------------------------------------------------------
     /**
-     * Constructs a MutableDateTime set to the milliseconds from 1970-01-01T00:00:00Z,
-     * using the supplied chronology.
+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z
+     * using <code>ISOChronology</code> in the default time zone.
      *
-     * @param millis  the milliseconds
-     * @param chronology  the chronology, must not be null
-     * @throws IllegalArgumentException if the chronology is null
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
      */
-    public MutableDateTime(long millis, Chronology chronology) {
-        iChronology = selectChronology(chronology);
-        iMillis = millis;
+    public MutableDateTime(long instant) {
+        super(instant);
     }
 
     /**
-     * Constructs a MutableDateTime from a ReadableInstant, using its chronology. If
-     * its chronology null, then the chronology is set to ISO, in the
-     * {@link DateTimeZone#getDefault() default} time zone.
-     *
-     * @param instant  the ReadableInstant, must not be null
-     * @throws IllegalArgumentException if the instant is null
-     */
-    public MutableDateTime(ReadableInstant instant) {
-        iChronology = selectChronology(instant);
-        iMillis = instant.getMillis();
-    }
-
-    /**
-     * Constructs a MutableDateTime from a ReadableInstant, using its chronology
-     * against a different time zone. If its chronology is null, then the
-     * chronology is set to ISO. If the selected chronology is not in the
-     * supplied time zone, a new chronology is created that is.
-     *
-     * @param instant  the ReadableInstant, must not be null
-     * @param zone  the time zone, must not be null
-     * @throws IllegalArgumentException if the instant or zone is null
-     */
-    public MutableDateTime(ReadableInstant instant, DateTimeZone zone) {
-        iChronology = selectChronology(instant, zone);
-        iMillis = instant.getMillis();
-    }
-
-    /**
-     * Constructs a MutableDateTime from a ReadableInstant, using the supplied
-     * chronology.
-     *
-     * @param instant  the ReadableInstant, must not be null
-     * @param chronology  the chronology, must not be null
-     * @throws IllegalArgumentException if the instant or chronology is null
-     */
-    public MutableDateTime(ReadableInstant instant, Chronology chronology) {
-        iChronology = selectChronology(instant, chronology);
-        iMillis = instant.getMillis();
-    }
-
-    /**
-     * Constructs a MutableDateTime from a Date, using the ISO chronology, in the
-     * {@link DateTimeZone#getDefault() default} time zone.
-     *
-     * @param date  the Date, must not be null
-     * @throws IllegalArgumentException if the date is null
-     */
-    public MutableDateTime(Date date) {
-        iChronology = selectChronology(date);
-        iMillis = date.getTime();
-    }
-
-    /**
-     * Constructs a MutableDateTime from a Date, using the ISO chronology, in the
-     * supplied time zone.
+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z
+     * using <code>ISOChronology</code> in the specified time zone.
+     * <p>
+     * If the specified time zone is null, the default zone is used.
      *
-     * @param date  the Date, must not be null
-     * @param zone  the time zone, must not be null
-     * @throws IllegalArgumentException if the date or zone is null
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
+     * @param zone  the time zone, null means default zone
      */
-    public MutableDateTime(Date date, DateTimeZone zone) {
-        iChronology = selectChronology(date, zone);
-        iMillis = date.getTime();
+    public MutableDateTime(long instant, DateTimeZone zone) {
+        super(instant, zone);
     }
 
     /**
-     * Constructs a MutableDateTime from a Date, using the supplied chronology.
+     * Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z
+     * using the specified chronology.
+     * <p>
+     * If the chronology is null, <code>ISOChronology</code>
+     * in the default time zone is used.
      *
-     * @param date  the Date, must not be null
-     * @param chronology  the chronology, must not be null
-     * @throws IllegalArgumentException if the date or chronology is null
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
+     * @param chronology  the chronology, null means ISOChronology in default zone
      */
-    public MutableDateTime(Date date, Chronology chronology) {
-        iChronology = selectChronology(date, chronology);
-        iMillis = date.getTime();
+    public MutableDateTime(long instant, Chronology chronology) {
+        super(instant, chronology);
     }
 
+    //-----------------------------------------------------------------------
     /**
-     * Constructs a MutableDateTime from a Calendar, using its closest mapped
-     * chronology and time zone.
-     *
-     * <p>When converting calendars to chronologies, the constructor is aware
-     * of GregorianCalendar and BuddhistCalendar and maps them to the
-     * equivalent chronology. Other calendars map to ISOChronology.
+     * Constructs an instance from an Object that represents a datetime.
+     * <p>
+     * If the object contains no chronology, <code>ISOChronology</code>
+     * in the default time zone is used.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
      *
-     * @param calendar  the Calendar, must not be null
-     * @throws IllegalArgumentException if the calendar is null
+     * @param instant  the datetime object, must not be null
+     * @throws IllegalArgumentException if the instant is null or invalid
      */
-    public MutableDateTime(Calendar calendar) {
-        iChronology = selectChronology(calendar);
-        iMillis = calendar.getTime().getTime();
+    public MutableDateTime(Object instant) {
+        super(instant);
     }
 
     /**
-     * Constructs a MutableDateTime from a Calendar, using its closest mapped
-     * chronology against a different time zone.
-     *
-     * <p>When converting calendars to chronologies, the constructor is aware
-     * of GregorianCalendar and BuddhistCalendar and maps them to the
-     * equivalent chronology. Other calendars map to ISOChronology.
+     * Constructs an instance from an Object that represents a datetime,
+     * forcing the time zone to that specified.
+     * <p>
+     * If the object contains no chronology, <code>ISOChronology</code> is used.
+     * If the specified time zone is null, the default zone is used.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
      *
-     * @param calendar  the Calendar, must not be null
-     * @param chronology  the chronology, must not be null
-     * @throws IllegalArgumentException if the calendar or zone is null
+     * @param instant  the datetime object, must not be null
+     * @param zone  the time zone, null means default time zone
+     * @throws IllegalArgumentException if the instant is null or invalid
      */
-    public MutableDateTime(Calendar calendar, DateTimeZone zone) {
-        iChronology = selectChronology(calendar, zone);
-        iMillis = calendar.getTime().getTime();
+    public MutableDateTime(Object instant, DateTimeZone zone) {
+        super(instant, zone);
     }
 
     /**
-     * Constructs a MutableDateTime from a Calendar, using the supplied chronology.
+     * Constructs an instance from an Object that represents a datetime,
+     * using the specifed chronology.
+     * <p>
+     * If the chronology is null, ISOChronology in the default time zone is used.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
      *
-     * @param calendar  the Calendar, must not be null
-     * @param chronology  the chronology, must not be null
-     * @throws IllegalArgumentException if the calendar or chronology is null
+     * @param instant  the datetime object, must not be null
+     * @param chronology  the chronology, null means ISOChronology in default zone
+     * @throws IllegalArgumentException if the instant is null or invalid
      */
-    public MutableDateTime(Calendar calendar, Chronology chronology) {
-        iChronology = selectChronology(calendar, chronology);
-        iMillis = calendar.getTime().getTime();
+    public MutableDateTime(Object instant, Chronology chronology) {
+        super(instant, chronology);
     }
 
+    //-----------------------------------------------------------------------
     /**
-     * Constructs a MutableDateTime from an ISO formatted String, using the ISO
-     * chronology, in the {@link DateTimeZone#getDefault() default} time zone.
+     * Constructs an instance from datetime field values
+     * using <code>ISOChronology</code> in the default time zone.
      *
-     * @param str  the string to parse, must not be null
-     * @throws IllegalArgumentException if the string is null
-     * @throws ParseException if parsing fails
+     * @param year  the year
+     * @param monthOfYear  the month of the year
+     * @param dayOfMonth  the day of the month
+     * @param hourOfDay  the hour of the day
+     * @param minuteOfHour  the minute of the hour
+     * @param secondOfMinute  the second of the minute
+     * @param millisOfSecond  the milisecond of the second
      */
-    public MutableDateTime(String str) throws ParseException {
-        iChronology = selectChronology(str);
-        DateTimeParser p = ISODateTimeFormat.getInstance(iChronology).dateTimeParser();
-        iMillis = p.parseMillis(str);
+    public MutableDateTime(
+            int year,
+            int monthOfYear,
+            int dayOfMonth,
+            int hourOfDay,
+            int minuteOfHour,
+            int secondOfMinute,
+            int millisOfSecond) {
+        super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
     }
 
     /**
-     * Constructs a MutableDateTime from an ISO formatted String, using the ISO
-     * chronology, in the supplied time zone.
+     * Constructs an instance from datetime field values
+     * using <code>ISOChronology</code> in the specified time zone.
+     * <p>
+     * If the specified time zone is null, the default zone is used.
      *
-     * @param str  the string to parse, must not be null
-     * @param zone the time zone, must not be null
-     * @throws IllegalArgumentException if the string or zone is null
-     * @throws ParseException if parsing fails
+     * @param year  the year
+     * @param monthOfYear  the month of the year
+     * @param dayOfMonth  the day of the month
+     * @param hourOfDay  the hour of the day
+     * @param minuteOfHour  the minute of the hour
+     * @param secondOfMinute  the second of the minute
+     * @param millisOfSecond  the milisecond of the second
+     * @param zone  the time zone, null means default time zone
      */
-    public MutableDateTime(String str, DateTimeZone zone) throws ParseException {
-        iChronology = selectChronology(str, zone);
-        DateTimeParser p = ISODateTimeFormat.getInstance(iChronology).dateTimeParser();
-        iMillis = p.parseMillis(str);
+    public MutableDateTime(
+            int year,
+            int monthOfYear,
+            int dayOfMonth,
+            int hourOfDay,
+            int minuteOfHour,
+            int secondOfMinute,
+            int millisOfSecond,
+            DateTimeZone zone) {
+        super(year, monthOfYear, dayOfMonth,
+              hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone);
     }
 
     /**
-     * Constructs a MutableDateTime from an ISO formatted String, using the supplied
-     * chronology.
+     * Constructs an instance from datetime field values
+     * using the specified chronology.
+     * <p>
+     * If the chronology is null, <code>ISOChronology</code>
+     * in the default time zone is used.
      *
-     * @param str  the string to parse, must not be null
-     * @param chronology  the chronology, must not be null
-     * @throws IllegalArgumentException if the string or chronology is null
-     * @throws ParseException if parsing fails
+     * @param year  the year
+     * @param monthOfYear  the month of the year
+     * @param dayOfMonth  the day of the month
+     * @param hourOfDay  the hour of the day
+     * @param minuteOfHour  the minute of the hour
+     * @param secondOfMinute  the second of the minute
+     * @param millisOfSecond  the milisecond of the second
+     * @param chronology  the chronology, null means ISOChronology in default zone
      */
-    public MutableDateTime(String str, Chronology chronology) throws ParseException {
-        iChronology = selectChronology(str, chronology);
-        DateTimeParser p = ISODateTimeFormat.getInstance(iChronology).dateTimeParser();
-        iMillis = p.parseMillis(str);
+    public MutableDateTime(
+            int year,
+            int monthOfYear,
+            int dayOfMonth,
+            int hourOfDay,
+            int minuteOfHour,
+            int secondOfMinute,
+            int millisOfSecond,
+            Chronology chronology) {
+        super(year, monthOfYear, dayOfMonth,
+              hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology);
     }
 
+    //-----------------------------------------------------------------------
     /**
      * Creates a new instance of this class.
      * <p>
      * The returned object will be a new instance of the implementation.
      * Immutable subclasses may return <code>this</code> if appropriate.
      *
-     * @param millis  the new millis, from 1970-01-01T00:00:00Z
+     * @param instant  the new instant, from 1970-01-01T00:00:00Z
      * @param chrono  the new chronology
      * @return a new instance of this class
      * @throws IllegalArgumentException if the chronology is null
      */
-    protected ReadableInstant create(long millis, Chronology chrono) {
+    protected ReadableInstant create(long instant, Chronology chrono) {
         if (chrono == null) {
             throw new IllegalArgumentException("The Chronology must not be null");
         }
-        return new MutableDateTime(millis, chrono);
+        return new MutableDateTime(instant, chrono);
     }
     
-    // Accessor/mutator/adder methods (Accessors same as for DateTime)
-    //-----------------------------------------------------------
-
+    // Millis
+    //-----------------------------------------------------------------------
     /**
-     * Gets the milliseconds of the datetime instant from the Java epoch
-     * of 1970-01-01T00:00:00Z.
-     * 
-     * @return the number of milliseconds since 1970-01-01T00:00:00Z
+     * Set the milliseconds of the datetime.
+     *
+     * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the
+     * datetime to
+     * @see #setDateTime(long)
      */
-    public long getMillis() {
-        return iMillis;
+    public void setMillis(long instant) {
+        super.setMillis(instant);
     }
 
     /**
-     * Set the milliseconds of the datetime.
+     * Set the date and time from an object representing an instant.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
      *
-     * @param millis the milliseconds since 1970-01-01T00:00:00Z to set the
-     * datetime to
+     * @param instant  an object representing an instant
+     * @throws IllegalArgumentException if the object is null or invalid
+     * @see #setDateTime(Object)
      */
-    public void setMillis(long millis) {
-        iMillis = millis;
+    public void setMillis(Object instant) {
+        super.setMillis(instant);
     }
 
+    // Add
+    //-----------------------------------------------------------------------
     /**
-     * Set the number of milliseconds of the datetime.
+     * Add an amount of time to the datetime.
      * 
-     * @param datetime  a ReadableInstant, Date, Calendar, Long or String
-     * @throws IllegalArgumentException if the object is null
-     * @throws ClassCastException if the object's type cannot be recognised
+     * @param duration  the millis to add
      */
-    public void setMillis(Object object) {
-        iMillis = getDateTimeMillisFromObject(object);
+    public void add(final long duration) {
+        setMillis(getMillis() + duration);
     }
 
     /**
      * Add an amount of time to the date.
      * 
-     * @param duration duration to add.
+     * @param duration  duration to add.
      */
-    /*
-    public void add(ReadableDuration duration) {
-        duration.addTo(this, 1);
+    public void add(final ReadableDuration duration) {
+        duration.addInto(this, 1);
     }
-    */
 
     /**
      * Add an amount of time to the date.
      * 
-     * @param duration duration to add.
-     * @param scalar direction and amount to add, which may be negative
+     * @param duration  duration to add.
+     * @param scalar  direction and amount to add, which may be negative
      */
-    /*
-    public void add(ReadableDuration duration, int scalar) {
-        duration.addTo(this, scalar);
+    public void add(final ReadableDuration duration, final int scalar) {
+        duration.addInto(this, scalar);
     }
-    */
 
     /**
      * Add an amount of time to the date.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableDuration, String and Long.
      * 
-     * @param object a ReadableDuration, Long or String evaluating to a
-     * duration
+     * @param duration  an object representing a duration
      */
-    public void add(Object object) {
-        /*
-        if (object instanceof ReadableDuration) {
-            add((ReadableDuration)object);
+    public void add(final Object duration) {
+        if (duration instanceof ReadableDuration) {
+            add((ReadableDuration) duration);
         } else {
-            iMillis += getDurationMillisFromObject(object);
+            DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);
+            add(converter.getDurationMillis(duration));
         }
-        */
-        iMillis += getDurationMillisFromObject(object);
-    }
-
-    /**
-     * Add an amount of time to the datetime.
-     * 
-     * @param millis  the millis to add
-     */
-    public void addMillis(long millis) {
-        iMillis += millis;
-    }
-
-    /**
-     * Gets the chronology of the datetime.
-     * 
-     * @return the Chronology that the datetime is using
-     */
-    public Chronology getChronology() {
-        return iChronology;
     }
 
+    // Chronology
+    //-----------------------------------------------------------------------
     /**
      * Set the chronology of the datetime.
      * 
-     * @param chronology  the chronology to use
-     * @throws IllegalArgumentException if the chronology is null
+     * @param chronology  the chronology to use, null means ISOChronology in default zone
      */
     public void setChronology(Chronology chronology) {
-        if (chronology == null) {
-            throw new IllegalArgumentException("The Chronology must not be null");
-        }
-        iChronology = chronology;
+        super.setChronology(chronology);
     }
 
+    // Time zone
+    //-----------------------------------------------------------------------
     /**
-     * Sets the time zone of the datetime via the chronology.
+     * Sets the time zone of the datetime, which changes the
+     * chronology. Setting the time zone does not affect the millisecond value
+     * of this instant.
+     * <p>
+     * If the chronology already has this time zone, no change occurs.
      *
-     * @param zone  the time zone to use
-     * @throws IllegalArgumentException if the time zone is null
+     * @param zone  the time zone to use, null means default zone
+     * @see #moveDateTimeZone
      */
     public void setDateTimeZone(DateTimeZone zone) {
-        if (zone == null) {
-            throw new IllegalArgumentException("The DateTimeZone must not be null");
-        }
-        if (iChronology.getDateTimeZone() != zone) {
-            iChronology = iChronology.withDateTimeZone(zone);
-        }
+        super.setDateTimeZone(zone);
     }
 
-    // public int get(DateTimeField field);  inherited from AbstractInstant
+    /**
+     * Moves the time zone of the datetime, which changes the
+     * chronology. Moving the time zone alters the millisecond value of this
+     * instant such that it is relative to the new time zone.
+     * <p>
+     * If the chronology already has this time zone, no change occurs.
+     *
+     * @param zone  the time zone to use, null means default zone
+     * @see #setDateTimeZone
+     */
+    public void moveDateTimeZone(DateTimeZone zone) {
+        super.moveDateTimeZone(zone);
+    }
 
+    // Field based
+    //-----------------------------------------------------------------------
     /**
      * Set a value in the specified field.
      * This could be used to set a field using a different Chronology.
@@ -498,8 +460,8 @@ public void setDateTimeZone(DateTimeZone zone) {
      * @param value the value
      * @throws NullPointerException if the field is null
      */
-    public void set(DateTimeField field, int value) {
-        iMillis = field.set(getMillis(), value);
+    public void set(final DateTimeField field, final int value) {
+        setMillis(field.set(getMillis(), value));
     }
 
     /**
@@ -515,8 +477,8 @@ public void set(DateTimeField field, int value) {
      * @param value the value
      * @throws NullPointerException if the field is null
      */
-    public void add(DateTimeField field, int value) {
-        iMillis = field.add(getMillis(), value);
+    public void add(final DateTimeField field, final int value) {
+        setMillis(field.add(getMillis(), value));
     }
 
     /**
@@ -532,241 +494,284 @@ public void add(DateTimeField field, int value) {
      * @param value the value
      * @throws NullPointerException if the field is null
      */
-    public void addWrapped(DateTimeField field, int value) {
-        iMillis = field.addWrapped(getMillis(), value);
+    public void addWrapped(final DateTimeField field, final int value) {
+        setMillis(field.addWrapped(getMillis(), value));
     }
 
-    // Date field mutator/adder methods
-    //-----------------------------------------------------------
-
+    // Date methods
+    //-----------------------------------------------------------------------
     /**
-     * Set the day of week to a value.
+     * Set the year to the specified value.
      *
-     * @param dayOfWeek  the day of the week.
+     * @param year  the year
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public void setDayOfWeek(int dayOfWeek) {
-        iMillis = getChronology().dayOfWeek().set(iMillis, dayOfWeek);
+    public void setYear(final int year) {
+        setMillis(getChronology().year().set(getMillis(), year));
     }
 
     /**
-     * Set the day of the month to a value.
+     * Add a number of years to the date.
      *
-     * @param dayOfMonth  the day of the month.
+     * @param years  the years to add
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public void setDayOfMonth(int dayOfMonth) {
-        iMillis = getChronology().dayOfMonth().set(iMillis, dayOfMonth);
+    public void addYears(final int years) {
+        setMillis(getChronology().years().add(getMillis(), years));
     }
 
+    //-----------------------------------------------------------------------
     /**
-     * Set the day of year to a value.
+     * Set the week of the year to the specified value.
      *
-     * @param dayOfYear the day of the year.
+     * @param weekyear  the weekyear
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public void setDayOfYear(int dayOfYear) {
-        iMillis = getChronology().dayOfYear().set(iMillis, dayOfYear);
+    public void setWeekyear(final int weekyear) {
+        setMillis(getChronology().weekyear().set(getMillis(), weekyear));
     }
 
     /**
-     * Add a number of days to the date.
+     * Add a number of weekyears to the date.
      *
-     * @param days  the days to add.
+     * @param weekyears  the weekyears to add
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public void addDays(int days) {
-        iMillis = getChronology().dayOfYear().add(iMillis, days);
+    public void addWeekyears(final int weekyears) {
+        setMillis(getChronology().weekyears().add(getMillis(), weekyears));
     }
 
+    //-----------------------------------------------------------------------
     /**
-     * Set the week of weekyear to a value.
+     * Set the month of the year to the specified value.
      *
-     * @param weekOfWeekyear the week of the weekyear.
+     * @param monthOfYear  the month of the year
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public void setWeekOfWeekyear(int weekOfWeekyear) {
-        iMillis = getChronology().weekOfWeekyear().set(iMillis, weekOfWeekyear);
+    public void setMonthOfYear(final int monthOfYear) {
+        setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear));
     }
 
     /**
-     * Add a number of weeks to the date.
+     * Add a number of months to the date.
      *
-     * @param weeks  the weeks to add.
+     * @param months  the months to add
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public void addWeeks(int weeks) {
-        iMillis = getChronology().weekOfWeekyear().add(iMillis, weeks);
+    public void addMonths(final int months) {
+        setMillis(getChronology().months().add(getMillis(), months));
     }
 
+    //-----------------------------------------------------------------------
     /**
-     * Set the week of the year to a value.
+     * Set the week of weekyear to the specified value.
      *
-     * @param weekyear  the weekyear.
+     * @param weekOfWeekyear the week of the weekyear
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public void setWeekyear(int weekyear) {
-        iMillis = getChronology().weekyear().set(iMillis, weekyear);
+    public void setWeekOfWeekyear(final int weekOfWeekyear) {
+        setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear));
     }
 
     /**
-     * Add a number of weekyears to the date.
+     * Add a number of weeks to the date.
      *
-     * @param weekyears  the weekyears to add.
+     * @param weeks  the weeks to add
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public void addWeekyears(int weekyears) {
-        iMillis = getChronology().weekyear().add(iMillis, weekyears);
+    public void addWeeks(final int weeks) {
+        setMillis(getChronology().weeks().add(getMillis(), weeks));
     }
 
+    //-----------------------------------------------------------------------
     /**
-     * Set the month of the year to a value.
+     * Set the day of year to the specified value.
      *
-     * @param month  the month of the year.
+     * @param dayOfYear the day of the year
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public void setMonthOfYear(int month) {
-        iMillis = getChronology().monthOfYear().set(iMillis, month);
+    public void setDayOfYear(final int dayOfYear) {
+        setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear));
     }
 
     /**
-     * Add a number of months to the date.
+     * Set the day of the month to the specified value.
      *
-     * @param months  the months to add.
+     * @param dayOfMonth  the day of the month
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public void addMonths(int months) {
-        iMillis = getChronology().monthOfYear().add(iMillis, months);
+    public void setDayOfMonth(final int dayOfMonth) {
+        setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth));
     }
 
     /**
-     * Set the year to a value.
+     * Set the day of week to the specified value.
      *
-     * @param year  the year.
+     * @param dayOfWeek  the day of the week
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public void setYear(int year) {
-        iMillis = getChronology().year().set(iMillis, year);
+    public void setDayOfWeek(final int dayOfWeek) {
+        setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek));
     }
 
     /**
-     * Add a number of years to the date.
+     * Add a number of days to the date.
      *
-     * @param years  the years to add.
+     * @param days  the days to add
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public void addYears(int years) {
-        iMillis = getChronology().year().add(iMillis, years);
+    public void addDays(final int days) {
+        setMillis(getChronology().days().add(getMillis(), days));
     }
 
-    // Time field mutator/adder methods
-    //-----------------------------------------------------------
-
+    // Time methods
+    //-----------------------------------------------------------------------
     /**
-     * Set the millis of the second.
+     * Set the hour of the day to the specified value.
      *
-     * @param millis  the millis of second.
+     * @param hourOfDay  the hour of day
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public void setMillisOfSecond(int millis) {
-        iMillis = getChronology().millisOfSecond().set(iMillis, millis);
+    public void setHourOfDay(final int hourOfDay) {
+        setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay));
     }
 
     /**
-     * Set the millis of the day.
+     * Add a number of hours to the date.
      *
-     * @param millis  the millis of day.
+     * @param hours  the hours to add
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public void setMillisOfDay(int millis) {
-        iMillis = getChronology().millisOfDay().set(iMillis, millis);
+    public void addHours(final int hours) {
+        setMillis(getChronology().hours().add(getMillis(), hours));
     }
-
+    
+    //-----------------------------------------------------------------------
     /**
-     * Set the second of the minute.
+     * Set the minute of the day to the specified value.
      *
-     * @param second  the second of minute.
+     * @param minuteOfDay  the minute of day
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public void setSecondOfMinute(int second) {
-        iMillis = getChronology().secondOfMinute().set(iMillis, second);
+    public void setMinuteOfDay(final int minuteOfDay) {
+        setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay));
     }
 
     /**
-     * Set the second of the day.
+     * Set the minute of the hour to the specified value.
      *
-     * @param second  the second of day.
+     * @param minuteOfHour  the minute of hour
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public void setSecondOfDay(int second) {
-        iMillis = getChronology().secondOfDay().set(iMillis, second);
+    public void setMinuteOfHour(final int minuteOfHour) {
+        setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour));
     }
 
     /**
-     * Add a number of seconds to the date.
+     * Add a number of minutes to the date.
      *
-     * @param seconds  the seconds to add.
+     * @param minutes  the minutes to add
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public void addSeconds(int seconds) {
-        iMillis = getChronology().secondOfDay().add(iMillis, seconds);
+    public void addMinutes(final int minutes) {
+        setMillis(getChronology().minutes().add(getMillis(), minutes));
     }
 
+    //-----------------------------------------------------------------------
     /**
-     * Set the minute of the hour.
+     * Set the second of the day to the specified value.
      *
-     * @param minute  the minute of hour.
+     * @param secondOfDay  the second of day
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public void setMinuteOfHour(int minute) {
-        iMillis = getChronology().minuteOfHour().set(iMillis, minute);
+    public void setSecondOfDay(final int secondOfDay) {
+        setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay));
     }
 
     /**
-     * Set the minute of the day.
+     * Set the second of the minute to the specified value.
      *
-     * @param minute  the minute of day.
+     * @param secondOfMinute  the second of minute
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public void setMinuteOfDay(int minute) {
-        iMillis = getChronology().minuteOfDay().set(iMillis, minute);
+    public void setSecondOfMinute(final int secondOfMinute) {
+        setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute));
     }
 
     /**
-     * Add a number of minutes to the date.
+     * Add a number of seconds to the date.
      *
-     * @param minutes  the minutes to add.
+     * @param seconds  the seconds to add
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public void addMinutes(int minutes) {
-        iMillis = getChronology().minuteOfDay().add(iMillis, minutes);
+    public void addSeconds(final int seconds) {
+        setMillis(getChronology().seconds().add(getMillis(), seconds));
     }
 
+    //-----------------------------------------------------------------------
     /**
-     * Set the hour of the day.
+     * Set the millis of the day to the specified value.
      *
-     * @param hour  the hour of day.
+     * @param millisOfDay  the millis of day
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public void setHourOfDay(int hour) {
-        iMillis = getChronology().hourOfDay().set(iMillis, hour);
+    public void setMillisOfDay(final int millisOfDay) {
+        setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay));
     }
 
     /**
-     * Add a number of hours to the date.
+     * Set the millis of the second to the specified value.
      *
-     * @param hours  the hours to add.
+     * @param millisOfSecond  the millis of second
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public void addHours(int hours) {
-        iMillis = getChronology().hourOfDay().add(iMillis, hours);
+    public void setMillisOfSecond(final int millisOfSecond) {
+        setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond));
     }
 
-    // Convenient helpers
-    //----------------------------------------------------
-    
     /**
-     * Set the date from various different types of object.
-     * The time part of the parameter will be ignored.
-     * The time part of this object will be unaffected.
+     * Add a number of milliseconds to the date. The implementation of this
+     * method differs from the {@link #add(long)} method in that a
+     * DateTimeField performs the addition.
      *
-     * @param date  a ReadableInstant, Date, Calendar, Long or String
-     * @throws IllegalArgumentException if the object is null.
-     * @throws ClassCastException if the object's type cannot be recognised
+     * @param millis  the milliseconds to add
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public void setDate(Object date) {
-        setDate(getDateTimeMillisFromObject(date));
+    public void addMillis(final int millis) {
+        setMillis(getChronology().millis().add(getMillis(), millis));
     }
 
+    // Setters
+    //-----------------------------------------------------------------------
     /**
      * Set the date from milliseconds.
-     * The time part of the parameter will be ignored.
      * The time part of this object will be unaffected.
      *
-     * @param millis milliseconds from 1970-01-01T00:00:00Z, ignoring time of
-     * day
+     * @param instant  milliseconds from 1970-01-01T00:00:00Z, time part ignored
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public void setDate(long millis) {
+    public void setDate(final long instant) {
         Chronology c = getChronology();
-        iMillis = c.getDateOnlyMillis(millis) + c.getTimeOnlyMillis(iMillis);
+        setMillis(c.getDateOnlyMillis(instant) + c.getTimeOnlyMillis(getMillis()));
+    }
+
+    /**
+     * Set the date from an object representing an instant.
+     * The time part of this object will be unaffected.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     *
+     * @param instant  an object representing an instant, time part ignored
+     * @throws IllegalArgumentException if the object is null or invalid
+     */
+    public void setDate(final Object instant) {
+        if (instant instanceof ReadableInstant) {
+            setDate(((ReadableInstant) instant).getMillis());
+        } else {
+            InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
+            setDate(converter.getInstantMillis(instant));
+        }
     }
 
     /**
@@ -774,42 +779,50 @@ public void setDate(long millis) {
      * The time part of this object will be unaffected.
      *
      * @param year  the year
-     * @param month  the month of the year
+     * @param monthOfYear  the month of the year
      * @param dayOfMonth  the day of the month
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public void setDate(int year, int monthOfYear, int dayOfMonth) {
-        // Do not modify this object until method completion
+    public void setDate(
+            final int year,
+            final int monthOfYear,
+            final int dayOfMonth) {
         Chronology c = getChronology();
-        long workVal = c.getTimeOnlyMillis( iMillis );
-        workVal = c.year().set( workVal, year );
-        workVal = c.monthOfYear().set( workVal, monthOfYear );
-        workVal = c.dayOfMonth().set( workVal, dayOfMonth );
-        iMillis = workVal;
+        long instant = c.getDateTimeMillis(
+            year, monthOfYear, dayOfMonth, 0, 0, 0, 0);
+        setDate(instant);
     }
 
+    //-----------------------------------------------------------------------
     /**
-     * Set the time from an object.
-     * The date part of the parameter will be ignored.
+     * Set the time from milliseconds.
      * The date part of this object will be unaffected.
      *
-     * @param time  a ReadableInstant, Date, Calendar, Long or String
-     * @throws IllegalArgumentException if the object is null.
-     * @throws ClassCastException if the object's type cannot be recognised
+     * @param millis milliseconds from T00:00:00Z, date part ignored
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public void setTime(Object time) {
-        setTime(getDateTimeMillisFromObject(time));
+    public void setTime(final long millis) {
+        Chronology c = getChronology();
+        setMillis(c.getDateOnlyMillis(getMillis()) + c.getTimeOnlyMillis(millis));
     }
 
     /**
-     * Set the time from milliseconds.
-     * The date part of the parameter will be ignored.
+     * Set the date from an object representing an instant.
      * The date part of this object will be unaffected.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
      *
-     * @param millis milliseconds from T00:00:00Z, ignoring date
+     * @param instant  an object representing an instant, date part ignored
+     * @throws IllegalArgumentException if the object is null or invalid
      */
-    public void setTime(long millis) {
-        Chronology c = getChronology();
-        iMillis = c.getDateOnlyMillis(iMillis) + c.getTimeOnlyMillis(millis);
+    public void setTime(final Object instant) {
+        if (instant instanceof ReadableInstant) {
+            setDateTime(((ReadableInstant) instant).getMillis());
+        } else {
+            InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
+            setDateTime(converter.getInstantMillis(instant));
+        }
     }
 
     /**
@@ -820,109 +833,114 @@ public void setTime(long millis) {
      * @param minuteOfHour  the minute of the hour
      * @param secondOfMinute  the second of the minute
      * @param millisOfSecond  the milisecond of the second
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public void setTime(int hour, int minuteOfHour, int secondOfMinute, int millisOfSecond) {
-        // Do not modify this object until method completion
-        Chronology c = getChronology();
-        long workVal = c.getDateOnlyMillis( iMillis );
-        workVal = c.hourOfDay().set( workVal, hour );
-        workVal = c.minuteOfHour().set( workVal, minuteOfHour );
-        workVal = c.secondOfMinute().set( workVal, secondOfMinute );
-        workVal = c.millisOfSecond().set( workVal, millisOfSecond );
-        iMillis = workVal;
+    public void setTime(
+            final int hour,
+            final int minuteOfHour,
+            final int secondOfMinute,
+            final int millisOfSecond) {
+        long instant = getChronology().getDateTimeMillis(
+            getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond);
+        setTime(instant);
     }
 
+    //-----------------------------------------------------------------------
     /**
-     * Set the date and time from an object.
+     * Set the date and time from milliseconds.
+     * This method is a synonm for {@link #setMillis(long)}.
      *
-     * @param datetime  a ReadableInstant, Date, Calendar, Long or String
-     * @throws IllegalArgumentException if the object is null.
-     * @throws ClassCastException if the object's type cannot be recognised
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public void setDateTime(Object datetime) {
-        iMillis = getDateTimeMillisFromObject(datetime);
+    public void setDateTime(final long instant) {
+        setMillis(instant);
     }
 
     /**
-     * Set the date and time from milliseconds.
+     * Set the date and time from an object representing an instant.
+     * This method is a synonm for {@link #setMillis(Object)}.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
      *
-     * @param millis  the millis
+     * @param instant  an object representing an instant
+     * @throws IllegalArgumentException if the object is null or invalid
      */
-    public void setDateTime(long millis) {
-        iMillis = millis;
+    public void setDateTime(final Object instant) {
+        setDateTime(instant);
     }
 
     /**
      * Set the date and time from fields.
      *
      * @param year  the year
-     * @param month  the month of the year
+     * @param monthOfYear  the month of the year
      * @param dayOfMonth  the day of the month
-     * @param hour  the hour
+     * @param hourOfDay  the hour of the day
      * @param minuteOfHour  the minute of the hour
      * @param secondOfMinute  the second of the minute
      * @param millisOfSecond  the milisecond of the second
+     * @throws IllegalArgumentException if the value is invalid
      */
-    public void setDateTime(int year,
-                            int monthOfYear,
-                            int dayOfMonth,
-                            int hourOfDay,
-                            int minuteOfHour,
-                            int secondOfMinute,
-                            int millisOfSecond)
-    {
-        // Do not modify this object until method completion
-        Chronology c = getChronology();
-        long workVal = 0;
-        workVal = c.year().set( workVal, year );
-        workVal = c.monthOfYear().set( workVal, monthOfYear );
-        workVal = c.dayOfMonth().set( workVal, dayOfMonth );
-        workVal = c.hourOfDay().set( workVal, hourOfDay );
-        workVal = c.minuteOfHour().set( workVal, minuteOfHour );
-        workVal = c.secondOfMinute().set( workVal, secondOfMinute );
-        workVal = c.millisOfSecond().set( workVal, millisOfSecond );
-        iMillis = workVal;
+    public void setDateTime(
+            final int year,
+            final int monthOfYear,
+            final int dayOfMonth,
+            final int hourOfDay,
+            final int minuteOfHour,
+            final int secondOfMinute,
+            final int millisOfSecond) {
+        long instant = getChronology().getDateTimeMillis(
+            year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+        setDateTime(instant);
     }
 
     // Date properties
-    //-----------------------------------------------------------
+    //-----------------------------------------------------------------------
+    /**
+     * Get the era property.
+     * 
+     * @return the era property
+     */
+    public MutableDateTimeFieldProperty era() {
+        return new MutableDateTimeFieldProperty(this, getChronology().era());
+    }
 
     /**
-     * Get the day of week property.
-     * <p>
-     * The values for day of week are defined in {@link DateTimeConstants}.
+     * Get the century of era property.
      * 
-     * @return the day of week property
+     * @return the year of era property
      */
-    public MutableDateTimeFieldProperty dayOfWeek() {
-        return new MutableDateTimeFieldProperty(this, getChronology().dayOfWeek());
+    public MutableDateTimeFieldProperty centuryOfEra() {
+        return new MutableDateTimeFieldProperty(this, getChronology().centuryOfEra());
     }
 
     /**
-     * Get the day of month property.
+     * Get the year of century property.
      * 
-     * @return the day of month property
+     * @return the year of era property
      */
-    public MutableDateTimeFieldProperty dayOfMonth() {
-        return new MutableDateTimeFieldProperty(this, getChronology().dayOfMonth());
+    public MutableDateTimeFieldProperty yearOfCentury() {
+        return new MutableDateTimeFieldProperty(this, getChronology().yearOfCentury());
     }
 
     /**
-     * Get the day of year property.
+     * Get the year of era property.
      * 
-     * @return the day of year property
+     * @return the year of era property
      */
-    public MutableDateTimeFieldProperty dayOfYear() {
-        return new MutableDateTimeFieldProperty(this, getChronology().dayOfYear());
+    public MutableDateTimeFieldProperty yearOfEra() {
+        return new MutableDateTimeFieldProperty(this, getChronology().yearOfEra());
     }
 
     /**
-     * Get the week of a week based year property.
+     * Get the year property.
      * 
-     * @return the week of a week based year property
+     * @return the year property
      */
-    public MutableDateTimeFieldProperty weekOfWeekyear() {
-        return new MutableDateTimeFieldProperty(this, getChronology().weekOfWeekyear());
+    public MutableDateTimeFieldProperty year() {
+        return new MutableDateTimeFieldProperty(this, getChronology().year());
     }
 
     /**
@@ -944,78 +962,72 @@ public MutableDateTimeFieldProperty monthOfYear() {
     }
 
     /**
-     * Get the year property.
-     * 
-     * @return the year property
-     */
-    public MutableDateTimeFieldProperty year() {
-        return new MutableDateTimeFieldProperty(this, getChronology().year());
-    }
-
-    /**
-     * Get the year of era property.
+     * Get the week of a week based year property.
      * 
-     * @return the year of era property
+     * @return the week of a week based year property
      */
-    public MutableDateTimeFieldProperty yearOfEra() {
-        return new MutableDateTimeFieldProperty(this, getChronology().yearOfEra());
+    public MutableDateTimeFieldProperty weekOfWeekyear() {
+        return new MutableDateTimeFieldProperty(this, getChronology().weekOfWeekyear());
     }
 
     /**
-     * Get the year of century property.
+     * Get the day of year property.
      * 
-     * @return the year of era property
+     * @return the day of year property
      */
-    public MutableDateTimeFieldProperty yearOfCentury() {
-        return new MutableDateTimeFieldProperty(this, getChronology().yearOfCentury());
+    public MutableDateTimeFieldProperty dayOfYear() {
+        return new MutableDateTimeFieldProperty(this, getChronology().dayOfYear());
     }
 
     /**
-     * Get the century of era property.
+     * Get the day of month property.
+     * <p>
+     * The values for day of month are defined in {@link DateTimeConstants}.
      * 
-     * @return the year of era property
+     * @return the day of month property
      */
-    public MutableDateTimeFieldProperty centuryOfEra() {
-        return new MutableDateTimeFieldProperty(this, getChronology().centuryOfEra());
+    public MutableDateTimeFieldProperty dayOfMonth() {
+        return new MutableDateTimeFieldProperty(this, getChronology().dayOfMonth());
     }
 
     /**
-     * Get the era property.
+     * Get the day of week property.
+     * <p>
+     * The values for day of week are defined in {@link DateTimeConstants}.
      * 
-     * @return the era property
+     * @return the day of week property
      */
-    public MutableDateTimeFieldProperty era() {
-        return new MutableDateTimeFieldProperty(this, getChronology().era());
+    public MutableDateTimeFieldProperty dayOfWeek() {
+        return new MutableDateTimeFieldProperty(this, getChronology().dayOfWeek());
     }
 
     // Time properties
-    //-----------------------------------------------------------
-    
+    //-----------------------------------------------------------------------
     /**
-     * Get the millis of second property
+     * Get the hour of day field property
      * 
-     * @return the millis of second property
+     * @return the hour of day property
      */
-    public MutableDateTimeFieldProperty millisOfSecond() {
-        return new MutableDateTimeFieldProperty(this, getChronology().millisOfSecond());
+    public MutableDateTimeFieldProperty hourOfDay() {
+        return new MutableDateTimeFieldProperty(this, getChronology().hourOfDay());
     }
 
     /**
-     * Get the millis of day property
+     * Get the minute of day property
      * 
-     * @return the millis of day property
+     * @return the minute of day property
      */
-    public MutableDateTimeFieldProperty millisOfDay() {
-        return new MutableDateTimeFieldProperty(this, getChronology().millisOfDay());
+    public MutableDateTimeFieldProperty minuteOfDay() {
+        return new MutableDateTimeFieldProperty(this, getChronology().minuteOfDay());
     }
 
     /**
-     * Get the second of minute field property
+     * Get the minute of hour field property
      * 
-     * @return the second of minute property
+     * @return the minute of hour property
      */
-    public MutableDateTimeFieldProperty secondOfMinute() {
-        return new MutableDateTimeFieldProperty(this, getChronology().secondOfMinute());
+    public MutableDateTimeFieldProperty minuteOfHour() {
+        return new MutableDateTimeFieldProperty(this, getChronology().minuteOfHour());
     }
 
     /**
@@ -1028,55 +1040,41 @@ public MutableDateTimeFieldProperty secondOfDay() {
     }
 
     /**
-     * Get the minute of hour field property
+     * Get the second of minute field property
      * 
-     * @return the minute of hour property
+     * @return the second of minute property
      */
-    public MutableDateTimeFieldProperty minuteOfHour() {
-        return new MutableDateTimeFieldProperty(this, getChronology().minuteOfHour());
+    public MutableDateTimeFieldProperty secondOfMinute() {
+        return new MutableDateTimeFieldProperty(this, getChronology().secondOfMinute());
     }
 
     /**
-     * Get the minute of day property
+     * Get the millis of day property
      * 
-     * @return the minute of day property
+     * @return the millis of day property
      */
-    public MutableDateTimeFieldProperty minuteOfDay() {
-        return new MutableDateTimeFieldProperty(this, getChronology().minuteOfDay());
+    public MutableDateTimeFieldProperty millisOfDay() {
+        return new MutableDateTimeFieldProperty(this, getChronology().millisOfDay());
     }
 
     /**
-     * Get the hour of day field property
+     * Get the millis of second property
      * 
-     * @return the hour of day property
+     * @return the millis of second property
      */
-    public MutableDateTimeFieldProperty hourOfDay() {
-        return new MutableDateTimeFieldProperty(this, getChronology().hourOfDay());
+    public MutableDateTimeFieldProperty millisOfSecond() {
+        return new MutableDateTimeFieldProperty(this, getChronology().millisOfSecond());
     }
 
     // Misc
-    //-----------------------------------------------------------
-
-    /**
-     * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZ).
-     * 
-     * @return ISO8601 time formatted string.
-     */
-    public String toString() {
-        return ISODateTimeFormat.getInstance(getChronology()).dateTime().print(this);
-    }
-
+    //-----------------------------------------------------------------------
     /**
      * Clone this object without having to cast the returned object.
      *
      * @return a clone of the this object.
      */
     public MutableDateTime copy() {
-        try {
-            return (MutableDateTime)super.clone();
-        } catch (CloneNotSupportedException ex) {
-            throw new InternalError("Clone error");
-        }
+        return (MutableDateTime)clone();
     }
 
     /**
@@ -1093,69 +1091,12 @@ public Object clone() {
     }
 
     /**
-     * Extracts a long datetime value from an object.
-     *
-     * @param object  an input object
-     * @return a long date-time value
-     * @throws IllegalArgumentException if the object is null, or the string invalid
-     * @throws ClassCastException if the object type is not supported
-     */
-    protected long getDateTimeMillisFromObject(Object object) {
-        if (object instanceof ReadableInstant) {
-            return ((ReadableInstant) object).getMillis();
-
-        } else if (object instanceof Date) {
-            return ((Date) object).getTime();
-
-        } else if (object instanceof Calendar) {
-            return ((Calendar) object).getTime().getTime();
-
-        } else if (object instanceof Long) {
-            return ((Long) object).longValue();
-
-        } else if (object instanceof String) {
-            try {
-                Instant instant = new Instant((String) object);
-                return instant.getMillis();
-
-            } catch (ParseException ex) {
-                throw new IllegalArgumentException("String '" + object + "' is an invalid date format");
-            }
-        } else if (object == null) {
-            throw new IllegalArgumentException("<null> cannot be converted to a datetime");
-        } else {
-            throw new ClassCastException("Class '" + object.getClass().getName() + "' cannot be converted to a datetime");
-        }
-    }
-
-    /**
-     * Extracts a fixed millisecond duration from an object.
+     * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZ).
      * 
-     * @param object  Long or String
-     * @throws IllegalArgumentException if the object is null, or the string invalid
-     * @throws ClassCastException if the object type is not supported
-     */
-    protected long getDurationMillisFromObject(Object object) {
-        if (object instanceof Long) {
-            Long other = (Long) object;
-            return other.longValue();
-        /* TODO } else if (object instanceof String) {
-            try {
-                TimePeriod other = new TimePeriod((String) object);
-                return other.getMillis();
-            } catch (ParseException ex) {
-                throw new IllegalArgumentException
-                    ("String '" + object + "' is an invalid time period format");
-            }*/
-        } else {
-            String type;
-            if (object == null) {
-                type = "<null>";
-            } else {
-                type = "Object of type \"" + object.getClass().getName() + '"';
-            }
-            throw new IllegalArgumentException(type + " cannot be converted to a duration");
-        }
+     * @return ISO8601 time formatted string.
+     */
+    public String toString() {
+        return ISODateTimeFormat.getInstance(getChronology()).dateTime().print(this);
     }
-    
+
 }
diff --git a/JodaTime/src/java/org/joda/time/MutableDateTimeFieldProperty.java b/JodaTime/src/java/org/joda/time/MutableDateTimeFieldProperty.java
index e363433b8..ffea8adb4 100644
--- a/JodaTime/src/java/org/joda/time/MutableDateTimeFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/MutableDateTimeFieldProperty.java
@@ -56,10 +56,20 @@
 import java.util.Locale;
 
 /**
- * MutableDateTimeFieldProperty binds a ReadWritableInstant to a DateTimeField.
+ * MutableDateTimeFieldProperty binds a MutableDateTime to a DateTimeField
+ * allowing powerful datetime functionality to be easily accessed.
  * <p>
- * MutableDateTimeFieldProperty allows the date and time manipulation code to
- * be field based yet still easy to use.
+ * The example below shows how to use the property to change the value of a
+ * MutableDateTime object.
+ * <pre>
+ * MutableDateTime dt = new MutableDateTime(1972, 12, 3, 0, 0, 0, 0);
+ * dt.year().add(20);
+ * dt.second().roundFloor();
+ * dt.minute().set(10);
+ * </pre>
+ * <p>
+ * MutableDateTimeFieldPropery itself is thread-safe and immutable, but the
+ * MutableDateTime being operated on may not be thread-safe.
  *
  * @see ReadWritableInstant
  * @see DateTimeField
@@ -68,51 +78,87 @@
  * @author Brian S O'Neill
  * @since 1.0
  */
-public class MutableDateTimeFieldProperty extends DateTimeFieldProperty {
+public class MutableDateTimeFieldProperty extends AbstractDateTimeFieldProperty {
+
+    static final long serialVersionUID = -4481126543819298617L;
+
+    /** The instant this property is working against */
+    private final MutableDateTime iInstant;
+    /** The field this property is working against */
+    private final DateTimeField iField;
 
     /**
      * Constructor.
-     *
+     * 
      * @param instant  the instant to set
      * @param field  the field to use
      */
-    public MutableDateTimeFieldProperty(ReadWritableInstant instant, DateTimeField field) {
-        super(instant, field);
+    public MutableDateTimeFieldProperty(MutableDateTime instant, DateTimeField field) {
+        super();
+        iInstant = instant;
+        iField = field;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the field being used.
+     * 
+     * @return the field
+     */
+    public DateTimeField getField() {
+        return iField;
+    }
+
+    /**
+     * Gets the instant being used.
+     * 
+     * @return the instant
+     */
+    public ReadableDateTime getInstant() {
+        return iInstant;
+    }
+
+    /**
+     * Gets the instant being used.
+     * 
+     * @return the instant
+     */
+    public MutableDateTime getMutableDateTime() {
+        return iInstant;
     }
 
+    //-----------------------------------------------------------------------
     /**
      * Adds a value to the millis value.
      * 
-     * @param value  the value to add.
+     * @param value  the value to add
      * @see DateTimeField#add(long,int)
      */
     public void add(int value) {
-        ReadWritableInstant instant = (ReadWritableInstant)getInstant();
-        instant.setMillis(getField().add(instant.getMillis(), value));
+        iInstant.setMillis(getField().add(iInstant.getMillis(), value));
     }
 
     /**
      * Adds a value to the millis value.
      * 
-     * @param value  the value to add.
+     * @param value  the value to add
      * @see DateTimeField#add(long,long)
      */
     public void add(long value) {
-        ReadWritableInstant instant = (ReadWritableInstant)getInstant();
-        instant.setMillis(getField().add(instant.getMillis(), value));
+        iInstant.setMillis(getField().add(iInstant.getMillis(), value));
     }
 
     /**
      * Adds a value, possibly wrapped, to the millis value.
      * 
-     * @param value  the value to add.
+     * @param value  the value to add
      * @see DateTimeField#addWrapped
      */
     public void addWrapped(int value) {
-        ReadWritableInstant instant = (ReadWritableInstant)getInstant();
-        instant.setMillis(getField().addWrapped(instant.getMillis(), value));
+        iInstant.setMillis(getField().addWrapped(iInstant.getMillis(), value));
     }
 
+    //-----------------------------------------------------------------------
     /**
      * Sets a value.
      * 
@@ -120,8 +166,7 @@ public void addWrapped(int value) {
      * @see DateTimeField#set(long,int)
      */
     public void set(int value) {
-        ReadWritableInstant instant = (ReadWritableInstant)getInstant();
-        instant.setMillis(getField().set(instant.getMillis(), value));
+        iInstant.setMillis(getField().set(iInstant.getMillis(), value));
     }
 
     /**
@@ -133,8 +178,7 @@ public void set(int value) {
      * @see DateTimeField#set(long,java.lang.String,java.util.Locale)
      */
     public void set(String text, Locale locale) {
-        ReadWritableInstant instant = (ReadWritableInstant)getInstant();
-        instant.setMillis(getField().set(instant.getMillis(), text, locale));
+        iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale));
     }
 
     /**
@@ -148,14 +192,14 @@ public final void set(String text) {
         set(text, null);
     }
 
+    //-----------------------------------------------------------------------
     /**
      * Round to the lowest whole unit of this field.
      *
      * @see DateTimeField#roundFloor
      */
     public void roundFloor() {
-        ReadWritableInstant instant = (ReadWritableInstant)getInstant();
-        instant.setMillis(getField().roundFloor(instant.getMillis()));
+        iInstant.setMillis(getField().roundFloor(iInstant.getMillis()));
     }
 
     /**
@@ -164,8 +208,7 @@ public void roundFloor() {
      * @see DateTimeField#roundCeiling
      */
     public void roundCeiling() {
-        ReadWritableInstant instant = (ReadWritableInstant)getInstant();
-        instant.setMillis(getField().roundCeiling(instant.getMillis()));
+        iInstant.setMillis(getField().roundCeiling(iInstant.getMillis()));
     }
 
     /**
@@ -175,8 +218,7 @@ public void roundCeiling() {
      * @see DateTimeField#roundHalfFloor
      */
     public void roundHalfFloor() {
-        ReadWritableInstant instant = (ReadWritableInstant)getInstant();
-        instant.setMillis(getField().roundHalfFloor(instant.getMillis()));
+        iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis()));
     }
 
     /**
@@ -186,28 +228,17 @@ public void roundHalfFloor() {
      * @see DateTimeField#roundHalfCeiling
      */
     public void roundHalfCeiling() {
-        ReadWritableInstant instant = (ReadWritableInstant)getInstant();
-        instant.setMillis(getField().roundHalfCeiling(instant.getMillis()));
+        iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis()));
     }
 
     /**
      * Round to the nearest whole unit of this field. If halfway, the ceiling
-     * is favored the floor only if it makes this field's value even.
+     * is favored over the floor only if it makes this field's value even.
      *
      * @see DateTimeField#roundHalfEven
      */
     public void roundHalfEven() {
-        ReadWritableInstant instant = (ReadWritableInstant)getInstant();
-        instant.setMillis(getField().roundHalfEven(instant.getMillis()));
+        iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis()));
     }
 
-    /**
-     * Retains only the fractional units of this field.
-     *
-     * @see DateTimeField#remainder
-     */
-    public void remainder() {
-        ReadWritableInstant instant = (ReadWritableInstant)getInstant();
-        instant.setMillis(getField().remainder(instant.getMillis()));
-    }
 }
diff --git a/JodaTime/src/java/org/joda/time/MutableDuration.java b/JodaTime/src/java/org/joda/time/MutableDuration.java
new file mode 100644
index 000000000..3e7a83994
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/MutableDuration.java
@@ -0,0 +1,445 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+import java.io.Serializable;
+
+/**
+ * Standard mutable duration implementation.
+ * <p>
+ * MutableDuration is mutable and not thread-safe, unless concurrent threads
+ * are not invoking mutator methods.
+ *
+ * @author Brian S O'Neill
+ * @author Stephen Colebourne
+ * @since 1.0
+ * @see Duration
+ */
+public class MutableDuration extends AbstractDuration
+    implements ReadWritableDuration, Cloneable, Serializable {
+
+    static final long serialVersionUID = 3436451121567212165L;
+
+    /**
+     * Copies another duration to this one.
+     *
+     * @throws UnsupportedOperationException if an unsupported field's value is
+     * non-zero
+     */
+    public MutableDuration(ReadableDuration duration) {
+        super(duration);
+    }
+
+    /**
+     * Copies another duration to this one.
+     *
+     * @param type use a different DurationType
+     * @throws UnsupportedOperationException if an unsupported field's value is
+     * non-zero
+     */
+    public MutableDuration(DurationType type, ReadableDuration duration) {
+        super(type, duration);
+    }
+
+    /**
+     * Create a duration from a set of field values.
+     *
+     * @param type determines which set of fields this duration supports
+     * @param years amount of years in this duration, which must be zero if
+     * unsupported.
+     * @param months amount of months in this duration, which must be zero if
+     * unsupported.
+     * @param weeks amount of weeks in this duration, which must be zero if
+     * unsupported.
+     * @param days amount of days in this duration, which must be zero if
+     * unsupported.
+     * @param hours amount of hours in this duration, which must be zero if
+     * unsupported.
+     * @param minutes amount of minutes in this duration, which must be zero if
+     * unsupported.
+     * @param seconds amount of seconds in this duration, which must be zero if
+     * unsupported.
+     * @param millis amount of milliseconds in this duration, which must be
+     * zero if unsupported.
+     * @throws UnsupportedOperationException if an unsupported field's value is
+     * non-zero
+     */
+    public MutableDuration(DurationType type,
+                           int years, int months, int weeks, int days,
+                           int hours, int minutes, int seconds, int millis) {
+        super(type, years, months, weeks, days, hours, minutes, seconds, millis);
+    }
+
+    /**
+     * Creates a duration from the given interval endpoints.
+     *
+     * @param type determines which set of fields this duration supports
+     * @param startInstant interval start, in milliseconds
+     * @param endInstant interval end, in milliseconds
+     */
+    public MutableDuration(DurationType type, long startInstant, long endInstant) {
+        super(type, startInstant, endInstant);
+    }
+
+    /**
+     * Creates a duration from the given interval endpoints.
+     *
+     * @param type determines which set of fields this duration supports
+     * @param startInstant interval start
+     * @param endInstant interval end
+     */
+    public MutableDuration(DurationType type,
+                           ReadableInstant startInstant, ReadableInstant endInstant) {
+        super(type, startInstant, endInstant);
+    }
+
+    /**
+     * Creates a duration from the given millisecond duration. If any supported
+     * fields are imprecise, an UnsupportedOperationException is thrown. The
+     * exception to this is when the specified duration is zero.
+     *
+     * @param type determines which set of fields this duration supports
+     * @param duration  the duration, in milliseconds
+     * @throws UnsupportedOperationException if any fields are imprecise
+     */
+    public MutableDuration(DurationType type, long duration) {
+        super(type, duration);
+    }
+
+    /**
+     * Sets all the fields in one go from another ReadableDuration.
+     * 
+     * @param duration  the duration to set
+     * @throws IllegalArgumentException if duration is null
+     * @throws UnsupportedOperationException if an unsupported field's value is
+     * non-zero
+     */
+    public void setDuration(ReadableDuration duration) {
+        super.setDuration(duration);
+    }
+
+    /**
+     * Sets all the fields in one go.
+     * 
+     * @param years amount of years in this duration, which must be zero if
+     * unsupported.
+     * @param months amount of months in this duration, which must be zero if
+     * unsupported.
+     * @param weeks amount of weeks in this duration, which must be zero if
+     * unsupported.
+     * @param days amount of days in this duration, which must be zero if
+     * unsupported.
+     * @param hours amount of hours in this duration, which must be zero if
+     * unsupported.
+     * @param minutes amount of minutes in this duration, which must be zero if
+     * unsupported.
+     * @param seconds amount of seconds in this duration, which must be zero if
+     * unsupported.
+     * @param millis amount of milliseconds in this duration, which must be
+     * zero if unsupported.
+     * @throws UnsupportedOperationException if an unsupported field's value is
+     * non-zero
+     */
+    public void setDuration(int years, int months, int weeks, int days,
+                            int hours, int minutes, int seconds, int millis) {
+        super.setDuration(years, months, weeks, days,
+                          hours, minutes, seconds, millis);
+    }
+
+    /**
+     * Sets all the fields in one go from a millisecond interval.
+     * 
+     * @param startInstant interval start, in milliseconds
+     * @param endInstant interval end, in milliseconds
+     */
+    public void setTotalMillis(long startInstant, long endInstant) {
+        super.setTotalMillis(startInstant, endInstant);
+    }
+
+    /**
+     * Sets all the fields in one go from a millisecond duration. If any
+     * supported fields are imprecise, an UnsupportedOperationException is
+     * thrown. The exception to this is when the specified duration is zero.
+     * 
+     * @param duration  the duration, in milliseconds
+     * @throws UnsupportedOperationException if any fields are imprecise
+     */
+    public void setTotalMillis(long duration) {
+        super.setTotalMillis(duration);
+    }
+    
+    //-----------------------------------------------------------------------
+    /**
+     * Adds a millisecond duration to this one.
+     * 
+     * @param duration  the duration to add, in milliseconds
+     * @throws IllegalStateException if the duration is imprecise
+     */
+    public void add(long duration) {
+        super.add(duration);
+    }
+    
+    /**
+     * Adds a duration to this one.
+     * 
+     * @param duration  the duration to add
+     * @throws IllegalArgumentException if the duration is null
+     * @throws IllegalStateException if the duration is imprecise
+     */
+    public void add(ReadableDuration duration) {
+        super.add(duration);
+    }
+    
+    /**
+     * Normalizes all the field values in this duration.
+     *
+     * @throws IllegalStateException if this duration is imprecise
+     */
+    public void normalize() {
+        super.normalize();
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the number of years of the duration.
+     * 
+     * @param years  the number of years
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    public void setYears(int years) {
+        super.setYears(years);
+    }
+
+    /**
+     * Adds the specified years to the number of years in the duration.
+     * 
+     * @param years  the number of years
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    public void addYears(int years) {
+        super.addYears(years);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the number of months of the duration.
+     * 
+     * @param months  the number of months
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    public void setMonths(int months) {
+        super.setMonths(months);
+    }
+
+    /**
+     * Adds the specified months to the number of months in the duration.
+     * 
+     * @param months  the number of months
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    public void addMonths(int months) {
+        super.addMonths(months);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the number of weeks of the duration.
+     * 
+     * @param weeks  the number of weeks
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    public void setWeeks(int weeks) {
+        super.setWeeks(weeks);
+    }
+
+    /**
+     * Adds the specified weeks to the number of weeks in the duration.
+     * 
+     * @param weeks  the number of weeks
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    public void addWeeks(int weeks) {
+        super.addWeeks(weeks);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the number of days of the duration.
+     * 
+     * @param days  the number of days
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    public void setDays(int days) {
+        super.setDays(days);
+    }
+
+    /**
+     * Adds the specified days to the number of days in the duration.
+     * 
+     * @param days  the number of days
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    public void addDays(int days) {
+        super.addDays(days);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the number of hours of the duration.
+     * 
+     * @param hours  the number of hours
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    public void setHours(int hours) {
+        super.setHours(hours);
+    }
+
+    /**
+     * Adds the specified hours to the number of hours in the duration.
+     * 
+     * @param hours  the number of hours
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    public void addHours(int hours) {
+        super.addHours(hours);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the number of minutes of the duration.
+     * 
+     * @param minutes  the number of minutes
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    public void setMinutes(int minutes) {
+        super.setMinutes(minutes);
+    }
+
+    /**
+     * Adds the specified minutes to the number of minutes in the duration.
+     * 
+     * @param minutes  the number of minutes
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    public void addMinutes(int minutes) {
+        super.addMinutes(minutes);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the number of seconds of the duration.
+     * 
+     * @param seconds  the number of seconds
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    public void setSeconds(int seconds) {
+        super.setSeconds(seconds);
+    }
+
+    /**
+     * Adds the specified seconds to the number of seconds in the duration.
+     * 
+     * @param seconds  the number of seconds
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    public void addSeconds(int seconds) {
+        super.addSeconds(seconds);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the number of millis of the duration.
+     * 
+     * @param millis  the number of millis
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    public void setMillis(int millis) {
+        super.setMillis(millis);
+    }
+
+    /**
+     * Adds the specified millis to the number of millis in the duration.
+     * 
+     * @param millis  the number of millis
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    public void addMillis(int millis) {
+        super.addMillis(millis);
+    }
+
+    // Misc
+    //-----------------------------------------------------------------------
+    /**
+     * Clone this object without having to cast the returned object.
+     *
+     * @return a clone of the this object.
+     */
+    public MutableDuration copy() {
+        return (MutableDuration)clone();
+    }
+
+    /**
+     * Clone this object.
+     *
+     * @return a clone of this object.
+     */
+    public Object clone() {
+        try {
+            return super.clone();
+        } catch (CloneNotSupportedException ex) {
+            throw new InternalError("Clone error");
+        }
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/PartialInstant.java b/JodaTime/src/java/org/joda/time/PartialInstant.java
new file mode 100644
index 000000000..c71da5d9b
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/PartialInstant.java
@@ -0,0 +1,190 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+/**
+ * Defines an instant that does not support every datetime field.
+ * A PartialInstant supports a range of fields, specified by lower and
+ * upper bounding fields.
+ *
+ * @author Brian S O'Neill
+ */
+public interface PartialInstant extends ReadableInstant {
+
+    /**
+     * Get the value as the number of milliseconds since the epoch,
+     * 1970-01-01T00:00:00Z, with unsupported field values reset.
+     *
+     * @return the value as milliseconds
+     */
+    long getMillis();
+
+    /**
+     * Get the value as the number of milliseconds since the epoch,
+     * 1970-01-01T00:00:00Z, with unsupported field values and time zone filled
+     * in by the given base instant.
+     *
+     * @param base  source of missing fields
+     * @return the value as milliseconds
+     */
+    long getMillis(ReadableInstant base);
+
+    /**
+     * Get the value as the number of milliseconds since the epoch,
+     * 1970-01-01T00:00:00Z, with unsupported field values filled in by the
+     * given base instant.
+     *
+     * @param base  source of missing fields
+     * @param zone  override the base time zone, null implies override with no
+     * time zone
+     * @return the value as milliseconds
+     */
+    long getMillis(ReadableInstant base, DateTimeZone zone);
+
+    /**
+     * Gets the chronology of the instant, null if not applicable. The time
+     * zone of the chronology is either null or UTC.
+     * <p>
+     * The {@link Chronology} provides conversion from the millisecond
+     * value to meaningful fields in a particular calendar system.
+     * 
+     * @return the Chronology
+     */
+    Chronology getChronology();
+
+    /**
+     * Returns the lower limiting field, where the lower limit field itself is
+     * supported. In other words, for the range described by the lower and
+     * upper limits, the lower limit is inclusive.
+     *
+     * @return lower limit or null if none
+     */
+    DateTimeField getLowerLimit();
+
+    /**
+     * Returns the upper limiting field, where the upper limit field itself is
+     * not supported. In other words, for the range described by the lower and
+     * upper limits, the upper limit is exclusive.
+     *
+     * @return upper limit or null if none
+     */
+    DateTimeField getUpperLimit();
+
+    /**
+     * Returns true if the given instant is a PartialDateTime that supports the
+     * same exact set of fields. Implementations may simply do the following:
+     * <pre>
+     *     return instant instanceof &lt;this class&gt;;
+     * </pre>
+     *
+     * @param instant  the instant to compare to
+     * @return true if instant is same type as this
+     */
+    boolean isMatchingType(ReadableInstant instant);
+
+    /**
+     * Returns the given instant, except with lower and upper limits
+     * applied. Field values are reset below the lower limit and at or above
+     * the upper limit.
+     *
+     * @param instant milliseconds from 1970-01-01T00:00:00
+     * @return the adjusted millisecond instant
+     */
+    long resetUnsupportedFields(long instant);
+
+    /**
+     * Returns the given instant, except with lower and upper limits
+     * applied. Field values are reset below the upper limit and at or above
+     * the lower limit.
+     *
+     * @param instant milliseconds from 1970-01-01T00:00:00
+     * @return the adjusted millisecond instant
+     */
+    long resetSupportedFields(long instant);
+
+    /**
+     * Compares this object with the specified object for equality based
+     * on the millisecond instant, the Chronology, and the limiting fields.
+     * <p>
+     * To compare two instants for absolute time (ie. UTC milliseconds ignoring
+     * the chronology), use {@link #isEqual(ReadableInstant)} or
+     * {@link #compareTo(Object)}.
+     *
+     * @param readableInstant  a readable instant to check against
+     * @return true if millisecond and chronology are equal, false if
+     *  not or the instant is null or of an incorrect type
+     */
+    boolean equals(Object readableInstant);
+
+    /**
+     * Gets a hash code for the instant that is compatable with the 
+     * equals method.
+     *
+     * @return a suitable hash code
+     */
+    int hashCode();
+
+    //-----------------------------------------------------------------------
+    /**
+     * Get the value as a String in a recognisable ISO8601 format, only
+     * displaying supported fields.
+     * <p>
+     * The string output is in ISO8601 format to enable the String
+     * constructor to correctly parse it.
+     *
+     * @return the value as an ISO8601 string
+     */
+    String toString();
+
+}
diff --git a/JodaTime/src/java/org/joda/time/ReadWritableDateTime.java b/JodaTime/src/java/org/joda/time/ReadWritableDateTime.java
new file mode 100644
index 000000000..620617425
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/ReadWritableDateTime.java
@@ -0,0 +1,373 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+// Import for @link support
+import org.joda.time.convert.ConverterManager;
+
+/**
+ * Defines an instant in time that can be queried and modified using datetime fields.
+ * <p>
+ * The implementation of this interface will be mutable.
+ * It may provide more advanced methods than those in the interface.
+ * <p>
+ * Methods in your application should be defined using <code>ReadWritableDateTime</code>
+ * as a parameter if the method wants to manipulate and change a date in simple ways.
+ *
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ */
+public interface ReadWritableDateTime extends ReadableDateTime, ReadWritableInstant {
+    
+    //-----------------------------------------------------------------------
+    /**
+     * Set the year to the specified value.
+     *
+     * @param year  the year
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void setYear(int year);
+
+    /**
+     * Add a number of years to the date.
+     *
+     * @param years  the years to add
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void addYears(int years);
+
+    //-----------------------------------------------------------------------
+    /**
+     * Set the week of the year to the specified value.
+     *
+     * @param weekyear  the weekyear
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void setWeekyear(int weekyear);
+
+    /**
+     * Add a number of weekyears to the date.
+     *
+     * @param weekyears  the weekyears to add
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void addWeekyears(int weekyears);
+
+    //-----------------------------------------------------------------------
+    /**
+     * Set the month of the year to the specified value.
+     *
+     * @param monthOfYear  the month of the year
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void setMonthOfYear(int monthOfYear);
+
+    /**
+     * Add a number of months to the date.
+     *
+     * @param months  the months to add
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void addMonths(int months);
+
+    //-----------------------------------------------------------------------
+    /**
+     * Set the week of weekyear to the specified value.
+     *
+     * @param weekOfWeekyear the week of the weekyear
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void setWeekOfWeekyear(int weekOfWeekyear);
+
+    /**
+     * Add a number of weeks to the date.
+     *
+     * @param weeks  the weeks to add
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void addWeeks(int weeks);
+
+    //-----------------------------------------------------------------------
+    /**
+     * Set the day of year to the specified value.
+     *
+     * @param dayOfYear the day of the year
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void setDayOfYear(int dayOfYear);
+
+    /**
+     * Set the day of the month to the specified value.
+     *
+     * @param dayOfMonth  the day of the month
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void setDayOfMonth(int dayOfMonth);
+
+    /**
+     * Set the day of week to the specified value.
+     *
+     * @param dayOfWeek  the day of the week
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void setDayOfWeek(int dayOfWeek);
+
+    /**
+     * Add a number of days to the date.
+     *
+     * @param days  the days to add
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void addDays(int days);
+
+    //-----------------------------------------------------------------------
+    /**
+     * Set the hour of the day to the specified value.
+     *
+     * @param hourOfDay  the hour of day
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void setHourOfDay(int hourOfDay);
+
+    /**
+     * Add a number of hours to the date.
+     *
+     * @param hours  the hours to add
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void addHours(int hours);
+    
+    //-----------------------------------------------------------------------
+    /**
+     * Set the minute of the day to the specified value.
+     *
+     * @param minuteOfDay  the minute of day
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void setMinuteOfDay(int minuteOfDay);
+
+    /**
+     * Set the minute of the hour to the specified value.
+     *
+     * @param minuteOfHour  the minute of hour
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void setMinuteOfHour(int minuteOfHour);
+
+    /**
+     * Add a number of minutes to the date.
+     *
+     * @param minutes  the minutes to add
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void addMinutes(int minutes);
+
+    //-----------------------------------------------------------------------
+    /**
+     * Set the second of the day to the specified value.
+     *
+     * @param secondOfDay  the second of day
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void setSecondOfDay(int secondOfDay);
+
+    /**
+     * Set the second of the minute to the specified value.
+     *
+     * @param secondOfMinute  the second of minute
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void setSecondOfMinute(int secondOfMinute);
+
+    /**
+     * Add a number of seconds to the date.
+     *
+     * @param seconds  the seconds to add
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void addSeconds(int seconds);
+
+    //-----------------------------------------------------------------------
+    /**
+     * Set the millis of the day to the specified value.
+     *
+     * @param millisOfDay  the millis of day
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void setMillisOfDay(int millisOfDay);
+
+    /**
+     * Set the millis of the second to the specified value.
+     *
+     * @param millisOfSecond  the millis of second
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void setMillisOfSecond(int millisOfSecond);
+
+    /**
+     * Add a number of milliseconds to the date. The implementation of this
+     * method differs from the {@link #add(long)} method in that a
+     * DateTimeField performs the addition.
+     *
+     * @param millis  the milliseconds to add
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void addMillis(int millis);
+
+    //-----------------------------------------------------------------------
+    /**
+     * Set the date from milliseconds.
+     * The time part of this object will be unaffected.
+     *
+     * @param instant  milliseconds from 1970-01-01T00:00:00Z, time part ignored
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void setDate(long instant);
+
+    /**
+     * Set the date from an object representing an instant.
+     * The time part of this object will be unaffected.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     *
+     * @param instant  an object representing an instant, time part ignored
+     * @throws IllegalArgumentException if the object is null or invalid
+     */
+    void setDate(Object instant);
+
+    /**
+     * Set the date from fields.
+     * The time part of this object will be unaffected.
+     *
+     * @param year  the year
+     * @param monthOfYear  the month of the year
+     * @param dayOfMonth  the day of the month
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void setDate(int year, int monthOfYear, int dayOfMonth);
+
+    //-----------------------------------------------------------------------
+    /**
+     * Set the time from milliseconds.
+     * The date part of this object will be unaffected.
+     *
+     * @param millis milliseconds from T00:00:00Z, date part ignored
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void setTime(long millis);
+
+    /**
+     * Set the date from an object representing an instant.
+     * The date part of this object will be unaffected.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     *
+     * @param instant  an object representing an instant, date part ignored
+     * @throws IllegalArgumentException if the object is null or invalid
+     */
+    void setTime(Object instant);
+
+    /**
+     * Set the time from fields.
+     * The date part of this object will be unaffected.
+     *
+     * @param hour  the hour
+     * @param minuteOfHour  the minute of the hour
+     * @param secondOfMinute  the second of the minute
+     * @param millisOfSecond  the milisecond of the second
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void setTime(int hour, int minuteOfHour, int secondOfMinute, int millisOfSecond);
+
+    //-----------------------------------------------------------------------
+    /**
+     * Set the date and time from milliseconds.
+     * This method is a synonm for {@link #setMillis(long)}.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void setDateTime(long instant);
+
+    /**
+     * Set the date and time from an object representing an instant.
+     * This method is a synonm for {@link #setMillis(Object)}.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     *
+     * @param instant  an object representing an instant
+     * @throws IllegalArgumentException if the object is null or invalid
+     */
+    void setDateTime(Object instant);
+
+    /**
+     * Set the date and time from fields.
+     *
+     * @param year  the year
+     * @param monthOfYear  the month of the year
+     * @param dayOfMonth  the day of the month
+     * @param hourOfDay  the hour of the day
+     * @param minuteOfHour  the minute of the hour
+     * @param secondOfMinute  the second of the minute
+     * @param millisOfSecond  the milisecond of the second
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void setDateTime(
+        int year, int monthOfYear, int dayOfMonth,
+        int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond);
+
+}
diff --git a/JodaTime/src/java/org/joda/time/ReadWritableDuration.java b/JodaTime/src/java/org/joda/time/ReadWritableDuration.java
new file mode 100644
index 000000000..1ce3dac8f
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/ReadWritableDuration.java
@@ -0,0 +1,280 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+/**
+ * Defines a duration of time that can be queried and modified using datetime fields.
+ * <p>
+ * The implementation of this interface will be mutable.
+ * It may provide more advanced methods than those in the interface.
+ *
+ * @author Brian S O'Neill
+ * @author Stephen Colebourne
+ * @since 1.0
+ */
+public interface ReadWritableDuration extends ReadableDuration {
+
+    /**
+     * Sets all the fields in one go from another ReadableDuration.
+     * 
+     * @param duration  the duration to set
+     * @throws IllegalArgumentException if duration is null
+     * @throws UnsupportedOperationException if an unsupported field's value is
+     * non-zero
+     */
+    void setDuration(ReadableDuration duration);
+
+    /**
+     * Sets all the fields in one go.
+     * 
+     * @param years amount of years in this duration, which must be zero if
+     * unsupported.
+     * @param months amount of months in this duration, which must be zero if
+     * unsupported.
+     * @param weeks amount of weeks in this duration, which must be zero if
+     * unsupported.
+     * @param days amount of days in this duration, which must be zero if
+     * unsupported.
+     * @param hours amount of hours in this duration, which must be zero if
+     * unsupported.
+     * @param minutes amount of minutes in this duration, which must be zero if
+     * unsupported.
+     * @param seconds amount of seconds in this duration, which must be zero if
+     * unsupported.
+     * @param millis amount of milliseconds in this duration, which must be
+     * zero if unsupported.
+     * @throws UnsupportedOperationException if an unsupported field's value is
+     * non-zero
+     */
+    void setDuration(int years, int months, int weeks, int days,
+                     int hours, int minutes, int seconds, int millis);
+
+    /**
+     * Sets all the fields in one go from a millisecond interval.
+     * 
+     * @param startInstant interval start, in milliseconds
+     * @param endInstant interval end, in milliseconds
+     */
+    void setTotalMillis(long startInstant, long endInstant);
+
+    /**
+     * Sets all the fields in one go from a millisecond duration.
+     * 
+     * @param duration  the duration, in milliseconds
+     * @throws UnsupportedOperationException if any fields are imprecise
+     */
+    void setTotalMillis(long duration);
+    
+    //-----------------------------------------------------------------------
+    /**
+     * Adds a millisecond duration to this one.
+     * 
+     * @param duration  the duration to add, in milliseconds
+     * @throws IllegalStateException if the duration is imprecise
+     */
+    void add(long duration);
+    
+    /**
+     * Adds a duration to this one.
+     * 
+     * @param duration  the duration to add
+     * @throws IllegalArgumentException if the duration is null
+     * @throws IllegalStateException if the duration is imprecise
+     */
+    void add(ReadableDuration duration);
+    
+    /**
+     * Normalizes all the field values in this duration.
+     *
+     * @throws IllegalStateException if this duration is imprecise
+     */
+    void normalize();
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the number of years of the duration.
+     * 
+     * @param years  the number of years
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    void setYears(int years);
+
+    /**
+     * Adds the specified years to the number of years in the duration.
+     * 
+     * @param years  the number of years
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    void addYears(int years);
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the number of months of the duration.
+     * 
+     * @param months  the number of months
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    void setMonths(int months);
+
+    /**
+     * Adds the specified months to the number of months in the duration.
+     * 
+     * @param months  the number of months
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    void addMonths(int months);
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the number of weeks of the duration.
+     * 
+     * @param weeks  the number of weeks
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    void setWeeks(int weeks);
+
+    /**
+     * Adds the specified weeks to the number of weeks in the duration.
+     * 
+     * @param weeks  the number of weeks
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    void addWeeks(int weeks);
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the number of days of the duration.
+     * 
+     * @param days  the number of days
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    void setDays(int days);
+
+    /**
+     * Adds the specified days to the number of days in the duration.
+     * 
+     * @param days  the number of days
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    void addDays(int days);
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the number of hours of the duration.
+     * 
+     * @param hours  the number of hours
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    void setHours(int hours);
+
+    /**
+     * Adds the specified hours to the number of hours in the duration.
+     * 
+     * @param hours  the number of hours
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    void addHours(int hours);
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the number of minutes of the duration.
+     * 
+     * @param minutes  the number of minutes
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    void setMinutes(int minutes);
+
+    /**
+     * Adds the specified minutes to the number of minutes in the duration.
+     * 
+     * @param minutes  the number of minutes
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    void addMinutes(int minutes);
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the number of seconds of the duration.
+     * 
+     * @param seconds  the number of seconds
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    void setSeconds(int seconds);
+
+    /**
+     * Adds the specified seconds to the number of seconds in the duration.
+     * 
+     * @param seconds  the number of seconds
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    void addSeconds(int seconds);
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the number of millis of the duration.
+     * 
+     * @param millis  the number of millis
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    void setMillis(int millis);
+
+    /**
+     * Adds the specified millis to the number of millis in the duration.
+     * 
+     * @param millis  the number of millis
+     * @throws UnsupportedOperationException if field is not supported.
+     */
+    void addMillis(int millis);
+
+}
diff --git a/JodaTime/src/java/org/joda/time/ReadWritableInstant.java b/JodaTime/src/java/org/joda/time/ReadWritableInstant.java
index 34cb39a20..355678489 100644
--- a/JodaTime/src/java/org/joda/time/ReadWritableInstant.java
+++ b/JodaTime/src/java/org/joda/time/ReadWritableInstant.java
@@ -53,11 +53,15 @@
  */
 package org.joda.time;
 
+// Import for @link support
+import org.joda.time.convert.ConverterManager;
+
 /**
- * Writable interface for an instant in the datetime continuum. 
+ * Defines an instant in the datetime continuum that can be queried and modified.
+ * This interface expresses the datetime as milliseconds from 1970-01-01T00:00:00Z.
  * <p>
- * This interface expresses the datetime as milliseconds from 
- * 1970-01-01T00:00:00Z.
+ * The implementation of this interface will be mutable.
+ * It may provide more advanced methods than those in the interface.
  *
  * @author Stephen Colebourne
  * @since 1.0
@@ -67,28 +71,78 @@
     /**
      * Set the value as the number of miliseconds since
      * the epoch, 1970-01-01T00:00:00Z.
+     * 
+     * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the
+     * instant to
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void setMillis(long instant);
+
+    /**
+     * Set the value from an Object representing an instant.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     * 
+     * @param instant  an object representing an instant
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void setMillis(Object instant);
+
+    /**
+     * Set the chronology of the datetime, which has no effect if not
+     * applicable.
+     * 
+     * @param chronology  the chronology to use, null means ISOChronology in default zone
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void setChronology(Chronology chronology);
+
+    /**
+     * Sets the time zone of the datetime via the chronology, which has no
+     * effect if not applicable. Setting the time zone does not affect the
+     * millisecond value of this instant.
      *
-     * @return the value as milliseconds
+     * @param zone  the time zone to use, null means default zone
+     * @throws IllegalArgumentException if the value is invalid
+     * @see #moveDateTimeZone
      */
-    void setMillis(long millis);
+    void setDateTimeZone(DateTimeZone zone);
 
     /**
-     * Set the value from Date, Calendar, DateTime etc.
+     * Moves the time zone of the datetime via the chronology, which has no
+     * effect if not applicable. Moving the time zone alters the millisecond
+     * value of this instant such that it is relative to the new time zone.
      *
-     * @return the value as a Calendar
+     * @param zone  the time zone to use, null means default zone
+     * @throws IllegalArgumentException if the value is invalid
+     * @see #setDateTimeZone
      */
-    void setMillis(Object obj);
+    void moveDateTimeZone(DateTimeZone zone);
 
     //-----------------------------------------------------------------------
+    /**
+     * Add a number of millis to the value.
+     * <p>
+     * If the resulting value is too large for millis, seconds
+     * will change and so on unless it is too large for the
+     * implementation, when an exception is thrown.
+     *
+     * @param duration  the millis to add
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    void add(long duration);
+
     /**
      * Add an amount of time.
      * <p>
      * If the resulting value is too large for the implementation,
      * an exception is thrown.
      *
-     * @param duration duration to add.
+     * @param duration  duration to add.
+     * @throws IllegalArgumentException if the value is invalid
      */
-    //void add(ReadableDuration duration);
+    void add(ReadableDuration duration);
 
     /**
      * Add an amount of time.
@@ -96,32 +150,25 @@
      * If the resulting value is too large for the implementation,
      * an exception is thrown.
      *
-     * @param duration duration to add.
+     * @param duration  duration to add.
      * @param scalar direction and amount to add, which may be negative
+     * @throws IllegalArgumentException if the value is invalid
      */
-    //void add(ReadableDuration duration, int scalar);
+    void add(ReadableDuration duration, int scalar);
 
     /**
      * Add an amount of time, either a ReadableDuration or Long (millis).
      * <p>
      * If the resulting value is too large for the implementation,
      * an exception is thrown.
-     *
-     * @param object  an object evaluating to an a period of time to
-     *  add.
-     */
-    void add(Object object);
-
-    /**
-     * Add a number of millis to the value.
      * <p>
-     * If the resulting value is too large for millis, seconds
-     * will change and so on unless it is too large for the
-     * implementation, when an exception is thrown.
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableDuration, String and Long.
      *
-     * @param millis  the millis to add
+     * @param duration  an object representing a duration
+     * @throws IllegalArgumentException if the value is invalid
      */
-    void addMillis(long millis);
+    void add(Object duration);
 
     //-----------------------------------------------------------------------
     /**
@@ -133,6 +180,7 @@
      *
      * @param field  a DateTimeField instance, usually obtained from a Chronology
      * @param value  the value of that field for the millis set in the implementation
+     * @throws IllegalArgumentException if the value is invalid
      */
     void set(DateTimeField field, int value);
     
@@ -145,6 +193,7 @@
      *
      * @param field  a DateTimeField instance, usually obtained from a Chronology
      * @param value  the value of that field for the millis set in the implementation
+     * @throws IllegalArgumentException if the value is invalid
      */
     void add(DateTimeField field, int value);
     
@@ -160,6 +209,7 @@
      *
      * @param field  a DateTimeField instance, usually obtained from a Chronology
      * @param value  the value of that field for the millis set in the implementation
+     * @throws IllegalArgumentException if the value is invalid
      */
     void addWrapped(DateTimeField field, int value);
     
diff --git a/JodaTime/src/java/org/joda/time/ReadableDateTime.java b/JodaTime/src/java/org/joda/time/ReadableDateTime.java
index 9f89c521a..be344693f 100644
--- a/JodaTime/src/java/org/joda/time/ReadableDateTime.java
+++ b/JodaTime/src/java/org/joda/time/ReadableDateTime.java
@@ -56,7 +56,14 @@
 import java.util.Locale;
 
 /**
- * Extends the ReadableInstant interface to support specific datetime fields.
+ * Defines an instant in time that can be queried using datetime fields.
+ * <p>
+ * The implementation of this interface may be mutable or immutable.
+ * This interface only gives access to retrieve data, never to change it.
+ * <p>
+ * Methods in your application should be defined using <code>ReadableDateTime</code>
+ * as a parameter if the method only wants to read the datetime, and not perform
+ * any advanced manipulations.
  *
  * @author Stephen Colebourne
  * @author Brian S O'Neill
@@ -197,50 +204,58 @@
 
     /**
      * Get this object as a DateTime.
+     * <p>
+     * If the implementation of the interface is a DateTime, it is returned directly.
      * 
-     * @return a DateTime using the same millis
+     * @return a DateTime using the same millis, unless partially specified
      */
     DateTime toDateTime();
 
     /**
      * Get this object as a DateTime.
+     * <p>
+     * If the implementation of the interface is a DateTime in the correct zone,
+     * it is returned directly.
      * 
-     * @param zone time zone to apply
-     * @return a DateTime using the same millis
+     * @param zone  time zone to apply
+     * @return a DateTime using the same millis, unless partially specified
      * @throws IllegalArgumentException if the time zone is null
      */
     DateTime toDateTime(DateTimeZone zone);
 
     /**
      * Get this object as a DateTime.
+     * <p>
+     * If the implementation of the interface is a DateTime in the correct chronology,
+     * it is returned directly.
      * 
-     * @param chronology chronology to apply
-     * @return a DateTime using the same millis
+     * @param chronology  chronology to apply
+     * @return a DateTime using the same millis, unless partially specified
      * @throws IllegalArgumentException if the chronology is null
      */
     DateTime toDateTime(Chronology chronology);
 
     /**
-     * Get this object as a MutableDateTime.
+     * Get this object as a MutableDateTime, always returning a new instance.
      * 
-     * @return a MutableDateTime using the same millis
+     * @return a MutableDateTime using the same millis, unless partially specified
      */
     MutableDateTime toMutableDateTime();
 
     /**
-     * Get this object as a MutableDateTime.
+     * Get this object as a MutableDateTime, always returning a new instance.
      * 
-     * @param zone time zone to apply
-     * @return a MutableDateTime using the same millis
+     * @param zone  time zone to apply
+     * @return a MutableDateTime using the same millis, unless partially specified
      * @throws IllegalArgumentException if the time zone is null
      */
     MutableDateTime toMutableDateTime(DateTimeZone zone);
 
     /**
-     * Get this object as a MutableDateTime.
+     * Get this object as a MutableDateTime, always returning a new instance.
      * 
-     * @param chronology chronology to apply
-     * @return a MutableDateTime using the same millis
+     * @param chronology  chronology to apply
+     * @return a MutableDateTime using the same millis, unless partially specified
      * @throws IllegalArgumentException if the chronology is null
      */
     MutableDateTime toMutableDateTime(Chronology chronology);
@@ -248,50 +263,51 @@
     /**
      * Get this object as a DateOnly.
      * 
-     * @return a DateOnly using the same millis
+     * @return a DateOnly using the same millis, unless partially specified
      */
-    //DateOnly toDateOnly();
+    DateOnly toDateOnly();
 
     /**
      * Get this object as a DateOnly.
      * 
      * @param chronology chronology to apply
-     * @return a DateOnly using the same millis
+     * @return a DateOnly using the same millis, unless partially specified
      * @throws IllegalArgumentException if the chronology is null
      */
-    //DateOnly toDateOnly(Chronology chronology);
+    DateOnly toDateOnly(Chronology chronology);
 
     /**
      * Get this object as a TimeOnly.
      * 
-     * @return a TimeOnly using the same millis
+     * @return a TimeOnly using the same millis, unless partially specified
      */
-    //TimeOnly toTimeOnly();
+    TimeOnly toTimeOnly();
 
     /**
      * Get this object as a TimeOnly.
      * 
      * @param chronology chronology to apply
-     * @return a TimeOnly using the same millis
+     * @return a TimeOnly using the same millis, unless partially specified
      * @throws IllegalArgumentException if the chronology is null
      */
-    //TimeOnly toTimeOnly(Chronology chronology);
+    TimeOnly toTimeOnly(Chronology chronology);
 
     /**
      * Output the instant using the specified format pattern.
      *
-     * @param pattern pattern specification
-     * @see org.joda.time.format.DateTimeFormatterBuilder#appendPattern(java.lang.String)
+     * @param pattern  pattern specification
+     * @throws IllegalArgumentException  if pattern is invalid
+     * @see  org.joda.time.format.DateTimeFormat
      */
     String toString(String pattern) throws IllegalArgumentException;
 
     /**
      * Output the instant using the specified format pattern.
      *
-     * @param pattern pattern specification
-     * @param locale Locale to use, must not be null
-     * @see org.joda.time.format.DateTimeFormatterBuilder#appendPattern(java.lang.String)
-     * @throws IllegalArgumentException if the locale is null
+     * @param pattern  pattern specification
+     * @param locale  Locale to use, or null for default
+     * @throws IllegalArgumentException  if pattern is invalid
+     * @see  org.joda.time.format.DateTimeFormat
      */
     String toString(String pattern, Locale locale) throws IllegalArgumentException;
     
diff --git a/JodaTime/src/java/org/joda/time/ReadableDuration.java b/JodaTime/src/java/org/joda/time/ReadableDuration.java
new file mode 100644
index 000000000..2effe3fe1
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/ReadableDuration.java
@@ -0,0 +1,311 @@
+/* 
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+/**
+ * Defines a duration of time that can be queried using fields.
+ * <p>
+ * Durations can be split up into multiple fields, but implementations are not
+ * required to evenly distribute the values across the fields. Nor are they
+ * required to normalize the fields nor match the signs.
+ * <p>
+ * For example, an implementation can represent a duration of "4 days, 6 hours"
+ * as "102 hours", "1 day, 78 hours", "367200000 milliseconds", or even
+ * "3 days, -8 hours, 2275 minutes, 298 seconds, 2000 milliseconds".
+ *
+ * @see ReadableInterval
+ * @author Brian S O'Neill
+ * @author Stephen Colebourne
+ * @since 1.0
+ */
+public interface ReadableDuration extends Comparable {
+
+    /**
+     * Returns the object which defines which fields this duration supports.
+     */
+    DurationType getDurationType();
+
+    /**
+     * Gets the total length of this duration in milliseconds, 
+     * failing if the duration is imprecise.
+     *
+     * @return the total length of the time duration in milliseconds.
+     * @throws IllegalStateException if the duration is imprecise
+     */
+    long getTotalMillis();
+
+    /**
+     * Is this duration a precise length of time, or descriptive.
+     * <p>
+     * A precise duration could include millis, seconds, minutes or hours.
+     * However, days, weeks, months and years can vary in length, resulting in
+     * an imprecise duration.
+     * <p>
+     * An imprecise duration can be made precise by pairing it with a
+     * date in a {@link ReadableInterval}.
+     *
+     * @return true if the duration is precise
+     */
+    boolean isPrecise();
+
+    //-----------------------------------------------------------------------
+    /**
+     * Adds this duration to the given instant, returning a new value.
+     * <p>
+     * To add just once, pass in a scalar of one. To subtract once, pass
+     * in a scaler of minus one.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the
+     * duration to
+     * @param scalar  the number of times to add the duration, negative to subtract
+     * @return milliseconds value plus this duration times scalar
+     * @throws ArithmeticException if the result of the calculation is too large
+     */
+    long addTo(long instant, int scalar);
+
+    /**
+     * Adds this duration to the given instant, returning a new value.
+     * <p>
+     * To add just once, pass in a scalar of one. To subtract once, pass
+     * in a scaler of minus one.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add the
+     * duration to
+     * @param scalar  the number of times to add the duration, negative to subtract
+     * @param chrono  override the duration's chronology, unless null is passed in
+     * @return milliseconds value plus this duration times scalar
+     * @throws ArithmeticException if the result of the calculation is too large
+     */
+    long addTo(long instant, int scalar, Chronology chrono);
+
+    /**
+     * Adds this duration to the given instant, returning a new Instant.
+     * <p>
+     * To add just once, pass in a scalar of one. To subtract once, pass
+     * in a scaler of minus one.
+     *
+     * @param instant  the instant to add the duration to
+     * @param scalar  the number of times to add the duration, negative to subtract
+     * @return instant with the original value plus this duration times scalar
+     * @throws IllegalArgumentException if the instant is null
+     * @throws ArithmeticException if the result of the calculation is too large
+     */
+    ReadableInstant addTo(ReadableInstant instant, int scalar);
+
+    /**
+     * Adds this duration into the given mutable instant.
+     * <p>
+     * To add just once, pass in a scalar of one. To subtract once, pass
+     * in a scaler of minus one.
+     *
+     * @param instant  the instant to update with the added duration
+     * @param scalar  the number of times to add the duration, negative to subtract
+     * @throws IllegalArgumentException if the instant is null
+     * @throws ArithmeticException if the result of the calculation is too large
+     */
+    void addInto(ReadWritableInstant instant, int scalar);
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the years field part of the duration.
+     * 
+     * @return the number of years in the duration, zero if unsupported
+     */
+    int getYears();
+
+    /**
+     * Gets the months field part of the duration.
+     * 
+     * @return the number of months in the duration, zero if unsupported
+     */
+    int getMonths();
+
+    /**
+     * Gets the weeks field part of the duration.
+     * 
+     * @return the number of weeks in the duration, zero if unsupported
+     */
+    int getWeeks();
+
+    /**
+     * Gets the days field part of the duration.
+     * 
+     * @return the number of days in the duration, zero if unsupported
+     */
+    int getDays();
+
+    /**
+     * Gets the hours field part of the duration.
+     * 
+     * @return the number of hours in the duration, zero if unsupported
+     */
+    int getHours();
+
+    /**
+     * Gets the minutes field part of the duration.
+     * 
+     * @return the number of minutes in the duration, zero if unsupported
+     */
+    int getMinutes();
+
+    /**
+     * Gets the seconds field part of the duration.
+     * 
+     * @return the number of seconds in the duration, zero if unsupported
+     */
+    int getSeconds();
+
+    /**
+     * Gets the millis field part of the duration.
+     * 
+     * @return the number of millis in the duration, zero if unsupported
+     */
+    int getMillis();
+
+    /**
+     * Get this object as an immutable Duration. This can be useful if you
+     * don't trust the implementation of the interface to be well-behaved, or
+     * to get a guaranteed immutable object.
+     * 
+     * @return a Duration using the same field set and values
+     */
+    Duration toDuration();
+
+    /**
+     * Get this object as a MutableDuration.
+     * 
+     * @return a MutableDuration using the same field set and values
+     */
+    MutableDuration toMutableDuration();
+
+    //-----------------------------------------------------------------------
+    /**
+     * Compares this duration with the specified duration, which can only be
+     * performed if both are precise.
+     *
+     * @param obj  a precise duration to check against
+     * @return negative value if this is less, 0 if equal, or positive value if greater
+     * @throws NullPointerException if the object is null
+     * @throws ClassCastException if the given object is not supported
+     * @throws IllegalStateException if either duration is imprecise
+     */
+    int compareTo(Object obj);
+
+    /**
+     * Is the length of this duration equal to the duration passed in.
+     * Both durations must be precise.
+     *
+     * @param duration  another duration to compare to
+     * @return true if this duration is equal to than the duration passed in
+     * @throws IllegalArgumentException if the duration is null
+     * @throws IllegalStateException if either duration is imprecise
+     */
+    boolean isEqual(ReadableDuration duration);
+
+    /**
+     * Is the length of this duration longer than the duration passed in.
+     * Both durations must be precise.
+     *
+     * @param duration  another duration to compare to
+     * @return true if this duration is equal to than the duration passed in
+     * @throws IllegalArgumentException if the duration is null
+     * @throws IllegalStateException if either duration is imprecise
+     */
+    boolean isLongerThan(ReadableDuration duration);
+
+    /**
+     * Is the length of this duration shorter than the duration passed in.
+     * Both durations must be precise.
+     *
+     * @param duration  another duration to compare to
+     * @return true if this duration is equal to than the duration passed in
+     * @throws IllegalArgumentException if the duration is null
+     * @throws IllegalStateException if either duration is imprecise
+     */
+    boolean isShorterThan(ReadableDuration duration);
+
+    //-----------------------------------------------------------------------
+    /**
+     * Compares this object with the specified object for equality based
+     * on the value of each field. All ReadableDuration instances are accepted.
+     * <p>
+     * To compare two durations for absolute duration (ie. millisecond duration
+     * ignoring the fields), use {@link #isEqual(ReadableDuration)} or
+     * {@link #compareTo(Object)}.
+     *
+     * @param readableDuration  a readable duration to check against
+     * @return true if all the field values are equal, false if
+     *  not or the duration is null or of an incorrect type
+     */
+    boolean equals(Object readableDuration);
+
+    /**
+     * Gets a hash code for the duration that is compatable with the 
+     * equals method.
+     *
+     * @return a hash code
+     */
+    int hashCode();
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the value as a String in the ISO8601 duration format.
+     * <p>
+     * For example, "P6H3M5S" represents 6 hours, 3 minutes, 5 seconds.
+     *
+     * @return the value as an ISO8601 string
+     */
+    String toString();
+
+}
diff --git a/JodaTime/src/java/org/joda/time/ReadableInstant.java b/JodaTime/src/java/org/joda/time/ReadableInstant.java
index 5103e8991..b2c610355 100644
--- a/JodaTime/src/java/org/joda/time/ReadableInstant.java
+++ b/JodaTime/src/java/org/joda/time/ReadableInstant.java
@@ -54,10 +54,15 @@
 package org.joda.time;
 
 /**
- * Readable interface for an instant in the datetime continuum. 
+ * Defines an instant in the datetime continuum.
+ * This interface expresses the datetime as milliseconds from 1970-01-01T00:00:00Z.
  * <p>
- * This interface expresses the datetime as milliseconds from 
- * 1970-01-01T00:00:00Z.
+ * The implementation of this interface may be mutable or immutable.
+ * This interface only gives access to retrieve data, never to change it.
+ * <p>
+ * Methods in your application should be defined using <code>ReadableInstant</code>
+ * as a parameter if the method only wants to read the instant without needing to know
+ * the specific datetime fields.
  *
  * @author Stephen Colebourne
  * @since 1.0
@@ -65,13 +70,45 @@
 public interface ReadableInstant extends Comparable {
 
     /**
-     * Get the value as the number of miliseconds since
+     * Get the value as the number of milliseconds since
      * the epoch, 1970-01-01T00:00:00Z.
      *
      * @return the value as milliseconds
      */
     long getMillis();
 
+    /**
+     * Get the value as the number of milliseconds since the epoch,
+     * 1970-01-01T00:00:00Z, with unsupported field values filled in by the
+     * given base instant.
+     * <p>
+     * This method is useful for ReadableInstants that only partially describe
+     * the instant. The base supplies missing information, including time
+     * zone. Instants that are complete simply return the same value as for
+     * getMillis(), ignoring the given base.
+     *
+     * @param base optional source of missing fields
+     * @return the value as milliseconds
+     */
+    long getMillis(ReadableInstant base);
+
+    /**
+     * Get the value as the number of milliseconds since the epoch,
+     * 1970-01-01T00:00:00Z, with unsupported field values filled in by the
+     * given base instant.
+     * <p>
+     * This method is useful for ReadableInstants that only partially describe
+     * the instant. The base supplies missing information, excluding time
+     * zone. Instants that are complete simply return the same value as for
+     * getMillis(), ignoring the given base.
+     *
+     * @param base source of missing fields
+     * @param zone override the base time zone, null implies override with no
+     * time zone
+     * @return the value as milliseconds
+     */
+    long getMillis(ReadableInstant base, DateTimeZone zone);
+
     /**
      * Gets the chronology of the instant, null if not applicable.
      * <p>
@@ -179,7 +216,7 @@
      * All ReadableInstant instances are accepted.
      *
      * @param readableInstant  a readable instant to check against
-     * @return -1 if this is less, 0 if equal or +1 if greater
+     * @return negative value if this is less, 0 if equal, or positive value if greater
      * @throws NullPointerException if the object is null
      * @throws ClassCastException if the object type is not supported
      */
diff --git a/JodaTime/src/java/org/joda/time/TimeOnly.java b/JodaTime/src/java/org/joda/time/TimeOnly.java
new file mode 100644
index 000000000..d2a661da4
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/TimeOnly.java
@@ -0,0 +1,413 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+import java.io.Serializable;
+
+import org.joda.time.chrono.iso.ISOChronology;
+// Import for @link support
+import org.joda.time.convert.ConverterManager;
+import org.joda.time.format.ISODateTimeFormat;
+
+/*
+ * <p>Each individual field can be queried in two ways:
+ * <ul>
+ * <li><code>getHourOfDay()</code>
+ * <li><code>hourOfDay().get()</code>
+ * </ul>
+ * The second technique also provides access to other useful methods on the
+ * field:
+ * <ul>
+ * <li>numeric value
+ * <li>text value
+ * <li>short text value
+ * <li>maximum value
+ * <li>minimum value
+ * </ul>
+ */
+
+/**
+ * TimeOnly is the basic implementation of a time only class supporting
+ * chronologies. It holds the time as milliseconds from T00:00:00. The date
+ * component and time zone is fixed at 1970-01-01TZ.
+ * <p>
+ * TimeOnly is thread-safe and immutable, provided that the Chronology is as
+ * well. All standard Chronology classes supplied are thread-safe and
+ * immutable.
+ *
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ * @since 1.0
+ * @see DateOnly
+ * @see DateTime
+ */
+public class TimeOnly extends AbstractPartialInstant implements Serializable {
+
+    static final long serialVersionUID = -8414446947366046476L;
+
+    // Constructors
+    //-----------------------------------------------------------------------
+    /**
+     * Constructs a TimeOnly to the current time in the default time zone.
+     */
+    public TimeOnly() {
+        super();
+    }
+
+    /**
+     * Constructs a TimeOnly to the current time in the given time zone.
+     *
+     * @param zone  the time zone, null means default zone
+     */
+    public TimeOnly(DateTimeZone zone) {
+        super(zone);
+    }
+
+    /**
+     * Constructs a TimeOnly to the current time in the time zone of the given
+     * chronology.
+     *
+     * @param chronology  the chronology, null means ISOChronology in default zone
+     */
+    public TimeOnly(Chronology chronology) {
+        super(chronology);
+    }
+
+    /**
+     * Constructs a TimeOnly set to the milliseconds from 1970-01-01T00:00:00Z.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
+     */
+    public TimeOnly(long instant) {
+        super(instant);
+    }
+
+    /**
+     * Constructs a TimeOnly set to the milliseconds from
+     * 1970-01-01T00:00:00Z. If the time zone of the given chronology is not
+     * null or UTC, then the instant is converted to local time.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
+     * @param chronology  the chronology, null means ISOChronology
+     */
+    public TimeOnly(long instant, Chronology chronology) {
+        super(instant, chronology);
+    }
+
+    /**
+     * Constructs an instance from an Object that represents a time.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     *
+     * @param instant  the datetime object, must not be null
+     * @throws IllegalArgumentException if the date is null
+     */
+    public TimeOnly(Object instant) {
+        super(instant);
+    }
+
+    /**
+     * Constructs an instance from an Object that represents a time, using the
+     * specified chronology.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     *
+     * @param instant  the datetime object, must not be null
+     * @param chronology  the chronology, must not be null
+     * @throws IllegalArgumentException if the date or chronology is null
+     */
+    public TimeOnly(Object instant, Chronology chronology) {
+        super(instant, chronology);
+    }
+
+    /**
+     * Constructs an instance from time field values using
+     * <code>ISOChronology</code>.
+     *
+     * @param hourOfDay  the hour of the day
+     * @param minuteOfHour  the minute of the hour
+     * @param secondOfMinute  the second of the minute
+     * @param millisOfSecond  the milisecond of the second
+     */
+    public TimeOnly(
+            final int hourOfDay,
+            final int minuteOfHour,
+            final int secondOfMinute,
+            final int millisOfSecond) {
+
+        super(ISOChronology.getInstanceUTC()
+              .getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond),
+              ISOChronology.getInstanceUTC());
+    }
+
+    /**
+     * Constructs an instance from time field values
+     * using the specified chronology.
+     * <p>
+     * If the chronology is null, <code>ISOChronology</code>
+     * is used.
+     *
+     * @param hourOfDay  the hour of the day
+     * @param minuteOfHour  the minute of the hour
+     * @param secondOfMinute  the second of the minute
+     * @param millisOfSecond  the milisecond of the second
+     * @param chronology  the chronology, null means ISOChronology
+     */
+    public TimeOnly(
+            final int hourOfDay,
+            final int minuteOfHour,
+            final int secondOfMinute,
+            final int millisOfSecond,
+            Chronology chronology) {
+
+        super((chronology == null ? (chronology = ISOChronology.getInstanceUTC()) : chronology)
+              .getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond),
+              chronology);
+    }
+
+    /**
+     * Returns the lower limiting field, null.
+     *
+     * @return null.
+     */
+    public final DateTimeField getLowerLimit() {
+        return null;
+    }
+
+    /**
+     * Returns the upper limiting field, dayOfYear.
+     *
+     * @return dayOfYear field
+     */
+    public final DateTimeField getUpperLimit() {
+        return getChronology().dayOfYear();
+    }
+
+    public final boolean isMatchingType(ReadableInstant instant) {
+        return instant instanceof TimeOnly;
+    }
+
+    // Time field access
+    //-----------------------------------------------------------------------
+    /**
+     * Get the hour of day field value.
+     *
+     * @return the hour of day
+     */
+    public final int getHourOfDay() {
+        return getChronology().hourOfDay().get(getMillis());
+    }
+
+    /**
+     * Get the minute of day field value.
+     *
+     * @return the minute of day
+     */
+    public final int getMinuteOfDay() {
+        return getChronology().minuteOfDay().get(getMillis());
+    }
+
+    /**
+     * Get the minute of hour field value.
+     *
+     * @return the minute of hour
+     */
+    public final int getMinuteOfHour() {
+        return getChronology().minuteOfHour().get(getMillis());
+    }
+
+    /**
+     * Get the second of day field value.
+     *
+     * @return the second of day
+     */
+    public final int getSecondOfDay() {
+        return getChronology().secondOfDay().get(getMillis());
+    }
+
+    /**
+     * Get the second of minute field value.
+     *
+     * @return the second of minute
+     */
+    public final int getSecondOfMinute() {
+        return getChronology().secondOfMinute().get(getMillis());
+    }
+
+    /**
+     * Get the millis of day field value.
+     *
+     * @return the millis of day
+     */
+    public final int getMillisOfDay() {
+        return getChronology().millisOfDay().get(getMillis());
+    }
+
+    /**
+     * Get the millis of second field value.
+     *
+     * @return the millis of second
+     */
+    public final int getMillisOfSecond() {
+        return getChronology().millisOfSecond().get(getMillis());
+    }
+
+    // TODO: DateTimeFieldProperty cannot be constructed with anything but
+    // DateTime.
+
+    // Properties
+    //-----------------------------------------------------------------------
+    /**
+     * Get the hour of day field property
+     * 
+     * @return the hour of day property
+     * /
+    public final DateTimeFieldProperty hourOfDay() {
+        return new DateTimeFieldProperty(this, getChronology().hourOfDay());
+    }
+
+    /**
+     * Get the minute of day property
+     * 
+     * @return the minute of day property
+     * /
+    public final DateTimeFieldProperty minuteOfDay() {
+        return new DateTimeFieldProperty(this, getChronology().minuteOfDay());
+    }
+
+    /**
+     * Get the minute of hour field property
+     * 
+     * @return the minute of hour property
+     * /
+    public final DateTimeFieldProperty minuteOfHour() {
+        return new DateTimeFieldProperty(this, getChronology().minuteOfHour());
+    }
+
+    /**
+     * Get the second of day property
+     * 
+     * @return the second of day property
+     * /
+    public final DateTimeFieldProperty secondOfDay() {
+        return new DateTimeFieldProperty(this, getChronology().secondOfDay());
+    }
+
+    /**
+     * Get the second of minute field property
+     * 
+     * @return the second of minute property
+     * /
+    public final DateTimeFieldProperty secondOfMinute() {
+        return new DateTimeFieldProperty(this, getChronology().secondOfMinute());
+    }
+
+    /**
+     * Get the millis of day property
+     * 
+     * @return the millis of day property
+     * /
+    public final DateTimeFieldProperty millisOfDay() {
+        return new DateTimeFieldProperty(this, getChronology().millisOfDay());
+    }
+
+    /**
+     * Get the millis of second property
+     * 
+     * @return the millis of second property
+     * /
+    public final DateTimeFieldProperty millisOfSecond() {
+        return new DateTimeFieldProperty(this, getChronology().millisOfSecond());
+    }
+    */
+
+    // Output
+    //-----------------------------------------------------------------------
+    /**
+     * Output the time in ISO8601 date only format (hh:mm:ss.SSS).
+     * 
+     * @return ISO8601 date formatted string
+     */
+    public final String toString() {
+        return ISODateTimeFormat.getInstance(getChronology())
+            .hourMinuteSecondFraction().print(getMillis());
+    }
+
+    protected ReadableInstant create(long millis, Chronology chronology) {
+        if (chronology == null) {
+            throw new IllegalArgumentException("The Chronology must not be null");
+        }
+        if (millis == getMillis() && chronology == getChronology()) {
+            return this;
+        }
+        return new TimeOnly(millis, chronology);
+    }
+    
+    /**
+     * Overridden to do nothing, ensuring this class and all subclasses are
+     * immutable.
+     */
+    protected final void setMillis(long millis) {
+    }
+
+    /**
+     * Overridden to do nothing, ensuring this class and all subclasses are
+     * immutable.
+     */
+    protected final void setChronology(Chronology chronology) {
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/AbstractDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/AbstractDateTimeField.java
new file mode 100644
index 000000000..87bc5527e
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/AbstractDateTimeField.java
@@ -0,0 +1,621 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import java.io.Serializable;
+import java.util.Locale;
+import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+
+/**
+ * AbstractDateTimeField provides the common behaviour for DateTimeField
+ * implementations. 
+ * <p>
+ * This class should generally not be used directly by API users. The
+ * DateTimeField interface should be used when different kinds of DateTimeField
+ * objects are to be referenced.
+ * <p>
+ * AbstractDateTimeField is thread-safe and immutable, and its subclasses must
+ * be as well.
+ *
+ * @author Brian S O'Neill
+ * @since 1.0
+ * @see DecoratedDateTimeField
+ */
+public abstract class AbstractDateTimeField implements DateTimeField, Serializable {
+
+    static final long serialVersionUID = -4388055220581798589L;
+
+    /** A desriptive name for the field */
+    private final String iName;
+
+    /**
+     * Constructor.
+     */
+    protected AbstractDateTimeField(String name) {
+        super();
+        if (name == null) {
+            throw new IllegalArgumentException("The name must not be null");
+        }
+        iName = name;
+    }
+    
+    public final String getName() {
+        return iName;
+    }
+
+    /**
+     * @return true always
+     */
+    public final boolean isSupported() {
+        return true;
+    }
+
+    // Main access API
+    //------------------------------------------------------------------------
+    /**
+     * Get the value of this field from the milliseconds.
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
+     * @return the value of the field, in the units of the field
+     */
+    public abstract int get(long instant);
+
+    /**
+     * Get the human-readable, text value of this field from the milliseconds.
+     * If the specified locale is null, the default locale is used.
+     * <p>
+     * The default implementation returns Integer.toString(get(instant)).
+     * <p>
+     * Note: subclasses that override this method should also override
+     * getMaximumTextLength.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
+     * @param locale the locale to use for selecting a text symbol, null for
+     * default
+     * @return the text value of the field
+     */
+    public String getAsText(long instant, Locale locale) {
+        return Integer.toString(get(instant));
+    }
+
+    /**
+     * Get the human-readable, text value of this field from the milliseconds.
+     * This implementation returns getAsText(instant, null).
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
+     * @return the text value of the field
+     */
+    public final String getAsText(long instant) {
+        return getAsText(instant, null);
+    }
+
+    /**
+     * Get the human-readable, short text value of this field from the
+     * milliseconds.  If the specified locale is null, the default locale is
+     * used.
+     * <p>
+     * The default implementation returns getAsText(instant, locale).
+     * <p>
+     * Note: subclasses that override this method should also override
+     * getMaximumShortTextLength.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
+     * @param locale the locale to use for selecting a text symbol, null for
+     * default
+     * @return the short text value of the field
+     */
+    public String getAsShortText(long instant, Locale locale) {
+        return getAsText(instant, locale);
+    }
+
+    /**
+     * Get the human-readable, short text value of this field from the
+     * milliseconds.  This implementation returns getAsShortText(instant, null).
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
+     * @return the short text value of the field
+     */
+    public final String getAsShortText(long instant) {
+        return getAsShortText(instant, null);
+    }
+
+    /**
+     * Adds a value (which may be negative) to the instant value,
+     * overflowing into larger fields if necessary.
+     * <p>
+     * The value will be added to this field. If the value is too large to be
+     * added solely to this field, larger fields will increase as required.
+     * Smaller fields should be unaffected, except where the result would be
+     * an invalid value for a smaller field. In this case the smaller field is
+     * adjusted to be in range.
+     * <p>
+     * For example, in the ISO chronology:<br>
+     * 2000-08-20 add six months is 2001-02-20<br>
+     * 2000-08-20 add twenty months is 2002-04-20<br>
+     * 2000-08-20 add minus nine months is 1999-11-20<br>
+     * 2001-01-31 add one month  is 2001-02-28<br>
+     * 2001-01-31 add two months is 2001-03-31<br>
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
+     * @param value  the value to add, in the units of the field
+     * @return the updated milliseconds
+     */
+    public long add(long instant, int value) {
+        return getDurationField().add(instant, value);
+    }
+
+    /**
+     * Adds a value (which may be negative) to the instant value,
+     * overflowing into larger fields if necessary.
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
+     * @param value  the long value to add, in the units of the field
+     * @return the updated milliseconds
+     * @throws IllegalArgumentException if value is too large
+     * @see #add(long,int)
+     */
+    public long add(long instant, long value) {
+        return getDurationField().add(instant, value);
+    }
+
+    /**
+     * Adds a value (which may be negative) to the instant value,
+     * wrapping within this field.
+     * <p>
+     * The value will be added to this field. If the value is too large to be
+     * added solely to this field then it wraps. Larger fields are always
+     * unaffected. Smaller fields should be unaffected, except where the
+     * result would be an invalid value for a smaller field. In this case the
+     * smaller field is adjusted to be in range.
+     * <p>
+     * For example, in the ISO chronology:<br>
+     * 2000-08-20 addWrapped six months is 2000-02-20<br>
+     * 2000-08-20 addWrapped twenty months is 2000-04-20<br>
+     * 2000-08-20 addWrapped minus nine months is 2000-11-20<br>
+     * 2001-01-31 addWrapped one month  is 2001-02-28<br>
+     * 2001-01-31 addWrapped two months is 2001-03-31<br>
+     * <p>
+     * The default implementation internally calls set. Subclasses are
+     * encouraged to provide a more efficient implementation.
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
+     * @param value  the value to add, in the units of the field
+     * @return the updated milliseconds
+     */
+    public long addWrapped(long instant, int value) {
+        int current = get(instant);
+        int wrapped = Utils.getWrappedValue
+            (current, value, getMinimumValue(instant), getMaximumValue(instant));
+        return set(instant, wrapped);
+    }
+
+    /**
+     * Computes the difference between two instants, as measured in the units
+     * of this field. Any fractional units are dropped from the result. Calling
+     * getDifference reverses the effect of calling add. In the following code:
+     *
+     * <pre>
+     * long instant = ...
+     * int v = ...
+     * int age = getDifference(add(instant, v), instant);
+     * </pre>
+     *
+     * The value 'age' is the same as the value 'v'.
+     *
+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to
+     * subtract from
+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to
+     * subtract off the minuend
+     * @return the difference in the units of this field
+     */
+    public int getDifference(long minuendInstant, long subtrahendInstant) {
+        return getDurationField().getDifference(minuendInstant, subtrahendInstant);
+    }
+
+    /**
+     * Computes the difference between two instants, as measured in the units
+     * of this field. Any fractional units are dropped from the result. Calling
+     * getDifference reverses the effect of calling add. In the following code:
+     *
+     * <pre>
+     * long instant = ...
+     * long v = ...
+     * long age = getDifferenceAsLong(add(instant, v), instant);
+     * </pre>
+     *
+     * The value 'age' is the same as the value 'v'.
+     *
+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to
+     * subtract from
+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to
+     * subtract off the minuend
+     * @return the difference in the units of this field
+     */
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        return getDurationField().getDifferenceAsLong(minuendInstant, subtrahendInstant);
+    }
+
+    /**
+     * Sets a value in the milliseconds supplied.
+     * <p>
+     * The value of this field will be set. If the value is invalid, an
+     * exception if thrown. Other fields are always unaffected.
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in
+     * @param value  the value to set, in the units of the field
+     * @return the updated milliseconds
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public abstract long set(long instant, int value);
+
+    /**
+     * Sets a value in the milliseconds supplied from a human-readable, text
+     * value. If the specified locale is null, the default locale is used.
+     * <p>
+     * The default implementation returns set(instant,
+     * Integer.parseInt(instant)).
+     * <p>
+     * Note: subclasses that override this method should also override
+     * getAsText.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in
+     * @param text  the text value to set
+     * @param locale the locale to use for selecting a text symbol, null for
+     * default
+     * @return the updated milliseconds
+     * @throws IllegalArgumentException if the text value is invalid
+     */
+    public long set(long instant, String text, Locale locale) {
+        try {
+            return set(instant, Integer.parseInt(text));
+        } catch (NumberFormatException ex) {
+            throw new IllegalArgumentException("Invalid " + getName() + " text: " + text);
+        }
+    }
+
+    /**
+     * Sets a value in the milliseconds supplied from a human-readable, text
+     * value. This implementation returns set(instant, text, null).
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in
+     * @param text  the text value to set
+     * @return the updated milliseconds
+     * @throws IllegalArgumentException if the text value is invalid
+     */
+    public final long set(long instant, String text) {
+        return set(instant, text, null);
+    }
+
+    // Extra information API
+    //------------------------------------------------------------------------
+    /**
+     * Returns the duration per unit value of this field. For example, if this
+     * field represents "hour of day", then the unit duration is an hour.
+     *
+     * @return the duration of this field, or UnsupportedDurationField if field
+     * has no duration
+     */
+    public abstract DurationField getDurationField();
+
+    /**
+     * Returns the range duration of this field. For example, if this field
+     * represents "hour of day", then the range duration is a day.
+     *
+     * @return the range duration of this field, or null if field has no range
+     */
+    public abstract DurationField getRangeDurationField();
+
+    /**
+     * Returns whether this field is 'leap' for the specified instant.
+     * <p>
+     * For example, a leap year would return true, a non leap year would return
+     * false.
+     * <p>
+     * This implementation returns false.
+     * 
+     * @return true if the field is 'leap'
+     */
+    public boolean isLeap(long instant) {
+        return false;
+    }
+
+    /**
+     * Gets the amount by which this field is 'leap' for the specified instant.
+     * <p>
+     * For example, a leap year would return one, a non leap year would return
+     * zero.
+     * <p>
+     * This implementation returns zero.
+     */
+    public int getLeapAmount(long instant) {
+        return 0;
+    }
+
+    /**
+     * If this field were to leap, then it would be in units described by the
+     * returned duration. If this field doesn't ever leap, null is returned.
+     * <p>
+     * This implementation returns null.
+     */
+    public DurationField getLeapDurationField() {
+        return null;
+    }
+
+    /**
+     * Get the minimum allowable value for this field.
+     * 
+     * @return the minimum valid value for this field, in the units of the
+     * field
+     */
+    public abstract int getMinimumValue();
+
+    /**
+     * Get the minimum value for this field evaluated at the specified time.
+     * <p>
+     * This implementation returns the same as {@link #getMinimumValue()}.
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
+     * @return the minimum value for this field, in the units of the field
+     */
+    public int getMinimumValue(long instant) {
+        return getMinimumValue();
+    }
+
+    /**
+     * Get the maximum allowable value for this field.
+     * 
+     * @return the maximum valid value for this field, in the units of the
+     * field
+     */
+    public abstract int getMaximumValue();
+
+    /**
+     * Get the maximum value for this field evaluated at the specified time.
+     * <p>
+     * This implementation returns the same as {@link #getMaximumValue()}.
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
+     * @return the maximum value for this field, in the units of the field
+     */
+    public int getMaximumValue(long instant) {
+        return getMaximumValue();
+    }
+
+    /**
+     * Get the maximum text value for this field. The default implementation
+     * returns the equivalent of Integer.toString(getMaximumValue()).length().
+     * 
+     * @param locale  the locale to use for selecting a text symbol
+     * @return the maximum text length
+     */
+    public int getMaximumTextLength(Locale locale) {
+        int max = getMaximumValue();
+        if (max >= 0) {
+            if (max < 10) {
+                return 1;
+            } else if (max < 100) {
+                return 2;
+            } else if (max < 1000) {
+                return 3;
+            }
+        }
+        return Integer.toString(max).length();
+    }
+
+    /**
+     * Get the maximum short text value for this field. The default
+     * implementation returns getMaximumTextLength().
+     * 
+     * @param locale  the locale to use for selecting a text symbol
+     * @return the maximum short text length
+     */
+    public int getMaximumShortTextLength(Locale locale) {
+        return getMaximumTextLength(locale);
+    }
+
+    // Calculation API
+    //------------------------------------------------------------------------
+    /**
+     * Round to the lowest whole unit of this field. After rounding, the value
+     * of this field and all fields of a higher magnitude are retained. The
+     * fractional millis that cannot be expressed in whole increments of this
+     * field are set to minimum.
+     * <p>
+     * For example, a datetime of 2002-11-02T23:34:56.789, rounded to the
+     * lowest whole hour is 2002-11-02T23:00:00.000.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
+     * @return rounded milliseconds
+     */
+    public abstract long roundFloor(long instant);
+
+    /**
+     * Round to the highest whole unit of this field. The value of this field
+     * and all fields of a higher magnitude may be incremented in order to
+     * achieve this result. The fractional millis that cannot be expressed in
+     * whole increments of this field are set to minimum.
+     * <p>
+     * For example, a datetime of 2002-11-02T23:34:56.789, rounded to the
+     * highest whole hour is 2002-11-03T00:00:00.000.
+     * <p>
+     * The default implementation calls roundFloor, and if the instant is
+     * modified as a result, adds one field unit. Subclasses are encouraged to
+     * provide a more efficient implementation.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
+     * @return rounded milliseconds
+     */
+    public long roundCeiling(long instant) {
+        long newInstant = roundFloor(instant);
+        if (newInstant != instant) {
+            instant = add(newInstant, 1);
+        }
+        return instant;
+    }
+
+    /**
+     * Round to the nearest whole unit of this field. If the given millisecond
+     * value is closer to the floor or is exactly halfway, this function
+     * behaves like roundFloor. If the millisecond value is closer to the
+     * ceiling, this function behaves like roundCeiling.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
+     * @return rounded milliseconds
+     */
+    public long roundHalfFloor(long instant) {
+        long floor = roundFloor(instant);
+        long ceiling = roundCeiling(instant);
+
+        long diffFromFloor = instant - floor;
+        long diffToCeiling = ceiling - instant;
+
+        if (diffFromFloor <= diffToCeiling) {
+            // Closer to the floor, or halfway - round floor
+            return floor;
+        } else {
+            return ceiling;
+        }
+    }
+
+    /**
+     * Round to the nearest whole unit of this field. If the given millisecond
+     * value is closer to the floor, this function behaves like roundFloor. If
+     * the millisecond value is closer to the ceiling or is exactly halfway,
+     * this function behaves like roundCeiling.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
+     * @return rounded milliseconds
+     */
+    public long roundHalfCeiling(long instant) {
+        long floor = roundFloor(instant);
+        long ceiling = roundCeiling(instant);
+
+        long diffFromFloor = instant - floor;
+        long diffToCeiling = ceiling - instant;
+
+        if (diffToCeiling <= diffFromFloor) {
+            // Closer to the ceiling, or halfway - round ceiling
+            return ceiling;
+        } else {
+            return floor;
+        }
+    }
+
+    /**
+     * Round to the nearest whole unit of this field. If the given millisecond
+     * value is closer to the floor, this function behaves like roundFloor. If
+     * the millisecond value is closer to the ceiling, this function behaves
+     * like roundCeiling.
+     * <p>
+     * If the millisecond value is exactly halfway between the floor and
+     * ceiling, the ceiling is chosen over the floor only if it makes this
+     * field's value even.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
+     * @return rounded milliseconds
+     */
+    public long roundHalfEven(long instant) {
+        long floor = roundFloor(instant);
+        long ceiling = roundCeiling(instant);
+
+        long diffFromFloor = instant - floor;
+        long diffToCeiling = ceiling - instant;
+
+        if (diffFromFloor < diffToCeiling) {
+            // Closer to the floor - round floor
+            return floor;
+        } else if (diffToCeiling < diffFromFloor) {
+            // Closer to the ceiling - round ceiling
+            return ceiling;
+        } else {
+            // Round to the instant that makes this field even. If both values
+            // make this field even (unlikely), favor the ceiling.
+            if ((get(ceiling) & 1) == 0) {
+                return ceiling;
+            }
+            return floor;
+        }
+    }
+
+    /**
+     * Returns the fractional duration milliseconds of this field. In other
+     * words, calling remainder returns the duration that roundFloor would
+     * subtract.
+     * <p>
+     * For example, on a datetime of 2002-11-02T23:34:56.789, the remainder by
+     * hour is 34 minutes and 56.789 seconds.
+     * <p>
+     * The default implementation computes
+     * <code>instant - roundFloor(instant)</code>. Subclasses are encouraged to
+     * provide a more efficient implementation.
+     *
+     * @param instant the milliseconds from 1970-01-01T00:00:00Z to get the
+     * remainder
+     * @return remainder duration, in milliseconds
+     */
+    public long remainder(long instant) {
+        return instant - roundFloor(instant);
+    }
+
+    /**
+     * Get a suitable debug string.
+     * 
+     * @return debug string
+     */
+    public String toString() {
+        return "DateTimeField[" + getName() + ']';
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/AbstractDurationField.java b/JodaTime/src/java/org/joda/time/chrono/AbstractDurationField.java
new file mode 100644
index 000000000..e6b2faf84
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/AbstractDurationField.java
@@ -0,0 +1,199 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import java.io.Serializable;
+import org.joda.time.DurationField;
+
+/**
+ * AbstractDurationField provides the common behaviour for DurationField
+ * implementations.
+ * <p>
+ * This class should generally not be used directly by API users. The
+ * DurationField interface should be used when different kinds of DurationField
+ * objects are to be referenced.
+ * <p>
+ * AbstractDurationField is thread-safe and immutable, and its subclasses must
+ * be as well.
+ *
+ * @author Brian S O'Neill
+ * @see DecoratedDurationField
+ */
+public abstract class AbstractDurationField implements DurationField, Serializable {
+
+    static final long serialVersionUID = -2554245107589433218L;
+
+    /** A desriptive name for the field */
+    private final String iName;
+
+    protected AbstractDurationField(String name) {
+        super();
+        if (name == null) {
+            throw new IllegalArgumentException("The name must not be null");
+        }
+        iName = name;
+    }
+
+    public final String getName() {
+        return iName;
+    }
+
+    /**
+     * @return true always
+     */
+    public final boolean isSupported() {
+        return true;
+    }
+
+    //------------------------------------------------------------------------
+    /**
+     * Get the value of this field from the milliseconds, which is approximate
+     * if this field is imprecise.
+     *
+     * @param duration  the milliseconds to query, which may be negative
+     * @return the value of the field, in the units of the field, which may be
+     * negative
+     */
+    public int getValue(long duration) {
+        return Utils.safeToInt(getValueAsLong(duration));
+    }
+
+    /**
+     * Get the value of this field from the milliseconds, which is approximate
+     * if this field is imprecise.
+     *
+     * @param duration  the milliseconds to query, which may be negative
+     * @return the value of the field, in the units of the field, which may be
+     * negative
+     */
+    public long getValueAsLong(long duration) {
+        return duration / getUnitMillis();
+    }
+
+    /**
+     * Get the value of this field from the milliseconds relative to an
+     * instant.
+     *
+     * <p>If the milliseconds is positive, then the instant is treated as a
+     * "start instant". If negative, the instant is treated as an "end
+     * instant".
+     *
+     * <p>The default implementation returns
+     * <code>Utils.safeToInt(getAsLong(millisDuration, instant))</code>.
+     * 
+     * @param duration  the milliseconds to query, which may be negative
+     * @param instant  the start instant to calculate relative to
+     * @return the value of the field, in the units of the field, which may be
+     * negative
+     */
+    public int getValue(long duration, long instant) {
+        return Utils.safeToInt(getValueAsLong(duration, instant));
+    }
+
+    /**
+     * Get the millisecond duration of this field from its value, which is
+     * approximate if this field is imprecise.
+     * 
+     * @param value  the value of the field, which may be negative
+     * @return the milliseconds that the field represents, which may be
+     * negative
+     */
+    public long getMillis(int value) {
+        return value * getUnitMillis();
+    }
+
+    /**
+     * Get the millisecond duration of this field from its value, which is
+     * approximate if this field is imprecise.
+     * 
+     * @param value  the value of the field, which may be negative
+     * @return the milliseconds that the field represents, which may be
+     * negative
+     */
+    public long getMillis(long value) {
+        return value * getUnitMillis();
+    }
+
+    // Calculation API
+    //------------------------------------------------------------------------
+    public int getDifference(long minuendInstant, long subtrahendInstant) {
+        return Utils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));
+    }
+
+    //------------------------------------------------------------------------
+    public int compareTo(Object durationField) {
+        DurationField otherField = (DurationField) durationField;
+        long otherMillis = otherField.getUnitMillis();
+        long thisMillis = getUnitMillis();
+        // cannot do (thisMillis - otherMillis) as can overflow
+        if (thisMillis == otherMillis) {
+            return 0;
+        }
+        if (thisMillis < otherMillis) {
+            return -1;
+        } else {
+            return 1;
+        }
+    }
+
+    /**
+     * Get a suitable debug string.
+     * 
+     * @return debug string
+     */
+    public String toString() {
+        return "DurationField[" + getName() + ']';
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/DecoratedChronology.java b/JodaTime/src/java/org/joda/time/chrono/DecoratedChronology.java
new file mode 100644
index 000000000..4c78ce60f
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/DecoratedChronology.java
@@ -0,0 +1,129 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeZone;
+
+/**
+ * <code>DecoratedChronology</code> extends {@link Chronology}, implementing
+ * only the minimum required set of methods. These implemented methods delegate
+ * to a wrapped field. The withUTC, withDateTimeZone, and toString methods are
+ * exceptions, and are left abstract.
+ * <p>
+ * This design allows new Chronology types to be defined that piggyback on top
+ * of another, inheriting all the safe method implementations from
+ * Chronology. Should any method require pure delegation to the wrapped field,
+ * simply override and use the provided getWrappedChronology method.
+ * <p>
+ * DecoratedChronology is thread-safe and immutable, and its subclasses must
+ * be as well.
+ *
+ * @author Brian S O'Neill
+ * @since 1.0
+ * @see DelegatedChronology
+ */
+public abstract class DecoratedChronology extends Chronology {
+
+    static final long serialVersionUID = 7094038875466049631L;
+
+    /** The Chronology being wrapped */
+    private final Chronology iChronology;
+    
+    /**
+     * Create a DecoratedChronology for any chronology.
+     *
+     * @param chrono the chronology
+     * @throws IllegalArgumentException if chronology is null
+     */
+    protected DecoratedChronology(Chronology chrono) {
+        if (chrono == null) {
+            throw new IllegalArgumentException("The Chronology must not be null");
+        }
+        iChronology = chrono;
+    }
+    
+    /**
+     * Gets the wrapped chronology.
+     * 
+     * @return the wrapped Chronology
+     */
+    protected Chronology getWrappedChronology() {
+        return iChronology;
+    }
+
+    /**
+     * Get the Chronology in the UTC time zone.
+     * 
+     * @return Chronology in UTC
+     */
+    public abstract Chronology withUTC();
+
+    /**
+     * Get the Chronology in the any time zone.
+     * 
+     * @return Chronology in ant time zone
+     */
+    public abstract Chronology withDateTimeZone(DateTimeZone zone);
+
+    /**
+     * Gets the time zone that this chronology is using.
+     * 
+     * @return the DateTimeZone
+     */
+    public DateTimeZone getDateTimeZone() {
+        return iChronology.getDateTimeZone();
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/DelegateDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/DecoratedDateTimeField.java
similarity index 52%
rename from JodaTime/src/java/org/joda/time/chrono/DelegateDateTimeField.java
rename to JodaTime/src/java/org/joda/time/chrono/DecoratedDateTimeField.java
index 10f27d366..518927101 100644
--- a/JodaTime/src/java/org/joda/time/chrono/DelegateDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/DecoratedDateTimeField.java
@@ -53,36 +53,45 @@
  */
 package org.joda.time.chrono;
 
-import java.util.Locale;
 import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
 
 /**
- * <code>DelegateDateTimeField</code> delegates each method call to the
- * date time field it wraps.
+ * <code>DecoratedDateTimeField</code> extends {@link AbstractDateTimeField},
+ * implementing only the minimum required set of methods. These implemented
+ * methods delegate to a wrapped field.
+ * <p>
+ * This design allows new DateTimeField types to be defined that piggyback on
+ * top of another, inheriting all the safe method implementations from
+ * AbstractDateTimeField. Should any method require pure delegation to the
+ * wrapped field, simply override and use the provided getWrappedField method.
+ * <p>
+ * DecoratedDateTimeField is thread-safe and immutable, and its subclasses must
+ * be as well.
  *
  * @author Brian S O'Neill
  * @since 1.0
+ * @see DelegatedDateTimeField
  */
-public abstract class DelegateDateTimeField extends DateTimeField {
+public class DecoratedDateTimeField extends AbstractDateTimeField {
 
-    private static DateTimeField getField(DateTimeField field) {
-        if (field == null) {
-            throw new IllegalArgumentException("The field must not be null");
-        }
-        return field;
-    }
+    static final long serialVersionUID = 203115783733757597L;
 
     /** The DateTimeField being wrapped */
     private final DateTimeField iField;
 
-    protected DelegateDateTimeField(DateTimeField field) {
-        super(getField(field).getName());
-        iField = field;
-    }
-
-    protected DelegateDateTimeField(String name, DateTimeField field) {
+    /**
+     * @param name allow name to be overridden
+     */
+    public DecoratedDateTimeField(DateTimeField field, String name) {
         super(name);
-        iField = getField(field);
+        if (field == null) {
+            throw new IllegalArgumentException("The field must not be null");
+        }
+        if (!field.isSupported()) {
+            throw new IllegalArgumentException("The field must be supported");
+        }
+        iField = field;
     }
 
     /**
@@ -90,111 +99,40 @@ protected DelegateDateTimeField(String name, DateTimeField field) {
      * 
      * @return the wrapped DateTimeField
      */
-    protected DateTimeField getDateTimeField() {
+    public final DateTimeField getWrappedField() {
         return iField;
     }
 
-    public int get(long millis) {
-        return iField.get(millis);
-    }
-
-    public String getAsText(long millis, Locale locale) {
-        return iField.getAsText(millis, locale);
-    }
-
-    public String getAsShortText(long millis, Locale locale) {
-        return iField.getAsShortText(millis, locale);
-    }
-
-    public long add(long millis, int value) {
-        return iField.add(millis, value);
-    }
-
-    public long add(long millis, long value) {
-        return iField.add(millis, value);
+    public boolean isLenient() {
+        return iField.isLenient();
     }
 
-    public long addWrapped(long millis, int value) {
-        return iField.addWrapped(millis, value);
+    public int get(long instant) {
+        return iField.get(instant);
     }
 
-    public long getDifference(long minuendMillis, long subtrahendMillis) {
-        return iField.getDifference(minuendMillis, subtrahendMillis);
+    public long set(long instant, int value) {
+        return iField.set(instant, value);
     }
 
-    public long set(long millis, int value) {
-        return iField.set(millis, value);
+    public DurationField getDurationField() {
+        return iField.getDurationField();
     }
 
-    public long set(long millis, String text, Locale locale) {
-        return iField.set(millis, text, locale);
-    }
-
-    public boolean isLeap(long millis) {
-        return iField.isLeap(millis);
-    }
-
-    public int getLeapAmount(long millis) {
-        return iField.getLeapAmount(millis);
-    }
-
-    public long getUnitMillis() {
-        return iField.getUnitMillis();
-    }
-
-    public long getRangeMillis() {
-        return iField.getRangeMillis();
+    public DurationField getRangeDurationField() {
+        return iField.getRangeDurationField();
     }
 
     public int getMinimumValue() {
         return iField.getMinimumValue();
     }
 
-    public int getMinimumValue(long millis) {
-        return iField.getMinimumValue(millis);
-    }
-
     public int getMaximumValue() {
         return iField.getMaximumValue();
     }
 
-    public int getMaximumValue(long millis) {
-        return iField.getMaximumValue(millis);
-    }
-
-    public int getMaximumTextLength(Locale locale) {
-        return iField.getMaximumTextLength(locale);
-    }
-
-    public int getMaximumShortTextLength(Locale locale) {
-        return iField.getMaximumShortTextLength(locale);
-    }
-
-    public long roundFloor(long millis) {
-        return iField.roundFloor(millis);
-    }
-
-    public long roundCeiling(long millis) {
-        return iField.roundCeiling(millis);
-    }
-
-    public long roundHalfFloor(long millis) {
-        return iField.roundHalfFloor(millis);
-    }
-
-    public long roundHalfCeiling(long millis) {
-        return iField.roundHalfCeiling(millis);
-    }
-
-    public long roundHalfEven(long millis) {
-        return iField.roundHalfEven(millis);
+    public long roundFloor(long instant) {
+        return iField.roundFloor(instant);
     }
 
-    public long remainder(long millis) {
-        return iField.remainder(millis);
-    }
-
-    public String toString() {
-        return iField.toString();
-    }
 }
diff --git a/JodaTime/src/java/org/joda/time/chrono/DecoratedDurationField.java b/JodaTime/src/java/org/joda/time/chrono/DecoratedDurationField.java
new file mode 100644
index 000000000..cd647eecd
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/DecoratedDurationField.java
@@ -0,0 +1,137 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+
+package org.joda.time.chrono;
+
+import org.joda.time.DurationField;
+
+/**
+ * <code>DecoratedDurationField</code> extends {@link AbstractDurationField},
+ * implementing only the minimum required set of methods. These implemented
+ * methods delegate to a wrapped field.
+ * <p>
+ * This design allows new DurationField types to be defined that piggyback on
+ * top of another, inheriting all the safe method implementations from
+ * AbstractDurationField. Should any method require pure delegation to the
+ * wrapped field, simply override and use the provided getWrappedField method.
+ * <p>
+ * DecoratedDurationField is thread-safe and immutable, and its subclasses must
+ * be as well.
+ *
+ * @author Brian S O'Neill
+ * @see DelegatedDurationField
+ */
+public class DecoratedDurationField extends AbstractDurationField {
+
+    static final long serialVersionUID = 8019982251647420015L;
+
+    /** The DurationField being wrapped */
+    private final DurationField iField;
+
+    /**
+     * @param name allow name to be overridden
+     */
+    public DecoratedDurationField(DurationField field, String name) {
+        super(name);
+        if (field == null) {
+            throw new IllegalArgumentException("The field must not be null");
+        }
+        if (!field.isSupported()) {
+            throw new IllegalArgumentException("The field must be supported");
+        }
+        iField = field;
+    }
+
+    /**
+     * Gets the wrapped duration field.
+     * 
+     * @return the wrapped DurationField
+     */
+    public final DurationField getWrappedField() {
+        return iField;
+    }
+
+    public boolean isPrecise() {
+        return iField.isPrecise();
+    }
+
+    public long getValueAsLong(long duration, long instant) {
+        return iField.getValueAsLong(duration, instant);
+    }
+
+    public long getMillis(int value, long instant) {
+        return iField.getMillis(value, instant);
+    }
+
+    public long getMillis(long value, long instant) {
+        return iField.getMillis(value, instant);
+    }
+
+    public long add(long instant, int value) {
+        return iField.add(instant, value);
+    }
+
+    public long add(long instant, long value) {
+        return iField.add(instant, value);
+    }
+
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);
+    }
+
+    public long getUnitMillis() {
+        return iField.getUnitMillis();
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/DelegateChronology.java b/JodaTime/src/java/org/joda/time/chrono/DelegatedChronology.java
similarity index 66%
rename from JodaTime/src/java/org/joda/time/chrono/DelegateChronology.java
rename to JodaTime/src/java/org/joda/time/chrono/DelegatedChronology.java
index c3be35bff..ecf56ae89 100644
--- a/JodaTime/src/java/org/joda/time/chrono/DelegateChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/DelegatedChronology.java
@@ -56,26 +56,34 @@
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeZone;
+import org.joda.time.DurationField;
 
 /**
- * <code>DelegateChronology</code> delegates each method call to the
+ * <code>DelegatedChronology</code> delegates each method call to the
  * chronology it wraps.
+ * <p>
+ * DelegatedChronology is thread-safe and immutable, and its subclasses must
+ * be as well.
  *
  * @author Stephen Colebourne
+ * @author Brian S O'Neill
  * @since 1.0
+ * @see DecoratedChronology
  */
-public abstract class DelegateChronology extends Chronology {
+public abstract class DelegatedChronology extends Chronology {
     
-    /** The Chonology being wrapped */
+    static final long serialVersionUID = 216867504527676612L;
+
+    /** The Chronology being wrapped */
     private final Chronology iChronology;
     
     /**
-     * Create a DelegateChronology for any chronology.
+     * Create a DelegatedChronology for any chronology.
      *
      * @param chrono the chronology
      * @throws IllegalArgumentException if chronology is null
      */
-    protected DelegateChronology(Chronology chrono) {
+    protected DelegatedChronology(Chronology chrono) {
         if (chrono == null) {
             throw new IllegalArgumentException("The Chronology must not be null");
         }
@@ -87,7 +95,7 @@ protected DelegateChronology(Chronology chrono) {
      * 
      * @return the wrapped Chronology
      */
-    protected Chronology getChronology() {
+    protected Chronology getWrappedChronology() {
         return iChronology;
     }
 
@@ -114,9 +122,66 @@ public DateTimeZone getDateTimeZone() {
         return iChronology.getDateTimeZone();
     }
 
+    public long getDateOnlyMillis(long instant) {
+        return iChronology.getDateOnlyMillis(instant);
+    }
+
+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
+        throws IllegalArgumentException
+    {
+        return iChronology.getDateOnlyMillis(year, monthOfYear, dayOfMonth);
+    }
+
+    public long getTimeOnlyMillis(long instant) {
+        return iChronology.getTimeOnlyMillis(instant);
+    }
+
+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        return iChronology.getTimeOnlyMillis
+            (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+    }
+
+    public long getDateTimeMillis(long instant,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        return iChronology.getDateTimeMillis
+            (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+    }
+
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int millisOfDay)
+        throws IllegalArgumentException
+    {
+        return iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);
+    }
+
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        return iChronology.getDateTimeMillis
+            (year, monthOfYear, dayOfMonth,
+             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+    }
+
     // Millis
     //------------------------------------------------------------
 
+    /**
+     * Get the millis duration field for this chronology.
+     * 
+     * @return DurationField
+     */
+    public DurationField millis() {
+        return iChronology.millis();
+    }
+
     /**
      * Get the millis of second field for this chronology.
      * 
@@ -138,6 +203,15 @@ public DateTimeField millisOfDay() {
     // Seconds
     //------------------------------------------------------------
 
+    /**
+     * Get the seconds duration field for this chronology.
+     * 
+     * @return DurationField
+     */
+    public DurationField seconds() {
+        return iChronology.seconds();
+    }
+
     /**
      * Get the second of minute field for this chronology.
      * 
@@ -159,6 +233,15 @@ public DateTimeField secondOfDay() {
     // Minutes
     //------------------------------------------------------------
 
+    /**
+     * Get the minutes duration field for this chronology.
+     * 
+     * @return DurationField
+     */
+    public DurationField minutes() {
+        return iChronology.minutes();
+    }
+
     /**
      * Get the minute of hour field for this chronology.
      * 
@@ -180,6 +263,15 @@ public DateTimeField minuteOfDay() {
     // Hours
     //------------------------------------------------------------
 
+    /**
+     * Get the hours duration field for this chronology.
+     * 
+     * @return DurationField
+     */
+    public DurationField hours() {
+        return iChronology.hours();
+    }
+
     /**
      * Get the hour of day (0-23) field for this chronology.
      * 
@@ -228,6 +320,15 @@ public DateTimeField halfdayOfDay() {
     // Day
     //------------------------------------------------------------
 
+    /**
+     * Get the days duration field for this chronology.
+     * 
+     * @return DurationField
+     */
+    public DurationField days() {
+        return iChronology.days();
+    }
+
     /**
      * Get the day of week field for this chronology.
      *
@@ -258,6 +359,15 @@ public DateTimeField dayOfYear() {
     // Week
     //------------------------------------------------------------
 
+    /**
+     * Get the weeks duration field for this chronology.
+     * 
+     * @return DurationField
+     */
+    public DurationField weeks() {
+        return iChronology.weeks();
+    }
+
     /**
      * Get the week of a week based year field for this chronology.
      *
@@ -267,6 +377,15 @@ public DateTimeField weekOfWeekyear() {
         return iChronology.weekOfWeekyear();
     }
 
+    /**
+     * Get the weekyears duration field for this chronology.
+     * 
+     * @return DurationField
+     */
+    public DurationField weekyears() {
+        return iChronology.weekyears();
+    }
+
     /**
      * Get the year of a week based year field for this chronology.
      *
@@ -279,6 +398,15 @@ public DateTimeField weekyear() {
     // Month
     //------------------------------------------------------------
 
+    /**
+     * Get the months duration field for this chronology.
+     * 
+     * @return DurationField
+     */
+    public DurationField months() {
+        return iChronology.months();
+    }
+
     /**
      * Get the month of year field for this chronology.
      *
@@ -291,6 +419,15 @@ public DateTimeField monthOfYear() {
     // Year
     //------------------------------------------------------------
 
+    /**
+     * Get the years duration field for this chronology.
+     * 
+     * @return DurationField
+     */
+    public DurationField years() {
+        return iChronology.years();
+    }
+
     /**
      * Get the year field for this chronology.
      * 
@@ -318,6 +455,15 @@ public DateTimeField yearOfCentury() {
         return iChronology.yearOfCentury();
     }
 
+    /**
+     * Get the centuries duration field for this chronology.
+     * 
+     * @return DurationField
+     */
+    public DurationField centuries() {
+        return iChronology.centuries();
+    }
+
     /**
      * Get the century of era field for this chronology.
      * 
@@ -327,6 +473,15 @@ public DateTimeField centuryOfEra() {
         return iChronology.centuryOfEra();
     }
 
+    /**
+     * Get the eras duration field for this chronology.
+     * 
+     * @return DurationField
+     */
+    public DurationField eras() {
+        return iChronology.eras();
+    }
+
     /**
      * Get the era field for this chronology.
      * 
diff --git a/JodaTime/src/java/org/joda/time/chrono/DelegatedDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/DelegatedDateTimeField.java
new file mode 100644
index 000000000..e3a6708f1
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/DelegatedDateTimeField.java
@@ -0,0 +1,240 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import java.io.Serializable;
+import java.util.Locale;
+import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+
+/**
+ * <code>DelegatedDateTimeField</code> delegates each method call to the
+ * date time field it wraps.
+ * <p>
+ * DelegatedDateTimeField is thread-safe and immutable, and its subclasses must
+ * be as well.
+ *
+ * @author Brian S O'Neill
+ * @since 1.0
+ * @see DecoratedDateTimeField
+ */
+public class DelegatedDateTimeField implements DateTimeField, Serializable {
+
+    static final long serialVersionUID = -4730164440214502503L;
+
+    /** The DateTimeField being wrapped */
+    private final DateTimeField iField;
+    /** A desriptive name for the field */
+    private final String iName;
+
+    protected DelegatedDateTimeField(DateTimeField field) {
+        this(field, null);
+    }
+
+    protected DelegatedDateTimeField(DateTimeField field, String name) {
+        super();
+        if (field == null) {
+            throw new IllegalArgumentException("The field must not be null");
+        }
+        iField = field;
+        iName = name;
+    }
+
+    /**
+     * Gets the wrapped date time field.
+     * 
+     * @return the wrapped DateTimeField
+     */
+    public final DateTimeField getWrappedField() {
+        return iField;
+    }
+
+    public String getName() {
+        return (iName == null) ? iField.getName() : iName;
+    }
+
+    public boolean isSupported() {
+        return iField.isSupported();
+    }
+
+    public boolean isLenient() {
+        return iField.isLenient();
+    }
+
+    public int get(long instant) {
+        return iField.get(instant);
+    }
+
+    public String getAsText(long instant, Locale locale) {
+        return iField.getAsText(instant, locale);
+    }
+
+    public String getAsText(long instant) {
+        return iField.getAsText(instant);
+    }
+
+    public String getAsShortText(long instant, Locale locale) {
+        return iField.getAsShortText(instant, locale);
+    }
+
+    public String getAsShortText(long instant) {
+        return iField.getAsShortText(instant);
+    }
+
+    public long add(long instant, int value) {
+        return iField.add(instant, value);
+    }
+
+    public long add(long instant, long value) {
+        return iField.add(instant, value);
+    }
+
+    public long addWrapped(long instant, int value) {
+        return iField.addWrapped(instant, value);
+    }
+
+    public int getDifference(long minuendInstant, long subtrahendInstant) {
+        return iField.getDifference(minuendInstant, subtrahendInstant);
+    }
+
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);
+    }
+
+    public long set(long instant, int value) {
+        return iField.set(instant, value);
+    }
+
+    public long set(long instant, String text, Locale locale) {
+        return iField.set(instant, text, locale);
+    }
+
+    public long set(long instant, String text) {
+        return iField.set(instant, text);
+    }
+
+    public DurationField getDurationField() {
+        return iField.getDurationField();
+    }
+
+    public DurationField getRangeDurationField() {
+        return iField.getRangeDurationField();
+    }
+
+    public boolean isLeap(long instant) {
+        return iField.isLeap(instant);
+    }
+
+    public int getLeapAmount(long instant) {
+        return iField.getLeapAmount(instant);
+    }
+
+    public DurationField getLeapDurationField() {
+        return iField.getLeapDurationField();
+    }
+
+    public int getMinimumValue() {
+        return iField.getMinimumValue();
+    }
+
+    public int getMinimumValue(long instant) {
+        return iField.getMinimumValue(instant);
+    }
+
+    public int getMaximumValue() {
+        return iField.getMaximumValue();
+    }
+
+    public int getMaximumValue(long instant) {
+        return iField.getMaximumValue(instant);
+    }
+
+    public int getMaximumTextLength(Locale locale) {
+        return iField.getMaximumTextLength(locale);
+    }
+
+    public int getMaximumShortTextLength(Locale locale) {
+        return iField.getMaximumShortTextLength(locale);
+    }
+
+    public long roundFloor(long instant) {
+        return iField.roundFloor(instant);
+    }
+
+    public long roundCeiling(long instant) {
+        return iField.roundCeiling(instant);
+    }
+
+    public long roundHalfFloor(long instant) {
+        return iField.roundHalfFloor(instant);
+    }
+
+    public long roundHalfCeiling(long instant) {
+        return iField.roundHalfCeiling(instant);
+    }
+
+    public long roundHalfEven(long instant) {
+        return iField.roundHalfEven(instant);
+    }
+
+    public long remainder(long instant) {
+        return iField.remainder(instant);
+    }
+
+    public String toString() {
+        return (iName == null) ? iField.toString() :
+            ("DateTimeField[" + iName + ']');
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/DelegatedDurationField.java b/JodaTime/src/java/org/joda/time/chrono/DelegatedDurationField.java
new file mode 100644
index 000000000..85751bb04
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/DelegatedDurationField.java
@@ -0,0 +1,179 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+
+package org.joda.time.chrono;
+
+import java.io.Serializable;
+import org.joda.time.DurationField;
+
+/**
+ * <code>DelegatedDurationField</code> delegates each method call to the
+ * duration field it wraps.
+ * <p>
+ * DelegatedDurationField is thread-safe and immutable, and its subclasses must
+ * be as well.
+ *
+ * @author Brian S O'Neill
+ * @see DecoratedDurationField
+ */
+public class DelegatedDurationField implements DurationField, Serializable {
+
+    static final long serialVersionUID = -5576443481242007829L;
+
+    /** The DurationField being wrapped */
+    private final DurationField iField;
+    /** A desriptive name for the field */
+    private final String iName;
+
+    protected DelegatedDurationField(DurationField field) {
+        this(field, null);
+    }
+
+    /**
+     * @param name allow name to be overridden
+     */
+    protected DelegatedDurationField(DurationField field, String name) {
+        if (field == null) {
+            throw new IllegalArgumentException("The field must not be null");
+        }
+        iField = field;
+        iName = name;
+    }
+
+    /**
+     * Gets the wrapped duration field.
+     * 
+     * @return the wrapped DurationField
+     */
+    public final DurationField getWrappedField() {
+        return iField;
+    }
+
+    public String getName() {
+        return (iName == null) ? iField.getName() : iName;
+    }
+
+    /**
+     * Returns true if this field is supported.
+     */
+    public boolean isSupported() {
+        return iField.isSupported();
+    }
+
+    public boolean isPrecise() {
+        return iField.isPrecise();
+    }
+    
+    public int getValue(long duration) {
+        return iField.getValue(duration);
+    }
+
+    public long getValueAsLong(long duration) {
+        return iField.getValueAsLong(duration);
+    }
+
+    public int getValue(long duration, long instant) {
+        return iField.getValue(duration, instant);
+    }
+
+    public long getValueAsLong(long duration, long instant) {
+        return iField.getValueAsLong(duration, instant);
+    }
+
+    public long getMillis(int value) {
+        return iField.getMillis(value);
+    }
+
+    public long getMillis(long value) {
+        return iField.getMillis(value);
+    }
+
+    public long getMillis(int value, long instant) {
+        return iField.getMillis(value, instant);
+    }
+
+    public long getMillis(long value, long instant) {
+        return iField.getMillis(value, instant);
+    }
+
+    public long add(long instant, int value) {
+        return iField.add(instant, value);
+    }
+
+    public long add(long instant, long value) {
+        return iField.add(instant, value);
+    }
+
+    public int getDifference(long minuendInstant, long subtrahendInstant) {
+        return iField.getDifference(minuendInstant, subtrahendInstant);
+    }
+
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);
+    }
+
+    public long getUnitMillis() {
+        return iField.getUnitMillis();
+    }
+
+    public int compareTo(Object durationField) {
+        return iField.compareTo(durationField);
+    }
+
+    public String toString() {
+        return (iName == null) ? iField.toString() :
+            ("DurationField[" + iName + ']');
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/DividedDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/DividedDateTimeField.java
index 483eacc23..d44be737c 100644
--- a/JodaTime/src/java/org/joda/time/chrono/DividedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/DividedDateTimeField.java
@@ -54,9 +54,14 @@
 package org.joda.time.chrono;
 
 import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
 
 /**
- * Generic division datetime field.
+ * Divides a DateTimeField such that the retrieved values are reduced by a
+ * fixed divisor. The field's unit duration is scaled accordingly, but the
+ * range duration is unchanged.
+ * <p>
+ * DividedDateTimeField is thread-safe and immutable.
  *
  * @see RemainderDateTimeField
  * 
@@ -64,127 +69,154 @@
  * @author Brian S O'Neill
  * @since 1.0
  */
-public class DividedDateTimeField extends DateTimeField {
+public class DividedDateTimeField extends DecoratedDateTimeField {
 
-    /** The field to divide */
-    private final DateTimeField iField;
-    /** The amount to divide by in the correct units */
-    private final int iUnitDivisor;
+    static final long serialVersionUID = 8318475124230605365L;
+
+    // Shared with RemainderDateTimeField.
+    final int iDivisor;
+    final DurationField iDurationField;
 
     private final int iMin;
     private final int iMax;
 
     /**
-     * Constructor
+     * Constructor.
      * 
-     * @param name  short, descriptive name, like "century".
      * @param field  the field to wrap, like "year()".
-     * @param unitDivisor  divisor in units, such as 100 years in a century
-     * @throws IllegalArgumentException if unit is less than two
+     * @param name  short, descriptive name, like "century".
+     * @param durationName  short, descriptive name, like "centuries".
+     * @param divisor  divisor, such as 100 years in a century
+     * @throws IllegalArgumentException if divisor is less than two
      */
-    public DividedDateTimeField(String name, DateTimeField field, int unitDivisor) {
-        super(name);
+    public DividedDateTimeField(DateTimeField field,
+                                String name, String durationName, int divisor) {
+        super(field, name);
                 
-        if (field == null) {
-            throw new IllegalArgumentException("The field must not be null");
+        if (divisor < 2) {
+            throw new IllegalArgumentException("The divisor must be at least 2");
         }
-        if (unitDivisor < 2) {
-            throw new IllegalArgumentException("The unit divisor must be at least 2");
+
+        DurationField unitField = field.getDurationField();
+        if (unitField == null) {
+            iDurationField = null;
+        } else {
+            iDurationField = new ScaledDurationField(unitField, durationName, divisor);
         }
-        iField = field;
-        iUnitDivisor = unitDivisor;
 
-        int i = iField.getMinimumValue();
-        int min = (i >= 0) ? i / unitDivisor : ((i + 1) / unitDivisor - 1);
+        iDivisor = divisor;
+
+        int i = field.getMinimumValue();
+        int min = (i >= 0) ? i / divisor : ((i + 1) / divisor - 1);
+
+        int j = field.getMaximumValue();
+        int max = (j >= 0) ? j / divisor : ((j + 1) / divisor - 1);
+
+        iMin = min;
+        iMax = max;
+    }
+
+    /**
+     * Construct a DividedDateTimeField that compliments the given
+     * RemainderDateTimeField.
+     *
+     * @param remainderField  complimentary remainder field, like "yearOfCentury()".
+     * @param name  short, descriptive name, like "century".
+     */
+    public DividedDateTimeField(RemainderDateTimeField remainderField, String name) {
+        super(remainderField.getWrappedField(), name);
+        int divisor = iDivisor = remainderField.iDivisor;
+        iDurationField = remainderField.iRangeField;
+
+        DateTimeField field = getWrappedField();
+        int i = field.getMinimumValue();
+        int min = (i >= 0) ? i / divisor : ((i + 1) / divisor - 1);
 
-        int j = iField.getMaximumValue();
-        int max = (j >= 0) ? j / unitDivisor : ((j + 1) / unitDivisor - 1);
+        int j = field.getMaximumValue();
+        int max = (j >= 0) ? j / divisor : ((j + 1) / divisor - 1);
 
         iMin = min;
         iMax = max;
     }
 
     /**
-     * Get the amount of divided units from the specified time instant.
+     * Get the amount of scaled units from the specified time instant.
      * 
-     * @param millis  the time instant in millis to query.
-     * @return the amount of divided units extracted from the input.
+     * @param instant  the time instant in millis to query.
+     * @return the amount of scaled units extracted from the input.
      */
-    public int get(long millis) {
-        int value = iField.get(millis);
+    public int get(long instant) {
+        int value = getWrappedField().get(instant);
         if (value >= 0) {
-            return value / iUnitDivisor;
+            return value / iDivisor;
         } else {
-            return ((value + 1) / iUnitDivisor) - 1;
+            return ((value + 1) / iDivisor) - 1;
         }
     }
 
     /**
-     * Add the specified amount of divided units to the specified time
+     * Add the specified amount of scaled units to the specified time
      * instant. The amount added may be negative.
      * 
-     * @param millis  the time instant in millis to update.
-     * @param amount  the amount of divided units to add (can be negative).
+     * @param instant  the time instant in millis to update.
+     * @param amount  the amount of scaled units to add (can be negative).
      * @return the updated time instant.
      */
-    public long add(long millis, int amount) {
-        return iField.add(millis, amount * iUnitDivisor);
+    public long add(long instant, int amount) {
+        return getWrappedField().add(instant, amount * iDivisor);
     }
 
     /**
-     * Add the specified amount of divided units to the specified time
+     * Add the specified amount of scaled units to the specified time
      * instant. The amount added may be negative.
      * 
-     * @param millis  the time instant in millis to update.
-     * @param amount  the amount of divided units to add (can be negative).
+     * @param instant  the time instant in millis to update.
+     * @param amount  the amount of scaled units to add (can be negative).
      * @return the updated time instant.
      */
-    public long add(long millis, long amount) {
-        return iField.add(millis, amount * iUnitDivisor);
+    public long add(long instant, long amount) {
+        return getWrappedField().add(instant, amount * iDivisor);
     }
 
     /**
-     * Add to the divided component of the specified time instant,
+     * Add to the scaled component of the specified time instant,
      * wrapping around within that component if necessary.
      * 
-     * @param millis  the time instant in millis to update.
-     * @param amount  the amount of divided units to add (can be negative).
+     * @param instant  the time instant in millis to update.
+     * @param amount  the amount of scaled units to add (can be negative).
      * @return the updated time instant.
      */
-    public long addWrapped(long millis, int amount) {
-        return set(millis, getWrappedValue(get(millis), amount, iMin, iMax));
+    public long addWrapped(long instant, int amount) {
+        return set(instant, Utils.getWrappedValue(get(instant), amount, iMin, iMax));
     }
 
-    public long getDifference(long minuendMillis, long subtrahendMillis) {
-        return iField.getDifference(minuendMillis, subtrahendMillis) / iUnitDivisor;
+    public int getDifference(long minuendInstant, long subtrahendInstant) {
+        return getWrappedField().getDifference(minuendInstant, subtrahendInstant) / iDivisor;
+    }
+
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant) / iDivisor;
     }
 
     /**
-     * Set the specified amount of divided units to the specified time instant.
+     * Set the specified amount of scaled units to the specified time instant.
      * 
-     * @param millis  the time instant in millis to update.
-     * @param value  value of divided units to set.
+     * @param instant  the time instant in millis to update.
+     * @param value  value of scaled units to set.
      * @return the updated time instant.
      * @throws IllegalArgumentException if value is too large or too small.
      */
-    public long set(long millis, int value) {
-        verifyValueBounds(value, iMin, iMax);
-        int remainder = getRemainder(iField.get(millis));
-        return iField.set(millis, value * iUnitDivisor + remainder);
+    public long set(long instant, int value) {
+        Utils.verifyValueBounds(this, value, iMin, iMax);
+        int remainder = getRemainder(getWrappedField().get(instant));
+        return getWrappedField().set(instant, value * iDivisor + remainder);
     }
 
     /**
-     * Returns the wrapped field's unit size multiplied by the unit divisor.
+     * Returns a scaled version of the wrapped field's unit duration field.
      */
-    public long getUnitMillis() {
-        return iField.getUnitMillis() * iUnitDivisor;
-    }
-
-    /**
-     * Returns the wrapped field's range.
-     */
-    public long getRangeMillis() {
-        return iField.getRangeMillis();
+    public DurationField getDurationField() {
+        return iDurationField;
     }
 
     /**
@@ -204,38 +236,30 @@ public int getMinimumValue() {
     public int getMaximumValue() {
         return iMax;
     }
-    
-    public long roundFloor(long millis) {
-        return iField.roundFloor(iField.set(millis, get(millis) * iUnitDivisor));
-    }
 
-    public long remainder(long millis) {
-        return set(millis, get(iField.remainder(millis)));
+    public long roundFloor(long instant) {
+        DateTimeField field = getWrappedField();
+        return field.roundFloor(field.set(instant, get(instant) * iDivisor));
     }
 
-    /**
-     * Returns the DateTimeField being wrapped.
-     * 
-     * @return field
-     */
-    public DateTimeField getField() {
-        return iField;
+    public long remainder(long instant) {
+        return set(instant, get(getWrappedField().remainder(instant)));
     }
 
     /**
-     * Returns the divisor to apply to the field in the field's units.
+     * Returns the divisor applied, in the field's units.
      * 
      * @return the divisor
      */
-    public int getUnitDivisor() {
-        return iUnitDivisor;
+    public int getDivisor() {
+        return iDivisor;
     }
 
     private int getRemainder(int value) {
         if (value >= 0) {
-            return value % iUnitDivisor;
+            return value % iDivisor;
         } else {
-            return (iUnitDivisor - 1) + ((value + 1) % iUnitDivisor);
+            return (iDivisor - 1) + ((value + 1) % iDivisor);
         }
     }
 
diff --git a/JodaTime/src/java/org/joda/time/chrono/FractionalDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/FractionalDateTimeField.java
deleted file mode 100644
index 7cefa4d50..000000000
--- a/JodaTime/src/java/org/joda/time/chrono/FractionalDateTimeField.java
+++ /dev/null
@@ -1,238 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-03 Stephen Colebourne.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono;
-
-import org.joda.time.DateTimeField;
-
-/**
- * Generic fractional datetime field.
- * <p>
- * This DateTimeField is useful for extracting a fractional part from the
- * milliseconds. This is very useful for time values.
- *
- * @author Brian S O'Neill
- * @author Stephen Colebourne
- * @since 1.0
- */
-public class FractionalDateTimeField extends DateTimeField {
-
-    /** The fractional unit in millis */
-    private final long iUnitMillis;
-    /** The maximum range in the correct units */
-    private final int iRange;
-
-    /**
-     * Constructor.
-     * 
-     * @param name  short, descriptive name, like "secondOfMinute".
-     * @param unitMillis  milliseconds per unit, such as 1000 for one second
-     * @param range  range in units, such as 60 seconds per minute
-     * @throws IllegalArgumentException if fractional unit is less than one, or if range is
-     *  less than two.
-     */
-    public FractionalDateTimeField(String name, long unitMillis, int range) {
-        super(name);
-                
-        if (unitMillis < 1) {
-            throw new IllegalArgumentException("The unit milliseconds must be at least 1");
-        }
-        if (range < 2) {
-            throw new IllegalArgumentException("The range must be at least 2");
-        }
-        iUnitMillis = unitMillis;
-        iRange = range;
-    }
-
-    /**
-     * Get the amount of fractional units from the specified time instant.
-     * 
-     * @param millis  the time instant in millis to query.
-     * @return the amount of fractional units extracted from the input.
-     */
-    public int get(long millis) {
-        if (millis >= 0) {
-            return (int) ((millis / iUnitMillis) % iRange);
-        } else {
-            return iRange - 1 + (int) (((millis + 1) / iUnitMillis) % iRange);
-        }
-    }
-
-    /**
-     * Add the specified amount of fractional units to the specified time
-     * instant. The amount added may be negative.
-     * 
-     * @param millis  the time instant in millis to update.
-     * @param amount  the amount of fractional units to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long add(long millis, int amount) {
-        return millis + amount * iUnitMillis;
-    }
-
-    /**
-     * Add the specified amount of fractional units to the specified time
-     * instant. The amount added may be negative.
-     * 
-     * @param millis  the time instant in millis to update.
-     * @param amount  the amount of fractional units to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long add(long millis, long amount) {
-        return millis + amount * iUnitMillis;
-    }
-
-    /**
-     * Add to the fractional component of the specified time instant,
-     * wrapping around within that component if necessary.
-     * 
-     * @param millis  the time instant in millis to update.
-     * @param amount  the amount of fractional units to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long addWrapped(long millis, int amount) {
-        int thisValue = get(millis);
-        int wrappedValue = getWrappedValue(thisValue, amount, getMinimumValue(), getMaximumValue());
-        // copy code from set() to avoid repeat call to get()
-        return millis + (wrappedValue - thisValue) * iUnitMillis;
-    }
-
-    public long getDifference(long minuendMillis, long subtrahendMillis) {
-        return (minuendMillis - subtrahendMillis) / iUnitMillis;
-    }
-
-    /**
-     * Set the specified amount of fractional units to the specified time instant.
-     * 
-     * @param millis  the time instant in millis to update.
-     * @param value  value of fractional units to set.
-     * @return the updated time instant.
-     * @throws IllegalArgumentException if value is too large or too small.
-     */
-    public long set(long millis, int value) {
-        verifyValueBounds(value, getMinimumValue(), getMaximumValue());
-        return millis + (value - get(millis)) * iUnitMillis;
-    }
-
-    /**
-     * Returns the milliseconds representing one unit of the field.
-     * <p>
-     * For example, 1000 for one second.
-     * 
-     * @return unit millis
-     */
-    public long getUnitMillis() {
-        return iUnitMillis;
-    }
-
-    public long getRangeMillis() {
-        return iRange * iUnitMillis;
-    }
-
-    /**
-     * Get the minimum value for the field.
-     * 
-     * @return the minimum value
-     */
-    public int getMinimumValue() {
-        return 0;
-    }
-
-    /**
-     * Get the maximum value for the field.
-     * 
-     * @return the maximum value
-     */
-    public int getMaximumValue() {
-        return iRange - 1;
-    }
-    
-    public long roundFloor(long millis) {
-        if (millis >= 0) {
-            return millis - millis % iUnitMillis;
-        } else {
-            millis += 1;
-            return millis - millis % iUnitMillis - iUnitMillis;
-        }
-    }
-
-    public long roundCeiling(long millis) {
-        if (millis >= 0) {
-            millis -= 1;
-            return millis - millis % iUnitMillis + iUnitMillis;
-        } else {
-            return millis - millis % iUnitMillis;
-        }
-    }
-
-    public long remainder(long millis) {
-        if (millis >= 0) {
-            return millis % iUnitMillis;
-        } else {
-            return (millis + 1) % iUnitMillis + iUnitMillis - 1;
-        }
-    }
-
-    /**
-     * Returns the range of the field in the field's units.
-     * <p>
-     * For example, 60 for seconds per minute. The field is allowed values
-     * from 0 to range - 1.
-     * 
-     * @return unit range
-     */
-    public int getRange() {
-        return iRange;
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/ImpreciseDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/ImpreciseDateTimeField.java
new file mode 100644
index 000000000..1f0b7e346
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/ImpreciseDateTimeField.java
@@ -0,0 +1,237 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+
+package org.joda.time.chrono;
+
+import org.joda.time.DurationField;
+
+/**
+ * Abstract datetime field class that defines its own DurationField, which
+ * delegates back into this ImpreciseDateTimeField.
+ * <p>
+ * This DateTimeField is useful for defining DateTimeFields that are composed
+ * of imprecise durations. If both duration fields are precise, then a
+ * {@link PreciseDateTimeField} should be used instead.
+ * <p>
+ * When defining imprecise DateTimeFields where a matching DurationField is
+ * already available, just extend AbstractDateTimeField directly so as not to
+ * create redundant DurationField instances.
+ * <p>
+ * ImpreciseDateTimeField is thread-safe and immutable, and its subclasses must
+ * be as well.
+ *
+ * @author Brian S O'Neill
+ * @see PreciseDateTimeField
+ */
+public abstract class ImpreciseDateTimeField extends AbstractDateTimeField {
+
+    static final long serialVersionUID = 7190739608550251860L;
+
+    final long iUnitMillis;
+    private final DurationField iDurationField;
+
+    /**
+     * Constructor.
+     * 
+     * @param name  short, descriptive name, like "monthOfYear".
+     * @param durationName  short, descriptive name, like "months".
+     * @param unitMillis  the average duration unit milliseconds
+     */
+    public ImpreciseDateTimeField(String name, String durationName, long unitMillis) {
+        super(name);
+        iUnitMillis = unitMillis;
+        iDurationField = new LinkedDurationField(durationName);
+    }
+
+    public abstract int get(long instant);
+
+    public abstract long set(long instant, int value);
+
+    public abstract long add(long instant, int value);
+
+    public abstract long add(long instant, long value);
+
+    /**
+     * Computes the difference between two instants, as measured in the units
+     * of this field. Any fractional units are dropped from the result. Calling
+     * getDifference reverses the effect of calling add. In the following code:
+     *
+     * <pre>
+     * long instant = ...
+     * int v = ...
+     * int age = getDifference(add(instant, v), instant);
+     * </pre>
+     *
+     * The value 'age' is the same as the value 'v'.
+     * <p>
+     * The default implementation call getDifferenceAsLong and converts the
+     * return value to an int.
+     *
+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to
+     * subtract from
+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to
+     * subtract off the minuend
+     * @return the difference in the units of this field
+     */
+    public int getDifference(long minuendInstant, long subtrahendInstant) {
+        return Utils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));
+    }
+
+    /**
+     * Computes the difference between two instants, as measured in the units
+     * of this field. Any fractional units are dropped from the result. Calling
+     * getDifference reverses the effect of calling add. In the following code:
+     *
+     * <pre>
+     * long instant = ...
+     * long v = ...
+     * long age = getDifferenceAsLong(add(instant, v), instant);
+     * </pre>
+     *
+     * The value 'age' is the same as the value 'v'.
+     * <p>
+     * The default implementation performs a guess-and-check algorithm using
+     * getDurationField().getUnitMillis() and the add() method. Subclasses are
+     * encouraged to provide a more efficient implementation.
+     *
+     * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to
+     * subtract from
+     * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to
+     * subtract off the minuend
+     * @return the difference in the units of this field
+     */
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        if (minuendInstant < subtrahendInstant) {
+            return -getDifferenceAsLong(subtrahendInstant, minuendInstant);
+        }
+        
+        long difference = (minuendInstant - subtrahendInstant) / iUnitMillis;
+        if (add(subtrahendInstant, difference) < minuendInstant) {
+            do {
+                difference++;
+            } while (add(subtrahendInstant, difference) <= minuendInstant);
+            difference--;
+        } else if (add(subtrahendInstant, difference) > minuendInstant) {
+            do {
+                difference--;
+            } while (add(subtrahendInstant, difference) > minuendInstant);
+        }
+        return difference;
+    }
+
+    public final DurationField getDurationField() {
+        return iDurationField;
+    }
+
+    public abstract DurationField getRangeDurationField();
+
+    public abstract long roundFloor(long instant);
+
+    protected final long getDurationUnitMillis() {
+        return iUnitMillis;
+    }
+
+    private final class LinkedDurationField extends AbstractDurationField {
+        static final long serialVersionUID = -203813474600094134L;
+
+        LinkedDurationField(String name) {
+            super(name);
+        }
+    
+        public boolean isPrecise() {
+            return false;
+        }
+    
+        public long getUnitMillis() {
+            return iUnitMillis;
+        }
+
+        public int getValue(long duration, long instant) {
+            return ImpreciseDateTimeField.this
+                .getDifference(instant + duration, instant);
+        }
+
+        public long getValueAsLong(long duration, long instant) {
+            return ImpreciseDateTimeField.this
+                .getDifferenceAsLong(instant + duration, instant);
+        }
+        
+        public long getMillis(int value, long instant) {
+            return ImpreciseDateTimeField.this.add(instant, value) - instant;
+        }
+
+        public long getMillis(long value, long instant) {
+            return ImpreciseDateTimeField.this.add(instant, value) - instant;
+        }
+
+        public long add(long instant, int value) {
+            return ImpreciseDateTimeField.this.add(instant, value);
+        }
+        
+        public long add(long instant, long value) {
+            return ImpreciseDateTimeField.this.add(instant, value);
+        }
+        
+        public int getDifference(long minuendInstant, long subtrahendInstant) {
+            return ImpreciseDateTimeField.this
+                .getDifference(minuendInstant, subtrahendInstant);
+        }
+        
+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+            return ImpreciseDateTimeField.this
+                .getDifferenceAsLong(minuendInstant, subtrahendInstant);
+        }
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java b/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java
new file mode 100644
index 000000000..9bf037050
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java
@@ -0,0 +1,369 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeZone;
+
+/**
+ * Wraps another chronology, ensuring all the fields are lenient.
+ * <p>
+ * LenientChronology is thread-safe and immutable.
+ *
+ * @author Brian S O'Neill
+ * @see LenientDateTimeField
+ * @see StrictChronology
+ */
+public class LenientChronology extends DelegatedChronology {
+
+    static final long serialVersionUID = -3148237568046877177L;
+
+    private transient DateTimeField iYearField;
+    private transient DateTimeField iYearOfEraField;
+    private transient DateTimeField iYearOfCenturyField;
+    private transient DateTimeField iCenturyOfEraField;
+    private transient DateTimeField iEraField;
+    private transient DateTimeField iDayOfWeekField;
+    private transient DateTimeField iDayOfMonthField;
+    private transient DateTimeField iDayOfYearField;
+    private transient DateTimeField iMonthOfYearField;
+    private transient DateTimeField iWeekOfWeekyearField;
+    private transient DateTimeField iWeekyearField;
+
+    private transient DateTimeField iMillisOfSecondField;
+    private transient DateTimeField iMillisOfDayField;
+    private transient DateTimeField iSecondOfMinuteField;
+    private transient DateTimeField iSecondOfDayField;
+    private transient DateTimeField iMinuteOfHourField;
+    private transient DateTimeField iMinuteOfDayField;
+    private transient DateTimeField iHourOfDayField;
+    private transient DateTimeField iHourOfHalfdayField;
+    private transient DateTimeField iClockhourOfDayField;
+    private transient DateTimeField iClockhourOfHalfdayField;
+    private transient DateTimeField iHalfdayOfDayField;
+
+    private transient Chronology iWithUTC;
+
+    /**
+     * Create a LenientChronology for any chronology.
+     *
+     * @param chrono the chronology
+     * @throws IllegalArgumentException if chronology is null
+     */
+    public LenientChronology(Chronology chrono) {
+        super(chrono);
+    }
+
+    public Chronology withUTC() {
+        if (iWithUTC == null) {
+            iWithUTC = new LenientChronology(getWrappedChronology().withUTC());
+        }
+        return iWithUTC;
+    }
+
+    public Chronology withDateTimeZone(DateTimeZone zone) {
+        return new LenientChronology(getWrappedChronology().withDateTimeZone(zone));
+    }
+
+    /**
+     * Overridden to ensure lenient fields are used.
+     */
+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
+        throws IllegalArgumentException
+    {
+        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);
+    }
+
+    /**
+     * Overridden to ensure lenient fields are used.
+     */
+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        long instant = hourOfDay().set(0, hourOfDay);
+        instant = minuteOfHour().set(instant, minuteOfHour);
+        instant = secondOfMinute().set(instant, secondOfMinute);
+        return millisOfSecond().set(instant, millisOfSecond);
+    }
+
+    /**
+     * Overridden to ensure lenient fields are used.
+     */
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int millisOfDay)
+        throws IllegalArgumentException
+    {
+        long instant = year().set(0, year);
+        instant = monthOfYear().set(instant, monthOfYear);
+        instant = dayOfMonth().set(instant, dayOfMonth);
+        return millisOfDay().set(instant, millisOfDay);
+    }
+
+    /**
+     * Overridden to ensure lenient fields are used.
+     */
+    public long getDateTimeMillis(long instant,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        instant = hourOfDay().set(instant, hourOfDay);
+        instant = minuteOfHour().set(instant, minuteOfHour);
+        instant = secondOfMinute().set(instant, secondOfMinute);
+        return millisOfSecond().set(instant, millisOfSecond);
+    }
+
+    /**
+     * Overridden to ensure lenient fields are used.
+     */
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        long instant = year().set(0, year);
+        instant = monthOfYear().set(instant, monthOfYear);
+        instant = dayOfMonth().set(instant, dayOfMonth);
+        instant = hourOfDay().set(instant, hourOfDay);
+        instant = minuteOfHour().set(instant, minuteOfHour);
+        instant = secondOfMinute().set(instant, secondOfMinute);
+        return millisOfSecond().set(instant, millisOfSecond);
+    }
+
+    // Milliseconds
+    //------------------------------------------------------------
+
+    public DateTimeField millisOfSecond() {
+        if (iMillisOfDayField == null) {
+            iMillisOfSecondField = LenientDateTimeField.getInstance(super.millisOfSecond());
+        }
+        return iMillisOfSecondField;
+    }
+
+    public DateTimeField millisOfDay() {
+        if (iMillisOfDayField == null) {
+            iMillisOfDayField = LenientDateTimeField.getInstance(super.millisOfDay());
+        }
+        return iMillisOfDayField;
+    }
+
+    // Seconds
+    //------------------------------------------------------------
+
+    public DateTimeField secondOfMinute() {
+        if (iSecondOfMinuteField == null) {
+            iSecondOfMinuteField = LenientDateTimeField.getInstance(super.secondOfMinute());
+        }
+        return iSecondOfMinuteField;
+    }
+
+    public DateTimeField secondOfDay() {
+        if (iSecondOfDayField == null) {
+            iSecondOfDayField = LenientDateTimeField.getInstance(super.secondOfDay());
+        }
+        return iSecondOfDayField;
+    }
+
+    // Minutes
+    //------------------------------------------------------------
+
+    public DateTimeField minuteOfHour() {
+        if (iMinuteOfHourField == null) {
+            iMinuteOfHourField = LenientDateTimeField.getInstance(super.minuteOfHour());
+        }
+        return iMinuteOfHourField;
+    }
+
+    public DateTimeField minuteOfDay() {
+        if (iMinuteOfDayField == null) {
+            iMinuteOfDayField = LenientDateTimeField.getInstance(super.minuteOfDay());
+        }
+        return iMinuteOfDayField;
+    }
+
+    // Hours
+    //------------------------------------------------------------
+
+    public DateTimeField hourOfDay() {
+        if (iHourOfDayField == null) {
+            iHourOfDayField = LenientDateTimeField.getInstance(super.hourOfDay());
+        }
+        return iHourOfDayField;
+    }
+
+    public DateTimeField clockhourOfDay() {
+        if (iClockhourOfDayField == null) {
+            iClockhourOfDayField = LenientDateTimeField.getInstance(super.clockhourOfDay());
+        }
+        return iClockhourOfDayField;
+    }
+
+    public DateTimeField hourOfHalfday() {
+        if (iHourOfHalfdayField == null) {
+            iHourOfHalfdayField = LenientDateTimeField.getInstance(super.hourOfHalfday());
+        }
+        return iHourOfHalfdayField;
+    }
+
+    public DateTimeField clockhourOfHalfday() {
+        if (iClockhourOfHalfdayField == null) {
+            iClockhourOfHalfdayField =
+                LenientDateTimeField.getInstance(super.clockhourOfHalfday());
+        }
+        return iClockhourOfHalfdayField;
+    }
+
+    public DateTimeField halfdayOfDay() {
+        if (iHalfdayOfDayField == null) {
+            iHalfdayOfDayField = LenientDateTimeField.getInstance(super.halfdayOfDay());
+        }
+        return iHalfdayOfDayField;
+    }
+
+    // Day
+    //------------------------------------------------------------
+
+    public DateTimeField dayOfWeek() {
+        if (iDayOfWeekField == null) {
+            iDayOfWeekField = LenientDateTimeField.getInstance(super.dayOfWeek());
+        }
+        return iDayOfWeekField;
+    }
+
+    public DateTimeField dayOfMonth() {
+        if (iDayOfMonthField == null) {
+            iDayOfMonthField = LenientDateTimeField.getInstance(super.dayOfMonth());
+        }
+        return iDayOfMonthField;
+    }
+
+    public DateTimeField dayOfYear() {
+        if (iDayOfYearField == null) {
+            iDayOfYearField = LenientDateTimeField.getInstance(super.dayOfYear());
+        }
+        return iDayOfYearField;
+    }
+
+    // Week
+    //------------------------------------------------------------
+
+    public DateTimeField weekOfWeekyear() {
+        if (iWeekOfWeekyearField == null) {
+            iWeekOfWeekyearField = LenientDateTimeField.getInstance(super.weekOfWeekyear());
+        }
+        return iWeekOfWeekyearField;
+    }
+
+    public DateTimeField weekyear() {
+        if (iWeekyearField == null) {
+            iWeekyearField = LenientDateTimeField.getInstance(super.weekyear());
+        }
+        return iWeekyearField;
+    }
+
+    // Month
+    //------------------------------------------------------------
+
+    public DateTimeField monthOfYear() {
+        if (iMonthOfYearField == null) {
+            iMonthOfYearField = LenientDateTimeField.getInstance(super.monthOfYear());
+        }
+        return iMonthOfYearField;
+    }
+
+    // Year
+    //------------------------------------------------------------
+
+    public DateTimeField year() {
+        if (iYearField == null) {
+            iYearField = LenientDateTimeField.getInstance(super.year());
+        }
+        return iYearField;
+    }
+
+    public DateTimeField yearOfEra() {
+        if (iYearOfEraField == null) {
+            iYearOfEraField = LenientDateTimeField.getInstance(super.yearOfEra());
+        }
+        return iYearOfEraField;
+    }
+
+    public DateTimeField yearOfCentury() {
+        if (iYearOfCenturyField == null) {
+            iYearOfCenturyField = LenientDateTimeField.getInstance(super.yearOfCentury());
+        }
+        return iYearOfCenturyField;
+    }
+
+    public DateTimeField centuryOfEra() {
+        if (iCenturyOfEraField == null) {
+            iCenturyOfEraField = LenientDateTimeField.getInstance(super.centuryOfEra());
+        }
+        return iCenturyOfEraField;
+    }
+
+    public DateTimeField era() {
+        if (iEraField == null) {
+            iEraField = LenientDateTimeField.getInstance(super.era());
+        }
+        return iEraField;
+    }
+
+    public String toString() {
+        return "LenientChronology[" + getWrappedChronology().toString() + ']';
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/LenientDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/LenientDateTimeField.java
new file mode 100644
index 000000000..049b577a2
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/LenientDateTimeField.java
@@ -0,0 +1,109 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import org.joda.time.DateTimeField;
+
+/**
+ * Converts a strict DateTimeField into a lenient one. By being lenient, the
+ * set method accepts out of bounds values, performing an addition instead.
+ * <p>
+ * LenientDateTimeField is thread-safe and immutable.
+ *
+ * @author Brian S O'Neill
+ * @see StrictDateTimeField
+ */
+public class LenientDateTimeField extends DelegatedDateTimeField {
+
+    static final long serialVersionUID = 8714085824173290599L;
+
+    /**
+     * Returns a lenient version of the given field. If it is already lenient,
+     * then it is returned as-is. Otherwise, a new LenientDateTimeField is
+     * returned.
+     */
+    public static DateTimeField getInstance(DateTimeField field) {
+        if (field == null) {
+            return null;
+        }
+        if (field instanceof StrictDateTimeField) {
+            field = ((StrictDateTimeField)field).getWrappedField();
+        }
+        if (field.isLenient()) {
+            return field;
+        }
+        return new LenientDateTimeField(field);
+    }
+
+    protected LenientDateTimeField(DateTimeField field) {
+        super(field);
+    }
+
+    public final boolean isLenient() {
+        return true;
+    }
+
+    /**
+     * Set values which may be out of bounds. If the value is out of bounds,
+     * the instant is first set to the minimum allowed value, and then the
+     * difference is added.
+     */
+    public long set(long instant, int value) {
+        int min = getMinimumValue(instant);
+        if (value >= min && value < getMaximumValue(instant)) {
+            return super.set(instant, value);
+        }
+        return add(super.set(instant, min), value - min);
+    }
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java b/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java
new file mode 100644
index 000000000..cc60446e0
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java
@@ -0,0 +1,830 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.Serializable;
+
+import java.util.HashMap;
+import java.util.Locale;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTime;
+import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeZone;
+import org.joda.time.DurationField;
+import org.joda.time.MutableDateTime;
+import org.joda.time.ReadableDateTime;
+import org.joda.time.format.DateTimePrinter;
+import org.joda.time.format.ISODateTimeFormat;
+
+/**
+ * Imposes limits on the range of instants that the fields within a Chronology
+ * may support. The limits are applied to both DateTimeFields and
+ * DurationFields.
+ * <p>
+ * Methods in DateTimeField and DurationField throw an IllegalArgumentException
+ * whenever given an input instant that is outside the limits or when an
+ * attempt is made to move an instant outside the limits.
+ * <p>
+ * LimitChronology is thread-safe and immutable.
+ *
+ * @author Brian S O'Neill
+ * @author Stephen Colebourne
+ * @since 1.0
+ */
+public class LimitChronology extends Chronology {
+
+    static final long serialVersionUID = 7670866536893052522L;
+
+    private final Chronology iChronology;
+
+    final DateTime iLowerLimit;
+    final DateTime iUpperLimit;
+
+    private transient LimitChronology iWithUTC;
+
+    private transient DurationField iErasField;
+    private transient DurationField iCenturiesField;
+    private transient DurationField iYearsField;
+    private transient DurationField iMonthsField;
+    private transient DurationField iWeekyearsField;
+    private transient DurationField iWeeksField;
+    private transient DurationField iDaysField;
+
+    private transient DurationField iHoursField;
+    private transient DurationField iMinutesField;
+    private transient DurationField iSecondsField;
+    private transient DurationField iMillisField;
+
+    private transient DateTimeField iYearField;
+    private transient DateTimeField iYearOfEraField;
+    private transient DateTimeField iYearOfCenturyField;
+    private transient DateTimeField iCenturyOfEraField;
+    private transient DateTimeField iEraField;
+    private transient DateTimeField iDayOfWeekField;
+    private transient DateTimeField iDayOfMonthField;
+    private transient DateTimeField iDayOfYearField;
+    private transient DateTimeField iMonthOfYearField;
+    private transient DateTimeField iWeekOfWeekyearField;
+    private transient DateTimeField iWeekyearField;
+
+    private transient DateTimeField iMillisOfSecondField;
+    private transient DateTimeField iMillisOfDayField;
+    private transient DateTimeField iSecondOfMinuteField;
+    private transient DateTimeField iSecondOfDayField;
+    private transient DateTimeField iMinuteOfHourField;
+    private transient DateTimeField iMinuteOfDayField;
+    private transient DateTimeField iHourOfDayField;
+    private transient DateTimeField iHourOfHalfdayField;
+    private transient DateTimeField iClockhourOfDayField;
+    private transient DateTimeField iClockhourOfHalfdayField;
+    private transient DateTimeField iHalfdayOfDayField;
+
+    /**
+     * Wraps another chronology, with datetime limits. When withUTC or
+     * withDateTimeZone is called, the returned LimitChronology instance has
+     * the same limits, except they are time zone adjusted.
+     *
+     * @param lowerLimit  inclusive lower limit, or null if none
+     * @param upperLimit  exclusive upper limit, or null if none
+     * @throws IllegalArgumentException if chronology is null or limits are invalid
+     */
+    public LimitChronology(Chronology chrono,
+                           ReadableDateTime lowerLimit, ReadableDateTime upperLimit) {
+        if (chrono == null) {
+            throw new IllegalArgumentException("Must supply a chronology");
+        }
+
+        iChronology = chrono;
+
+        iLowerLimit = lowerLimit == null ? null : lowerLimit.toDateTime();
+        iUpperLimit = upperLimit == null ? null : upperLimit.toDateTime();
+
+        if (iLowerLimit != null && iUpperLimit != null) {
+            if (!iLowerLimit.isBefore(iUpperLimit)) {
+                throw new IllegalArgumentException
+                    ("The lower limit must be come before than the upper limit");
+            }
+        }
+
+        setFields();
+    }
+
+    private void setFields() {
+        Chronology c = iChronology;
+
+        // Keep a local cache of converted fields so as not to create redundant
+        // objects.
+        HashMap converted = new HashMap();
+
+        // Convert duration fields...
+
+        iErasField = convertField(c.eras(), converted);
+        iCenturiesField = convertField(c.centuries(), converted);
+        iYearsField = convertField(c.years(), converted);
+        iMonthsField = convertField(c.months(), converted);
+        iWeekyearsField = convertField(c.weekyears(), converted);
+        iWeeksField = convertField(c.weeks(), converted);
+        iDaysField = convertField(c.days(), converted);
+
+        iHoursField = convertField(c.hours(), converted);
+        iMinutesField = convertField(c.minutes(), converted);
+        iSecondsField = convertField(c.seconds(), converted);
+        iMillisField = convertField(c.millis(), converted);
+
+        // Convert datetime fields...
+
+        iYearField = convertField(c.year(), converted);
+        iYearOfEraField = convertField(c.yearOfEra(), converted);
+        iYearOfCenturyField = convertField(c.yearOfCentury(), converted);
+        iCenturyOfEraField = convertField(c.centuryOfEra(), converted);
+        iEraField = convertField(c.era(), converted);
+        iDayOfWeekField = convertField(c.dayOfWeek(), converted);
+        iDayOfMonthField = convertField(c.dayOfMonth(), converted);
+        iDayOfYearField = convertField(c.dayOfYear(), converted);
+        iMonthOfYearField = convertField(c.monthOfYear(), converted);
+        iWeekOfWeekyearField = convertField(c.weekOfWeekyear(), converted);
+        iWeekyearField = convertField(c.weekyear(), converted);
+
+        iMillisOfSecondField = convertField(c.millisOfSecond(), converted);
+        iMillisOfDayField = convertField(c.millisOfDay(), converted);
+        iSecondOfMinuteField = convertField(c.secondOfMinute(), converted);
+        iSecondOfDayField = convertField(c.secondOfDay(), converted);
+        iMinuteOfHourField = convertField(c.minuteOfHour(), converted);
+        iMinuteOfDayField = convertField(c.minuteOfDay(), converted);
+        iHourOfDayField = convertField(c.hourOfDay(), converted);
+        iHourOfHalfdayField = convertField(c.hourOfHalfday(), converted);
+        iClockhourOfDayField = convertField(c.clockhourOfDay(), converted);
+        iClockhourOfHalfdayField = convertField(c.clockhourOfHalfday(), converted);
+        iHalfdayOfDayField = convertField(c.halfdayOfDay(), converted);
+    }
+
+    private DurationField convertField(DurationField field, HashMap converted) {
+        if (field == null || !field.isSupported()) {
+            return field;
+        }
+        if (converted.containsKey(field)) {
+            return (DurationField)converted.get(field);
+        }
+        LimitDurationField limitField = new LimitDurationField(field);
+        converted.put(field, limitField);
+        return limitField;
+    }
+
+    private DateTimeField convertField(DateTimeField field, HashMap converted) {
+        if (field == null || !field.isSupported()) {
+            return field;
+        }
+        if (converted.containsKey(field)) {
+            return (DateTimeField)converted.get(field);
+        }
+        LimitDateTimeField limitField =
+            new LimitDateTimeField(field,
+                                   convertField(field.getDurationField(), converted),
+                                   convertField(field.getRangeDurationField(), converted),
+                                   convertField(field.getLeapDurationField(), converted));
+        converted.put(field, limitField);
+        return limitField;
+    }
+
+    /**
+     * Returns the inclusive lower limit instant.
+     * 
+     * @return lower limit
+     */
+    public DateTime getLowerLimit() {
+        return iLowerLimit;
+    }
+
+    /**
+     * Returns the inclusive upper limit instant.
+     * 
+     * @return upper limit
+     */
+    public DateTime getUpperBound() {
+        return iUpperLimit;
+    }
+
+    /**
+     * Gets the wrapped chronology.
+     * 
+     * @return the wrapped Chronology
+     */
+    protected Chronology getWrappedChronology() {
+        return iChronology;
+    }
+
+    /**
+     * If this LimitChronology is already UTC, then this is
+     * returned. Otherwise, a new instance is returned, with the limits
+     * adjusted to the new time zone.
+     */
+    public Chronology withUTC() {
+        return withDateTimeZone(DateTimeZone.UTC);
+    }
+
+    /**
+     * If this LimitChronology has the same time zone as the one given, then
+     * this is returned. Otherwise, a new instance is returned, with the limits
+     * adjusted to the new time zone.
+     */
+    public Chronology withDateTimeZone(DateTimeZone zone) {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        if (zone == getDateTimeZone()) {
+            return this;
+        }
+
+        if (zone == DateTimeZone.UTC && iWithUTC != null) {
+            return iWithUTC;
+        }
+
+        DateTime lowerLimit = iLowerLimit;
+        if (lowerLimit != null) {
+            MutableDateTime mdt = lowerLimit.toMutableDateTime();
+            mdt.moveDateTimeZone(zone);
+            lowerLimit = mdt.toDateTime();
+        }
+
+        DateTime upperLimit = iUpperLimit;
+        if (upperLimit != null) {
+            MutableDateTime mdt = upperLimit.toMutableDateTime();
+            mdt.moveDateTimeZone(zone);
+            upperLimit = mdt.toDateTime();
+        }
+        
+        LimitChronology chrono = new LimitChronology
+            (iChronology.withDateTimeZone(zone), lowerLimit, upperLimit);
+
+        if (zone == DateTimeZone.UTC) {
+            iWithUTC = chrono;
+        }
+
+        return chrono;
+    }
+
+    public DateTimeZone getDateTimeZone() {
+        return iChronology.getDateTimeZone();
+    }
+
+    public long getDateOnlyMillis(long instant) {
+        checkLimits(instant, null);
+        instant = iChronology.getDateOnlyMillis(instant);
+        checkLimits(instant, "resulting");
+        return instant;
+    }
+
+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
+        throws IllegalArgumentException
+    {
+        long instant = iChronology.getDateOnlyMillis(year, monthOfYear, dayOfMonth);
+        checkLimits(instant, "resulting");
+        return instant;
+    }
+
+    public long getTimeOnlyMillis(long instant) {
+        checkLimits(instant, null);
+        instant = iChronology.getTimeOnlyMillis(instant);
+        checkLimits(instant, "resulting");
+        return instant;
+    }
+
+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        long instant = iChronology.getTimeOnlyMillis
+            (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+        checkLimits(instant, "resulting");
+        return instant;
+    }
+
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int millisOfDay)
+        throws IllegalArgumentException
+    {
+        long instant = iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);
+        checkLimits(instant, "resulting");
+        return instant;
+    }
+
+    public long getDateTimeMillis(long instant,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        checkLimits(instant, null);
+        instant = iChronology.getDateTimeMillis
+            (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+        checkLimits(instant, "resulting");
+        return instant;
+    }
+
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        long instant = iChronology.getDateTimeMillis
+            (year, monthOfYear, dayOfMonth,
+             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+        checkLimits(instant, "resulting");
+        return instant;
+    }
+
+    // Milliseconds
+    //------------------------------------------------------------
+
+    public DurationField millis() {
+        return iMillisField;
+    }
+
+    public DateTimeField millisOfSecond() {
+        return iMillisOfSecondField;
+    }
+
+    public DateTimeField millisOfDay() {
+        return iMillisOfDayField;
+    }
+
+    // Seconds
+    //------------------------------------------------------------
+
+    public DurationField seconds() {
+        return iSecondsField;
+    }
+
+    public DateTimeField secondOfMinute() {
+        return iSecondOfMinuteField;
+    }
+
+    public DateTimeField secondOfDay() {
+        return iSecondOfDayField;
+    }
+
+    // Minutes
+    //------------------------------------------------------------
+
+    public DurationField minutes() {
+        return iMinutesField;
+    }
+
+    public DateTimeField minuteOfHour() {
+        return iMinuteOfHourField;
+    }
+
+    public DateTimeField minuteOfDay() {
+        return iMinuteOfDayField;
+    }
+
+    // Hours
+    //------------------------------------------------------------
+
+    public DurationField hours() {
+        return iHoursField;
+    }
+
+    public DateTimeField hourOfDay() {
+        return iHourOfDayField;
+    }
+
+    public DateTimeField clockhourOfDay() {
+        return iClockhourOfDayField;
+    }
+
+    public DateTimeField hourOfHalfday() {
+        return iHourOfHalfdayField;
+    }
+
+    public DateTimeField clockhourOfHalfday() {
+        return iClockhourOfHalfdayField;
+    }
+
+    public DateTimeField halfdayOfDay() {
+        return iHalfdayOfDayField;
+    }
+
+    // Day
+    //------------------------------------------------------------
+
+    public DurationField days() {
+        return iDaysField;
+    }
+
+    public DateTimeField dayOfWeek() {
+        return iDayOfWeekField;
+    }
+
+    public DateTimeField dayOfMonth() {
+        return iDayOfMonthField;
+    }
+
+    public DateTimeField dayOfYear() {
+        return iDayOfYearField;
+    }
+
+    // Week
+    //------------------------------------------------------------
+
+    public DurationField weeks() {
+        return iWeeksField;
+    }
+
+    public DateTimeField weekOfWeekyear() {
+        return iWeekOfWeekyearField;
+    }
+
+    public DurationField weekyears() {
+        return iWeekyearsField;
+    }
+
+    public DateTimeField weekyear() {
+        return iWeekyearField;
+    }
+
+    // Month
+    //------------------------------------------------------------
+
+    public DurationField months() {
+        return iMonthsField;
+    }
+
+    public DateTimeField monthOfYear() {
+        return iMonthOfYearField;
+    }
+
+    // Year
+    //------------------------------------------------------------
+
+    public DurationField years() {
+        return iYearsField;
+    }
+
+    public DateTimeField year() {
+        return iYearField;
+    }
+
+    public DateTimeField yearOfEra() {
+        return iYearOfEraField;
+    }
+
+    public DateTimeField yearOfCentury() {
+        return iYearOfCenturyField;
+    }
+
+    public DurationField centuries() {
+        return iCenturiesField;
+    }
+
+    public DateTimeField centuryOfEra() {
+        return iCenturyOfEraField;
+    }
+
+    public DurationField eras() {
+        return iErasField;
+    }
+
+    public DateTimeField era() {
+        return iEraField;
+    }
+
+    public String toString() {
+        return iChronology.toString();
+    }
+
+    private void readObject(ObjectInputStream in)
+        throws IOException, ClassNotFoundException
+    {
+        in.defaultReadObject();
+        setFields();
+    }
+
+    void checkLimits(long instant, String desc) {
+        DateTime limit;
+        if ((limit = iLowerLimit) != null && instant < limit.getMillis()) {
+            throw new LimitException(desc, true);
+        }
+        if ((limit = iUpperLimit) != null && instant >= limit.getMillis()) {
+            throw new LimitException(desc, false);
+        }
+    }
+
+    /**
+     * Extends IllegalArgumentException such that the exception message is not
+     * generated unless it is actually requested.
+     */
+    private class LimitException extends IllegalArgumentException {
+        static final long serialVersionUID = -5924689995607498581L;
+
+        private final boolean iIsLow;
+
+        LimitException(String desc, boolean isLow) {
+            super(desc);
+            iIsLow = isLow;
+        }
+
+        public String getMessage() {
+            StringBuffer buf = new StringBuffer(85);
+            buf.append("The");
+            String desc = super.getMessage();
+            if (desc != null) {
+                buf.append(' ');
+                buf.append(desc);
+            }
+            buf.append(" instant is ");
+
+            DateTimePrinter p = ISODateTimeFormat.getInstance(getWrappedChronology()).dateTime();
+
+            if (iIsLow) {
+                buf.append("below the supported minimum of ");
+                p.printTo(buf, iLowerLimit);
+            } else {
+                buf.append("above the supported maximum of ");
+                p.printTo(buf, iUpperLimit);
+            }
+            
+            buf.append(" (");
+            buf.append(getWrappedChronology());
+            buf.append(')');
+
+            return buf.toString();
+        }
+
+        public String toString() {
+            return "IllegalArgumentException: " + getMessage();
+        }
+    }
+
+    private class LimitDurationField extends DecoratedDurationField {
+        static final long serialVersionUID = 8049297699408782284L;
+
+        LimitDurationField(DurationField field) {
+            super(field, field.getName());
+        }
+
+        public int getValue(long duration, long instant) {
+            checkLimits(instant, null);
+            return getWrappedField().getValue(duration, instant);
+        }
+
+        public long getValueAsLong(long duration, long instant) {
+            checkLimits(instant, null);
+            return getWrappedField().getValueAsLong(duration, instant);
+        }
+
+        public long getMillis(int value, long instant) {
+            checkLimits(instant, null);
+            return getWrappedField().getMillis(value, instant);
+        }
+
+        public long getMillis(long value, long instant) {
+            checkLimits(instant, null);
+            return getWrappedField().getMillis(value, instant);
+        }
+
+        public long add(long instant, int amount) {
+            checkLimits(instant, null);
+            long result = getWrappedField().add(instant, amount);
+            checkLimits(result, "resulting");
+            return result;
+        }
+
+        public long add(long instant, long amount) {
+            checkLimits(instant, null);
+            long result = getWrappedField().add(instant, amount);
+            checkLimits(result, "resulting");
+            return result;
+        }
+
+        public int getDifference(long minuendInstant, long subtrahendInstant) {
+            checkLimits(minuendInstant, "minuend");
+            checkLimits(subtrahendInstant, "subtrahend");
+            return getWrappedField().getDifference(minuendInstant, subtrahendInstant);
+        }
+
+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+            checkLimits(minuendInstant, "minuend");
+            checkLimits(subtrahendInstant, "subtrahend");
+            return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant);
+        }
+
+    }
+
+    private class LimitDateTimeField extends DecoratedDateTimeField {
+        static final long serialVersionUID = -2435306746995699312L;
+
+        private final DurationField iDurationField;
+        private final DurationField iRangeDurationField;
+        private final DurationField iLeapDurationField;
+
+        LimitDateTimeField(DateTimeField field,
+                           DurationField durationField,
+                           DurationField rangeDurationField,
+                           DurationField leapDurationField) {
+            super(field, field.getName());
+            iDurationField = durationField;
+            iRangeDurationField = rangeDurationField;
+            iLeapDurationField = leapDurationField;
+        }
+
+        public int get(long instant) {
+            checkLimits(instant, null);
+            return getWrappedField().get(instant);
+        }
+        
+        public String getAsText(long instant, Locale locale) {
+            checkLimits(instant, null);
+            return getWrappedField().getAsText(instant, locale);
+        }
+        
+        public String getAsShortText(long instant, Locale locale) {
+            checkLimits(instant, null);
+            return getWrappedField().getAsShortText(instant, locale);
+        }
+        
+        public long add(long instant, int amount) {
+            checkLimits(instant, null);
+            long result = getWrappedField().add(instant, amount);
+            checkLimits(result, "resulting");
+            return result;
+        }
+
+        public long add(long instant, long amount) {
+            checkLimits(instant, null);
+            long result = getWrappedField().add(instant, amount);
+            checkLimits(result, "resulting");
+            return result;
+        }
+
+        public long addWrapped(long instant, int amount) {
+            checkLimits(instant, null);
+            long result = getWrappedField().addWrapped(instant, amount);
+            checkLimits(result, "resulting");
+            return result;
+        }
+        
+        public int getDifference(long minuendInstant, long subtrahendInstant) {
+            checkLimits(minuendInstant, "minuend");
+            checkLimits(subtrahendInstant, "subtrahend");
+            return getWrappedField().getDifference(minuendInstant, subtrahendInstant);
+        }
+        
+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+            checkLimits(minuendInstant, "minuend");
+            checkLimits(subtrahendInstant, "subtrahend");
+            return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant);
+        }
+        
+        public long set(long instant, int value) {
+            checkLimits(instant, null);
+            long result = getWrappedField().set(instant, value);
+            checkLimits(result, "resulting");
+            return result;
+        }
+        
+        public long set(long instant, String text, Locale locale) {
+            checkLimits(instant, null);
+            long result = getWrappedField().set(instant, text, locale);
+            checkLimits(result, "resulting");
+            return result;
+        }
+        
+        public final DurationField getDurationField() {
+            return iDurationField;
+        }
+
+        public final DurationField getRangeDurationField() {
+            return iRangeDurationField;
+        }
+
+        public boolean isLeap(long instant) {
+            checkLimits(instant, null);
+            return getWrappedField().isLeap(instant);
+        }
+        
+        public int getLeapAmount(long instant) {
+            checkLimits(instant, null);
+            return getWrappedField().getLeapAmount(instant);
+        }
+        
+        public final DurationField getLeapDurationField() {
+            return iLeapDurationField;
+        }
+        
+        public long roundFloor(long instant) {
+            checkLimits(instant, null);
+            long result = getWrappedField().roundFloor(instant);
+            checkLimits(result, "resulting");
+            return result;
+        }
+        
+        public long roundCeiling(long instant) {
+            checkLimits(instant, null);
+            long result = getWrappedField().roundCeiling(instant);
+            checkLimits(result, "resulting");
+            return result;
+        }
+        
+        public long roundHalfFloor(long instant) {
+            checkLimits(instant, null);
+            long result = getWrappedField().roundHalfFloor(instant);
+            checkLimits(result, "resulting");
+            return result;
+        }
+        
+        public long roundHalfCeiling(long instant) {
+            checkLimits(instant, null);
+            long result = getWrappedField().roundHalfCeiling(instant);
+            checkLimits(result, "resulting");
+            return result;
+        }
+        
+        public long roundHalfEven(long instant) {
+            checkLimits(instant, null);
+            long result = getWrappedField().roundHalfEven(instant);
+            checkLimits(result, "resulting");
+            return result;
+        }
+        
+        public long remainder(long instant) {
+            checkLimits(instant, null);
+            long result = getWrappedField().remainder(instant);
+            checkLimits(result, "resulting");
+            return result;
+        }
+
+        public int getMinimumValue(long instant) {
+            checkLimits(instant, null);
+            return getWrappedField().getMinimumValue(instant);
+        }
+
+        public int getMaximumValue(long instant) {
+            checkLimits(instant, null);
+            return getWrappedField().getMaximumValue(instant);
+        }
+
+        public int getMaximumTextLength(Locale locale) {
+            return getWrappedField().getMaximumTextLength(locale);
+        }
+
+        public int getMaximumShortTextLength(Locale locale) {
+            return getWrappedField().getMaximumShortTextLength(locale);
+        }
+
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/LimitDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/LimitDateTimeField.java
deleted file mode 100644
index 7b45383e5..000000000
--- a/JodaTime/src/java/org/joda/time/chrono/LimitDateTimeField.java
+++ /dev/null
@@ -1,306 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-03 Stephen Colebourne.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono;
-
-import java.util.Locale;
-
-import org.joda.time.DateTimeField;
-
-/**
- * Generic limiting datetime field.
- * <p>
- * This DateTimeField allows specific millisecond boundaries to be applied 
- * to DateTimeFields.
- *
- * @author Stephen Colebourne
- * @author Brian S O'Neill
- * @since 1.0
- */
-public class LimitDateTimeField extends DateTimeField {
-
-    /** The field to wrap */
-    private final DateTimeField iField;
-    /** The lower boundary in millis */
-    private final long iLowerBound;
-    /** The upper boundary in millis */
-    private final long iUpperBound;
-
-    /**
-     * Constructor
-     * 
-     * @param name  short, descriptive name, like "secondOfMinute".
-     * @param lowerBound  milliseconds to form the lower boundary inclusive
-     * @param upperBound  milliseconds to form the upper boundary inclusive
-     * @throws IllegalArgumentException if field is null or boundary is invalid
-     */
-    public LimitDateTimeField(String name, DateTimeField field, long lowerBound, long upperBound) {
-        super(name);
-                
-        if (field == null) {
-            throw new IllegalArgumentException("The field must not be null");
-        }
-        if (lowerBound >= upperBound) {
-            throw new IllegalArgumentException("The lowerBound must be less than the upperBound");
-        }
-        iField = field;
-        iLowerBound = lowerBound;
-        iUpperBound = upperBound;
-    }
-
-    /**
-     * Get the amount of fractional units from the specified time instant.
-     * 
-     * @param millis  the time instant in millis to query.
-     * @return the amount of fractional units extracted from the input.
-     */
-    public int get(long millis) {
-        checkBounds(millis, "value");
-        return iField.get(millis);
-    }
-
-    public String getAsText(long millis, Locale locale) {
-        checkBounds(millis, "value");
-        return iField.getAsText(millis, locale);
-    }
-
-    public String getAsShortText(long millis, Locale locale) {
-        checkBounds(millis, "value");
-        return iField.getAsShortText(millis, locale);
-    }
-
-    /**
-     * Add the specified amount of fractional units to the specified time
-     * instant. The amount added may be negative.
-     * 
-     * @param millis  the time instant in millis to update.
-     * @param amount  the amount of fractional units to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long add(long millis, int amount) {
-        checkBounds(millis, "value");
-        long result = iField.add(millis, amount);
-        checkBounds(millis, "result");
-        return result;
-    }
-
-    /**
-     * Add the specified amount of fractional units to the specified time
-     * instant. The amount added may be negative.
-     * 
-     * @param millis  the time instant in millis to update.
-     * @param amount  the amount of fractional units to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long add(long millis, long amount) {
-        checkBounds(millis, "value");
-        long result = iField.add(millis, amount);
-        checkBounds(millis, "result");
-        return result;
-    }
-
-    /**
-     * Add to the fractional component of the specified time instant,
-     * wrapping around within that component if necessary.
-     * 
-     * @param millis  the time instant in millis to update.
-     * @param amount  the amount of fractional units to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long addWrapped(long millis, int amount) {
-        checkBounds(millis, "value");
-        long result = iField.addWrapped(millis, amount);
-        checkBounds(millis, "result");
-        return result;
-    }
-
-    public long getDifference(long minuendMillis, long subtrahendMillis) {
-        checkBounds(minuendMillis, "minuend");
-        checkBounds(subtrahendMillis, "subtrahend");
-        return iField.getDifference(minuendMillis, subtrahendMillis);
-    }
-
-    /**
-     * Set the specified amount of fractional units to the specified time instant.
-     * 
-     * @param millis  the time instant in millis to update.
-     * @param value  value of fractional units to set.
-     * @return the updated time instant.
-     * @throws IllegalArgumentException if value is too large or too small.
-     */
-    public long set(long millis, int value) {
-        checkBounds(millis, "value");
-        long result = iField.set(millis, value);
-        checkBounds(millis, "result");
-        return result;
-    }
-
-    public long set(long millis, String text, Locale locale) {
-        checkBounds(millis, "value");
-        long result = iField.set(millis, text, locale);
-        checkBounds(millis, "result");
-        return result;
-    }
-
-    public long getUnitMillis() {
-        return iField.getUnitMillis();
-    }
-
-    public long getRangeMillis() {
-        return iField.getRangeMillis();
-    }
-
-    /**
-     * Get the minimum value for the field.
-     * 
-     * @return the minimum value
-     */
-    public int getMinimumValue() {
-        return iField.getMinimumValue();
-    }
-
-    /**
-     * Get the maximum value for the field.
-     * 
-     * @return the maximum value
-     */
-    public int getMaximumValue() {
-        return iField.getMaximumValue();
-    }
-
-    public int getMaximumTextLength(Locale locale) {
-        return iField.getMaximumTextLength(locale);
-    }
-
-    public int getMaximumShortTextLength(Locale locale) {
-        return iField.getMaximumShortTextLength(locale);
-    }
-
-    public long roundFloor(long millis) {
-        checkBounds(millis, "value");
-        long result = iField.roundFloor(millis);
-        checkBounds(millis, "result");
-        return result;
-    }
-
-    public long roundCeiling(long millis) {
-        checkBounds(millis, "value");
-        long result = iField.roundCeiling(millis);
-        checkBounds(millis, "result");
-        return result;
-    }
-
-    public long roundHalfFloor(long millis) {
-        checkBounds(millis, "value");
-        long result = iField.roundHalfFloor(millis);
-        checkBounds(millis, "result");
-        return result;
-    }
-
-    public long roundHalfCeiling(long millis) {
-        checkBounds(millis, "value");
-        long result = iField.roundHalfCeiling(millis);
-        checkBounds(millis, "result");
-        return result;
-    }
-
-    public long roundHalfEven(long millis) {
-        checkBounds(millis, "value");
-        long result = iField.roundHalfEven(millis);
-        checkBounds(millis, "result");
-        return result;
-    }
-
-    public long remainder(long millis) {
-        checkBounds(millis, "value");
-        long result = iField.remainder(millis);
-        checkBounds(millis, "result");
-        return result;
-    }
-
-   /**
-     * Returns the DateTimeField being wrapped.
-     * 
-     * @return field
-     */
-    public DateTimeField getField() {
-        return iField;
-    }
-
-    /**
-     * Returns the milliseconds lower bound.
-     * 
-     * @return lower bound
-     */
-    public long getLowerBound() {
-        return iLowerBound;
-    }
-
-    /**
-     * Returns the milliseconds upper bound.
-     * 
-     * @return upper bound
-     */
-    public long getUpperBound() {
-        return iUpperBound;
-    }
-
-    private void checkBounds(long millis, String desc) {
-        if (millis < iLowerBound) {
-            throw new IllegalArgumentException("The millisecond " + desc + " is below the minimum");
-        }
-        if (millis > iUpperBound) {
-            throw new IllegalArgumentException("The millisecond " + desc + " is above the maximum");
-        }
-    }
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/MillisDurationField.java b/JodaTime/src/java/org/joda/time/chrono/MillisDurationField.java
new file mode 100644
index 000000000..28a4b5de0
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/MillisDurationField.java
@@ -0,0 +1,187 @@
+/* 
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import java.io.Serializable;
+import org.joda.time.DurationField;
+
+/**
+ * Duration field class representing a field with a fixed unit length of one
+ * millisecond.
+ * <p>
+ * MillisDurationField is thread-safe and immutable.
+ *
+ * @author Brian S O'Neill
+ */
+public final class MillisDurationField implements DurationField, Serializable {
+    
+    static final long serialVersionUID = 2656707858124633367L;
+
+    public static final DurationField INSTANCE = new MillisDurationField();
+
+    private MillisDurationField() {
+    }
+    
+    //------------------------------------------------------------------------
+    public String getName() {
+        return "millis";
+    }
+
+    /**
+     * @return true always
+     */
+    public boolean isSupported() {
+        return true;
+    }
+
+    /**
+     * This field is precise.
+     * 
+     * @return true always
+     */
+    public final boolean isPrecise() {
+        return true;
+    }
+    
+    /**
+     * Returns the amount of milliseconds per unit value of this field.
+     *
+     * @return one always
+     */
+    public final long getUnitMillis() {
+        return 1;
+    }
+
+    //------------------------------------------------------------------------
+    public int getValue(long duration) {
+        return Utils.safeToInt(duration);
+    }
+
+    public long getValueAsLong(long duration) {
+        return duration;
+    }
+
+    public int getValue(long duration, long instant) {
+        return Utils.safeToInt(duration);
+    }
+
+    public long getValueAsLong(long duration, long instant) {
+        return duration;
+    }
+
+    public long getMillis(int value) {
+        return value;
+    }
+
+    public long getMillis(long value) {
+        return value;
+    }
+
+    public long getMillis(int value, long instant) {
+        return value;
+    }
+
+    public long getMillis(long value, long instant) {
+        return value;
+    }
+
+    public long add(long instant, int value) {
+        return instant + value;
+    }
+
+    public long add(long instant, long value) {
+        return instant + value;
+    }
+
+    public int getDifference(long minuendInstant, long subtrahendInstant) {
+        return Utils.safeToInt(minuendInstant - subtrahendInstant);
+    }
+
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        return minuendInstant - subtrahendInstant;
+    }
+
+    //------------------------------------------------------------------------
+    public int compareTo(Object durationField) {
+        DurationField otherField = (DurationField) durationField;
+        long otherMillis = otherField.getUnitMillis();
+        long thisMillis = getUnitMillis();
+        // cannot do (thisMillis - otherMillis) as can overflow
+        if (thisMillis == otherMillis) {
+            return 0;
+        }
+        if (thisMillis < otherMillis) {
+            return -1;
+        } else {
+            return 1;
+        }
+    }
+
+    /**
+     * Get a suitable debug string.
+     * 
+     * @return debug string
+     */
+    public String toString() {
+        return "DurationField[" + getName() + ']';
+    }
+
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return INSTANCE;
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/NonZeroDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/NonZeroDateTimeField.java
index c074234b1..ba14ded77 100644
--- a/JodaTime/src/java/org/joda/time/chrono/NonZeroDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/NonZeroDateTimeField.java
@@ -54,72 +54,80 @@
 package org.joda.time.chrono;
 
 import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
 
 /**
  * Wraps another field such that zero values are replaced with one more than
  * it's maximum. This is particularly useful for implementing an clockhourOfDay
  * field, where the midnight value of 0 is replaced with 24.
+ * <p>
+ * NonZeroDateTimeField is thread-safe and immutable.
  *
  * @author Brian S O'Neill
  * @since 1.0
  */
-public final class NonZeroDateTimeField extends DateTimeField {
-    private final DateTimeField iField;
+public final class NonZeroDateTimeField extends DecoratedDateTimeField {
+
+    static final long serialVersionUID = 961749798233026866L;
 
     /**
      * @param name  short, descriptive name, like "clockhourOfDay".
      * @throws IllegalArgumentException if wrapped field's minimum value is not zero
      */
-    public NonZeroDateTimeField(String name, DateTimeField field) {
-        super(name);
-        if (field == null) {
-            throw new IllegalArgumentException("The field must not be null");
-        }
+    public NonZeroDateTimeField(DateTimeField field, String name) {
+        super(field, name);
         if (field.getMinimumValue() != 0) {
             throw new IllegalArgumentException("Wrapped field's minumum value must be zero");
         }
-        iField = field;
     }
 
-    public int get(long millis) {
-        int value = iField.get(millis);
+    public int get(long instant) {
+        int value = getWrappedField().get(instant);
         if (value == 0) {
             value = getMaximumValue();
         }
         return value;
     }
 
-    public long add(long millis, int amount) {
-        return iField.add(millis, amount);
+    public long add(long instant, int value) {
+        return getWrappedField().add(instant, value);
+    }
+
+    public long add(long instant, long value) {
+        return getWrappedField().add(instant, value);
     }
 
-    public long add(long millis, long amount) {
-        return iField.add(millis, amount);
+    public long addWrapped(long instant, int value) {
+        return getWrappedField().addWrapped(instant, value);
     }
 
-    public long addWrapped(long millis, int amount) {
-        return iField.addWrapped(millis, amount);
+    public int getDifference(long minuendInstant, long subtrahendInstant) {
+        return getWrappedField().getDifference(minuendInstant, subtrahendInstant);
     }
-    
-    public long getDifference(long minuendMillis, long subtrahendMillis) {
-        return iField.getDifference(minuendMillis, subtrahendMillis);
+
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant);
     }
 
-    public long set(long millis, int value) {
+    public long set(long instant, int value) {
         int max = getMaximumValue();
-        verifyValueBounds(value, 1, max);
+        Utils.verifyValueBounds(this, value, 1, max);
         if (value == max) {
             value = 0;
         }
-        return iField.set(millis, value);
+        return getWrappedField().set(instant, value);
+    }
+
+    public boolean isLeap(long instant) {
+        return getWrappedField().isLeap(instant);
     }
 
-    public long getUnitMillis() {
-        return iField.getUnitMillis();
+    public int getLeapAmount(long instant) {
+        return getWrappedField().getLeapAmount(instant);
     }
 
-    public long getRangeMillis() {
-        return iField.getRangeMillis();
+    public DurationField getLeapDurationField() {
+        return getWrappedField().getLeapDurationField();
     }
 
     /**
@@ -136,7 +144,7 @@ public int getMinimumValue() {
      * 
      * @return the minimum value of 1
      */
-    public int getMinimumValue(long millis) {
+    public int getMinimumValue(long instant) {
         return 1;
     }
 
@@ -147,7 +155,7 @@ public int getMinimumValue(long millis) {
      * @return the maximum value
      */
     public int getMaximumValue() {
-        return iField.getMaximumValue() + 1;
+        return getWrappedField().getMaximumValue() + 1;
     }
 
     /**
@@ -156,28 +164,32 @@ public int getMaximumValue() {
      * 
      * @return the maximum value
      */
-    public int getMaximumValue(long millis) {
-        return iField.getMaximumValue(millis) + 1;
+    public int getMaximumValue(long instant) {
+        return getWrappedField().getMaximumValue(instant) + 1;
     }
 
-    public long roundFloor(long millis) {
-        return iField.roundFloor(millis);
+    public long roundFloor(long instant) {
+        return getWrappedField().roundFloor(instant);
     }
 
-    public long roundCeiling(long millis) {
-        return iField.roundCeiling(millis);
+    public long roundCeiling(long instant) {
+        return getWrappedField().roundCeiling(instant);
     }
 
-    public long remainder(long millis) {
-        return iField.remainder(millis);
+    public long roundHalfFloor(long instant) {
+        return getWrappedField().roundHalfFloor(instant);
     }
 
-    /**
-     * Returns the DateTimeField being wrapped.
-     * 
-     * @return field
-     */
-    public DateTimeField getField() {
-        return iField;
+    public long roundHalfCeiling(long instant) {
+        return getWrappedField().roundHalfCeiling(instant);
+    }
+
+    public long roundHalfEven(long instant) {
+        return getWrappedField().roundHalfEven(instant);
     }
+
+    public long remainder(long instant) {
+        return getWrappedField().remainder(instant);
+    }
+
 }
diff --git a/JodaTime/src/java/org/joda/time/chrono/OffsetDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/OffsetDateTimeField.java
index 47ca9e170..80ab50a4e 100644
--- a/JodaTime/src/java/org/joda/time/chrono/OffsetDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/OffsetDateTimeField.java
@@ -54,16 +54,19 @@
 package org.joda.time.chrono;
 
 import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
 
 /**
  * Generic offset adjusting datetime field.
+ * <p>
+ * OffsetDateTimeField is thread-safe and immutable.
  * 
  * @author Brian S O'Neill
  * @since 1.0
  */
-public class OffsetDateTimeField extends DateTimeField {
-    /** The field to adjust */
-    private final DateTimeField iField;
+public class OffsetDateTimeField extends DecoratedDateTimeField {
+    static final long serialVersionUID = 3145790132623583142L;
+
     private final int iOffset;
 
     private final int iMin;
@@ -72,46 +75,42 @@
     /**
      * Constructor
      * 
-     * @param name  short, descriptive name, like "offsetYear".
      * @param field  the field to wrap, like "year()".
+     * @param name  short, descriptive name, like "offsetYear".
      * @param offset  offset to add to field values
      * @throws IllegalArgumentException if offset is zero
      */
-    public OffsetDateTimeField(String name, DateTimeField field, int offset) {
-        this(name, field, offset, Integer.MIN_VALUE, Integer.MAX_VALUE);
+    public OffsetDateTimeField(DateTimeField field, String name, int offset) {
+        this(field, name, offset, Integer.MIN_VALUE, Integer.MAX_VALUE);
     }
 
     /**
      * Constructor
      * 
-     * @param name  short, descriptive name, like "offsetYear".
      * @param field  the field to wrap, like "year()".
+     * @param name  short, descriptive name, like "offsetYear".
      * @param offset  offset to add to field values
      * @param minValue  minimum allowed value
      * @param maxValue  maximum allowed value
      * @throws IllegalArgumentException if offset is zero
      */
-    public OffsetDateTimeField(String name, DateTimeField field, int offset,
+    public OffsetDateTimeField(DateTimeField field, String name, int offset,
                                int minValue, int maxValue) {
-        super(name);
+        super(field, name);
                 
-        if (field == null) {
-            throw new IllegalArgumentException("The field must not be null");
-        }
         if (offset == 0) {
             throw new IllegalArgumentException("The offset cannot be zero");
         }
 
-        iField = field;
         iOffset = offset;
 
-        if (minValue < (iField.getMinimumValue() + offset)) {
-            iMin = iField.getMinimumValue() + offset;
+        if (minValue < (field.getMinimumValue() + offset)) {
+            iMin = field.getMinimumValue() + offset;
         } else {
             iMin = minValue;
         }
-        if (maxValue > (iField.getMaximumValue() + offset)) {
-            iMax = iField.getMaximumValue() + offset;
+        if (maxValue > (field.getMaximumValue() + offset)) {
+            iMax = field.getMaximumValue() + offset;
         } else {
             iMax = maxValue;
         }
@@ -120,76 +119,76 @@ public OffsetDateTimeField(String name, DateTimeField field, int offset,
     /**
      * Get the amount of offset units from the specified time instant.
      * 
-     * @param millis  the time instant in millis to query.
+     * @param instant  the time instant in millis to query.
      * @return the amount of units extracted from the input.
      */
-    public int get(long millis) {
-        return iField.get(millis) + iOffset;
+    public int get(long instant) {
+        return super.get(instant) + iOffset;
     }
 
     /**
      * Add the specified amount of offset units to the specified time
      * instant. The amount added may be negative.
      * 
-     * @param millis  the time instant in millis to update.
+     * @param instant  the time instant in millis to update.
      * @param amount  the amount of units to add (can be negative).
      * @return the updated time instant.
      */
-    public long add(long millis, int amount) {
-        millis = iField.add(millis, amount);
-        verifyValueBounds(get(millis), iMin, iMax);
-        return millis;
+    public long add(long instant, int amount) {
+        instant = super.add(instant, amount);
+        Utils.verifyValueBounds(this, get(instant), iMin, iMax);
+        return instant;
     }
 
     /**
      * Add the specified amount of offset units to the specified time
      * instant. The amount added may be negative.
      * 
-     * @param millis  the time instant in millis to update.
+     * @param instant  the time instant in millis to update.
      * @param amount  the amount of units to add (can be negative).
      * @return the updated time instant.
      */
-    public long add(long millis, long amount) {
-        millis = iField.add(millis, amount);
-        verifyValueBounds(get(millis), iMin, iMax);
-        return millis;
+    public long add(long instant, long amount) {
+        instant = super.add(instant, amount);
+        Utils.verifyValueBounds(this, get(instant), iMin, iMax);
+        return instant;
     }
 
     /**
      * Add to the offset component of the specified time instant,
      * wrapping around within that component if necessary.
      * 
-     * @param millis  the time instant in millis to update.
+     * @param instant  the time instant in millis to update.
      * @param amount  the amount of units to add (can be negative).
      * @return the updated time instant.
      */
-    public long addWrapped(long millis, int amount) {
-        return set(millis, getWrappedValue(get(millis), amount, iMin, iMax));
-    }
-
-    public long getDifference(long minuendMillis, long subtrahendMillis) {
-        return iField.getDifference(minuendMillis, subtrahendMillis);
+    public long addWrapped(long instant, int amount) {
+        return set(instant, Utils.getWrappedValue(get(instant), amount, iMin, iMax));
     }
 
     /**
      * Set the specified amount of offset units to the specified time instant.
      * 
-     * @param millis  the time instant in millis to update.
+     * @param instant  the time instant in millis to update.
      * @param value  value of units to set.
      * @return the updated time instant.
      * @throws IllegalArgumentException if value is too large or too small.
      */
-    public long set(long millis, int value) {
-        verifyValueBounds(value, iMin, iMax);
-        return iField.set(millis, value - iOffset);
+    public long set(long instant, int value) {
+        Utils.verifyValueBounds(this, value, iMin, iMax);
+        return super.set(instant, value - iOffset);
     }
 
-    public long getUnitMillis() {
-        return iField.getUnitMillis();
+    public boolean isLeap(long instant) {
+        return getWrappedField().isLeap(instant);
     }
 
-    public long getRangeMillis() {
-        return iField.getRangeMillis();
+    public int getLeapAmount(long instant) {
+        return getWrappedField().getLeapAmount(instant);
+    }
+
+    public DurationField getLeapDurationField() {
+        return getWrappedField().getLeapDurationField();
     }
 
     /**
@@ -210,29 +209,28 @@ public int getMaximumValue() {
         return iMax;
     }
     
-    public long roundFloor(long millis) {
-        return iField.roundFloor(millis);
+    public long roundFloor(long instant) {
+        return getWrappedField().roundFloor(instant);
     }
 
-    public long roundCeiling(long millis) {
-        return iField.roundCeiling(millis);
+    public long roundCeiling(long instant) {
+        return getWrappedField().roundCeiling(instant);
     }
 
-    public long roundHalfFloor(long millis) {
-        return iField.roundHalfFloor(millis);
+    public long roundHalfFloor(long instant) {
+        return getWrappedField().roundHalfFloor(instant);
     }
 
-    public long remainder(long millis) {
-        return iField.remainder(millis);
+    public long roundHalfCeiling(long instant) {
+        return getWrappedField().roundHalfCeiling(instant);
     }
 
-    /**
-     * Returns the DateTimeField being wrapped.
-     * 
-     * @return field
-     */
-    public DateTimeField getField() {
-        return iField;
+    public long roundHalfEven(long instant) {
+        return getWrappedField().roundHalfEven(instant);
+    }
+
+    public long remainder(long instant) {
+        return getWrappedField().remainder(instant);
     }
 
     /**
diff --git a/JodaTime/src/java/org/joda/time/chrono/PreciseDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/PreciseDateTimeField.java
new file mode 100644
index 000000000..d159c06e3
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/PreciseDateTimeField.java
@@ -0,0 +1,170 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import org.joda.time.DurationField;
+
+/**
+ * Precise datetime field, composed of two precise duration fields.
+ * <p>
+ * This DateTimeField is useful for defining DateTimeFields that are composed
+ * of precise durations, like time of day fields. If either duration field is
+ * imprecise, then an {@link ImpreciseDateTimeField} may be used instead.
+ * <p>
+ * PreciseDateTimeField is thread-safe and immutable.
+ *
+ * @author Brian S O'Neill
+ * @author Stephen Colebourne
+ * @since 1.0
+ * @see ImpreciseDateTimeField
+ */
+public class PreciseDateTimeField extends PreciseDurationDateTimeField {
+
+    static final long serialVersionUID = -5586801265774496376L;
+
+    /** The maximum range in the correct units */
+    private final int iRange;
+
+    private final DurationField iRangeField;
+
+    /**
+     * Constructor.
+     * 
+     * @param name  short, descriptive name, like "secondOfMinute".
+     * @param unit  precise unit duration, like "seconds()".
+     * @param range precise range duration, preferably a multiple of the unit,
+     * like "minutes()".
+     * @throws IllegalArgumentException if either duration field is imprecise
+     * @throws IllegalArgumentException if unit milliseconds is less than one
+     * or effective value range is less than two.
+     */
+    public PreciseDateTimeField(String name,
+                                DurationField unit, DurationField range) {
+        super(name, unit);
+
+        if (!range.isPrecise()) {
+            throw new IllegalArgumentException("Range duration field must be precise");
+        }
+
+        long rangeMillis = range.getUnitMillis();
+        iRange = (int)(rangeMillis / getUnitMillis());
+        if (iRange < 2) {
+            throw new IllegalArgumentException("The effective range must be at least 2");
+        }
+
+        iRangeField = range;
+    }
+
+    /**
+     * Get the amount of fractional units from the specified time instant.
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
+     * @return the amount of fractional units extracted from the input.
+     */
+    public int get(long instant) {
+        if (instant >= 0) {
+            return (int) ((instant / getUnitMillis()) % iRange);
+        } else {
+            return iRange - 1 + (int) (((instant + 1) / getUnitMillis()) % iRange);
+        }
+    }
+
+    /**
+     * Add to the component of the specified time instant, wrapping around
+     * within that component if necessary.
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
+     * @param amount  the amount of units to add (can be negative).
+     * @return the updated time instant.
+     */
+    public long addWrapped(long instant, int amount) {
+        int thisValue = get(instant);
+        int wrappedValue = Utils.getWrappedValue
+            (thisValue, amount, getMinimumValue(), getMaximumValue());
+        // copy code from set() to avoid repeat call to get()
+        return instant + (wrappedValue - thisValue) * getUnitMillis();
+    }
+
+    /**
+     * Returns the range duration of this field. For example, if this field
+     * represents "minute of hour", then the range duration field is an hours.
+     *
+     * @return the range duration of this field, or null if field has no range
+     */
+    public DurationField getRangeDurationField() {
+        return iRangeField;
+    }
+
+    /**
+     * Get the maximum value for the field.
+     * 
+     * @return the maximum value
+     */
+    public int getMaximumValue() {
+        return iRange - 1;
+    }
+    
+    /**
+     * Returns the range of the field in the field's units.
+     * <p>
+     * For example, 60 for seconds per minute. The field is allowed values
+     * from 0 to range - 1.
+     * 
+     * @return unit range
+     */
+    public int getRange() {
+        return iRange;
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/PreciseDurationDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/PreciseDurationDateTimeField.java
new file mode 100644
index 000000000..a670d6f5c
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/PreciseDurationDateTimeField.java
@@ -0,0 +1,225 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+
+package org.joda.time.chrono;
+
+import org.joda.time.DurationField;
+
+/**
+ * Precise datetime field, which has a precise unit duration field.
+ * <p>
+ * PreciseDurationDateTimeField is thread-safe and immutable, and its
+ * subclasses must be as well.
+ *
+ * @author Brian S O'Neill
+ */
+public abstract class PreciseDurationDateTimeField extends AbstractDateTimeField {
+
+    static final long serialVersionUID = 5004523158306266035L;
+
+    /** The fractional unit in millis */
+    private final long iUnitMillis;
+
+    private final DurationField iUnitField;
+
+    /**
+     * Constructor.
+     * 
+     * @param name  short, descriptive name, like "dayOfMonth".
+     * @param unit  precise unit duration, like "days()".
+     * @throws IllegalArgumentException if duration field is imprecise
+     * @throws IllegalArgumentException if unit milliseconds is less than one
+     */
+    public PreciseDurationDateTimeField(String name, DurationField unit) {
+        super(name);
+
+        if (!unit.isPrecise()) {
+            throw new IllegalArgumentException("Unit duration field must be precise");
+        }
+
+        iUnitMillis = unit.getUnitMillis();
+        if (iUnitMillis < 1) {
+            throw new IllegalArgumentException("The unit milliseconds must be at least 1");
+        }
+
+        iUnitField = unit;
+    }
+
+    /**
+     * Returns false by default.
+     */
+    public boolean isLenient() {
+        return false;
+    }
+
+    /**
+     * Add the specified amount of units to the specified time instant. The
+     * amount added may be negative.
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
+     * @param amount  the amount of units to add (can be negative).
+     * @return the updated time instant.
+     */
+    public long add(long instant, int amount) {
+        return instant + amount * iUnitMillis;
+    }
+
+    /**
+     * Add the specified amount of units to the specified time instant. The
+     * amount added may be negative.
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to
+     * @param amount  the amount of units to add (can be negative).
+     * @return the updated time instant.
+     */
+    public long add(long instant, long amount) {
+        return instant + amount * iUnitMillis;
+    }
+
+    public int getDifference(long minuendInstant, long subtrahendInstant) {
+        return Utils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));
+    }
+
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        return (minuendInstant - subtrahendInstant) / iUnitMillis;
+    }
+
+    /**
+     * Set the specified amount of units to the specified time instant.
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in
+     * @param value  value of units to set.
+     * @return the updated time instant.
+     * @throws IllegalArgumentException if value is too large or too small.
+     */
+    public long set(long instant, int value) {
+        Utils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValue());
+        return instant + (value - get(instant)) * iUnitMillis;
+    }
+
+    /**
+     * This method assumes that this field is properly rounded on
+     * 1970-01-01T00:00:00. If the rounding alignment differs, override this
+     * method as follows:
+     * <pre>
+     * return super.roundFloor(instant + ALIGNMENT_MILLIS) - ALIGNMENT_MILLIS;
+     * </pre>
+     */
+    public long roundFloor(long instant) {
+        if (instant >= 0) {
+            return instant - instant % iUnitMillis;
+        } else {
+            instant += 1;
+            return instant - instant % iUnitMillis - iUnitMillis;
+        }
+    }
+
+    /**
+     * This method assumes that this field is properly rounded on
+     * 1970-01-01T00:00:00. If the rounding alignment differs, override this
+     * method as follows:
+     * <pre>
+     * return super.roundCeiling(instant + ALIGNMENT_MILLIS) - ALIGNMENT_MILLIS;
+     * </pre>
+     */
+    public long roundCeiling(long instant) {
+        if (instant >= 0) {
+            instant -= 1;
+            return instant - instant % iUnitMillis + iUnitMillis;
+        } else {
+            return instant - instant % iUnitMillis;
+        }
+    }
+
+    /**
+     * This method assumes that this field is properly rounded on
+     * 1970-01-01T00:00:00. If the rounding alignment differs, override this
+     * method as follows:
+     * <pre>
+     * return super.remainder(instant + ALIGNMENT_MILLIS);
+     * </pre>
+     */
+    public long remainder(long instant) {
+        if (instant >= 0) {
+            return instant % iUnitMillis;
+        } else {
+            return (instant + 1) % iUnitMillis + iUnitMillis - 1;
+        }
+    }
+
+    /**
+     * Returns the duration per unit value of this field. For example, if this
+     * field represents "minute of hour", then the duration field is minutes.
+     *
+     * @return the duration of this field, or UnsupportedDurationField if field
+     * has no duration
+     */
+    public DurationField getDurationField() {
+        return iUnitField;
+    }
+
+    /**
+     * Get the minimum value for the field.
+     * 
+     * @return the minimum value
+     */
+    public int getMinimumValue() {
+        return 0;
+    }
+
+    public final long getUnitMillis() {
+        return iUnitMillis;
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/PreciseDurationField.java b/JodaTime/src/java/org/joda/time/chrono/PreciseDurationField.java
new file mode 100644
index 000000000..4be09fa78
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/PreciseDurationField.java
@@ -0,0 +1,151 @@
+/* 
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+/**
+ * Duration field class representing a field with a fixed unit length.
+ * <p>
+ * PreciseDurationField is thread-safe and immutable.
+ * 
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+public class PreciseDurationField extends AbstractDurationField {
+    
+    static final long serialVersionUID = -8346152187724495365L;
+
+    /** The size of the unit */
+    private final long iUnitMillis;
+
+    /**
+     * Constructor.
+     * 
+     * @param name  the name of the field, like "seconds"
+     * @param unitMillis  the unit milliseconds
+     */    
+    public PreciseDurationField(String name, long unitMillis) {
+        super(name);
+        iUnitMillis = unitMillis;
+    }
+    
+    //------------------------------------------------------------------------
+    /**
+     * This field is precise.
+     * 
+     * @return true always
+     */
+    public final boolean isPrecise() {
+        return true;
+    }
+    
+    /**
+     * Returns the amount of milliseconds per unit value of this field.
+     *
+     * @return the unit size of this field, in milliseconds
+     */
+    public final long getUnitMillis() {
+        return iUnitMillis;
+    }
+
+    //------------------------------------------------------------------------
+    /**
+     * Get the value of this field from the milliseconds.
+     * 
+     * @param duration  the milliseconds to query, which may be negative
+     * @param instant  ignored
+     * @return the value of the field, in the units of the field, which may be
+     * negative
+     */
+    public long getValueAsLong(long duration, long instant) {
+        return duration / iUnitMillis;
+    }
+
+    /**
+     * Get the millisecond duration of this field from its value.
+     * 
+     * @param value  the value of the field, which may be negative
+     * @param instant  ignored
+     * @return the milliseconds that the field represents, which may be
+     * negative
+     */
+    public long getMillis(int value, long instant) {
+        return value * iUnitMillis;
+    }
+
+    /**
+     * Get the millisecond duration of this field from its value.
+     * 
+     * @param value  the value of the field, which may be negative
+     * @param instant  ignored
+     * @return the milliseconds that the field represents, which may be
+     * negative
+     */
+    public long getMillis(long value, long instant) {
+        return value * iUnitMillis;
+    }
+
+    public long add(long instant, int value) {
+        return instant + value * iUnitMillis;
+    }
+
+    public long add(long instant, long value) {
+        return instant + value * iUnitMillis;
+    }
+
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        return (minuendInstant - subtrahendInstant) / iUnitMillis;
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/RemainderDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/RemainderDateTimeField.java
index f5cceb186..8cdfbfc59 100644
--- a/JodaTime/src/java/org/joda/time/chrono/RemainderDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/RemainderDateTimeField.java
@@ -54,121 +54,115 @@
 package org.joda.time.chrono;
 
 import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
 
 /**
- * Generic remainder datetime field.
- * 
+ * Counterpart remainder datetime field to {@link DividedDateTimeField}. The
+ * field's unit duration is unchanged, but the range duration is scaled
+ * accordingly.
+ * <p>
+ * RemainderDateTimeField is thread-safe and immutable.
+ *
  * @see DividedDateTimeField
- * 
+ *
  * @author Brian S O'Neill
  * @since 1.0
  */
-public class RemainderDateTimeField extends DateTimeField {
-    /** The field to get the remainder */
-    private final DateTimeField iField;
-    /** The amount to divide by in the correct units */
-    private final int iUnitDivisor;
+public class RemainderDateTimeField extends DecoratedDateTimeField {
+
+    static final long serialVersionUID = 5708241235177666790L;
+
+    // Shared with DividedDateTimeField.
+    final int iDivisor;
+    final DurationField iRangeField;
 
     /**
-     * Constructor
+     * Constructor.
      * 
-     * @param name  short, descriptive name, like "yearOfCentury".
      * @param field  the field to wrap, like "year()".
-     * @param unitDivisor  divisor in units, such as 100 years in a century
-     * @throws IllegalArgumentException if unit is less than two
+     * @param name  short, descriptive name, like "yearOfCentury".
+     * @param rangeName  short, descriptive name, like "centuries".
+     * @param divisor  divisor, such as 100 years in a century
+     * @throws IllegalArgumentException if divisor is less than two
      */
-    public RemainderDateTimeField(String name, DateTimeField field, int unitDivisor) {
-        super(name);
-                
-        if (field == null) {
-            throw new IllegalArgumentException("The field must not be null");
+    public RemainderDateTimeField(DateTimeField field,
+                                  String name, String rangeName, int divisor) {
+        super(field, name);
+
+        if (divisor < 2) {
+            throw new IllegalArgumentException("The divisor must be at least 2");
         }
-        if (unitDivisor < 2) {
-            throw new IllegalArgumentException("The unit divisor must be at least 2");
+
+        DurationField rangeField = field.getDurationField();
+        if (rangeField == null) {
+            iRangeField = null;
+        } else {
+            iRangeField = new ScaledDurationField(rangeField, rangeName, divisor);
         }
-        iField = field;
-        iUnitDivisor = unitDivisor;
+
+        iDivisor = divisor;
+    }
+
+    /**
+     * Construct a RemainderDateTimeField that compliments the given
+     * DividedDateTimeField.
+     *
+     * @param dividedField  complimentary divided field, like "century()".
+     * @param name  short, descriptive name, like "yearOfCentury".
+     */
+    public RemainderDateTimeField(DividedDateTimeField dividedField, String name) {
+        super(dividedField.getWrappedField(), name);
+        iDivisor = dividedField.iDivisor;
+        iRangeField = dividedField.iDurationField;
     }
 
     /**
      * Get the remainder from the specified time instant.
      * 
-     * @param millis  the time instant in millis to query.
+     * @param instant  the time instant in millis to query.
      * @return the remainder extracted from the input.
      */
-    public int get(long millis) {
-        int value = iField.get(millis);
+    public int get(long instant) {
+        int value = getWrappedField().get(instant);
         if (value >= 0) {
-            return value % iUnitDivisor;
+            return value % iDivisor;
         } else {
-            return (iUnitDivisor - 1) + ((value + 1) % iUnitDivisor);
+            return (iDivisor - 1) + ((value + 1) % iDivisor);
         }
     }
-    
-    /**
-     * Add the specified amount to the specified time instant. The amount added
-     * may be negative.
-     * 
-     * @param millis  the time instant in millis to update.
-     * @param amount  the amount to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long add(long millis, int amount) {
-        return iField.add(millis, amount);
-    }
-    
-    /**
-     * Add the specified amount to the specified time instant. The amount added
-     * may be negative.
-     * 
-     * @param millis  the time instant in millis to update.
-     * @param amount  the amount to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long add(long millis, long amount) {
-        return iField.add(millis, amount);
-    }
 
     /**
      * Add the specified amount to the specified time instant, wrapping around
      * within the remainder range if necessary. The amount added may be
      * negative.
      * 
-     * @param millis  the time instant in millis to update.
+     * @param instant  the time instant in millis to update.
      * @param amount  the amount to add (can be negative).
      * @return the updated time instant.
      */
-    public long addWrapped(long millis, int amount) {
-        return set(millis, getWrappedValue(get(millis), amount, 0, iUnitDivisor - 1));
-    }
-    
-    public long getDifference(long minuendMillis, long subtrahendMillis) {
-        return iField.getDifference(minuendMillis, subtrahendMillis);
+    public long addWrapped(long instant, int amount) {
+        return set(instant, Utils.getWrappedValue(get(instant), amount, 0, iDivisor - 1));
     }
 
     /**
      * Set the specified amount of remainder units to the specified time instant.
      * 
-     * @param millis  the time instant in millis to update.
+     * @param instant  the time instant in millis to update.
      * @param value  value of remainder units to set.
      * @return the updated time instant.
      * @throws IllegalArgumentException if value is too large or too small.
      */
-    public long set(long millis, int value) {
-        verifyValueBounds(value, 0, iUnitDivisor - 1);
-        int divided = getDivided(iField.get(millis));
-        return iField.set(millis, divided * iUnitDivisor + value);
-    }
-    
-    public long getUnitMillis() {
-        return iField.getUnitMillis();
+    public long set(long instant, int value) {
+        Utils.verifyValueBounds(this, value, 0, iDivisor - 1);
+        int divided = getDivided(getWrappedField().get(instant));
+        return getWrappedField().set(instant, divided * iDivisor + value);
     }
 
     /**
-     * Returns the wrapped field's unit size multiplied by the unit divisor.
+     * Returns a scaled version of the wrapped field's unit duration field.
      */
-    public long getRangeMillis() {
-        return iField.getUnitMillis() * iUnitDivisor;
+    public DurationField getRangeDurationField() {
+        return iRangeField;
     }
 
     /**
@@ -179,52 +173,55 @@ public long getRangeMillis() {
     public int getMinimumValue() {
         return 0;
     }
-    
+
     /**
      * Get the maximum value for the field, which is always one less than the
-     * unit divisor.
+     * divisor.
      * 
      * @return the maximum value
      */
     public int getMaximumValue() {
-        return iUnitDivisor - 1;
+        return iDivisor - 1;
     }
-    
-    public long roundFloor(long millis) {
-        return iField.roundFloor(millis);
+
+    public long roundFloor(long instant) {
+        return getWrappedField().roundFloor(instant);
     }
 
-    public long roundCeiling(long millis) {
-        return iField.roundCeiling(millis);
+    public long roundCeiling(long instant) {
+        return getWrappedField().roundCeiling(instant);
     }
 
-    public long remainder(long millis) {
-        return iField.remainder(millis);
+    public long roundHalfFloor(long instant) {
+        return getWrappedField().roundHalfFloor(instant);
     }
 
-    /**
-     * Returns the DateTimeField being wrapped.
-     * 
-     * @return field
-     */
-    public DateTimeField getField() {
-        return iField;
+    public long roundHalfCeiling(long instant) {
+        return getWrappedField().roundHalfCeiling(instant);
+    }
+
+    public long roundHalfEven(long instant) {
+        return getWrappedField().roundHalfEven(instant);
+    }
+
+    public long remainder(long instant) {
+        return getWrappedField().remainder(instant);
     }
 
     /**
-     * Returns the divisor to apply to the field in the field's units.
+     * Returns the divisor applied, in the field's units.
      * 
      * @return the divisor
      */
-    public int getUnitDivisor() {
-        return iUnitDivisor;
+    public int getDivisor() {
+        return iDivisor;
     }
 
     private int getDivided(int value) {
         if (value >= 0) {
-            return value / iUnitDivisor;
+            return value / iDivisor;
         } else {
-            return ((value + 1) / iUnitDivisor) - 1;
+            return ((value + 1) / iDivisor) - 1;
         }
     }
 
diff --git a/JodaTime/src/java/org/joda/time/chrono/ScaledDurationField.java b/JodaTime/src/java/org/joda/time/chrono/ScaledDurationField.java
new file mode 100644
index 000000000..e7faada75
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/ScaledDurationField.java
@@ -0,0 +1,151 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+
+package org.joda.time.chrono;
+
+import org.joda.time.DurationField;
+
+/**
+ * Scales a DurationField such that it's unit millis becomes larger in
+ * magnitude.
+ * <p>
+ * ScaledDurationField is thread-safe and immutable.
+ *
+ * @see PreciseDurationField
+ *
+ * @author Brian S O'Neill
+ */
+public class ScaledDurationField extends DecoratedDurationField {
+
+    static final long serialVersionUID = -3205227092378684157L;
+
+    private final int iScalar;
+
+    /**
+     * Constructor
+     * 
+     * @param field  the field to wrap, like "year()".
+     * @param name  short, descriptive name, like "centuries".
+     * @param scalar  scalar, such as 100 years in a century
+     * @throws IllegalArgumentException if scalar is zero or one.
+     */
+    public ScaledDurationField(DurationField field, String name, int scalar) {
+        super(field, name);
+        if (scalar == 0 || scalar == 1) {
+            throw new IllegalArgumentException("The scalar must not be 0 or 1");
+        }
+        iScalar = scalar;
+    }
+
+    public int getValue(long duration) {
+        return getWrappedField().getValue(duration) / iScalar;
+    }
+
+    public long getValueAsLong(long duration) {
+        return getWrappedField().getValueAsLong(duration) / iScalar;
+    }
+
+    public int getValue(long duration, long instant) {
+        return getWrappedField().getValue(duration, instant) / iScalar;
+    }
+
+    public long getValueAsLong(long duration, long instant) {
+        return getWrappedField().getValueAsLong(duration, instant) / iScalar;
+    }
+
+    public long getMillis(int value) {
+        return getWrappedField().getMillis(value * iScalar);
+    }
+
+    public long getMillis(long value) {
+        return getWrappedField().getMillis(value * iScalar);
+    }
+
+    public long getMillis(int value, long instant) {
+        return getWrappedField().getMillis(value * iScalar, instant);
+    }
+
+    public long getMillis(long value, long instant) {
+        return getWrappedField().getMillis(value * iScalar, instant);
+    }
+
+    public long add(long instant, int value) {
+        return getWrappedField().add(instant, value * iScalar);
+    }
+
+    public long add(long instant, long value) {
+        return getWrappedField().add(instant, value * iScalar);
+    }
+
+    public int getDifference(long minuendInstant, long subtrahendInstant) {
+        return getWrappedField().getDifference(minuendInstant, subtrahendInstant) / iScalar;
+    }
+
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant) / iScalar;
+    }
+
+    public long getUnitMillis() {
+        return getWrappedField().getUnitMillis() * iScalar;
+    }
+
+    /**
+     * Returns the scalar applied, in the field's units.
+     * 
+     * @return the scalar
+     */
+    public int getScalar() {
+        return iScalar;
+    }
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java b/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java
new file mode 100644
index 000000000..3351b9f73
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java
@@ -0,0 +1,369 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeZone;
+
+/**
+ * Wraps another chronology, ensuring all the fields are strict.
+ * <p>
+ * StrictChronology is thread-safe and immutable.
+ *
+ * @author Brian S O'Neill
+ * @see StrictDateTimeField
+ * @see LenientChronology
+ */
+public class StrictChronology extends DelegatedChronology {
+
+    static final long serialVersionUID = 6633006628097111960L;
+
+    private transient DateTimeField iYearField;
+    private transient DateTimeField iYearOfEraField;
+    private transient DateTimeField iYearOfCenturyField;
+    private transient DateTimeField iCenturyOfEraField;
+    private transient DateTimeField iEraField;
+    private transient DateTimeField iDayOfWeekField;
+    private transient DateTimeField iDayOfMonthField;
+    private transient DateTimeField iDayOfYearField;
+    private transient DateTimeField iMonthOfYearField;
+    private transient DateTimeField iWeekOfWeekyearField;
+    private transient DateTimeField iWeekyearField;
+
+    private transient DateTimeField iMillisOfSecondField;
+    private transient DateTimeField iMillisOfDayField;
+    private transient DateTimeField iSecondOfMinuteField;
+    private transient DateTimeField iSecondOfDayField;
+    private transient DateTimeField iMinuteOfHourField;
+    private transient DateTimeField iMinuteOfDayField;
+    private transient DateTimeField iHourOfDayField;
+    private transient DateTimeField iHourOfHalfdayField;
+    private transient DateTimeField iClockhourOfDayField;
+    private transient DateTimeField iClockhourOfHalfdayField;
+    private transient DateTimeField iHalfdayOfDayField;
+
+    private transient Chronology iWithUTC;
+
+    /**
+     * Create a StrictChronology for any chronology.
+     *
+     * @param chrono the chronology
+     * @throws IllegalArgumentException if chronology is null
+     */
+    public StrictChronology(Chronology chrono) {
+        super(chrono);
+    }
+
+    public Chronology withUTC() {
+        if (iWithUTC == null) {
+            iWithUTC = new StrictChronology(getWrappedChronology().withUTC());
+        }
+        return iWithUTC;
+    }
+
+    public Chronology withDateTimeZone(DateTimeZone zone) {
+        return new StrictChronology(getWrappedChronology().withDateTimeZone(zone));
+    }
+
+    /**
+     * Overridden to ensure strict fields are used.
+     */
+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
+        throws IllegalArgumentException
+    {
+        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);
+    }
+
+    /**
+     * Overridden to ensure strict fields are used.
+     */
+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        long instant = hourOfDay().set(0, hourOfDay);
+        instant = minuteOfHour().set(instant, minuteOfHour);
+        instant = secondOfMinute().set(instant, secondOfMinute);
+        return millisOfSecond().set(instant, millisOfSecond);
+    }
+
+    /**
+     * Overridden to ensure strict fields are used.
+     */
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int millisOfDay)
+        throws IllegalArgumentException
+    {
+        long instant = year().set(0, year);
+        instant = monthOfYear().set(instant, monthOfYear);
+        instant = dayOfMonth().set(instant, dayOfMonth);
+        return millisOfDay().set(instant, millisOfDay);
+    }
+
+    /**
+     * Overridden to ensure strict fields are used.
+     */
+    public long getDateTimeMillis(long instant,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        instant = hourOfDay().set(instant, hourOfDay);
+        instant = minuteOfHour().set(instant, minuteOfHour);
+        instant = secondOfMinute().set(instant, secondOfMinute);
+        return millisOfSecond().set(instant, millisOfSecond);
+    }
+
+    /**
+     * Overridden to ensure strict fields are used.
+     */
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        long instant = year().set(0, year);
+        instant = monthOfYear().set(instant, monthOfYear);
+        instant = dayOfMonth().set(instant, dayOfMonth);
+        instant = hourOfDay().set(instant, hourOfDay);
+        instant = minuteOfHour().set(instant, minuteOfHour);
+        instant = secondOfMinute().set(instant, secondOfMinute);
+        return millisOfSecond().set(instant, millisOfSecond);
+    }
+
+    // Milliseconds
+    //------------------------------------------------------------
+
+    public DateTimeField millisOfSecond() {
+        if (iMillisOfDayField == null) {
+            iMillisOfSecondField = StrictDateTimeField.getInstance(super.millisOfSecond());
+        }
+        return iMillisOfSecondField;
+    }
+
+    public DateTimeField millisOfDay() {
+        if (iMillisOfDayField == null) {
+            iMillisOfDayField = StrictDateTimeField.getInstance(super.millisOfDay());
+        }
+        return iMillisOfDayField;
+    }
+
+    // Seconds
+    //------------------------------------------------------------
+
+    public DateTimeField secondOfMinute() {
+        if (iSecondOfMinuteField == null) {
+            iSecondOfMinuteField = StrictDateTimeField.getInstance(super.secondOfMinute());
+        }
+        return iSecondOfMinuteField;
+    }
+
+    public DateTimeField secondOfDay() {
+        if (iSecondOfDayField == null) {
+            iSecondOfDayField = StrictDateTimeField.getInstance(super.secondOfDay());
+        }
+        return iSecondOfDayField;
+    }
+
+    // Minutes
+    //------------------------------------------------------------
+
+    public DateTimeField minuteOfHour() {
+        if (iMinuteOfHourField == null) {
+            iMinuteOfHourField = StrictDateTimeField.getInstance(super.minuteOfHour());
+        }
+        return iMinuteOfHourField;
+    }
+
+    public DateTimeField minuteOfDay() {
+        if (iMinuteOfDayField == null) {
+            iMinuteOfDayField = StrictDateTimeField.getInstance(super.minuteOfDay());
+        }
+        return iMinuteOfDayField;
+    }
+
+    // Hours
+    //------------------------------------------------------------
+
+    public DateTimeField hourOfDay() {
+        if (iHourOfDayField == null) {
+            iHourOfDayField = StrictDateTimeField.getInstance(super.hourOfDay());
+        }
+        return iHourOfDayField;
+    }
+
+    public DateTimeField clockhourOfDay() {
+        if (iClockhourOfDayField == null) {
+            iClockhourOfDayField = StrictDateTimeField.getInstance(super.clockhourOfDay());
+        }
+        return iClockhourOfDayField;
+    }
+
+    public DateTimeField hourOfHalfday() {
+        if (iHourOfHalfdayField == null) {
+            iHourOfHalfdayField = StrictDateTimeField.getInstance(super.hourOfHalfday());
+        }
+        return iHourOfHalfdayField;
+    }
+
+    public DateTimeField clockhourOfHalfday() {
+        if (iClockhourOfHalfdayField == null) {
+            iClockhourOfHalfdayField =
+                StrictDateTimeField.getInstance(super.clockhourOfHalfday());
+        }
+        return iClockhourOfHalfdayField;
+    }
+
+    public DateTimeField halfdayOfDay() {
+        if (iHalfdayOfDayField == null) {
+            iHalfdayOfDayField = StrictDateTimeField.getInstance(super.halfdayOfDay());
+        }
+        return iHalfdayOfDayField;
+    }
+
+    // Day
+    //------------------------------------------------------------
+
+    public DateTimeField dayOfWeek() {
+        if (iDayOfWeekField == null) {
+            iDayOfWeekField = StrictDateTimeField.getInstance(super.dayOfWeek());
+        }
+        return iDayOfWeekField;
+    }
+
+    public DateTimeField dayOfMonth() {
+        if (iDayOfMonthField == null) {
+            iDayOfMonthField = StrictDateTimeField.getInstance(super.dayOfMonth());
+        }
+        return iDayOfMonthField;
+    }
+
+    public DateTimeField dayOfYear() {
+        if (iDayOfYearField == null) {
+            iDayOfYearField = StrictDateTimeField.getInstance(super.dayOfYear());
+        }
+        return iDayOfYearField;
+    }
+
+    // Week
+    //------------------------------------------------------------
+
+    public DateTimeField weekOfWeekyear() {
+        if (iWeekOfWeekyearField == null) {
+            iWeekOfWeekyearField = StrictDateTimeField.getInstance(super.weekOfWeekyear());
+        }
+        return iWeekOfWeekyearField;
+    }
+
+    public DateTimeField weekyear() {
+        if (iWeekyearField == null) {
+            iWeekyearField = StrictDateTimeField.getInstance(super.weekyear());
+        }
+        return iWeekyearField;
+    }
+
+    // Month
+    //------------------------------------------------------------
+
+    public DateTimeField monthOfYear() {
+        if (iMonthOfYearField == null) {
+            iMonthOfYearField = StrictDateTimeField.getInstance(super.monthOfYear());
+        }
+        return iMonthOfYearField;
+    }
+
+    // Year
+    //------------------------------------------------------------
+
+    public DateTimeField year() {
+        if (iYearField == null) {
+            iYearField = StrictDateTimeField.getInstance(super.year());
+        }
+        return iYearField;
+    }
+
+    public DateTimeField yearOfEra() {
+        if (iYearOfEraField == null) {
+            iYearOfEraField = StrictDateTimeField.getInstance(super.yearOfEra());
+        }
+        return iYearOfEraField;
+    }
+
+    public DateTimeField yearOfCentury() {
+        if (iYearOfCenturyField == null) {
+            iYearOfCenturyField = StrictDateTimeField.getInstance(super.yearOfCentury());
+        }
+        return iYearOfCenturyField;
+    }
+
+    public DateTimeField centuryOfEra() {
+        if (iCenturyOfEraField == null) {
+            iCenturyOfEraField = StrictDateTimeField.getInstance(super.centuryOfEra());
+        }
+        return iCenturyOfEraField;
+    }
+
+    public DateTimeField era() {
+        if (iEraField == null) {
+            iEraField = StrictDateTimeField.getInstance(super.era());
+        }
+        return iEraField;
+    }
+
+    public String toString() {
+        return "StrictChronology[" + getWrappedChronology().toString() + ']';
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/StrictDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/StrictDateTimeField.java
new file mode 100644
index 000000000..ed3dae75a
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/StrictDateTimeField.java
@@ -0,0 +1,107 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import org.joda.time.DateTimeField;
+
+/**
+ * Converts a lenient DateTimeField into a strict one. By being strict, the set
+ * throws an IllegalArgumentException if the value is out of bounds.
+ * <p>
+ * StrictDateTimeField is thread-safe and immutable.
+ *
+ * @author Brian S O'Neill
+ * @see LenientDateTimeField
+ */
+public class StrictDateTimeField extends DelegatedDateTimeField {
+
+    static final long serialVersionUID = 3154803964207950910L;
+
+    /**
+     * Returns a strict version of the given field. If it is already strict,
+     * then it is returned as-is. Otherwise, a new StrictDateTimeField is
+     * returned.
+     */
+    public static DateTimeField getInstance(DateTimeField field) {
+        if (field == null) {
+            return null;
+        }
+        if (field instanceof LenientDateTimeField) {
+            field = ((LenientDateTimeField)field).getWrappedField();
+        }
+        if (!field.isLenient()) {
+            return field;
+        }
+        return new StrictDateTimeField(field);
+    }
+
+    protected StrictDateTimeField(DateTimeField field) {
+        super(field);
+    }
+
+    public final boolean isLenient() {
+        return false;
+    }
+
+    /**
+     * Does a bounds check before setting the value.
+     *
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public long set(long instant, int value) {
+        Utils.verifyValueBounds
+            (this, value, getMinimumValue(instant), getMaximumValue(instant));
+        return super.set(instant, value);
+    }
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/UnsupportedDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/UnsupportedDateTimeField.java
new file mode 100644
index 000000000..6d1ff23eb
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/UnsupportedDateTimeField.java
@@ -0,0 +1,433 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+
+package org.joda.time.chrono;
+
+import java.io.Serializable;
+import java.util.HashMap;
+import java.util.Locale;
+import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+
+/**
+ * A placeholder implementation to use when a datetime field is not supported.
+ * <p>
+ * UnsupportedDateTimeField is thread-safe and immutable.
+ *
+ * @author Brian S O'Neill
+ */
+public final class UnsupportedDateTimeField implements DateTimeField, Serializable {
+
+    static final long serialVersionUID = -1934618396111902255L;
+
+    /**
+     * Instance with the name "unsupported".
+     */
+    public static final UnsupportedDateTimeField INSTANCE =
+        getInstance("unsupported", UnsupportedDurationField.INSTANCE);
+
+    private static HashMap cCache;
+
+    /**
+     * @throws IllegalArgumentException if durationField is null
+     */
+    public static synchronized UnsupportedDateTimeField getInstance
+        (String name, DurationField durationField) {
+
+        UnsupportedDateTimeField field;
+        if (cCache == null) {
+            cCache = new HashMap(7);
+            field = null;
+        } else {
+            field = (UnsupportedDateTimeField)cCache.get(name);
+            if (field != null && field.getDurationField() != durationField) {
+                field = null;
+            }
+        }
+        if (field == null) {
+            field = new UnsupportedDateTimeField(name, durationField);
+            cCache.put(name, field);
+        }
+        return field;
+    }
+
+    private final String iName;
+    private final DurationField iDurationField;
+
+    private UnsupportedDateTimeField(String name, DurationField durationField) {
+        if (durationField == null) {
+            throw new IllegalArgumentException();
+        }
+        iName = name;
+        iDurationField = durationField;
+    }
+
+    // Design note: Simple accessors return a suitable value, but methods
+    // intended to perform calculations throw an UnsupportedOperationException.
+
+    public String getName() {
+        return iName;
+    }
+
+    /**
+     * This field is not supported.
+     *
+     * @return false always
+     */
+    public boolean isSupported() {
+        return false;
+    }
+
+    /**
+     * This field is not lenient.
+     *
+     * @return false always
+     */
+    public boolean isLenient() {
+        return false;
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int get(long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public String getAsText(long instant, Locale locale) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public String getAsText(long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public String getAsShortText(long instant, Locale locale) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public String getAsShortText(long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Delegates to the duration field.
+     *
+     * @throws UnsupportedOperationException if the duration is unsupported
+     */
+    public long add(long instant, int value) {
+        return getDurationField().add(instant, value);
+    }
+
+    /**
+     * Delegates to the duration field.
+     *
+     * @throws UnsupportedOperationException if the duration is unsupported
+     */
+    public long add(long instant, long value) {
+        return getDurationField().add(instant, value);
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long addWrapped(long instant, int value) {
+        throw unsupported();
+    }
+
+    /**
+     * Delegates to the duration field.
+     *
+     * @throws UnsupportedOperationException if the duration is unsupported
+     */
+    public int getDifference(long minuendInstant, long subtrahendInstant) {
+        return getDurationField().getDifference(minuendInstant, subtrahendInstant);
+    }
+
+    /**
+     * Delegates to the duration field.
+     *
+     * @throws UnsupportedOperationException if the duration is unsupported
+     */
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        return getDurationField().getDifferenceAsLong(minuendInstant, subtrahendInstant);
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long set(long instant, int value) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long set(long instant, String text, Locale locale) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long set(long instant, String text) {
+        throw unsupported();
+    }
+
+    /**
+     * Even though this DateTimeField is unsupported, the duration field might
+     * be supported.
+     *
+     * @return a possibly supported DurationField
+     */
+    public DurationField getDurationField() {
+        return iDurationField;
+    }
+
+    /**
+     * Always returns null.
+     *
+     * @return null always
+     */
+    public DurationField getRangeDurationField() {
+        return null;
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public boolean isLeap(long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int getLeapAmount(long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always returns null.
+     *
+     * @return null always
+     */
+    public DurationField getLeapDurationField() {
+        return null;
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int getMinimumValue() {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int getMinimumValue(long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int getMaximumValue() {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int getMaximumValue(long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int getMaximumTextLength(Locale locale) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int getMaximumShortTextLength(Locale locale) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long roundFloor(long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long roundCeiling(long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long roundHalfFloor(long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long roundHalfCeiling(long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long roundHalfEven(long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long remainder(long instant) {
+        throw unsupported();
+    }
+
+    //------------------------------------------------------------------------
+    /**
+     * Get a suitable debug string.
+     * 
+     * @return debug string
+     */
+    public String toString() {
+        return "UnsupportedDateTimeField";
+    }
+
+    /**
+     * Ensure proper singleton serialization
+     */
+    private Object readResolve() {
+        return getInstance(iName, iDurationField);
+    }
+
+    private UnsupportedOperationException unsupported() {
+        return new UnsupportedOperationException(iName + " field is unsupported");
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/UnsupportedDurationField.java b/JodaTime/src/java/org/joda/time/chrono/UnsupportedDurationField.java
new file mode 100644
index 000000000..c767e983e
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/UnsupportedDurationField.java
@@ -0,0 +1,272 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+
+package org.joda.time.chrono;
+
+import java.io.Serializable;
+import java.util.HashMap;
+import org.joda.time.DurationField;
+
+/**
+ * A placeholder implementation to use when a duration field is not supported.
+ * <p>
+ * UnsupportedDurationField is thread-safe and immutable.
+ *
+ * @author Brian S O'Neill
+ */
+public final class UnsupportedDurationField implements DurationField, Serializable {
+
+    static final long serialVersionUID = -6390301302770925357L;
+
+    /**
+     * Instance with the name "unsupported".
+     */
+    public static final UnsupportedDurationField INSTANCE = getInstance("unsupported");
+
+    private static HashMap cCache;
+
+    public static synchronized UnsupportedDurationField getInstance(String name) {
+        UnsupportedDurationField field;
+        if (cCache == null) {
+            cCache = new HashMap(7);
+            field = null;
+        } else {
+            field = (UnsupportedDurationField)cCache.get(name);
+        }
+        if (field == null) {
+            field = new UnsupportedDurationField(name);
+            cCache.put(name, field);
+        }
+        return field;
+    }
+
+    private final String iName;
+
+    private UnsupportedDurationField(String name) {
+        iName = name;
+    }
+
+    // Design note: Simple Accessors return a suitable value, but methods
+    // intended to perform calculations throw an UnsupportedOperationException.
+
+    public String getName() {
+        return iName;
+    }
+
+    /**
+     * This field is not supported.
+     *
+     * @return false always
+     */
+    public boolean isSupported() {
+        return false;
+    }
+
+    /**
+     * This field is precise.
+     * 
+     * @return true always
+     */
+    public boolean isPrecise() {
+        return true;
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int getValue(long duration) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long getValueAsLong(long duration) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int getValue(long duration, long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long getValueAsLong(long duration, long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long getMillis(int value) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long getMillis(long value) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long getMillis(int value, long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long getMillis(long value, long instant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long add(long instant, int value) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long add(long instant, long value) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public int getDifference(long minuendInstant, long subtrahendInstant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always throws UnsupportedOperationException
+     *
+     * @throws UnsupportedOperationException
+     */
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        throw unsupported();
+    }
+
+    /**
+     * Always returns zero.
+     *
+     * @return zero always
+     */
+    public long getUnitMillis() {
+        return 0;
+    }
+
+    /**
+     * Always returns zero, indicating that sort order is not relevent.
+     *
+     * @return zero always
+     */
+    public int compareTo(Object durationField) {
+        return 0;
+    }
+
+    //------------------------------------------------------------------------
+    /**
+     * Get a suitable debug string.
+     * 
+     * @return debug string
+     */
+    public String toString() {
+        return "UnsupportedDurationField";
+    }
+
+    /**
+     * Ensure proper singleton serialization
+     */
+    private Object readResolve() {
+        return getInstance(iName);
+    }
+
+    private UnsupportedOperationException unsupported() {
+        return new UnsupportedOperationException(iName + " field is unsupported");
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/Utils.java b/JodaTime/src/java/org/joda/time/chrono/Utils.java
new file mode 100644
index 000000000..9154e5429
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/Utils.java
@@ -0,0 +1,225 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import org.joda.time.DateTimeField;
+
+/**
+ * General utilities that don't fit elsewhere.
+ * <p>
+ * Utils is thread-safe and immutable.
+ *
+ * @author Stephen Colebourne
+ * @since 1.0
+ */
+public class Utils {
+
+    /**
+     * Restricted constructor.
+     */
+    private Utils() {
+        super();
+    }
+    
+    //------------------------------------------------------------------------
+    /**
+     * Add two values throwing an exception if overflow occurs.
+     * 
+     * @param val1  the first value
+     * @param val2  the second value
+     * @return the new total
+     */
+    public static long safeAdd(long val1, long val2) {
+        long total = val1 + val2;
+        if (val1 > 0 && val2 > 0 && total < 0) {
+            throw new ArithmeticException("The calculation caused an overflow: " + val1 +" + " + val2);
+        }
+        if (val1 < 0 && val2 < 0 && total > 0) {
+            throw new ArithmeticException("The calculation caused an overflow: " + val1 +" + " + val2);
+        }
+        return total;
+    }
+    
+    /**
+     * Multiply two values throwing an exception if overflow occurs.
+     * 
+     * @param val1  the first value
+     * @param val2  the second value
+     * @return the new total
+     */
+    public static long safeMultiply(long val1, long val2) {
+        if (val1 == 0  || val2 == 0) {
+            return 0L;
+        }
+        long total = val1 * val2;
+        if (total / val2 != val1) {
+            throw new ArithmeticException("The calculation caused an overflow: " + val1 +" * " + val2);
+        }
+        return total;
+    }
+    
+    /**
+     * Casts to an int throwing an exception if overflow occurs.
+     * 
+     * @param value  the value
+     * @return the value as an int
+     */
+    public static int safeToInt(long value) {
+        if (Integer.MIN_VALUE <= value && value <= Integer.MAX_VALUE) {
+            return (int) value;
+        }
+        throw new ArithmeticException("Value cannot fit in an int: " + value);
+    }
+
+    /**
+     * Verify that input values are within specified bounds.
+     * 
+     * @param value  the value to check
+     * @param lowerBound  the lower bound allowed for value
+     * @param upperBound  the upper bound allowed for value
+     * @throws IllegalArgumentException if value is not in the specified bounds
+     */
+    public static void verifyValueBounds(DateTimeField field, 
+                                         int value, int lowerBound, int upperBound) {
+        if ((value < lowerBound) || (value > upperBound)) {
+            throw new IllegalArgumentException(
+                "Value: "
+                    + value
+                    + " for "
+                    + field.getName()
+                    + " must be in the range ("
+                    + lowerBound
+                    + ','
+                    + upperBound
+                    + ')');
+        }
+    }
+
+    /**
+     * Verify that input values are within specified bounds.
+     * 
+     * @param value  the value to check
+     * @param lowerBound  the lower bound allowed for value
+     * @param upperBound  the upper bound allowed for value
+     * @throws IllegalArgumentException if value is not in the specified bounds
+     */
+    public static void verifyValueBounds(String fieldName,
+                                         int value, int lowerBound, int upperBound) {
+        if ((value < lowerBound) || (value > upperBound)) {
+            throw new IllegalArgumentException(
+                "Value: "
+                    + value
+                    + " for "
+                    + fieldName
+                    + " must be in the range ("
+                    + lowerBound
+                    + ','
+                    + upperBound
+                    + ')');
+        }
+    }
+
+    /**
+     * Utility method used by addWrapped implementations to ensure the new
+     * value lies within the field's legal value range.
+     *
+     * @param currentValue the current value of the data, which may lie outside
+     * the wrapped value range
+     * @param wrapValue  the value to add to current value before
+     *  wrapping.  This may be negative.
+     * @param minValue the wrap range minimum value.
+     * @param maxValue the wrap range maximum value.  This must be
+     *  greater than minValue (checked by the method).
+     * @return the wrapped value
+     * @throws IllegalArgumentException if minValue is greater
+     *  than or equal to maxValue
+     */
+    public static int getWrappedValue(int currentValue, int wrapValue,
+                                      int minValue, int maxValue) {
+        return getWrappedValue(currentValue + wrapValue, minValue, maxValue);
+    }
+
+    /**
+     * Utility method that ensures the given value lies within the field's
+     * legal value range.
+     * 
+     * @param value  the value to fit into the wrapped value range
+     * @param minValue the wrap range minimum value.
+     * @param maxValue the wrap range maximum value.  This must be
+     *  greater than minValue (checked by the method).
+     * @return the wrapped value
+     * @throws IllegalArgumentException if minValue is greater
+     *  than or equal to maxValue
+     */
+    public static int getWrappedValue(int value, int minValue, int maxValue) {
+        if (minValue >= maxValue) {
+            throw new IllegalArgumentException("MIN > MAX");
+        }
+
+        int wrapRange = maxValue - minValue + 1;
+        value -= minValue;
+
+        if (value >= 0) {
+            return (value % wrapRange) + minValue;
+        }
+
+        int remByRange = (-value) % wrapRange;
+
+        if (remByRange == 0) {
+            return 0 + minValue;
+        }
+        return (wrapRange - remByRange) + minValue;
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java b/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
index dccf32efc..8707c9464 100644
--- a/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
@@ -56,23 +56,50 @@
 import java.io.IOException;
 import java.io.ObjectInputStream;
 
+import java.util.HashMap;
 import java.util.Locale;
 
 import org.joda.time.Chronology;
+import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeZone;
+import org.joda.time.DurationField;
 
 /**
  * Wraps another Chronology for supporting time zones.
+ * <p>
+ * ZonedChronology is thread-safe and immutable.
  *
  * @author Brian S O'Neill
  * @author Stephen Colebourne
  * @since 1.0
  */
 public class ZonedChronology extends Chronology {
+
+    static final long serialVersionUID = -1079258847191166848L;
+
+    static boolean useTimeArithmetic(DurationField field) {
+        // Use time of day arithmetic rules for unit durations less than
+        // typical time zone offsets.
+        return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12;
+    }
+
     private final Chronology iChronology;
     private final DateTimeZone iZone;
 
+    private transient DurationField iErasField;
+    private transient DurationField iCenturiesField;
+    private transient DurationField iYearsField;
+    private transient DurationField iMonthsField;
+    private transient DurationField iWeekyearsField;
+    private transient DurationField iWeeksField;
+    private transient DurationField iDaysField;
+
+    private transient DurationField iHoursField;
+    private transient DurationField iMinutesField;
+    private transient DurationField iSecondsField;
+    private transient DurationField iMillisField;
+
     private transient DateTimeField iYearField;
     private transient DateTimeField iYearOfEraField;
     private transient DateTimeField iYearOfCenturyField;
@@ -124,33 +151,79 @@ public ZonedChronology(Chronology chrono, DateTimeZone zone) {
 
     private void setFields() {
         Chronology c = iChronology;
-        DateTimeZone z = iZone;
-
-        iYearField = new ZonedDateField(c.year(), z);
-        iYearOfEraField = new ZonedDateField(c.yearOfEra(), z);
-        iYearOfCenturyField = new ZonedDateField(c.yearOfCentury(), z);
-        iCenturyOfEraField = new ZonedDateField(c.centuryOfEra(), z);
-        iEraField = new ZonedDateField(c.era(), z);
-        iDayOfMonthField = new ZonedDateField(c.dayOfMonth(), z);
-        iDayOfWeekField = new ZonedDateField(c.dayOfWeek(), z);
-        iDayOfYearField = new ZonedDateField(c.dayOfYear(), z);
-        iMonthOfYearField = new ZonedDateField(c.monthOfYear(), z);
-        iWeekOfWeekyearField = new ZonedDateField(c.weekOfWeekyear(), z);
-        iWeekyearField = new ZonedDateField(c.weekyear(), z);
-        
-        iMillisOfSecondField = new ZonedTimeField(c.millisOfSecond(), z);
-        iMillisOfDayField = new ZonedTimeField(c.millisOfDay(), z);
-        iSecondOfMinuteField = new ZonedTimeField(c.secondOfMinute(), z);
-        iSecondOfDayField = new ZonedTimeField(c.secondOfDay(), z);
-        iMinuteOfHourField = new ZonedTimeField(c.minuteOfHour(), z);
-        iMinuteOfDayField = new ZonedTimeField(c.minuteOfDay(), z);
-        iHourOfDayField = new ZonedTimeField(c.hourOfDay(), z);
-        iHourOfHalfdayField = new ZonedTimeField(c.hourOfHalfday(), z);
-        iClockhourOfDayField = new ZonedTimeField(c.clockhourOfDay(), z);
-        iClockhourOfHalfdayField = new ZonedTimeField(c.clockhourOfHalfday(), z);
-
-        // Treat halfday as a date field for adds.
-        iHalfdayOfDayField = new ZonedDateField(c.halfdayOfDay(), z);
+
+        // Keep a local cache of converted fields so as not to create redundant
+        // objects.
+        HashMap converted = new HashMap();
+
+        // Convert duration fields...
+
+        iErasField = convertField(c.eras(), converted);
+        iCenturiesField = convertField(c.centuries(), converted);
+        iYearsField = convertField(c.years(), converted);
+        iMonthsField = convertField(c.months(), converted);
+        iWeekyearsField = convertField(c.weekyears(), converted);
+        iWeeksField = convertField(c.weeks(), converted);
+        iDaysField = convertField(c.days(), converted);
+
+        iHoursField = convertField(c.hours(), converted);
+        iMinutesField = convertField(c.minutes(), converted);
+        iSecondsField = convertField(c.seconds(), converted);
+        iMillisField = convertField(c.millis(), converted);
+
+        // Convert datetime fields...
+
+        iYearField = convertField(c.year(), converted);
+        iYearOfEraField = convertField(c.yearOfEra(), converted);
+        iYearOfCenturyField = convertField(c.yearOfCentury(), converted);
+        iCenturyOfEraField = convertField(c.centuryOfEra(), converted);
+        iEraField = convertField(c.era(), converted);
+        iDayOfWeekField = convertField(c.dayOfWeek(), converted);
+        iDayOfMonthField = convertField(c.dayOfMonth(), converted);
+        iDayOfYearField = convertField(c.dayOfYear(), converted);
+        iMonthOfYearField = convertField(c.monthOfYear(), converted);
+        iWeekOfWeekyearField = convertField(c.weekOfWeekyear(), converted);
+        iWeekyearField = convertField(c.weekyear(), converted);
+
+        iMillisOfSecondField = convertField(c.millisOfSecond(), converted);
+        iMillisOfDayField = convertField(c.millisOfDay(), converted);
+        iSecondOfMinuteField = convertField(c.secondOfMinute(), converted);
+        iSecondOfDayField = convertField(c.secondOfDay(), converted);
+        iMinuteOfHourField = convertField(c.minuteOfHour(), converted);
+        iMinuteOfDayField = convertField(c.minuteOfDay(), converted);
+        iHourOfDayField = convertField(c.hourOfDay(), converted);
+        iHourOfHalfdayField = convertField(c.hourOfHalfday(), converted);
+        iClockhourOfDayField = convertField(c.clockhourOfDay(), converted);
+        iClockhourOfHalfdayField = convertField(c.clockhourOfHalfday(), converted);
+        iHalfdayOfDayField = convertField(c.halfdayOfDay(), converted);
+    }
+
+    private DurationField convertField(DurationField field, HashMap converted) {
+        if (field == null || !field.isSupported()) {
+            return field;
+        }
+        if (converted.containsKey(field)) {
+            return (DurationField)converted.get(field);
+        }
+        ZonedDurationField zonedField = new ZonedDurationField(field, iZone);
+        converted.put(field, zonedField);
+        return zonedField;
+    }
+
+    private DateTimeField convertField(DateTimeField field, HashMap converted) {
+        if (field == null || !field.isSupported()) {
+            return field;
+        }
+        if (converted.containsKey(field)) {
+            return (DateTimeField)converted.get(field);
+        }
+        ZonedDateTimeField zonedField =
+            new ZonedDateTimeField(field, iZone,
+                                   convertField(field.getDurationField(), converted),
+                                   convertField(field.getRangeDurationField(), converted),
+                                   convertField(field.getLeapDurationField(), converted));
+        converted.put(field, zonedField);
+        return zonedField;
     }
 
     public DateTimeZone getDateTimeZone() {
@@ -163,7 +236,7 @@ public Chronology withUTC() {
 
     public Chronology withDateTimeZone(DateTimeZone zone) {
         if (zone == null) {
-            throw new IllegalArgumentException("The DateTimeZone must not be null");
+            zone = DateTimeZone.getDefault();
         }
         if (zone == iZone) {
             return this;
@@ -174,9 +247,69 @@ public Chronology withDateTimeZone(DateTimeZone zone) {
         return new ZonedChronology(iChronology, zone);
     }
 
+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
+        throws IllegalArgumentException
+    {
+        return localToUTC(iChronology.getDateOnlyMillis
+                          (year, monthOfYear, dayOfMonth));
+    }
+
+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        return localToUTC(iChronology.getTimeOnlyMillis
+                          (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));
+    }
+
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int millisOfDay)
+        throws IllegalArgumentException
+    {
+        return localToUTC(iChronology.getDateTimeMillis
+                          (year, monthOfYear, dayOfMonth, millisOfDay));
+    }
+
+    public long getDateTimeMillis(long instant,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        return localToUTC(iChronology.getDateTimeMillis
+                          (instant + iZone.getOffset(instant),
+                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));
+    }
+
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        return localToUTC(iChronology.getDateTimeMillis
+                          (year, monthOfYear, dayOfMonth, 
+                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));
+    }
+
+    /**
+     * @param instant instant from 1970-01-01T00:00:00 local time
+     */
+    private long localToUTC(long instant) {
+        int offset = iZone.getOffsetFromLocal(instant);
+        instant -= offset;
+        if (offset != iZone.getOffset(instant)) {
+            throw new IllegalArgumentException
+                ("Illegal instant due to time zone offset transition");
+        }
+        return instant;
+    }
+
     // Milliseconds
     //------------------------------------------------------------
 
+    public DurationField millis() {
+        return iMillisField;
+    }
+
     public DateTimeField millisOfSecond() {
         return iMillisOfSecondField;
     }
@@ -188,6 +321,10 @@ public DateTimeField millisOfDay() {
     // Seconds
     //------------------------------------------------------------
 
+    public DurationField seconds() {
+        return iSecondsField;
+    }
+
     public DateTimeField secondOfMinute() {
         return iSecondOfMinuteField;
     }
@@ -199,6 +336,10 @@ public DateTimeField secondOfDay() {
     // Minutes
     //------------------------------------------------------------
 
+    public DurationField minutes() {
+        return iMinutesField;
+    }
+
     public DateTimeField minuteOfHour() {
         return iMinuteOfHourField;
     }
@@ -210,6 +351,10 @@ public DateTimeField minuteOfDay() {
     // Hours
     //------------------------------------------------------------
 
+    public DurationField hours() {
+        return iHoursField;
+    }
+
     public DateTimeField hourOfDay() {
         return iHourOfDayField;
     }
@@ -232,7 +377,11 @@ public DateTimeField halfdayOfDay() {
 
     // Day
     //------------------------------------------------------------
-    
+
+    public DurationField days() {
+        return iDaysField;
+    }
+
     public DateTimeField dayOfWeek() {
         return iDayOfWeekField;
     }
@@ -247,25 +396,41 @@ public DateTimeField dayOfYear() {
 
     // Week
     //------------------------------------------------------------
-    
+
+    public DurationField weeks() {
+        return iWeeksField;
+    }
+
     public DateTimeField weekOfWeekyear() {
         return iWeekOfWeekyearField;
     }
 
+    public DurationField weekyears() {
+        return iWeekyearsField;
+    }
+
     public DateTimeField weekyear() {
         return iWeekyearField;
     }
 
     // Month
     //------------------------------------------------------------
-    
+
+    public DurationField months() {
+        return iMonthsField;
+    }
+
     public DateTimeField monthOfYear() {
         return iMonthOfYearField;
     }
 
     // Year
     //------------------------------------------------------------
-    
+
+    public DurationField years() {
+        return iYearsField;
+    }
+
     public DateTimeField year() {
         return iYearField;
     }
@@ -278,14 +443,26 @@ public DateTimeField yearOfCentury() {
         return iYearOfCenturyField;
     }
 
+    public DurationField centuries() {
+        return iCenturiesField;
+    }
+
     public DateTimeField centuryOfEra() {
         return iCenturyOfEraField;
     }
 
+    public DurationField eras() {
+        return iErasField;
+    }
+
     public DateTimeField era() {
         return iEraField;
     }
 
+    public String toString() {
+        return iChronology.toString();
+    }
+
     private void readObject(ObjectInputStream in)
         throws IOException, ClassNotFoundException
     {
@@ -293,161 +470,245 @@ private void readObject(ObjectInputStream in)
         setFields();
     }
 
+    /*
+     * Because time durations are typically smaller than time zone offsets, the
+     * arithmetic methods subtract the original offset. This produces a more
+     * expected behavior when crossing time zone offset transitions. For dates,
+     * the new offset is subtracted off. This behavior, if applied to time
+     * fields, can nullify or reverse an add when crossing a transition.
+     */
+
+    static class ZonedDurationField extends AbstractDurationField {
+        static final long serialVersionUID = -485345310999208286L;
+
+        final DurationField iField;
+        final boolean iTimeField;
+        final DateTimeZone iZone;
+
+        ZonedDurationField(DurationField field, DateTimeZone zone) {
+            super(field.getName());
+            if (!field.isSupported()) {
+                throw new IllegalArgumentException();
+            }
+            iField = field;
+            iTimeField = useTimeArithmetic(field);
+            this.iZone = zone;
+        }
+
+        public boolean isPrecise() {
+            return iTimeField ? iField.isPrecise() : iZone.isFixed();
+        }
+
+        public long getUnitMillis() {
+            return iField.getUnitMillis();
+        }
+
+        public int getValue(long duration, long instant) {
+            return iField.getValue(duration, instant + this.iZone.getOffset(instant));
+        }
+
+        public long getValueAsLong(long duration, long instant) {
+            return iField.getValueAsLong(duration, instant + this.iZone.getOffset(instant));
+        }
+
+        public long getMillis(int value, long instant) {
+            return iField.getMillis(value, instant + this.iZone.getOffset(instant));
+        }
+
+        public long getMillis(long value, long instant) {
+            return iField.getMillis(value, instant + this.iZone.getOffset(instant));
+        }
+
+        public long add(long instant, int value) {
+            int offset = this.iZone.getOffset(instant);
+            instant = iField.add(instant + offset, value);
+            return instant - (iTimeField ? offset : this.iZone.getOffsetFromLocal(instant));
+        }
+
+        public long add(long instant, long value) {
+            int offset = this.iZone.getOffset(instant);
+            instant = iField.add(instant + offset, value);
+            return instant - (iTimeField ? offset : this.iZone.getOffsetFromLocal(instant));
+        }
+
+        public int getDifference(long minuendInstant, long subtrahendInstant) {
+            int offset = this.iZone.getOffset(subtrahendInstant);
+            return iField.getDifference
+                (minuendInstant + (iTimeField ? offset : this.iZone.getOffset(minuendInstant)),
+                 subtrahendInstant + offset);
+        }
+
+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+            int offset = this.iZone.getOffset(subtrahendInstant);
+            return iField.getDifferenceAsLong
+                (minuendInstant + (iTimeField ? offset : this.iZone.getOffset(minuendInstant)),
+                 subtrahendInstant + offset);
+        }
+    }
+
     /**
      * A DateTimeField that decorates another to add timezone behaviour.
      * <p>
-     * This class converts passed in millis to local wall millis, and 
-     * vice versa on output.
+     * This class converts passed in instants to local wall time, and vice
+     * versa on output.
      */
-    static class ZonedDateField extends DateTimeField {
+    static final class ZonedDateTimeField extends AbstractDateTimeField {
+        static final long serialVersionUID = -3968986277775529794L;
+
         final DateTimeField iField;
         final DateTimeZone iZone;
-        
-        ZonedDateField(DateTimeField field, DateTimeZone zone) {
+        final DurationField iDurationField;
+        final boolean iTimeField;
+        final DurationField iRangeDurationField;
+        final DurationField iLeapDurationField;
+
+        ZonedDateTimeField(DateTimeField field,
+                           DateTimeZone zone,
+                           DurationField durationField,
+                           DurationField rangeDurationField,
+                           DurationField leapDurationField) {
             super(field.getName());
+            if (!field.isSupported()) {
+                throw new IllegalArgumentException();
+            }
             iField = field;
             this.iZone = zone;
+            iDurationField = durationField;
+            iTimeField = useTimeArithmetic(durationField);
+            iRangeDurationField = rangeDurationField;
+            iLeapDurationField = leapDurationField;
         }
-        
-        public int get(long millis) {
-            return iField.get(millis + this.iZone.getOffset(millis));
+
+        public boolean isLenient() {
+            return iField.isLenient();
         }
-        
-        public String getAsText(long millis, Locale locale) {
-            return iField.getAsText(millis + this.iZone.getOffset(millis), locale);
+
+        public int get(long instant) {
+            return iField.get(instant + this.iZone.getOffset(instant));
         }
-        
-        public String getAsShortText(long millis, Locale locale) {
-            return iField.getAsShortText(millis + this.iZone.getOffset(millis), locale);
+
+        public String getAsText(long instant, Locale locale) {
+            return iField.getAsText(instant + this.iZone.getOffset(instant), locale);
         }
-        
-        public long add(long millis, int value) {
-            millis = iField.add(millis + this.iZone.getOffset(millis), value);
-            return millis - this.iZone.getOffsetFromLocal(millis);
+
+        public String getAsShortText(long instant, Locale locale) {
+            return iField.getAsShortText(instant + this.iZone.getOffset(instant), locale);
         }
-        
-        public long add(long millis, long value) {
-            millis = iField.add(millis + this.iZone.getOffset(millis), value);
-            return millis - this.iZone.getOffsetFromLocal(millis);
+
+        public long add(long instant, int value) {
+            int offset = this.iZone.getOffset(instant);
+            instant = iField.add(instant + offset, value);
+            return instant - (iTimeField ? offset : this.iZone.getOffsetFromLocal(instant));
         }
 
-        public long addWrapped(long millis, int value) {
-            millis = iField.addWrapped(millis + this.iZone.getOffset(millis), value);
-            return millis - this.iZone.getOffsetFromLocal(millis);
+        public long add(long instant, long value) {
+            int offset = this.iZone.getOffset(instant);
+            instant = iField.add(instant + offset, value);
+            return instant - (iTimeField ? offset : this.iZone.getOffsetFromLocal(instant));
         }
 
-        public long getDifference(long minuendMillis, long subtrahendMillis) {
-            return iField.getDifference(minuendMillis + this.iZone.getOffset(minuendMillis),
-                                        subtrahendMillis + this.iZone.getOffset(subtrahendMillis));
+        public long addWrapped(long instant, int value) {
+            int offset = this.iZone.getOffset(instant);
+            instant = iField.addWrapped(instant + offset, value);
+            return instant - (iTimeField ? offset : this.iZone.getOffsetFromLocal(instant));
         }
 
-        public long set(long millis, int value) {
-            long offset = this.iZone.getOffset(millis);
-            
-            millis = iField.set(millis + offset, value);
-            long offsetFromLocal = this.iZone.getOffsetFromLocal(millis);
-            millis -= offsetFromLocal;
-            
+        public long set(long instant, int value) {
+            long offset = this.iZone.getOffset(instant);
+
+            instant = iField.set(instant + offset, value);
+            long offsetFromLocal = this.iZone.getOffsetFromLocal(instant);
+            instant -= offsetFromLocal;
+
             if (offset != offsetFromLocal) {
-                if (get(millis) != value) {
+                if (get(instant) != value) {
                     throw new IllegalArgumentException
                         ("Illegal value for " + iField.getName() + ": " + value);
                 }
             }
-            
-            return millis;
+
+            return instant;
         }
-        
-        public long set(long millis, String text, Locale locale) {
-            millis = iField.set(millis + this.iZone.getOffset(millis), text, locale);
+
+        public long set(long instant, String text, Locale locale) {
+            instant = iField.set(instant + this.iZone.getOffset(instant), text, locale);
             // Cannot verify that new value stuck because set may be lenient.
-            return millis - this.iZone.getOffsetFromLocal(millis);
-        }
-        
-        public boolean isLeap(long millis) {
-            return iField.isLeap(millis + this.iZone.getOffset(millis));
+            return instant - this.iZone.getOffsetFromLocal(instant);
         }
 
-        public int getLeapAmount(long millis) {
-            return iField.getLeapAmount(millis + this.iZone.getOffset(millis));
-        }
-        
-        public long getUnitMillis() {
-            return iField.getUnitMillis();
+        public int getDifference(long minuendInstant, long subtrahendInstant) {
+            int offset = this.iZone.getOffset(subtrahendInstant);
+            return iField.getDifference
+                (minuendInstant + (iTimeField ? offset : this.iZone.getOffset(minuendInstant)),
+                 subtrahendInstant + offset);
         }
 
-        public long getRangeMillis() {
-            return iField.getRangeMillis();
+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+            int offset = this.iZone.getOffset(subtrahendInstant);
+            return iField.getDifferenceAsLong
+                (minuendInstant + (iTimeField ? offset : this.iZone.getOffset(minuendInstant)),
+                 subtrahendInstant + offset);
         }
 
-        public int getMinimumValue() {
-            return iField.getMinimumValue();
-        }
-        
-        public int getMinimumValue(long millis) {
-            return iField.getMinimumValue(millis + this.iZone.getOffset(millis));
+        public final DurationField getDurationField() {
+            return iDurationField;
         }
-        
-        public int getMaximumValue() {
-            return iField.getMaximumValue();
+
+        public final DurationField getRangeDurationField() {
+            return iRangeDurationField;
         }
-        
-        public int getMaximumValue(long millis) {
-            return iField.getMaximumValue(millis + this.iZone.getOffset(millis));
+
+        public boolean isLeap(long instant) {
+            return iField.isLeap(instant + this.iZone.getOffset(instant));
         }
-        
-        public long roundFloor(long millis) {
-            millis = iField.roundFloor(millis + this.iZone.getOffset(millis));
-            return millis - this.iZone.getOffsetFromLocal(millis);
+
+        public int getLeapAmount(long instant) {
+            return iField.getLeapAmount(instant + this.iZone.getOffset(instant));
         }
-        
-        public long roundCeiling(long millis) {
-            millis = iField.roundCeiling(millis + this.iZone.getOffset(millis));
-            return millis - this.iZone.getOffsetFromLocal(millis);
+
+        public final DurationField getLeapDurationField() {
+            return iLeapDurationField;
         }
 
-        public long remainder(long millis) {
-            millis = iField.remainder(millis + this.iZone.getOffset(millis));
-            return millis - this.iZone.getOffsetFromLocal(millis);
+        public long roundFloor(long instant) {
+            int offset = this.iZone.getOffset(instant);
+            instant = iField.roundFloor(instant + offset);
+            return instant - (iTimeField ? offset : this.iZone.getOffsetFromLocal(instant));
         }
 
-        public int getMaximumTextLength(Locale locale) {
-            return iField.getMaximumTextLength(locale);
+        public long roundCeiling(long instant) {
+            int offset = this.iZone.getOffset(instant);
+            instant = iField.roundCeiling(instant + offset);
+            return instant - (iTimeField ? offset : this.iZone.getOffsetFromLocal(instant));
         }
-        
-        public int getMaximumShortTextLength(Locale locale) {
-            return iField.getMaximumShortTextLength(locale);
+
+        public long remainder(long instant) {
+            return iField.remainder(instant + this.iZone.getOffset(instant));
         }
-    }
 
-    static class ZonedTimeField extends ZonedDateField {
-        ZonedTimeField(DateTimeField field, DateTimeZone zone) {
-            super(field, zone);
+        public int getMinimumValue() {
+            return iField.getMinimumValue();
         }
 
-        // Because time fields are smaller than time zone offsets, override the
-        // arithmetic methods to follow more expected behavior when crossing
-        // time zone offset transitions. The original add method can nullify or
-        // reverse an add when crossing a transition.
+        public int getMinimumValue(long instant) {
+            return iField.getMinimumValue(instant + this.iZone.getOffset(instant));
+        }
 
-        public long add(long millis, int value) {
-            int offset = this.iZone.getOffset(millis);
-            return iField.add(millis + offset, value) - offset;
+        public int getMaximumValue() {
+            return iField.getMaximumValue();
         }
-        
-        public long add(long millis, long value) {
-            int offset = this.iZone.getOffset(millis);
-            return iField.add(millis + offset, value) - offset;
+
+        public int getMaximumValue(long instant) {
+            return iField.getMaximumValue(instant + this.iZone.getOffset(instant));
         }
 
-        public long addWrapped(long millis, int value) {
-            int offset = this.iZone.getOffset(millis);
-            return iField.addWrapped(millis + offset, value) - offset;
+        public int getMaximumTextLength(Locale locale) {
+            return iField.getMaximumTextLength(locale);
         }
 
-        public long getDifference(long minuendMillis, long subtrahendMillis) {
-            int offset = this.iZone.getOffset(subtrahendMillis);
-            return iField.getDifference(minuendMillis + offset, subtrahendMillis + offset);
+        public int getMaximumShortTextLength(Locale locale) {
+            return iField.getMaximumShortTextLength(locale);
         }
     }
+
 }
diff --git a/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistChronology.java b/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistChronology.java
index 05738459c..6a48b38ed 100644
--- a/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistChronology.java
@@ -57,11 +57,16 @@
 import java.util.Map;
 
 import org.joda.time.Chronology;
+import org.joda.time.DateTime;
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeZone;
-import org.joda.time.chrono.DelegateChronology;
+import org.joda.time.DurationField;
+import org.joda.time.chrono.DecoratedChronology;
+import org.joda.time.chrono.DividedDateTimeField;
+import org.joda.time.chrono.LimitChronology;
 import org.joda.time.chrono.OffsetDateTimeField;
+import org.joda.time.chrono.RemainderDateTimeField;
 import org.joda.time.chrono.gj.GJChronology;
 
 /**
@@ -72,14 +77,16 @@
  * in the year. This class is compatable with the BuddhistCalendar class 
  * supplied by Sun.
  * <p>
- * At present the century fields are unsupported.
+ * BuddhistChronology is thread-safe and immutable.
  *
  * @author Stephen Colebourne
  * @author Brian S O'Neill
  * @since 1.0
  */
-public final class BuddhistChronology extends DelegateChronology {
+public final class BuddhistChronology extends DecoratedChronology {
     
+    static final long serialVersionUID = -3474595157769370126L;
+
     /**
      * Constant value for 'Buddhist Era', equivalent to the value returned
      * for AD/CE.
@@ -89,15 +96,11 @@
     /** Number of years difference in calendars. */
     private static final int BUDDHIST_OFFSET = 543;
 
-    /** UTC instance of the chronology */
-    private static final BuddhistChronology INSTANCE_UTC =
-        new BuddhistChronology(GJChronology.getInstance(DateTimeZone.UTC, null, false));
-
     /** Cache of zone to chronology */
     private static final Map cCache = new HashMap();
-    static {
-        cCache.put(DateTimeZone.UTC, INSTANCE_UTC);
-    }
+
+    /** UTC instance of the chronology */
+    private static final BuddhistChronology INSTANCE_UTC = getInstance(DateTimeZone.UTC);
 
     /**
      * Standard instance of a Buddhist Chronology, that matches
@@ -125,7 +128,6 @@ public static BuddhistChronology getInstance() {
      * GregorianJulian calendar rules with a cutover date.
      *
      * @param zone  the time zone to use, null is default
-     * @throws IllegalArgumentException if the zone is null
      */
     public static synchronized BuddhistChronology getInstance(DateTimeZone zone) {
         if (zone == null) {
@@ -138,30 +140,71 @@ public static synchronized BuddhistChronology getInstance(DateTimeZone zone) {
         }
         return chrono;
     }
-    
+
     // Constructors and instance variables
     //-----------------------------------------------------------------------
     // Fields are transient because readResolve will always return a cached instance.
     private transient DateTimeField iYearField;
     private transient DateTimeField iWeekyearField;
+    private transient DateTimeField iYearOfCenturyField;
+    private transient DateTimeField iCenturyOfEraField;
     
     /**
      * Restricted constructor.
      */
-    private BuddhistChronology(GJChronology gjChronology) {
-        super(gjChronology);
-        DateTimeField field = gjChronology.year();
-        iYearField = new OffsetDateTimeField(field.getName(), field, BUDDHIST_OFFSET);
-        field = gjChronology.weekyear();
-        iWeekyearField = new OffsetDateTimeField(field.getName(), field, BUDDHIST_OFFSET);
+    private BuddhistChronology(Chronology chronology) {
+        this(chronology, false);
+    }
+
+    /**
+     * Restricted constructor.
+     */
+    private BuddhistChronology(Chronology chronology, boolean unlimited) {
+        // BuddhistChronology is constructed in three magic steps:
+        //
+        // 1. Wrap a BuddhistChronology with proper offset, but no range limits
+        // 2. Wrap a LimitChronology, which will copy and wrap all the fields
+        // 3. Wrap a BuddhistChronology which purely delegates to LimitChronology
+        //
+        // Why is it done this way? So that the LimitChronology error message
+        // shows the limit printed using BuddhistChronology fields. This extra
+        // wrapping does not impose any additional overhead when accessing
+        // fields because LimitChronology copies them.
+        //
+        // Is this a good design? No.
+
+        super(unlimited ? chronology : limitChronology(chronology));
+
+        DateTimeField field = getWrappedChronology().year();
+        if (unlimited) {
+            field = new OffsetDateTimeField(field, field.getName(), BUDDHIST_OFFSET);
+        }
+        iYearField = field;
+            
+        field = getWrappedChronology().weekyear();
+        if (unlimited) {
+            field = new OffsetDateTimeField(field, field.getName(), BUDDHIST_OFFSET);
+        }
+        iWeekyearField = field;
+
         // All other fields delegated to GJ
     }
+
+    /**
+     * Returns a LimitChronology that wraps an unlimited BuddhistChronology
+     * that wraps the given Chronology.
+     */    
+    private static Chronology limitChronology(Chronology chrono) {
+        chrono = new BuddhistChronology(chrono, true);
+        DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);
+        return new LimitChronology(chrono, lowerLimit, null);
+    }
     
     /**
      * Serialization singleton
      */
     private Object readResolve() {
-        return getInstance(getChronology().getDateTimeZone());
+        return getInstance(getWrappedChronology().getDateTimeZone());
     }
 
     // Conversion
@@ -191,8 +234,222 @@ public Chronology withDateTimeZone(DateTimeZone zone) {
         return getInstance(zone);
     }
 
+    // Millis
+    //------------------------------------------------------------
+
+    /**
+     * Get the millis duration field for this chronology.
+     * 
+     * @return DurationField
+     */
+    public DurationField millis() {
+        return getWrappedChronology().millis();
+    }
+
+    /**
+     * Get the millis of second field for this chronology.
+     * 
+     * @return DateTimeField
+     */
+    public DateTimeField millisOfSecond() {
+        return getWrappedChronology().millisOfSecond();
+    }
+
+    /**
+     * Get the millis of day field for this chronology.
+     * 
+     * @return DateTimeField
+     */
+    public DateTimeField millisOfDay() {
+        return getWrappedChronology().millisOfDay();
+    }
+
+    // Seconds
+    //------------------------------------------------------------
+
+    /**
+     * Get the seconds duration field for this chronology.
+     * 
+     * @return DurationField
+     */
+    public DurationField seconds() {
+        return getWrappedChronology().seconds();
+    }
+
+    /**
+     * Get the second of minute field for this chronology.
+     * 
+     * @return DateTimeField
+     */
+    public DateTimeField secondOfMinute() {
+        return getWrappedChronology().secondOfMinute();
+    }
+
+    /**
+     * Get the second of day field for this chronology.
+     * 
+     * @return DateTimeField
+     */
+    public DateTimeField secondOfDay() {
+        return getWrappedChronology().secondOfDay();
+    }
+
+    // Minutes
+    //------------------------------------------------------------
+
+    /**
+     * Get the minutes duration field for this chronology.
+     * 
+     * @return DurationField
+     */
+    public DurationField minutes() {
+        return getWrappedChronology().minutes();
+    }
+
+    /**
+     * Get the minute of hour field for this chronology.
+     * 
+     * @return DateTimeField
+     */
+    public DateTimeField minuteOfHour() {
+        return getWrappedChronology().minuteOfHour();
+    }
+
+    /**
+     * Get the minute of day field for this chronology.
+     * 
+     * @return DateTimeField
+     */
+    public DateTimeField minuteOfDay() {
+        return getWrappedChronology().minuteOfDay();
+    }
+
+    // Hours
+    //------------------------------------------------------------
+
+    /**
+     * Get the hours duration field for this chronology.
+     * 
+     * @return DurationField
+     */
+    public DurationField hours() {
+        return getWrappedChronology().hours();
+    }
+
+    /**
+     * Get the hour of day (0-23) field for this chronology.
+     * 
+     * @return DateTimeField
+     */
+    public DateTimeField hourOfDay() {
+        return getWrappedChronology().hourOfDay();
+    }
+
+    /**
+     * Get the hour of day (offset to 1-24) field for this chronology.
+     * 
+     * @return DateTimeField
+     */
+    public DateTimeField clockhourOfDay() {
+        return getWrappedChronology().clockhourOfDay();
+    }
+
+    /**
+     * Get the hour of am/pm (0-11) field for this chronology.
+     * 
+     * @return DateTimeField
+     */
+    public DateTimeField hourOfHalfday() {
+        return getWrappedChronology().hourOfHalfday();
+    }
+
+    /**
+     * Get the hour of am/pm (offset to 1-12) field for this chronology.
+     * 
+     * @return DateTimeField
+     */
+    public DateTimeField clockhourOfHalfday() {
+        return getWrappedChronology().clockhourOfHalfday();
+    }
+
+    /**
+     * Get the AM(0) PM(1) field for this chronology.
+     * 
+     * @return DateTimeField
+     */
+    public DateTimeField halfdayOfDay() {
+        return getWrappedChronology().halfdayOfDay();
+    }
+
+    // Day
+    //------------------------------------------------------------
+
+    /**
+     * Get the days duration field for this chronology.
+     * 
+     * @return DurationField
+     */
+    public DurationField days() {
+        return getWrappedChronology().days();
+    }
+
+    /**
+     * Get the day of week field for this chronology.
+     *
+     * @return DateTimeField
+     */
+    public DateTimeField dayOfWeek() {
+        return getWrappedChronology().dayOfWeek();
+    }
+
+    /**
+     * Get the day of month field for this chronology.
+     *
+     * @return DateTimeField
+     */
+    public DateTimeField dayOfMonth() {
+        return getWrappedChronology().dayOfMonth();
+    }
+
+    /**
+     * Get the day of year field for this chronology.
+     *
+     * @return DateTimeField
+     */
+    public DateTimeField dayOfYear() {
+        return getWrappedChronology().dayOfYear();
+    }
+
     // Week
-    //-----------------------------------------------------------------------
+    //------------------------------------------------------------
+
+    /**
+     * Get the weeks duration field for this chronology.
+     * 
+     * @return DurationField
+     */
+    public DurationField weeks() {
+        return getWrappedChronology().weeks();
+    }
+
+    /**
+     * Get the week of a week based year field for this chronology.
+     *
+     * @return DateTimeField
+     */
+    public DateTimeField weekOfWeekyear() {
+        return getWrappedChronology().weekOfWeekyear();
+    }
+
+    /**
+     * Get the weekyears duration field for this chronology.
+     * 
+     * @return DurationField
+     */
+    public DurationField weekyears() {
+        return getWrappedChronology().weekyears();
+    }
+
     /**
      * Get the year of a week based year field for this chronology.
      *
@@ -202,15 +459,45 @@ public DateTimeField weekyear() {
         return iWeekyearField;
     }
 
+    // Month
+    //------------------------------------------------------------
+
+    /**
+     * Get the months duration field for this chronology.
+     * 
+     * @return DurationField
+     */
+    public DurationField months() {
+        return getWrappedChronology().months();
+    }
+
+    /**
+     * Get the month of year field for this chronology.
+     *
+     * @return DateTimeField
+     */
+    public DateTimeField monthOfYear() {
+        return getWrappedChronology().monthOfYear();
+    }
+
     // Year
-    //-----------------------------------------------------------------------
+    //------------------------------------------------------------
+
+    /**
+     * Get the years duration field for this chronology.
+     * 
+     * @return DurationField
+     */
+    public DurationField years() {
+        return getWrappedChronology().years();
+    }
+
     /**
      * Get the year field for this chronology.
      * 
      * @return DateTimeField
      */
     public DateTimeField year() {
-        // TODO block negative years
         return iYearField;
     }
 
@@ -220,7 +507,6 @@ public DateTimeField year() {
      * @return DateTimeField
      */
     public DateTimeField yearOfEra() {
-        // TODO block negative years
         return iYearField;
     }
 
@@ -228,26 +514,39 @@ public DateTimeField yearOfEra() {
      * Get the year of century field for this chronology.
      * 
      * @return DateTimeField
-     * @throws UnsupportedOperationException always
      */
     public DateTimeField yearOfCentury() {
-        // TODO
-        throw new UnsupportedOperationException("yearOfCentury is unsupported for " + getClass().getName());
+        if (iYearOfCenturyField == null) {
+            DateTimeField tempField = new RemainderDateTimeField
+                ((DividedDateTimeField)centuryOfEra(), "");
+            iYearOfCenturyField = new OffsetDateTimeField(tempField, "yearOfCentury", 1);
+        }
+        return iYearOfCenturyField;
+    }
+
+    /**
+     * Get the centuries duration field for this chronology.
+     * 
+     * @return DurationField
+     */
+    public DurationField centuries() {
+        return getWrappedChronology().centuries();
     }
 
     /**
      * Get the century of era field for this chronology.
      * 
      * @return DateTimeField
-     * @throws UnsupportedOperationException always
      */
     public DateTimeField centuryOfEra() {
-        // TODO
-        throw new UnsupportedOperationException("centuryOfEra is unsupported for " + getClass().getName());
+        if (iCenturyOfEraField == null) {
+            DateTimeField tempField = new OffsetDateTimeField(yearOfEra(), "", 99);
+            iCenturyOfEraField = new DividedDateTimeField
+                (tempField, "centuryOfEra", "centuries", 100);
+        }
+        return iCenturyOfEraField;
     }
 
-    // Misc
-    //-----------------------------------------------------------------------
     /**
      * Get the era field for this chronology.
      * 
@@ -256,7 +555,7 @@ public DateTimeField centuryOfEra() {
     public DateTimeField era() {
         return BuddhistEraDateTimeField.INSTANCE;
     }
-    
+
     // Output
     //-----------------------------------------------------------------------
     /**
@@ -265,8 +564,12 @@ public DateTimeField era() {
      * @return a debugging string
      */
     public String toString() {
+        String str = "BuddhistChronology";
         DateTimeZone zone = getDateTimeZone();
-        return "BuddhistChronology[" + (zone == null ? "" : zone.getID()) + "]";
+        if (zone != null) {
+            str = str + '[' + zone.getID() + ']';
+        }
+        return str;
     }
    
 }
diff --git a/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistEraDateTimeField.java
index 22043890c..ad683d9c2 100644
--- a/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistEraDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistEraDateTimeField.java
@@ -56,15 +56,22 @@
 import java.util.Locale;
 
 import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+import org.joda.time.chrono.AbstractDateTimeField;
+import org.joda.time.chrono.UnsupportedDurationField;
+import org.joda.time.chrono.Utils;
 
 /**
  * Provides time calculations for the buddhist era component of time.
  *
  * @author Stephen Colebourne
+ * @author Brian S O'Neill
  * @since 1.0
  */
-final class BuddhistEraDateTimeField extends DateTimeField {
+final class BuddhistEraDateTimeField extends AbstractDateTimeField {
     
+    static final long serialVersionUID = -9175876774456816364L;
+
     /**
      * Singleton instance of BuddhistYearDateTimeField
      */
@@ -84,77 +91,70 @@ private Object readResolve() {
         return INSTANCE;
     }
 
+    public boolean isLenient() {
+        return false;
+    }
+
     /**
      * Get the Era component of the specified time instant.
      * 
      * @param millis  the time instant in millis to query.
      * @return the era extracted from the input.
      */
-    public int get(long millis) {
+    public int get(long instant) {
         return BuddhistChronology.BE;
     }
 
     /**
-     * Unsupported - add the specified eras to the specified time instant.
+     * Set the Era component of the specified time instant.
      * 
      * @param millis  the time instant in millis to update.
-     * @param years  the years to add (can be negative).
+     * @param era  the era (BuddhistChronology.BE) to update the time to.
      * @return the updated time instant.
+     * @throws IllegalArgumentException  if era is invalid.
      */
-    public long add(long millis, int era) {
-        throw new UnsupportedOperationException("Adding to Era field is unsupported");
+    public long set(long instant, int era) {
+        Utils.verifyValueBounds(this, era, getMinimumValue(), getMaximumValue());
+
+        return instant;
     }
 
     /**
-     * Unsupported - add the specified eras to the specified time instant.
-     * 
-     * @param millis  the time instant in millis to update.
-     * @param years  the years to add (can be negative).
-     * @return the updated time instant.
+     * @see org.joda.time.DateTimeField#set(long, String, Locale)
      */
-    public long add(long millis, long era) {
-        throw new UnsupportedOperationException("Adding to Era field is unsupported");
+    public long set(long instant, String text, Locale locale) {
+        if ("BE".equals(text) == false) {
+            throw new IllegalArgumentException("Invalid era text: " + text);
+        }
+        return instant;
     }
 
-    /**
-     * Unsupported - add the specified eras to the specified time instant.
-     * 
-     * @param millis  the time instant in millis to update.
-     * @param era  the era to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long addWrapped(long millis, int era) {
-        throw new UnsupportedOperationException("Adding to Era field is unsupported");
+    public long roundFloor(long instant) {
+        return Long.MIN_VALUE;
     }
 
-    public long getDifference(long minuendMillis, long subtrahendMillis) {
-        throw new UnsupportedOperationException("Era field difference is unsupported");
+    public long roundCeiling(long instant) {
+        return Long.MAX_VALUE;
     }
 
-    /**
-     * Set the Era component of the specified time instant.
-     * 
-     * @param millis  the time instant in millis to update.
-     * @param era  the era (BuddhistChonology.BE) to update the time to.
-     * @return the updated time instant.
-     * @throws IllegalArgumentException  if era is invalid.
-     */
-    public long set(long millis, int era) {
-        super.verifyValueBounds(era, getMinimumValue(), getMaximumValue());
+    public long roundHalfFloor(long instant) {
+        return Long.MIN_VALUE;
+    }
 
-        return millis;
+    public long roundHalfCeiling(long instant) {
+        return Long.MIN_VALUE;
     }
 
-    public long getUnitMillis() {
-        // Should actually be double this, but that is not possible since Java
-        // doesn't support unsigned types.
-        return Long.MAX_VALUE;
+    public long roundHalfEven(long instant) {
+        return Long.MIN_VALUE;
     }
 
-    public long getRangeMillis() {
-        // Should actually be double this, but that is not possible since Java
-        // doesn't support unsigned types.
-        return Long.MAX_VALUE;
+    public DurationField getDurationField() {
+        return UnsupportedDurationField.INSTANCE;
+    }
+
+    public DurationField getRangeDurationField() {
+        return null;
     }
 
     public int getMinimumValue() {
@@ -168,7 +168,7 @@ public int getMaximumValue() {
     /**
      * @see org.joda.time.DateTimeField#getAsShortText(long, Locale)
      */
-    public String getAsShortText(long millis, Locale locale) {
+    public String getAsShortText(long instant, Locale locale) {
         return "BE";
     }
     
@@ -182,7 +182,7 @@ public int getMaximumShortTextLength(Locale locale) {
     /**
      * @see org.joda.time.DateTimeField#getAsShortText(long, Locale)
      */
-    public String getAsText(long millis, Locale locale) {
+    public String getAsText(long instant, Locale locale) {
         return "BE";
     }
 
@@ -193,30 +193,4 @@ public int getMaximumTextLength(Locale locale) {
         return 2;
     }
 
-    /**
-     * @see org.joda.time.DateTimeField#set(long, String, Locale)
-     */
-    public long set(long millis, String text, Locale locale) {
-        if ("BE".equals(text) == false) {
-            throw new IllegalArgumentException("Invalid era text: " + text);
-        }
-        return millis;    
-    }
-    
-
-    /**
-     * Unsupported.
-     * @throws UnsupportedOperationException always
-     */
-    public long roundFloor(long millis) {
-        throw new UnsupportedOperationException("Rounding an Era field is unsupported");
-    }
-
-    /**
-     * Unsupported.
-     * @throws UnsupportedOperationException always
-     */
-    public long remainder(long millis) {
-        throw new UnsupportedOperationException("Calculating remainder from Era field is unsupported");
-    }
 }
diff --git a/JodaTime/src/java/org/joda/time/chrono/buddhist/package.html b/JodaTime/src/java/org/joda/time/chrono/buddhist/package.html
index 7112affbf..eacc09fcb 100644
--- a/JodaTime/src/java/org/joda/time/chrono/buddhist/package.html
+++ b/JodaTime/src/java/org/joda/time/chrono/buddhist/package.html
@@ -1,9 +1,70 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<html>
+<head>
+<title>org.joda.time.chrono.buddhist package</title>
+<!--
+
+   Joda Software License, Version 1.0
+  
+  
+   Copyright (c) 2001-03 Stephen Colebourne.
+   All rights reserved.
+  
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions
+   are met:
+  
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+  
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+  
+   3. The end-user documentation included with the redistribution,
+      if any, must include the following acknowledgment:
+         "This product includes software developed by the
+          Joda project (http://www.joda.org/)."
+      Alternately, this acknowledgment may appear in the software itself,
+      if and wherever such third-party acknowledgments normally appear.
+  
+   4. The name "Joda" must not be used to endorse or promote products
+      derived from this software without prior written permission. For
+      written permission, please contact licence@joda.org.
+  
+   5. Products derived from this software may not be called "Joda",
+      nor may "Joda" appear in their name, without prior written
+      permission of the Joda project.
+  
+   THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+   USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+   OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+   SUCH DAMAGE.
+   ====================================================================
+  
+   This software consists of voluntary contributions made by many
+   individuals on behalf of the Joda project and was originally
+   created by Stephen Colebourne <scolebourne@joda.org>. For more
+   information on the Joda project, please see <http://www.joda.org/>.
+
+-->
+</head>
 <body>
-<h3>Buddhist Chronology</h3>
 <p>
-The Buddhist calendar defines one era (BE) that runs 543 years out of sync with
-the Gregorian Julian calendar. In all other aspects the chronology follows the
-GJChronology, for example the cutover date is the same as the default curover date.
+Provides a Buddhist Chronology implementation. The Buddhist calendar defines
+one era (BE) that runs 543 years out of sync with the Gregorian Julian
+calendar. In all other aspects the chronology follows the GJChronology. For
+example, the cutover date is the same as the default GJ cutover date.
 </p>
 </body>
+</html>
 
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/CutoverChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/CutoverChronology.java
index b661d9226..fb55edef8 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/CutoverChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/CutoverChronology.java
@@ -58,6 +58,9 @@
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeZone;
+import org.joda.time.DurationField;
+import org.joda.time.chrono.AbstractDateTimeField;
+import org.joda.time.chrono.DecoratedDurationField;
 
 /**
  * Chronology for supporting the cutover from the Julian calendar to the
@@ -68,25 +71,18 @@
  * @since 1.0
  */
 final class CutoverChronology extends GJChronology {
+
+    static final long serialVersionUID = -2545574827706931671L;
+
     /**
      * Convert a datetime from one chronology to another.
      */
-    private static long convert(long millis, Chronology from, Chronology to) {
-        if (from == to) {
-            return millis;
-        }
-
-        int year = from.year().get(millis);
-        int monthOfYear = from.monthOfYear().get(millis);
-        int dayOfMonth = from.dayOfMonth().get(millis);
-        int millisOfDay = from.millisOfDay().get(millis);
-
-        millis = to.year().set(0, year);
-        millis = to.monthOfYear().set(millis, monthOfYear);
-        millis = to.dayOfMonth().set(millis, dayOfMonth);
-        millis = to.millisOfDay().set(millis, millisOfDay);
-
-        return millis;
+    private static long convert(long instant, Chronology from, Chronology to) {
+        return to.getDateTimeMillis
+            (from.year().get(instant),
+             from.monthOfYear().get(instant),
+             from.dayOfMonth().get(instant),
+             from.millisOfDay().get(instant));
     }
 
     private static void checkUTC(Chronology chrono) {
@@ -99,15 +95,15 @@ private static void checkUTC(Chronology chrono) {
     private final GJChronology iJulianChronology;
     private final GJChronology iGregorianChronology;
 
-    final long iCutoverMillis;
-    transient final long iGapMillis;
+    final long iCutoverInstant;
+    transient final long iGapDuration;
 
     /**
      * @param julian chronology used before the cutover instant
      * @param gregorian chronology used at and after the cutover instant
-     * @param cutoverMillis instant when the gregorian chronology began
+     * @param cutoverInstant instant when the gregorian chronology began
      */
-    CutoverChronology(JulianChronology julian, GregorianChronology gregorian, long cutoverMillis) {
+    CutoverChronology(JulianChronology julian, GregorianChronology gregorian, long cutoverInstant) {
         checkUTC(julian);
         checkUTC(gregorian);
 
@@ -120,29 +116,22 @@ private static void checkUTC(Chronology chrono) {
 
         iJulianChronology = julian;
         iGregorianChronology = gregorian;
-        iCutoverMillis = cutoverMillis;
+        iCutoverInstant = cutoverInstant;
 
         // Compute difference between the chronologies at the cutover instant
-        iGapMillis = cutoverMillis - julianToGregorian(cutoverMillis);
+        iGapDuration = cutoverInstant - julianToGregorian(cutoverInstant);
 
         // Begin field definitions.
 
+        // First just copy all the Gregorian fields and then override those
+        // that need special attention.
+        copyFields(gregorian);
+        
         // Assuming cutover is at midnight, all time of day fields can be
         // gregorian since they are unaffected by cutover.
-        iMillisOfSecondField = gregorian.millisOfSecond();
-        iMillisOfDayField = gregorian.millisOfDay();
-        iSecondOfMinuteField = gregorian.secondOfMinute();
-        iSecondOfDayField = gregorian.secondOfDay();
-        iMinuteOfHourField = gregorian.minuteOfHour();
-        iMinuteOfDayField = gregorian.minuteOfDay();
-        iHourOfDayField = gregorian.hourOfDay();
-        iHourOfHalfdayField = gregorian.hourOfHalfday();
-        iClockhourOfDayField = gregorian.clockhourOfDay();
-        iClockhourOfHalfdayField = gregorian.clockhourOfHalfday();
-        iHalfdayOfDayField = gregorian.halfdayOfDay();
 
         // Verify assumption.
-        if (gregorian.millisOfDay().get(cutoverMillis) == 0) {
+        if (gregorian.millisOfDay().get(cutoverInstant) == 0) {
             // Cutover is sometime in the day, so cutover fields are required
             // for time of day.
 
@@ -160,17 +149,10 @@ private static void checkUTC(Chronology chrono) {
         }
 
         // These fields just require basic cutover support.
-        iEraField = new CutoverField(julian.era(), gregorian.era());
-        iDayOfMonthField = new CutoverField(julian.dayOfMonth(), gregorian.dayOfMonth());
-
-        // These fields require special attention when add is called since they
-        // internally call set.
-        iYearField = new CutoverVarField(julian.year(), gregorian.year());
-        iYearOfEraField = new CutoverVarField(julian.yearOfEra(), gregorian.yearOfEra());
-        iYearOfCenturyField = new CutoverVarField(julian.yearOfCentury(), gregorian.yearOfCentury());
-        iCenturyOfEraField = new CutoverVarField(julian.centuryOfEra(), gregorian.centuryOfEra());
-        iMonthOfYearField = new CutoverVarField(julian.monthOfYear(), gregorian.monthOfYear());
-        iWeekyearField = new CutoverVarField(julian.weekyear(), gregorian.weekyear());
+        {
+            iEraField = new CutoverField(julian.era(), gregorian.era());
+            iDayOfMonthField = new CutoverField(julian.dayOfMonth(), gregorian.dayOfMonth());
+        }
 
         // DayOfYear and weekOfWeekyear require special handling since cutover
         // year has fewer days and weeks. Extend the cutover to the start of
@@ -178,27 +160,97 @@ private static void checkUTC(Chronology chrono) {
         // the cutover year.
 
         {
-            long cutover = gregorian.year().roundCeiling(iCutoverMillis);
+            long cutover = gregorian.year().roundCeiling(iCutoverInstant);
             iDayOfYearField = new CutoverField
                 (julian.dayOfYear(), gregorian.dayOfYear(), cutover);
         }
 
         {
-            long cutover = gregorian.weekyear().roundCeiling(iCutoverMillis);
+            long cutover = gregorian.weekyear().roundCeiling(iCutoverInstant);
             iWeekOfWeekyearField = new CutoverField
                 (julian.weekOfWeekyear(), gregorian.weekOfWeekyear(), cutover);
         }
 
-        // Day of week is unaffected by cutover. Either julian or gregorian will work.
-        iDayOfWeekField = gregorian.dayOfWeek();
+        // These fields are special because they have imprecise durations. The
+        // family of addition methods need special attention. Override affected
+        // duration fields as well.
+        {
+            iYearField = new ImpreciseCutoverField(julian.year(), gregorian.year());
+            iYearsField = iYearField.getDurationField();
+            iYearOfEraField = new ImpreciseCutoverField
+                (julian.yearOfEra(), gregorian.yearOfEra(), iYearsField);
+            iYearOfCenturyField = new ImpreciseCutoverField
+                (julian.yearOfCentury(), gregorian.yearOfCentury(), iYearsField);
+            
+            iCenturyOfEraField = new ImpreciseCutoverField(julian.centuryOfEra(), gregorian.centuryOfEra());
+            iCenturiesField = iCenturyOfEraField.getDurationField();
+            
+            iMonthOfYearField = new ImpreciseCutoverField(julian.monthOfYear(), gregorian.monthOfYear());
+            iMonthsField = iMonthOfYearField.getDurationField();
+            
+            iWeekyearField = new ImpreciseCutoverField(julian.weekyear(), gregorian.weekyear());
+            iWeekyearsField = iWeekyearField.getDurationField();
+        }
     }
 
     public Chronology withUTC() {
         return this;
     }
 
+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
+        throws IllegalArgumentException
+    {
+        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);
+    }
+
+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        // Time fields are same for Julian and Gregorian.
+        return iGregorianChronology.getTimeOnlyMillis
+            (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+    }
+
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int millisOfDay)
+        throws IllegalArgumentException
+    {
+        // Assume date is Gregorian.
+        long instant = iGregorianChronology.getDateTimeMillis
+            (year, monthOfYear, dayOfMonth, millisOfDay);
+        if (instant < iCutoverInstant) {
+            // Maybe it's Julian.
+            instant = iJulianChronology.getDateTimeMillis
+                (year, monthOfYear, dayOfMonth, millisOfDay);
+            if (instant >= iCutoverInstant) {
+                // Okay, it's in the illegal cutover gap.
+                throw new IllegalArgumentException("Specified date does not exist");
+            }
+        }
+        return instant;
+    }
+
+    public long getDateTimeMillis(long instant,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        return getDateOnlyMillis(instant)
+            + getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+    }
+
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0)
+            + getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+    }
+
     public long getGregorianJulianCutoverMillis() {
-        return iCutoverMillis;
+        return iCutoverInstant;
     }
 
     public boolean isCenturyISO() {
@@ -209,242 +261,250 @@ public final int getMinimumDaysInFirstWeek() {
         return iGregorianChronology.getMinimumDaysInFirstWeek();
     }
 
-    long julianToGregorian(long millis) {
-        return convert(millis, iJulianChronology, iGregorianChronology);
+    long julianToGregorian(long instant) {
+        return convert(instant, iJulianChronology, iGregorianChronology);
     }
 
-    long gregorianToJulian(long millis) {
-        return convert(millis, iGregorianChronology, iJulianChronology);
+    long gregorianToJulian(long instant) {
+        return convert(instant, iGregorianChronology, iJulianChronology);
     }
 
     /**
      * This basic cutover field adjusts calls to 'get' and 'set' methods, and
      * assumes that calls to add and addWrapped are unaffected by the cutover.
      */
-    private class CutoverField extends DateTimeField {
+    private class CutoverField extends AbstractDateTimeField {
+        static final long serialVersionUID = 3528501219481026402L;
+
         final DateTimeField iJulianField;
         final DateTimeField iGregorianField;
         final long iCutover;
 
+        protected DurationField iDurationField;
+
         /**
          * @param julianField field from the chronology used before the cutover instant
          * @param gregorianField field from the chronology used at and after the cutover
          */
         CutoverField(DateTimeField julianField, DateTimeField gregorianField) {
-            super(gregorianField.getName());
-            iJulianField = julianField;
-            iGregorianField = gregorianField;
-            iCutover = iCutoverMillis;
+            this(julianField, gregorianField, iCutoverInstant);
         }
 
-        CutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {
+        CutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverInstant) {
             super(gregorianField.getName());
             iJulianField = julianField;
             iGregorianField = gregorianField;
-            iCutover = cutoverMillis;
+            iCutover = cutoverInstant;
+            // Although average length of Julian and Gregorian years differ,
+            // use the Gregorian duration field because it is more accurate.
+            iDurationField = gregorianField.getDurationField();
+        }
+
+        public boolean isLenient() {
+            return false;
         }
 
-        public int get(long millis) {
-            if (millis >= iCutover) {
-                return iGregorianField.get(millis);
+        public int get(long instant) {
+            if (instant >= iCutover) {
+                return iGregorianField.get(instant);
             } else {
-                return iJulianField.get(millis);
+                return iJulianField.get(instant);
             }
         }
 
-        public String getAsText(long millis, Locale locale) {
-            if (millis >= iCutover) {
-                return iGregorianField.getAsText(millis, locale);
+        public String getAsText(long instant, Locale locale) {
+            if (instant >= iCutover) {
+                return iGregorianField.getAsText(instant, locale);
             } else {
-                return iJulianField.getAsText(millis, locale);
+                return iJulianField.getAsText(instant, locale);
             }
         }
 
-        public String getAsShortText(long millis, Locale locale) {
-            if (millis >= iCutover) {
-                return iGregorianField.getAsShortText(millis, locale);
+        public String getAsShortText(long instant, Locale locale) {
+            if (instant >= iCutover) {
+                return iGregorianField.getAsShortText(instant, locale);
             } else {
-                return iJulianField.getAsShortText(millis, locale);
+                return iJulianField.getAsShortText(instant, locale);
             }
         }
 
-        public long add(long millis, int value) {
-            return iGregorianField.add(millis, value);
+        public long add(long instant, int value) {
+            return iGregorianField.add(instant, value);
         }
 
-        public long add(long millis, long value) {
-            return iGregorianField.add(millis, value);
+        public long add(long instant, long value) {
+            return iGregorianField.add(instant, value);
         }
 
-        public long addWrapped(long millis, int value) {
-            return iGregorianField.addWrapped(millis, value);
+        public int getDifference(long minuendInstant, long subtrahendInstant) {
+            return iGregorianField.getDifference(minuendInstant, subtrahendInstant);
         }
 
-        public long getDifference(long minuendMillis, long subtrahendMillis) {
-            return iGregorianField.getDifference(minuendMillis, subtrahendMillis);
+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+            return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);
         }
 
-        public long set(long millis, int value) {
-            if (millis >= iCutover) {
-                millis = iGregorianField.set(millis, value);
-                if (millis < iCutover) {
+        public long set(long instant, int value) {
+            if (instant >= iCutover) {
+                instant = iGregorianField.set(instant, value);
+                if (instant < iCutover) {
                     // Only adjust if gap fully crossed.
-                    if (millis + iGapMillis < iCutover) {
-                        millis = gregorianToJulian(millis);
+                    if (instant + iGapDuration < iCutover) {
+                        instant = gregorianToJulian(instant);
                     }
                     // Verify that new value stuck.
-                    if (get(millis) != value) {
+                    if (get(instant) != value) {
                         throw new IllegalArgumentException
                             ("Illegal value for " + iGregorianField.getName() + ": " + value);
                     }
                 }
             } else {
-                millis = iJulianField.set(millis, value);
-                if (millis >= iCutover) {
+                instant = iJulianField.set(instant, value);
+                if (instant >= iCutover) {
                     // Only adjust if gap fully crossed.
-                    if (millis - iGapMillis >= iCutover) {
-                        millis = julianToGregorian(millis);
+                    if (instant - iGapDuration >= iCutover) {
+                        instant = julianToGregorian(instant);
                     }
                     // Verify that new value stuck.
-                    if (get(millis) != value) {
+                    if (get(instant) != value) {
                         throw new IllegalArgumentException
                             ("Illegal value for " + iJulianField.getName() + ": " + value);
                     }
                 }
             }
-            return millis;
+            return instant;
         }
 
-        public long set(long millis, String text, Locale locale) {
-            if (millis >= iCutover) {
-                millis = iGregorianField.set(millis, text, locale);
-                if (millis < iCutover) {
+        public long set(long instant, String text, Locale locale) {
+            if (instant >= iCutover) {
+                instant = iGregorianField.set(instant, text, locale);
+                if (instant < iCutover) {
                     // Only adjust if gap fully crossed.
-                    if (millis + iGapMillis < iCutover) {
-                        millis = gregorianToJulian(millis);
+                    if (instant + iGapDuration < iCutover) {
+                        instant = gregorianToJulian(instant);
                     }
                     // Cannot verify that new value stuck because set may be lenient.
                 }
             } else {
-                millis = iJulianField.set
-                    (millis, text, locale);
-                if (millis >= iCutover) {
+                instant = iJulianField.set(instant, text, locale);
+                if (instant >= iCutover) {
                     // Only adjust if gap fully crossed.
-                    if (millis - iGapMillis >= iCutover) {
-                        millis = julianToGregorian(millis);
+                    if (instant - iGapDuration >= iCutover) {
+                        instant = julianToGregorian(instant);
                     }
                     // Cannot verify that new value stuck because set may be lenient.
                 }
             }
-            return millis;
+            return instant;
         }
 
-        public boolean isLeap(long millis) {
-            if (millis >= iCutover) {
-                return iGregorianField.isLeap(millis);
-            } else {
-                return iJulianField.isLeap(millis);
+        public DurationField getDurationField() {
+            return iDurationField;
+        }
+
+        public DurationField getRangeDurationField() {
+            DurationField rangeField = iGregorianField.getRangeDurationField();
+            if (rangeField == null) {
+                rangeField = iJulianField.getRangeDurationField();
             }
+            return rangeField;
         }
 
-        public int getLeapAmount(long millis) {
-            if (millis >= iCutover) {
-                return iGregorianField.getLeapAmount(millis);
+        public boolean isLeap(long instant) {
+            if (instant >= iCutover) {
+                return iGregorianField.isLeap(instant);
             } else {
-                return iJulianField.getLeapAmount(millis);
+                return iJulianField.isLeap(instant);
             }
         }
 
-        public long getUnitMillis() {
-            // Since getUnitSize doesn't accept a millis argument, return
-            // Gregorian unit size because it is more accurate.
-            return iGregorianField.getUnitMillis();
+        public int getLeapAmount(long instant) {
+            if (instant >= iCutover) {
+                return iGregorianField.getLeapAmount(instant);
+            } else {
+                return iJulianField.getLeapAmount(instant);
+            }
         }
 
-        public long getRangeMillis() {
-            return iGregorianField.getRangeMillis();
+        public DurationField getLeapDurationField() {
+            return iGregorianField.getLeapDurationField();
         }
 
-        // Note on getMinimumValue and getMaximumValue: For all fields but
-        // year, yearOfEra, and centuryOfEra, the Julian and Gregorian limits
-        // are identical. The Julian limit is returned for getMaximumValue
-        // because it is smaller than the Gregorian limit. This is to prevent
-        // calling a field mutator that advances so far beyond the gap that the
-        // Julian calendar overflows.
 
         public int getMinimumValue() {
+            // For all precise fields, the Julian and Gregorian limits are
+            // identical. Choose Julian to tighten up the year limits.
             return iJulianField.getMinimumValue();
         }
         
-        public int getMinimumValue(long millis) {
-            if (millis >= iCutover) {
-                return iGregorianField.getMinimumValue(millis);
-            } else {
-                return iJulianField.getMinimumValue(millis);
+        public int getMinimumValue(long instant) {
+            if (instant < iCutover) {
+                return iJulianField.getMinimumValue(instant);
             }
+
+            int min = iGregorianField.getMinimumValue(instant);
+
+            // Because the cutover may reduce the length of this field, verify
+            // the minimum by setting it.
+            instant = iGregorianField.set(instant, min);
+            if (instant < iCutover) {
+                min = iGregorianField.get(iCutover);
+            }
+
+            return min;
         }
 
         public int getMaximumValue() {
-            return iJulianField.getMaximumValue();
+            // For all precise fields, the Julian and Gregorian limits are
+            // identical.
+            return iGregorianField.getMaximumValue();
         }
 
-        public int getMaximumValue(long millis) {
-            if (millis >= iCutover) {
-                return iGregorianField.getMaximumValue(millis);
-            } else {
-                return iJulianField.getMaximumValue(millis);
+        public int getMaximumValue(long instant) {
+            if (instant >= iCutover) {
+                return iGregorianField.getMaximumValue(instant);
             }
-        }
 
-        public long roundFloor(long millis) {
-            if (millis >= iCutover) {
-                millis = iGregorianField.roundFloor(millis);
-                if (millis < iCutover) {
-                    // Only adjust if gap fully crossed.
-                    if (millis + iGapMillis < iCutover) {
-                        millis = gregorianToJulian(millis);
-                    }
-                }
-            } else {
-                millis = iJulianField.roundFloor(millis);
+            int max = iJulianField.getMaximumValue(instant);
+
+            // Because the cutover may reduce the length of this field, verify
+            // the maximum by setting it.
+            instant = iJulianField.set(instant, max);
+            if (instant >= iCutover) {
+                max = iJulianField.get(iJulianField.add(iCutover, -1));
             }
-            return millis;
+
+            return max;
         }
 
-        public long roundCeiling(long millis) {
-            if (millis >= iCutover) {
-                millis = iGregorianField.roundCeiling(millis);
-            } else {
-                millis = iJulianField.roundCeiling(millis);
-                if (millis >= iCutover) {
+        public long roundFloor(long instant) {
+            if (instant >= iCutover) {
+                instant = iGregorianField.roundFloor(instant);
+                if (instant < iCutover) {
                     // Only adjust if gap fully crossed.
-                    if (millis - iGapMillis >= iCutover) {
-                        millis = julianToGregorian(millis);
+                    if (instant + iGapDuration < iCutover) {
+                        instant = gregorianToJulian(instant);
                     }
                 }
+            } else {
+                instant = iJulianField.roundFloor(instant);
             }
-            return millis;
+            return instant;
         }
 
-        public long remainder(long millis) {
-            if (millis >= iCutover) {
-                millis = iGregorianField.remainder(millis);
-                if (millis < iCutover) {
-                    // Only adjust if gap fully crossed.
-                    if (millis + iGapMillis < iCutover) {
-                        millis = gregorianToJulian(millis);
-                    }
-                }
+        public long roundCeiling(long instant) {
+            if (instant >= iCutover) {
+                instant = iGregorianField.roundCeiling(instant);
             } else {
-                millis = iJulianField.remainder(millis);
-                if (millis >= iCutover) {
+                instant = iJulianField.roundCeiling(instant);
+                if (instant >= iCutover) {
                     // Only adjust if gap fully crossed.
-                    if (millis - iGapMillis >= iCutover) {
-                        millis = julianToGregorian(millis);
+                    if (instant - iGapDuration >= iCutover) {
+                        instant = julianToGregorian(instant);
                     }
                 }
             }
-            return millis;
+            return instant;
         }
 
         public int getMaximumTextLength(Locale locale) {
@@ -464,92 +524,167 @@ public int getMaximumShortTextLength(Locale locale) {
      * set must be applied to add and addWrapped. Knowing when to use this
      * field requires specific knowledge of how the GJ fields are implemented.
      */
-    private class CutoverVarField extends CutoverField {
-        CutoverVarField(DateTimeField julianField, DateTimeField gregorianField) {
+    private final class ImpreciseCutoverField extends CutoverField {
+        static final long serialVersionUID = 3410248757173576441L;
+
+        /**
+         * Creates a duration field that links back to this.
+         */
+        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField) {
+            this(julianField, gregorianField, null);
+        }
+
+        /**
+         * Uses a shared duration field rather than creating a new one.
+         *
+         * @param durationField shared duration field
+         */
+        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,
+                              DurationField durationField)
+        {
             super(julianField, gregorianField);
+            if (durationField == null) {
+                durationField = new LinkedDurationField(iDurationField, this);
+            }
+            iDurationField = durationField;
         }
 
-        public long add(long millis, int value) {
-            if (millis >= iCutover) {
-                millis = iGregorianField.add(millis, value);
-                if (millis < iCutover) {
+        public long add(long instant, int value) {
+            if (instant >= iCutover) {
+                instant = iGregorianField.add(instant, value);
+                if (instant < iCutover) {
                     // Only adjust if gap fully crossed.
-                    if (millis + iGapMillis < iCutover) {
-                        millis = gregorianToJulian(millis);
+                    if (instant + iGapDuration < iCutover) {
+                        instant = gregorianToJulian(instant);
                     }
                 }
             } else {
-                millis = iJulianField.add(millis, value);
-                if (millis >= iCutover) {
+                instant = iJulianField.add(instant, value);
+                if (instant >= iCutover) {
                     // Only adjust if gap fully crossed.
-                    if (millis - iGapMillis >= iCutover) {
-                        millis = julianToGregorian(millis);
+                    if (instant - iGapDuration >= iCutover) {
+                        instant = julianToGregorian(instant);
                     }
                 }
             }
-            return millis;
+            return instant;
         }
         
-        public long add(long millis, long value) {
-            if (millis >= iCutover) {
-                millis = iGregorianField.add(millis, value);
-                if (millis < iCutover) {
+        public long add(long instant, long value) {
+            if (instant >= iCutover) {
+                instant = iGregorianField.add(instant, value);
+                if (instant < iCutover) {
                     // Only adjust if gap fully crossed.
-                    if (millis + iGapMillis < iCutover) {
-                        millis = gregorianToJulian(millis);
+                    if (instant + iGapDuration < iCutover) {
+                        instant = gregorianToJulian(instant);
                     }
                 }
             } else {
-                millis = iJulianField.add(millis, value);
-                if (millis >= iCutover) {
+                instant = iJulianField.add(instant, value);
+                if (instant >= iCutover) {
                     // Only adjust if gap fully crossed.
-                    if (millis - iGapMillis >= iCutover) {
-                        millis = julianToGregorian(millis);
+                    if (instant - iGapDuration >= iCutover) {
+                        instant = julianToGregorian(instant);
                     }
                 }
             }
-            return millis;
+            return instant;
         }
 
-        public long addWrapped(long millis, int value) {
-            if (millis >= iCutover) {
-                millis = iGregorianField.addWrapped(millis, value);
-                if (millis < iCutover) {
-                    // Only adjust if gap fully crossed.
-                    if (millis + iGapMillis < iCutover) {
-                        millis = gregorianToJulian(millis);
-                    }
+        public int getDifference(long minuendInstant, long subtrahendInstant) {
+            if (minuendInstant >= iCutover) {
+                if (subtrahendInstant >= iCutover) {
+                    return iGregorianField.getDifference(minuendInstant, subtrahendInstant);
                 }
+                // Remember, the add is being reversed. Since subtrahend is
+                // Julian, convert minuend to Julian to match.
+                minuendInstant = gregorianToJulian(minuendInstant);
+                return iJulianField.getDifference(minuendInstant, subtrahendInstant);
             } else {
-                millis = iJulianField.addWrapped(millis, value);
-                if (millis >= iCutover) {
-                    // Only adjust if gap fully crossed.
-                    if (millis - iGapMillis >= iCutover) {
-                        millis = julianToGregorian(millis);
-                    }
+                if (subtrahendInstant < iCutover) {
+                    return iJulianField.getDifference(minuendInstant, subtrahendInstant);
                 }
+                // Remember, the add is being reversed. Since subtrahend is
+                // Gregorian, convert minuend to Gregorian to match.
+                minuendInstant = julianToGregorian(minuendInstant);
+                return iGregorianField.getDifference(minuendInstant, subtrahendInstant);
             }
-            return millis;
         }
 
-        public long getDifference(long minuendMillis, long subtrahendMillis) {
-            if (minuendMillis >= iCutover) {
-                if (subtrahendMillis >= iCutover) {
-                    return iGregorianField.getDifference(minuendMillis, subtrahendMillis);
+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+            if (minuendInstant >= iCutover) {
+                if (subtrahendInstant >= iCutover) {
+                    return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);
                 }
                 // Remember, the add is being reversed. Since subtrahend is
                 // Julian, convert minuend to Julian to match.
-                minuendMillis = gregorianToJulian(minuendMillis);
-                return iJulianField.getDifference(minuendMillis, subtrahendMillis);
+                minuendInstant = gregorianToJulian(minuendInstant);
+                return iJulianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);
             } else {
-                if (subtrahendMillis < iCutover) {
-                    return iJulianField.getDifference(minuendMillis, subtrahendMillis);
+                if (subtrahendInstant < iCutover) {
+                    return iJulianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);
                 }
                 // Remember, the add is being reversed. Since subtrahend is
                 // Gregorian, convert minuend to Gregorian to match.
-                minuendMillis = julianToGregorian(minuendMillis);
-                return iGregorianField.getDifference(minuendMillis, subtrahendMillis);
+                minuendInstant = julianToGregorian(minuendInstant);
+                return iGregorianField.getDifferenceAsLong(minuendInstant, subtrahendInstant);
             }
         }
+
+        // Since the imprecise fields have durations longer than the gap
+        // duration, keep these methods simple. The inherited implementations
+        // produce incorrect results.
+        //
+        // Degenerate case: If this field is a month, and the cutover is set
+        // far into the future, then the gap duration may be so large as to
+        // reduce the number of months in a year. If the missing month(s) are
+        // at the beginning or end of the year, then the minimum and maximum
+        // values are not 1 and 12. I don't expect this case to ever occur.
+
+        public int getMinimumValue(long instant) {
+            if (instant >= iCutover) {
+                return iGregorianField.getMinimumValue(instant);
+            } else {
+                return iJulianField.getMinimumValue(instant);
+            }
+        }
+
+        public int getMaximumValue(long instant) {
+            if (instant >= iCutover) {
+                return iGregorianField.getMaximumValue(instant);
+            } else {
+                return iJulianField.getMaximumValue(instant);
+            }
+        }
+    }
+
+    /**
+     * Links the duration back to a ImpreciseCutoverField.
+     */
+    private static class LinkedDurationField extends DecoratedDurationField {
+        static final long serialVersionUID = 4097975388007713084L;
+
+        private final ImpreciseCutoverField iField;
+
+        LinkedDurationField(DurationField durationField, ImpreciseCutoverField dateTimeField) {
+            super(durationField, durationField.getName());
+            iField = dateTimeField;
+        }
+
+        public long add(long instant, int value) {
+            return iField.add(instant, value);
+        }
+
+        public long add(long instant, long value) {
+            return iField.add(instant, value);
+        }
+
+        public int getDifference(long minuendInstant, long subtrahendInstant) {
+            return iField.getDifference(minuendInstant, subtrahendInstant);
+        }
+
+        public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+            return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);
+        }
     }
 }
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJCenturyChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJCenturyChronology.java
index c968452f3..2dff47c04 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJCenturyChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJCenturyChronology.java
@@ -59,17 +59,20 @@
 import org.joda.time.DateTimeZone;
 import org.joda.time.chrono.OffsetDateTimeField;
 import org.joda.time.chrono.DividedDateTimeField;
-import org.joda.time.chrono.NonZeroDateTimeField;
+import org.joda.time.chrono.RemainderDateTimeField;
 
 /**
  * Chronology for supporting GJ style centuries. Century 1 begin on year 1, and
- * century of year ranges from 1 to 100.
+ * year of century ranges from 1 to 100.
  *
  * @author Brian S O'Neill
  * @author Stephen Colebourne
  * @since 1.0
  */
 class GJCenturyChronology extends GJChronology {
+
+    static final long serialVersionUID = -8572000567534692411L;
+
     private final GJChronology iChronology;
 
     /**
@@ -85,41 +88,62 @@ public GJCenturyChronology(GJChronology chrono) {
         }
 
         iChronology = chrono;
+        copyFields(chrono);
 
-        iYearField = chrono.year();
-        iYearOfEraField = chrono.yearOfEra();
-        iEraField = chrono.era();
-        iDayOfMonthField = chrono.dayOfMonth();
-        iDayOfWeekField = chrono.dayOfWeek();
-        iDayOfYearField = chrono.dayOfYear();
-        iMonthOfYearField = chrono.monthOfYear();
-        iWeekOfWeekyearField = chrono.weekOfWeekyear();
-        iWeekyearField = chrono.weekyear();
-
-        iMillisOfSecondField = chrono.millisOfSecond();
-        iMillisOfDayField = chrono.millisOfDay();
-        iSecondOfMinuteField = chrono.secondOfMinute();
-        iSecondOfDayField = chrono.secondOfDay();
-        iMinuteOfHourField = chrono.minuteOfHour();
-        iMinuteOfDayField = chrono.minuteOfDay();
-        iHourOfDayField = chrono.hourOfDay();
-        iHourOfHalfdayField = chrono.hourOfHalfday();
-        iClockhourOfDayField = chrono.clockhourOfDay();
-        iClockhourOfHalfdayField = chrono.clockhourOfHalfday();
-        iHalfdayOfDayField = chrono.halfdayOfDay();
-
-        DateTimeField offsetYear =
-            new OffsetDateTimeField("yearOfEra", iYearOfEraField, 99);
-        iCenturyOfEraField =
-            new DividedDateTimeField("centuryOfEra", offsetYear, 100);
-        iYearOfCenturyField =
-            new NonZeroDateTimeField("yearOfCentury", chrono.yearOfCentury());
+        DateTimeField tempField = new OffsetDateTimeField(iYearOfEraField, "", 99);
+        iCenturyOfEraField = new DividedDateTimeField
+            (tempField, "centuryOfEra", "centuries", 100);
+
+        tempField = new RemainderDateTimeField
+            ((DividedDateTimeField)iCenturyOfEraField, "");
+        iYearOfCenturyField = new OffsetDateTimeField(tempField, "yearOfCentury", 1);
     }
 
     public Chronology withUTC() {
         return this;
     }
 
+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
+        throws IllegalArgumentException
+    {
+        return iChronology.getDateOnlyMillis(year, monthOfYear, dayOfMonth);
+    }
+
+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        return iChronology.getTimeOnlyMillis
+            (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+    }
+
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int millisOfDay)
+        throws IllegalArgumentException
+    {
+        return iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);
+    }
+
+    public long getDateTimeMillis(long instant,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        return iChronology.getDateTimeMillis
+            (instant,
+             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+    }
+
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        return iChronology.getDateTimeMillis
+            (year, monthOfYear, dayOfMonth,
+             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+    }
+
     public long getGregorianJulianCutoverMillis() {
         return iChronology.getGregorianJulianCutoverMillis();
     }
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJChronology.java
index 99aa870bf..b5459255d 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJChronology.java
@@ -62,10 +62,15 @@
 import java.util.HashMap;
 
 import org.joda.time.Chronology;
+// Import for @link support
+import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeZone;
+import org.joda.time.DurationField;
 import org.joda.time.Instant;
 import org.joda.time.ReadableInstant;
+import org.joda.time.format.DateTimePrinter;
+import org.joda.time.format.ISODateTimeFormat;
 
 /**
  * GJChronology provides access to the individual date time fields 
@@ -96,12 +101,17 @@
  * A pure proleptic Gregorian chronology is obtained by specifying a cutover of
  * Long.MIN_VALUE. Likewise, a pure Julian chronology is obtained with a
  * cutover of Long.MAX_VALUE.
+ * <p>
+ * GJChronology is thread-safe and immutable.
  *
  * @author Stephen Colebourne
  * @author Brian S O'Neill
  * @since 1.0
  */
 public abstract class GJChronology extends Chronology {
+
+    static final long serialVersionUID = 3258844765135550418L;
+
     /**
      * The default GregorianJulian cutover point
      */
@@ -110,6 +120,18 @@
     // Cache that maps DateTimeZones to Factory instances.
     private static HashMap cZonesToFactories = new HashMap();
 
+    transient DurationField iYearsField;
+    transient DurationField iCenturiesField;
+    transient DurationField iMonthsField;
+    transient DurationField iWeekyearsField;
+
+    transient DurationField iMillisField;
+    transient DurationField iSecondsField;
+    transient DurationField iMinutesField;
+    transient DurationField iHoursField;
+    transient DurationField iDaysField;
+    transient DurationField iWeeksField;
+
     transient DateTimeField iYearField;
     transient DateTimeField iYearOfEraField;
     transient DateTimeField iYearOfCenturyField;
@@ -240,13 +262,13 @@ public static synchronized GJChronology getInstance(DateTimeZone zone,
                                                         boolean centuryISO,
                                                         int minDaysInFirstWeek)
     {
-        long millis;
+        long cutover;
         if (gregorianCutover != null) {
-            millis = gregorianCutover.getMillis();
+            cutover = gregorianCutover.getMillis();
         } else {
-            millis = DEFAULT_CUTOVER;
+            cutover = DEFAULT_CUTOVER;
         }
-        return getInstance(zone, millis, centuryISO, minDaysInFirstWeek);
+        return getInstance(zone, cutover, centuryISO, minDaysInFirstWeek);
     }
 
     /**
@@ -295,7 +317,7 @@ public static synchronized GJChronology getInstance(DateTimeZone zone,
 
     public Chronology withDateTimeZone(DateTimeZone zone) {
         if (zone == null) {
-            throw new IllegalArgumentException("The DateTimeZone must not be null");
+            zone = DateTimeZone.getDefault();
         }
         if (zone == getDateTimeZone()) {
             return this;
@@ -341,6 +363,10 @@ public Instant getGregorianJulianCutover() {
     // Milliseconds
     //------------------------------------------------------------
 
+    public DurationField millis() {
+        return iMillisField;
+    }
+
     public DateTimeField millisOfSecond() {
         return iMillisOfSecondField;
     }
@@ -352,6 +378,10 @@ public DateTimeField millisOfDay() {
     // Seconds
     //------------------------------------------------------------
 
+    public DurationField seconds() {
+        return iSecondsField;
+    }
+
     public DateTimeField secondOfMinute() {
         return iSecondOfMinuteField;
     }
@@ -360,6 +390,13 @@ public DateTimeField secondOfDay() {
         return iSecondOfDayField;
     }
 
+    // Minutes
+    //------------------------------------------------------------
+
+    public DurationField minutes() {
+        return iMinutesField;
+    }
+
     public DateTimeField minuteOfHour() {
         return iMinuteOfHourField;
     }
@@ -371,6 +408,10 @@ public DateTimeField minuteOfDay() {
     // Hours
     //------------------------------------------------------------
 
+    public DurationField hours() {
+        return iHoursField;
+    }
+
     public DateTimeField hourOfDay() {
         return iHourOfDayField;
     }
@@ -394,6 +435,10 @@ public DateTimeField halfdayOfDay() {
     // Day
     //------------------------------------------------------------
     
+    public DurationField days() {
+        return iDaysField;
+    }
+
     public DateTimeField dayOfWeek() {
         return iDayOfWeekField;
     }
@@ -409,10 +454,18 @@ public DateTimeField dayOfYear() {
     // Week
     //------------------------------------------------------------
     
+    public DurationField weeks() {
+        return iWeeksField;
+    }
+
     public DateTimeField weekOfWeekyear() {
         return iWeekOfWeekyearField;
     }
 
+    public DurationField weekyears() {
+        return iWeekyearsField;
+    }
+
     public DateTimeField weekyear() {
         return iWeekyearField;
     }
@@ -420,6 +473,10 @@ public DateTimeField weekyear() {
     // Month
     //------------------------------------------------------------
     
+    public DurationField months() {
+        return iMonthsField;
+    }
+
     public DateTimeField monthOfYear() {
         return iMonthOfYearField;
     }
@@ -427,6 +484,10 @@ public DateTimeField monthOfYear() {
     // Year
     //------------------------------------------------------------
     
+    public DurationField years() {
+        return iYearsField;
+    }
+
     public DateTimeField year() {
         return iYearField;
     }
@@ -439,6 +500,10 @@ public DateTimeField yearOfCentury() {
         return iYearOfCenturyField;
     }
 
+    public DurationField centuries() {
+        return iCenturiesField;
+    }
+
     public DateTimeField centuryOfEra() {
         return iCenturyOfEraField;
     }
@@ -447,6 +512,47 @@ public DateTimeField era() {
         return iEraField;
     }
 
+    // Output
+    //-----------------------------------------------------------------------
+    /**
+     * Gets a debugging toString.
+     * 
+     * @return a debugging string
+     */
+    public String toString() {
+        StringBuffer sb = new StringBuffer(50);
+        sb.append("GJChronology");
+        sb.append('[');
+        sb.append(getDateTimeZone().getID());
+        sb.append(", ");
+
+        long cutover = getGregorianJulianCutoverMillis();
+        if (cutover == Long.MAX_VALUE) {
+            sb.append("julian");
+        } else if (cutover == Long.MIN_VALUE) {
+            sb.append("gregorian");
+        } else {
+            sb.append("cutover=");
+            ISODateTimeFormat format = ISODateTimeFormat.getInstance(withUTC());
+            DateTimePrinter printer;
+            if (withUTC().getTimeOnlyMillis(cutover) == 0) {
+                printer = format.date();
+            } else {
+                printer = format.dateTime();
+            }
+            printer.printTo(sb, cutover);
+        }
+
+        sb.append(", century=");
+        sb.append(isCenturyISO() ? "iso" : "gj");
+
+        sb.append(", mdfw=");
+        sb.append(getMinimumDaysInFirstWeek());
+        sb.append(']');
+
+        return sb.toString();
+    }
+
     /**
      * Serialize GJChronology instances using a small stub. This reduces the
      * serialized size, and deserialized instances come from the cache.
@@ -461,7 +567,51 @@ Object writeReplace() {
                         getMinimumDaysInFirstWeek());
     }
 
+    /**
+     * Used by subclass constructors to copy all the fields of another
+     * chronology into this one.
+     */
+    void copyFields(Chronology chrono) {
+        iYearsField = chrono.years();
+        iCenturiesField = chrono.centuries();
+        iMonthsField = chrono.months();
+        iWeekyearsField = chrono.weekyears();
+
+        iMillisField = chrono.millis();
+        iSecondsField = chrono.seconds();
+        iMinutesField = chrono.minutes();
+        iHoursField = chrono.hours();
+        iDaysField = chrono.days();
+        iWeeksField = chrono.weeks();
+
+        iYearField = chrono.year();
+        iYearOfEraField = chrono.yearOfEra();
+        iYearOfCenturyField = chrono.yearOfCentury();
+        iCenturyOfEraField = chrono.centuryOfEra();
+        iEraField = chrono.era();
+        iDayOfWeekField = chrono.dayOfWeek();
+        iDayOfMonthField = chrono.dayOfMonth();
+        iDayOfYearField = chrono.dayOfYear();
+        iMonthOfYearField = chrono.monthOfYear();
+        iWeekOfWeekyearField = chrono.weekOfWeekyear();
+        iWeekyearField = chrono.weekyear();
+
+        iMillisOfSecondField = chrono.millisOfSecond();
+        iMillisOfDayField = chrono.millisOfDay();
+        iSecondOfMinuteField = chrono.secondOfMinute();
+        iSecondOfDayField = chrono.secondOfDay();
+        iMinuteOfHourField = chrono.minuteOfHour();
+        iMinuteOfDayField = chrono.minuteOfDay();
+        iHourOfDayField = chrono.hourOfDay();
+        iHourOfHalfdayField = chrono.hourOfHalfday();
+        iClockhourOfDayField = chrono.clockhourOfDay();
+        iClockhourOfHalfdayField = chrono.clockhourOfHalfday();
+        iHalfdayOfDayField = chrono.halfdayOfDay();
+    }
+
     private static final class Stub implements Serializable {
+        static final long serialVersionUID = -1220272966668670015L;
+
         private transient DateTimeZone iZone;
         private transient long iCutover;
         private transient boolean iCenturyISO;
@@ -534,27 +684,29 @@ public synchronized GJChronology getInstance(long gregorianCutover,
                 }
             }
 
-            if (gregorianCutover == Long.MAX_VALUE) {
-                chrono = new JulianChronology(minDaysInFirstWeek);
-            } else if (gregorianCutover == Long.MIN_VALUE) {
-                chrono = new GregorianChronology(minDaysInFirstWeek);
+            if (iZone != DateTimeZone.UTC) {
+                chrono = GJChronology.getInstance
+                    (DateTimeZone.UTC, gregorianCutover, centuryISO, minDaysInFirstWeek);
+                chrono = new GJZonedChronology(chrono, iZone);
             } else {
-                JulianChronology julian_utc = (JulianChronology)GJChronology.getInstance
-                    (DateTimeZone.UTC, Long.MAX_VALUE, true, minDaysInFirstWeek);
-                GregorianChronology gregorian_utc = (GregorianChronology)GJChronology.getInstance
-                    (DateTimeZone.UTC, Long.MIN_VALUE, true, minDaysInFirstWeek);
-
-                chrono = new CutoverChronology(julian_utc, gregorian_utc, gregorianCutover);
-            }
+                if (gregorianCutover == Long.MAX_VALUE) {
+                    chrono = new JulianChronology(minDaysInFirstWeek);
+                } else if (gregorianCutover == Long.MIN_VALUE) {
+                    chrono = new GregorianChronology(minDaysInFirstWeek);
+                } else {
+                    JulianChronology julian_utc = (JulianChronology)GJChronology.getInstance
+                        (DateTimeZone.UTC, Long.MAX_VALUE, true, minDaysInFirstWeek);
+                    GregorianChronology gregorian_utc = (GregorianChronology)GJChronology.getInstance
+                        (DateTimeZone.UTC, Long.MIN_VALUE, true, minDaysInFirstWeek);
+                    
+                    chrono = new CutoverChronology(julian_utc, gregorian_utc, gregorianCutover);
+                }
 
-            if (!centuryISO) {
-                chrono = new GJCenturyChronology(chrono);
+                if (!centuryISO) {
+                    chrono = new GJCenturyChronology(chrono);
+                }
             }
             
-            if (iZone != DateTimeZone.UTC) {
-                chrono = new GJZonedChronology(chrono, iZone);
-            }
-
             cache.add(new SoftReference(chrono));
             return chrono;
         }
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfMonthDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfMonthDateTimeField.java
index ba1f2383d..456d4a661 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfMonthDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfMonthDateTimeField.java
@@ -54,7 +54,9 @@
 package org.joda.time.chrono.gj;
 
 import org.joda.time.DateTimeConstants;
-import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+import org.joda.time.chrono.PreciseDurationDateTimeField;
+import org.joda.time.chrono.Utils;
 
 /**
  * Provides time calculations for the day of the month component of time.
@@ -64,92 +66,32 @@
  * @author Brian S O'Neill
  * @since 1.0
  */
-final class GJDayOfMonthDateTimeField extends DateTimeField {
+final class GJDayOfMonthDateTimeField extends PreciseDurationDateTimeField {
+
+    static final long serialVersionUID = -4677223814028011723L;
 
     private final ProlepticChronology iChronology;
 
     /**
-     * Restricted constructor
+     * Restricted constructor.
      */
-    GJDayOfMonthDateTimeField(ProlepticChronology chronology) {
-        super("dayOfMonth");
+    GJDayOfMonthDateTimeField(ProlepticChronology chronology, DurationField days) {
+        super("dayOfMonth", days);
         iChronology = chronology;
     }
 
     /**
      * Get the day of the month component of the specified time instant.
      * 
-     * @param millis  the time instant in millis to query.
+     * @param instant  the time instant in millis to query.
      * @return the day of the month extracted from the input.
      */
-    public int get(long millis) {
-        return iChronology.getDayOfMonth(millis);
-    }
-
-    /**
-     * Add the specified day of the month to the specified time instant.
-     * The amount added may be negative.
-     * 
-     * @param millis  the time instant in millis to update.
-     * @param days  the days to add to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long add(long millis, int days) {
-        return millis + days * (long)DateTimeConstants.MILLIS_PER_DAY;
-    }
-
-    public long add(long millis, long days) {
-        return millis + days * DateTimeConstants.MILLIS_PER_DAY;
-    }
-
-    /**
-     * Add to the day of the month component of the specified time instant
-     * wrapping around within that component if necessary.
-     * The amount added may be negative.
-     * 
-     * @param millis  the time instant in millis to update.
-     * @param days  the days to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long addWrapped(long millis, int days) {
-        // This method deviates from the normal logic found in
-        // concrete subclasses of DateTimeField.
-        // This is because the maximum allowed day for a given
-        // month must be calculated at run time.
-        int thisYear = iChronology.year().get(millis);
-        int thisMonth = iChronology.getMonthOfYear(millis, thisYear);
-        int thisDom = iChronology.getDayOfMonth(millis, thisYear, thisMonth);
-        int wrappedDom = getWrappedValue
-            (thisDom, days, 1, iChronology.getDaysInYearMonth(thisYear, thisMonth));
-        return set(millis, wrappedDom);
-    }
-
-    public long getDifference(long minuendMillis, long subtrahendMillis) {
-        return (minuendMillis - subtrahendMillis) / DateTimeConstants.MILLIS_PER_DAY;
-    }
-
-    /**
-     * Set the day of the month component of the specified time instant.
-     * 
-     * @param millis  the time instant in millis to update.
-     * @param year  the day (1,28-31) to update the time to.
-     * @return the updated time instant.
-     * @throws IllegalArgumentException  if day is is invalid for this year and month.
-     */
-    public long set(long millis, int day) {
-        int thisYear = iChronology.year().get(millis);
-        int thisMonth = iChronology.getMonthOfYear(millis, thisYear);
-        verifyValueBounds(day, 1, iChronology.getDaysInYearMonth(thisYear, thisMonth));
-        int thisDom = iChronology.getDayOfMonth(millis, thisYear, thisMonth);
-        return millis + (day - thisDom) * (long)DateTimeConstants.MILLIS_PER_DAY;
-    }
-
-    public long getUnitMillis() {
-        return DateTimeConstants.MILLIS_PER_DAY;
+    public int get(long instant) {
+        return iChronology.getDayOfMonth(instant);
     }
 
-    public long getRangeMillis() {
-        return iChronology.getRoughMillisPerMonth();
+    public DurationField getRangeDurationField() {
+        return iChronology.months();
     }
 
     public int getMinimumValue() {
@@ -160,38 +102,12 @@ public int getMaximumValue() {
         return 31;
     }
 
-    public int getMaximumValue(long millis) {
-        int thisYear = iChronology.year().get(millis);
-        int thisMonth = iChronology.getMonthOfYear(millis, thisYear);
+    public int getMaximumValue(long instant) {
+        int thisYear = iChronology.year().get(instant);
+        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);
         return iChronology.getDaysInYearMonth(thisYear, thisMonth);
     }
 
-    public long roundFloor(long millis) {
-        if (millis >= 0) {
-            return millis - millis % DateTimeConstants.MILLIS_PER_DAY;
-        } else {
-            millis += 1;
-            return millis - millis % DateTimeConstants.MILLIS_PER_DAY - DateTimeConstants.MILLIS_PER_DAY;
-        }
-    }
-
-    public long roundCeiling(long millis) {
-        if (millis >= 0) {
-            millis -= 1;
-            return millis - millis % DateTimeConstants.MILLIS_PER_DAY + DateTimeConstants.MILLIS_PER_DAY;
-        } else {
-            return millis - millis % DateTimeConstants.MILLIS_PER_DAY;
-        }
-    }
-
-    public long remainder(long millis) {
-        if (millis >= 0) {
-            return millis % DateTimeConstants.MILLIS_PER_DAY;
-        } else {
-            return (millis + 1) % DateTimeConstants.MILLIS_PER_DAY + DateTimeConstants.MILLIS_PER_DAY - 1;
-        }
-    }
-
     /**
      * Serialization singleton
      */
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfWeekDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfWeekDateTimeField.java
index 73fbf789e..98787aa5e 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfWeekDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfWeekDateTimeField.java
@@ -56,7 +56,9 @@
 import java.util.Locale;
 
 import org.joda.time.DateTimeConstants;
-import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+import org.joda.time.chrono.PreciseDurationDateTimeField;
+import org.joda.time.chrono.Utils;
 
 /**
  * GJDayOfWeekDateTimeField provides time calculations for the
@@ -67,35 +69,34 @@
  * @author Stephen Colebourne
  * @author Brian S O'Neill
  */
-final class GJDayOfWeekDateTimeField extends DateTimeField {
-    
-    private static final int MIN = DateTimeConstants.MONDAY;
-    private static final int MAX = DateTimeConstants.SUNDAY;
+final class GJDayOfWeekDateTimeField extends PreciseDurationDateTimeField {
     
+    static final long serialVersionUID = -3857947176719041436L;
+
     private final ProlepticChronology iChronology;
 
     /**
      * Restricted constructor.
      */
-    GJDayOfWeekDateTimeField(ProlepticChronology chronology) {
-        super("dayOfWeek");
+    GJDayOfWeekDateTimeField(ProlepticChronology chronology, DurationField days) {
+        super("dayOfWeek", days);
         iChronology = chronology;
     }
 
     /**
      * Get the value of the specified time instant.
      * 
-     * @param millis  the time instant in millis to query
+     * @param instant  the time instant in millis to query
      * @return the day of the week extracted from the input
      */
-    public int get(long millis) {
+    public int get(long instant) {
         // 1970-01-01 is day of week 4, Thursday.
 
         long daysSince19700101;
-        if (millis >= 0) {
-            daysSince19700101 = millis / DateTimeConstants.MILLIS_PER_DAY;
+        if (instant >= 0) {
+            daysSince19700101 = instant / DateTimeConstants.MILLIS_PER_DAY;
         } else {
-            daysSince19700101 = (millis - (DateTimeConstants.MILLIS_PER_DAY - 1))
+            daysSince19700101 = (instant - (DateTimeConstants.MILLIS_PER_DAY - 1))
                 / DateTimeConstants.MILLIS_PER_DAY;
             if (daysSince19700101 < -3) {
                 return 7 + (int) ((daysSince19700101 + 4) % 7);
@@ -108,93 +109,39 @@ public int get(long millis) {
     /**
      * Get the textual value of the specified time instant.
      * 
-     * @param millis  the time instant in millis to query
+     * @param instant  the time instant in millis to query
      * @param locale  the locale to use
      * @return the day of the week, such as 'Monday'
      */
-    public String getAsText(long millis, Locale locale) {
-        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(get(millis));
+    public String getAsText(long instant, Locale locale) {
+        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToText(get(instant));
     }
 
     /**
      * Get the abbreviated textual value of the specified time instant.
      * 
-     * @param millis  the time instant in millis to query
+     * @param instant  the time instant in millis to query
      * @param locale  the locale to use
      * @return the day of the week, such as 'Mon'
      */
-    public String getAsShortText(long millis, Locale locale) {
-        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToShortText(get(millis));
-    }
-
-    /**
-     * Add to the value of the specified time instant.
-     * The amount added may be negative.
-     * 
-     * @param millis  the time instant in millis to update
-     * @param day  the day of the week to add (can be negative)
-     * @return the updated time instant
-     */
-    public long add(long millis, int days) {
-        return millis + days * (long)DateTimeConstants.MILLIS_PER_DAY;
-    }
-
-    public long add(long millis, long days) {
-        return millis + days * DateTimeConstants.MILLIS_PER_DAY;
-    }
-
-    /**
-     * Add to the value of the specified time instant wrapping around
-     * within that component if necessary.
-     * The amount added may be negative.
-     * 
-     * @param millis  the time instant in millis to update
-     * @param day  the day of the week to add (can be negative)
-     * @return the updated time instant.
-     */
-    public long addWrapped(long millis, int days) {
-        int thisDow = get(millis);
-        int wrappedDow = getWrappedValue(thisDow, days, MIN, MAX);
-        // copy code from set() to avoid repeat call to get()
-        return millis + (wrappedDow - thisDow) * (long)DateTimeConstants.MILLIS_PER_DAY;
-    }
-
-    public long getDifference(long minuendMillis, long subtrahendMillis) {
-        return (minuendMillis - subtrahendMillis) / DateTimeConstants.MILLIS_PER_DAY;
-    }
-
-    /**
-     * Set the value of the specified time instant.
-     * 
-     * @param millis  the time instant in millis to update
-     * @param day  the day of the week (1,7) to update the time to
-     * @return the updated time instant
-     * @throws IllegalArgumentException  if day is invalid
-     */
-    public long set(long millis, int day) {
-        verifyValueBounds(day, MIN, MAX);
-        int thisDow = get(millis);
-        return millis + (day - thisDow) * (long)DateTimeConstants.MILLIS_PER_DAY;
+    public String getAsShortText(long instant, Locale locale) {
+        return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToShortText(get(instant));
     }
 
     /**
      * Set the value of the specified time instant from text.
      * 
-     * @param millis  the time instant in millis to update
+     * @param instant  the time instant in millis to update
      * @param text  the text to set from
      * @param locale  the locale to use
      * @return the updated millis
      */
-    public long set(long millis, String text, Locale locale) {
-        return set(millis, GJLocaleSymbols.forLocale(locale).dayOfWeekTextToValue(text));
-    }
-
-    public long getUnitMillis() {
-        return DateTimeConstants.MILLIS_PER_DAY;
+    public long set(long instant, String text, Locale locale) {
+        return set(instant, GJLocaleSymbols.forLocale(locale).dayOfWeekTextToValue(text));
     }
 
-    public long getRangeMillis() {
-        return DateTimeConstants.MILLIS_PER_WEEK;
+    public DurationField getRangeDurationField() {
+        return iChronology.weeks();
     }
 
     /**
@@ -203,7 +150,7 @@ public long getRangeMillis() {
      * @return the field's minimum value
      */
     public int getMinimumValue() {
-        return MIN;
+        return DateTimeConstants.MONDAY;
     }
 
     /**
@@ -212,7 +159,7 @@ public int getMinimumValue() {
      * @return the field's maximum value
      */
     public int getMaximumValue() {
-        return MAX;
+        return DateTimeConstants.SUNDAY;
     }
 
     /**
@@ -234,32 +181,6 @@ public int getMaximumTextLength(Locale locale) {
     public int getMaximumShortTextLength(Locale locale) {
         return GJLocaleSymbols.forLocale(locale).getDayOfWeekMaxShortTextLength();
     }
-    
-    public long roundFloor(long millis) {
-        if (millis >= 0) {
-            return millis - millis % DateTimeConstants.MILLIS_PER_DAY;
-        } else {
-            millis += 1;
-            return millis - millis % DateTimeConstants.MILLIS_PER_DAY - DateTimeConstants.MILLIS_PER_DAY;
-        }
-    }
-
-    public long roundCeiling(long millis) {
-        if (millis >= 0) {
-            millis -= 1;
-            return millis - millis % DateTimeConstants.MILLIS_PER_DAY + DateTimeConstants.MILLIS_PER_DAY;
-        } else {
-            return millis - millis % DateTimeConstants.MILLIS_PER_DAY;
-        }
-    }
-
-    public long remainder(long millis) {
-        if (millis >= 0) {
-            return millis % DateTimeConstants.MILLIS_PER_DAY;
-        } else {
-            return (millis + 1) % DateTimeConstants.MILLIS_PER_DAY + (DateTimeConstants.MILLIS_PER_DAY - 1);
-        }
-    }
 
     /**
      * Serialization singleton
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfYearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfYearDateTimeField.java
index 2be4c0b96..8f5536d96 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfYearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfYearDateTimeField.java
@@ -54,7 +54,9 @@
 package org.joda.time.chrono.gj;
 
 import org.joda.time.DateTimeConstants;
-import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+import org.joda.time.chrono.PreciseDurationDateTimeField;
+import org.joda.time.chrono.Utils;
 
 /**
  * Provides time calculations for the day of the year component of time.
@@ -64,83 +66,33 @@
  * @author Brian S O'Neill
  * @since 1.0
  */
-final class GJDayOfYearDateTimeField extends DateTimeField {
+final class GJDayOfYearDateTimeField extends PreciseDurationDateTimeField {
+
+    static final long serialVersionUID = -6821236822336841037L;
+
     private final ProlepticChronology iChronology;
 
     /**
      * Restricted constructor
      */
-    GJDayOfYearDateTimeField(ProlepticChronology chronology) {
-        super("dayOfYear");
+    GJDayOfYearDateTimeField(ProlepticChronology chronology, DurationField days) {
+        super("dayOfYear", days);
         iChronology = chronology;
     }
 
     /**
      * Get the day of the year component of the specified time instant.
      * 
-     * @param millis  the time instant in millis to query.
+     * @param instant  the time instant in millis to query.
      * @return the day of the year extracted from the input.
      */
-    public int get(long millis) {
-        long dateMillis = iChronology.year().roundFloor(millis);
-        return (int) ((millis - dateMillis) / DateTimeConstants.MILLIS_PER_DAY) + 1;
-    }
-
-    /**
-     * Add the specified day of the year to the specified time instant.
-     * The amount added may be negative.
-     * 
-     * @param millis  the time instant in millis to update.
-     * @param days  the days to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long add(long millis, int days) {
-        return millis + days * (long)DateTimeConstants.MILLIS_PER_DAY;
-    }
-
-    public long add(long millis, long days) {
-        return millis + days * DateTimeConstants.MILLIS_PER_DAY;
-    }
-
-    /**
-     * Add to the day of the year component of the specified time instant
-     * wrapping around within that component if necessary.
-     * 
-     * @param millis  the time instant in millis to update.
-     * @param years  the years to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long addWrapped(long millis, int days) {
-        int thisDoy = get(millis);
-        int wrappedDoy = getWrappedValue(thisDoy, days, getMinimumValue(millis), getMaximumValue(millis));
-        // avoid recalculating fields in set
-        return millis + (wrappedDoy - thisDoy) * (long)DateTimeConstants.MILLIS_PER_DAY;
+    public int get(long instant) {
+        long dateInstant = iChronology.year().roundFloor(instant);
+        return (int) ((instant - dateInstant) / DateTimeConstants.MILLIS_PER_DAY) + 1;
     }
 
-    public long getDifference(long minuendMillis, long subtrahendMillis) {
-        return (minuendMillis - subtrahendMillis) / DateTimeConstants.MILLIS_PER_DAY;
-    }
-
-    /**
-     * Set the day of the year component of the specified time instant.
-     * 
-     * @param millis  the time instant in millis to update.
-     * @param day  the day of the year (1,365/366) to update the time to.
-     * @return the updated time instant.
-     * @throws IllegalArgumentException  if year is invalid.
-    */
-    public long set(long millis, int day) {
-        verifyValueBounds(day, getMinimumValue(millis), getMaximumValue(millis));
-        int thisDoy = get(millis);
-        return millis + (day - thisDoy) * (long)DateTimeConstants.MILLIS_PER_DAY;
-    }
-
-    public long getUnitMillis() {
-        return DateTimeConstants.MILLIS_PER_DAY;
-    }
-
-    public long getRangeMillis() {
-        return iChronology.getRoughMillisPerYear();
+    public DurationField getRangeDurationField() {
+        return iChronology.years();
     }
 
     public int getMinimumValue() {
@@ -151,37 +103,11 @@ public int getMaximumValue() {
         return 366;
     }
 
-    public int getMaximumValue(long millis) {
-        int thisYear = iChronology.year().get(millis);
+    public int getMaximumValue(long instant) {
+        int thisYear = iChronology.year().get(instant);
         return iChronology.getDaysInYear(thisYear);
     }
 
-    public long roundFloor(long millis) {
-        if (millis >= 0) {
-            return millis - millis % DateTimeConstants.MILLIS_PER_DAY;
-        } else {
-            millis += 1;
-            return millis - millis % DateTimeConstants.MILLIS_PER_DAY - DateTimeConstants.MILLIS_PER_DAY;
-        }
-    }
-
-    public long roundCeiling(long millis) {
-        if (millis >= 0) {
-            millis -= 1;
-            return millis - millis % DateTimeConstants.MILLIS_PER_DAY + DateTimeConstants.MILLIS_PER_DAY;
-        } else {
-            return millis - millis % DateTimeConstants.MILLIS_PER_DAY;
-        }
-    }
-
-    public long remainder(long millis) {
-        if (millis >= 0) {
-            return millis % DateTimeConstants.MILLIS_PER_DAY;
-        } else {
-            return (millis + 1) % DateTimeConstants.MILLIS_PER_DAY + (DateTimeConstants.MILLIS_PER_DAY - 1);
-        }
-    }
-
     /**
      * Serialization singleton
      */
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJEraDateTimeField.java
index 153b1c97a..61c520b5b 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJEraDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJEraDateTimeField.java
@@ -56,7 +56,10 @@
 import java.util.Locale;
 
 import org.joda.time.DateTimeConstants;
-import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+import org.joda.time.chrono.AbstractDateTimeField;
+import org.joda.time.chrono.UnsupportedDurationField;
+import org.joda.time.chrono.Utils;
 
 /**
  * Provides time calculations for the era component of time.
@@ -66,8 +69,10 @@
  * @version 1.0
  * @since 1.0
  */
-final class GJEraDateTimeField extends DateTimeField {
+final class GJEraDateTimeField extends AbstractDateTimeField {
     
+    static final long serialVersionUID = 4240986525305515528L;
+
     private final ProlepticChronology iChronology;
 
     /**
@@ -78,85 +83,88 @@
         iChronology = chronology;
     }
 
+    public boolean isLenient() {
+        return false;
+    }
+
     /**
      * Get the Era component of the specified time instant.
      * 
-     * @param millis  the time instant in millis to query.
+     * @param instant  the time instant in millis to query.
      */
-    public int get(long millis) {
-        if (iChronology.year().get(millis) <= 0) {
+    public int get(long instant) {
+        if (iChronology.year().get(instant) <= 0) {
             return DateTimeConstants.BCE;
         } else {
             return DateTimeConstants.CE;
         }
     }
 
-    public String getAsText(long millis, Locale locale) {
-        return GJLocaleSymbols.forLocale(locale).eraValueToText(get(millis));
+    public String getAsText(long instant, Locale locale) {
+        return GJLocaleSymbols.forLocale(locale).eraValueToText(get(instant));
     }
 
     /**
-     * Unsupported - add the specified eras to the specified time instant.
+     * Set the Era component of the specified time instant.
      * 
-     * @param millis  the time instant in millis to update.
-     * @param eras  
+     * @param instant  the time instant in millis to update.
+     * @param era  the era to update the time to.
      * @return the updated time instant.
+     * @throws IllegalArgumentException  if era is invalid.
      */
-    public long add(long millis, int eras) {
-        throw new UnsupportedOperationException("Adding to Era field is unsupported");
-    }
-
-    public long add(long millis, long value) {
-        throw new UnsupportedOperationException("Adding to Era field is unsupported");
+    public long set(long instant, int era) {
+        Utils.verifyValueBounds(this, era, DateTimeConstants.BCE, DateTimeConstants.CE);
+            
+        int oldEra = get(instant);
+        if (oldEra != era) {
+            int year = iChronology.year().get(instant);
+            return iChronology.year().set(instant, -year);
+        } else {
+            return instant;
+        }
     }
 
-    /**
-     * Unsupported - add the specified eras to the specified time instant.
-     * 
-     * @param millis  the time instant in millis to update.
-     * @param eras
-     * @return the updated time instant.
-     */
-    public long addWrapped(long millis, int years) {
-        throw new UnsupportedOperationException("Adding to Era field is unsupported");
+    public long set(long instant, String text, Locale locale) {
+        return set(instant, GJLocaleSymbols.forLocale(locale).eraTextToValue(text));
     }
 
-    public long getDifference(long minuendMillis, long subtrahendMillis) {
-        throw new UnsupportedOperationException("Era field difference is unsupported");
+    public long roundFloor(long instant) {
+        if (get(instant) == DateTimeConstants.CE) {
+            return iChronology.year().set(0, 1);
+        } else {
+            return Long.MIN_VALUE;
+        }
     }
 
-    /**
-     * Set the Era component of the specified time instant.
-     * 
-     * @param millis  the time instant in millis to update.
-     * @param era  the era to update the time to.
-     * @return the updated time instant.
-     * @throws IllegalArgumentException  if era is invalid.
-     */
-    public long set(long millis, int era) {
-        super.verifyValueBounds(era, DateTimeConstants.BCE, DateTimeConstants.CE);
-            
-        int oldEra = get(millis);
-        if (oldEra != era) {
-            int year = iChronology.year().get(millis);
-            return iChronology.year().set(millis, -year);
+    public long roundCeiling(long instant) {
+        if (get(instant) == DateTimeConstants.BCE) {
+            return iChronology.year().set(0, 1);
         } else {
-            return millis;
+            return Long.MAX_VALUE;
         }
     }
 
-    public long set(long millis, String text, Locale locale) {
-        return set(millis, GJLocaleSymbols.forLocale(locale).eraTextToValue(text));
+    public long roundHalfFloor(long instant) {
+        // In reality, the era is infinite, so there is no halfway point.
+        return roundFloor(instant);
     }
 
-    public long getUnitMillis() {
-        return Long.MAX_VALUE;
+    public long roundHalfCeiling(long instant) {
+        // In reality, the era is infinite, so there is no halfway point.
+        return roundFloor(instant);
     }
 
-    public long getRangeMillis() {
-        // Should actually be double this, but that is not possible since Java
-        // doesn't support unsigned types.
-        return Long.MAX_VALUE;
+    public long roundHalfEven(long instant) {
+        // In reality, the era is infinite, so there is no halfway point.
+        return roundFloor(instant);
+    }
+
+    public DurationField getDurationField() {
+        return UnsupportedDurationField.INSTANCE;
+    }
+
+    public DurationField getRangeDurationField() {
+        return null;
     }
 
     public int getMinimumValue() {
@@ -171,20 +179,6 @@ public int getMaximumTextLength(Locale locale) {
         return GJLocaleSymbols.forLocale(locale).getEraMaxTextLength();
     }
 
-    /**
-     * Unsupported.
-     */
-    public long roundFloor(long millis) {
-        throw new UnsupportedOperationException("Rounding an Era field is unsupported");
-    }
-
-    /**
-     * Unsupported.
-     */
-    public long remainder(long millis) {
-        throw new UnsupportedOperationException("Calculating remainder from Era field is unsupported");
-    }
-
     /**
      * Serialization singleton
      */
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJLocaleSymbols.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJLocaleSymbols.java
index ca8f95fcf..77ff588a7 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJLocaleSymbols.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJLocaleSymbols.java
@@ -54,8 +54,9 @@
 
 package org.joda.time.chrono.gj;
 
+import java.lang.ref.WeakReference;
 import java.text.DateFormatSymbols;
-import java.util.HashMap;
+import java.util.WeakHashMap;
 import java.util.Locale;
 
 /**
@@ -64,14 +65,26 @@
  * @author Brian S O'Neill
  */
 class GJLocaleSymbols {
-    private static HashMap cCache = new HashMap();
+    private static final int FAST_CACHE_SIZE = 64;
 
-    public static synchronized GJLocaleSymbols forLocale(Locale locale) {
-        GJLocaleSymbols symbols = (GJLocaleSymbols)cCache.get(locale);
-        if (symbols == null) {
-            symbols = new GJLocaleSymbols(locale);
-            cCache.put(locale, symbols);
+    private static final GJLocaleSymbols[] cFastCache = new GJLocaleSymbols[FAST_CACHE_SIZE];
+
+    private static WeakHashMap cCache = new WeakHashMap();
+
+    public static GJLocaleSymbols forLocale(Locale locale) {
+        int index = System.identityHashCode(locale) & (FAST_CACHE_SIZE - 1);
+        GJLocaleSymbols symbols = cFastCache[index];
+        if (symbols != null && symbols.iLocale.get() == locale) {
+            return symbols;
+        }
+        synchronized (cCache) {
+            symbols = (GJLocaleSymbols) cCache.get(locale);
+            if (symbols == null) {
+                symbols = new GJLocaleSymbols(locale);
+                cCache.put(locale, symbols);
+            }
         }
+        cFastCache[index] = symbols;
         return symbols;
     }
 
@@ -105,6 +118,8 @@ private static int maxLength(String[] a) {
         return max;
     }
 
+    private final WeakReference iLocale;
+
     private final String[] iEras;
     private final String[] iDaysOfWeek;
     private final String[] iShortDaysOfWeek;
@@ -123,6 +138,9 @@ private GJLocaleSymbols(Locale locale) {
         if (locale == null) {
             locale = Locale.getDefault();
         }
+
+        iLocale = new WeakReference(locale);
+
         DateFormatSymbols dfs = new DateFormatSymbols(locale);
 
         iEras = dfs.getEras();
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJMonthOfYearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJMonthOfYearDateTimeField.java
index e893ada1b..77b5f68c1 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJMonthOfYearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJMonthOfYearDateTimeField.java
@@ -58,6 +58,9 @@
 
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+import org.joda.time.chrono.ImpreciseDateTimeField;
+import org.joda.time.chrono.Utils;
 
 /**
  * Provides time calculations for the month of the year component of time.
@@ -68,7 +71,10 @@
  * @version 1.0
  * @since 1.0
  */
-final class GJMonthOfYearDateTimeField extends DateTimeField {
+final class GJMonthOfYearDateTimeField extends ImpreciseDateTimeField {
+
+    static final long serialVersionUID = -4748157875845286249L;
+
     private static final int MIN = DateTimeConstants.JANUARY;
     private static final int MAX = DateTimeConstants.DECEMBER;
 
@@ -78,28 +84,32 @@
      * Restricted constructor
      */
     GJMonthOfYearDateTimeField(ProlepticChronology chronology) {
-        super("monthOfYear");
+        super("monthOfYear", "months", chronology.getRoughMillisPerMonth());
         iChronology = chronology;
     }
 
+    public boolean isLenient() {
+        return false;
+    }
+
     /**
      * Get the Month component of the specified time instant.
      *
      * @see org.joda.time.DateTimeField#get(long)
      * @see org.joda.time.ReadableDateTime#getMonthOfYear()
-     * @param millis  the time instant in millis to query.
+     * @param instant  the time instant in millis to query.
      * @return the month extracted from the input.
      */
-    public int get(long millis) {
-        return iChronology.getMonthOfYear(millis);
+    public int get(long instant) {
+        return iChronology.getMonthOfYear(instant);
     }
 
-    public String getAsText(long millis, Locale locale) {
-        return GJLocaleSymbols.forLocale(locale).monthOfYearValueToText(get(millis));
+    public String getAsText(long instant, Locale locale) {
+        return GJLocaleSymbols.forLocale(locale).monthOfYearValueToText(get(instant));
     }
 
-    public String getAsShortText(long millis, Locale locale) {
-        return GJLocaleSymbols.forLocale(locale).monthOfYearValueToShortText(get(millis));
+    public String getAsShortText(long instant, Locale locale) {
+        return GJLocaleSymbols.forLocale(locale).monthOfYearValueToShortText(get(instant));
     }
 
     /**
@@ -113,24 +123,24 @@ public String getAsShortText(long millis, Locale locale) {
      * 
      * @see org.joda.time.DateTimeField#add
      * @see org.joda.time.ReadWritableDateTime#addMonths(int)
-     * @param millis  the time instant in millis to update.
+     * @param instant  the time instant in millis to update.
      * @param months  the months to add (can be negative).
      * @return the updated time instant.
      */
-    public long add(long millis, int months) {
+    public long add(long instant, int months) {
         if (months == 0) {
-            return millis; // the easy case
+            return instant; // the easy case
         }
         //
         // Save time part first.
         //
-        long timePart = iChronology.millisOfDay().get(millis);
+        long timePart = iChronology.millisOfDay().get(instant);
         //
         //
         // Get this year and month.
         //
-        int thisYear = iChronology.year().get(millis);
-        int thisMonth = iChronology.getMonthOfYear(millis, thisYear);
+        int thisYear = iChronology.year().get(instant);
+        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);
         // ----------------------------------------------------------
         //
         // Do not refactor without careful consideration.
@@ -162,7 +172,7 @@ public long add(long millis, int months) {
         //
         // Quietly force DOM to nearest sane value.
         //
-        int dayToUse = iChronology.getDayOfMonth(millis, thisYear, thisMonth);
+        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);
         int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse);
         if (dayToUse > maxDay) {
             dayToUse = maxDay;
@@ -175,18 +185,18 @@ public long add(long millis, int months) {
         return datePart + timePart;
     }
 
-    public long add(long millis, long months) {
+    public long add(long instant, long months) {
         int i_months = (int)months;
         if (i_months == months) {
-            return add(millis, i_months);
+            return add(instant, i_months);
         }
 
         // Copied from add(long, int) and modified slightly:
 
-        long timePart = iChronology.millisOfDay().get(millis);
+        long timePart = iChronology.millisOfDay().get(instant);
 
-        int thisYear = iChronology.year().get(millis);
-        int thisMonth = iChronology.getMonthOfYear(millis, thisYear);
+        int thisYear = iChronology.year().get(instant);
+        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);
 
         long yearToUse;
         long monthToUse = thisMonth - 1 + months;
@@ -216,7 +226,7 @@ public long add(long millis, long months) {
         int i_yearToUse = (int)yearToUse;
         int i_monthToUse = (int)monthToUse;
 
-        int dayToUse = iChronology.getDayOfMonth(millis, thisYear, thisMonth);
+        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);
         int maxDay = iChronology.getDaysInYearMonth(i_yearToUse, i_monthToUse);
         if (dayToUse > maxDay) {
             dayToUse = maxDay;
@@ -233,45 +243,45 @@ public long add(long millis, long months) {
      * 
      * @see org.joda.time.DateTimeField#addWrapped
      * @see org.joda.time.ReadWritableDateTime#addWrappedMonthOfYear(int)
-     * @param millis  the time instant in millis to update.
+     * @param instant  the time instant in millis to update.
      * @param months  the months to add (can be negative).
      * @return the updated time instant.
      */
-    public long addWrapped(long millis, int months) {
-        return set(millis, getWrappedValue(get(millis), months, MIN, MAX));
+    public long addWrapped(long instant, int months) {
+        return set(instant, Utils.getWrappedValue(get(instant), months, MIN, MAX));
     }
 
-    public long getDifference(long minuendMillis, long subtrahendMillis) {
-        if (minuendMillis < subtrahendMillis) {
-            return -getDifference(subtrahendMillis, minuendMillis);
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        if (minuendInstant < subtrahendInstant) {
+            return -getDifference(subtrahendInstant, minuendInstant);
         }
 
         DateTimeField yearField = iChronology.year();
-        int minuendYear = yearField.get(minuendMillis);
-        int minuendMonth = iChronology.getMonthOfYear(minuendMillis, minuendYear);
-        int subtrahendYear = yearField.get(subtrahendMillis);
-        int subtrahendMonth = iChronology.getMonthOfYear(subtrahendMillis, subtrahendYear);
+        int minuendYear = yearField.get(minuendInstant);
+        int minuendMonth = iChronology.getMonthOfYear(minuendInstant, minuendYear);
+        int subtrahendYear = yearField.get(subtrahendInstant);
+        int subtrahendMonth = iChronology.getMonthOfYear(subtrahendInstant, subtrahendYear);
 
         long difference = (minuendYear - subtrahendYear) * 12L + minuendMonth - subtrahendMonth;
 
         // Before adjusting for remainder, account for special case of add
         // where the day-of-month is forced to the nearest sane value.
         int minuendDom = iChronology.getDayOfMonth
-            (minuendMillis, minuendYear, minuendMonth);
+            (minuendInstant, minuendYear, minuendMonth);
         if (minuendDom == iChronology.getDaysInYearMonth(minuendYear, minuendMonth)) {
             // Last day of the minuend month...
             int subtrahendDom = iChronology.getDayOfMonth
-                (subtrahendMillis, subtrahendYear, subtrahendMonth);
+                (subtrahendInstant, subtrahendYear, subtrahendMonth);
             if (subtrahendDom > minuendDom) {
                 // ...and day of subtrahend month is larger.
-                subtrahendMillis = iChronology.dayOfMonth().set(subtrahendMillis, minuendDom);
+                subtrahendInstant = iChronology.dayOfMonth().set(subtrahendInstant, minuendDom);
             }
         }
 
         // Inlined remainder method to avoid duplicate calls.
-        long minuendRem = minuendMillis
+        long minuendRem = minuendInstant
             - iChronology.getYearMonthMillis(minuendYear, minuendMonth);
-        long subtrahendRem = subtrahendMillis
+        long subtrahendRem = subtrahendInstant
             - iChronology.getYearMonthMillis(subtrahendYear, subtrahendMonth);
 
         if (minuendRem < subtrahendRem) {
@@ -289,17 +299,17 @@ public long getDifference(long minuendMillis, long subtrahendMillis) {
      * 07-31 to month 6 = 06-30<p>
      * 03-31 to month 2 = 02-28 or 02-29 depending<p>
      * 
-     * @param millis  the time instant in millis to update.
+     * @param instant  the time instant in millis to update.
      * @param month  the month (1,12) to update the time to.
      * @return the updated time instant.
      * @throws IllegalArgumentException  if month is invalid
      */
-    public long set(long millis, int month) {
-        super.verifyValueBounds(month, MIN, MAX);
+    public long set(long instant, int month) {
+        Utils.verifyValueBounds(this, month, MIN, MAX);
         //
-        int thisYear = iChronology.year().get(millis);
+        int thisYear = iChronology.year().get(instant);
         //
-        int thisDom = iChronology.getDayOfMonth(millis, thisYear);
+        int thisDom = iChronology.getDayOfMonth(instant, thisYear);
         int maxDom = iChronology.getDaysInYearMonth(thisYear, month);
         if (thisDom > maxDom) {
             // Quietly force DOM to nearest sane value.
@@ -307,19 +317,33 @@ public long set(long millis, int month) {
         }
         // Return newly calculated millis value
         return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +
-            iChronology.millisOfDay().get(millis);
+            iChronology.millisOfDay().get(instant);
+    }
+
+    public long set(long instant, String text, Locale locale) {
+        return set(instant, GJLocaleSymbols.forLocale(locale).monthOfYearTextToValue(text));
+    }
+
+    public DurationField getRangeDurationField() {
+        return iChronology.years();
     }
 
-    public long set(long millis, String text, Locale locale) {
-        return set(millis, GJLocaleSymbols.forLocale(locale).monthOfYearTextToValue(text));
+    public boolean isLeap(long instant) {
+        int thisYear = iChronology.year().get(instant);
+        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);
+        if (thisMonth != 2) {
+            return false;
+        } else {
+            return 29 == iChronology.getDaysInYearMonth(thisYear, thisMonth);
+        }
     }
 
-    public long getUnitMillis() {
-        return iChronology.getRoughMillisPerMonth();
+    public int getLeapAmount(long instant) {
+        return isLeap(instant) ? 1 : 0;
     }
 
-    public long getRangeMillis() {
-        return iChronology.getRoughMillisPerYear();
+    public DurationField getLeapDurationField() {
+        return iChronology.days();
     }
 
     public int getMinimumValue() {
@@ -338,14 +362,14 @@ public int getMaximumShortTextLength(Locale locale) {
         return GJLocaleSymbols.forLocale(locale).getMonthMaxShortTextLength();
     }
 
-    public long roundFloor(long millis) {
-        int year = iChronology.year().get(millis);
-        int month = iChronology.getMonthOfYear(millis, year);
+    public long roundFloor(long instant) {
+        int year = iChronology.year().get(instant);
+        int month = iChronology.getMonthOfYear(instant, year);
         return iChronology.getYearMonthMillis(year, month);
     }
 
-    public long remainder(long millis) {
-        return millis - roundFloor(millis);
+    public long remainder(long instant) {
+        return instant - roundFloor(instant);
     }
 
     /**
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekOfWeekyearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekOfWeekyearDateTimeField.java
index 3b7093b09..6fa3a695d 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekOfWeekyearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekOfWeekyearDateTimeField.java
@@ -55,6 +55,9 @@
 
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+import org.joda.time.chrono.PreciseDurationDateTimeField;
+import org.joda.time.chrono.Utils;
 
 /**
  * Provides time calculations for the week of a week based year component of time.
@@ -65,18 +68,17 @@
  * @version 1.0
  * @since 1.0
  */
-final class GJWeekOfWeekyearDateTimeField extends DateTimeField {
+final class GJWeekOfWeekyearDateTimeField extends PreciseDurationDateTimeField {
 
-    private static final int MIN = 1;
-    private static final int MAX = 53;
+    static final long serialVersionUID = -1587436826395135328L;
 
     private final ProlepticChronology iChronology;
 
     /**
      * Restricted constructor
      */
-    GJWeekOfWeekyearDateTimeField(ProlepticChronology chronology) {
-        super("weekOfWeekyear");
+    GJWeekOfWeekyearDateTimeField(ProlepticChronology chronology, DurationField weeks) {
+        super("weekOfWeekyear", weeks);
         iChronology = chronology;
     }
 
@@ -84,112 +86,57 @@
      * Get the week of a week based year component of the specified time instant.
      * 
      * @see org.joda.time.DateTimeField#get(long)
-     * @param millis  the time instant in millis to query.
+     * @param instant  the time instant in millis to query.
      * @return the week of the year extracted from the input.
      */
-    public int get(long millis) {
-        int year = iChronology.year().get(millis);
+    public int get(long instant) {
+        int year = iChronology.year().get(instant);
         //
         long firstWeekMillis1 = iChronology.getFirstWeekOfYearMillis(year);
-        if (millis < firstWeekMillis1) {
+        if (instant < firstWeekMillis1) {
             return iChronology.getWeeksInYear(year - 1);
         }
         long firstWeekMillis2 = iChronology.getFirstWeekOfYearMillis(year + 1);
-        if (millis >= firstWeekMillis2) {
+        if (instant >= firstWeekMillis2) {
             return 1;
         }
-        return (int) ((millis - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1;
+        return (int) ((instant - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1;
     }
 
-    /**
-     * Add the specified weeks to the specified time instant.
-     * <p>
-     * The amount added may be negative.
-     * 
-     * @see org.joda.time.DateTimeField#add
-     * @param millis  the time instant in millis to update.
-     * @param weeks  the weeks to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long add(long millis, int weeks) {
-        // Return newly calculated millis value
-        return millis + (weeks * (long)DateTimeConstants.MILLIS_PER_WEEK);
+    public DurationField getRangeDurationField() {
+        return iChronology.weekyears();
     }
 
-    public long add(long millis, long weeks) {
-        // Return newly calculated millis value
-        return millis + (weeks * DateTimeConstants.MILLIS_PER_WEEK);
-    }
+    // 1970-01-01 is day of week 4, Thursday. The rounding methods need to
+    // apply a corrective alignment since weeks begin on day of week 1, Monday.
 
-    /**
-     * Add to the week component of the specified time instant
-     * wrapping around within that component if necessary.
-     * 
-     * @see org.joda.time.DateTimeField#addWrapped
-     * @param millis  the time instant in millis to update.
-     * @param years  the years to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long addWrapped(long millis, int weeks) {
-        int thisWeek = get(millis);
-        int wrappedWeek = getWrappedValue(thisWeek, weeks, 1, getMaximumValue(millis));
-        return millis + (wrappedWeek - thisWeek) * (long)DateTimeConstants.MILLIS_PER_WEEK;
+    public long roundFloor(long instant) {
+        return super.roundFloor(instant + 3 * DateTimeConstants.MILLIS_PER_DAY)
+            - 3 * DateTimeConstants.MILLIS_PER_DAY;
     }
 
-    public long getDifference(long minuendMillis, long subtrahendMillis) {
-        return (minuendMillis - subtrahendMillis) / DateTimeConstants.MILLIS_PER_WEEK;
+    public long roundCeiling(long instant) {
+        return super.roundCeiling(instant + 3 * DateTimeConstants.MILLIS_PER_DAY)
+            - 3 * DateTimeConstants.MILLIS_PER_DAY;
     }
 
-    /**
-     * Set the week of a week based year component of the specified time instant.
-     * 
-     * @see org.joda.time.DateTimeField#set
-     * @param millis  the time instant in millis to update.
-     * @param week  the week (1,53) to update the time to.
-     * @return the updated time instant.
-     * @throws IllegalArgumentException  if week is invalid.
-     */
-    public long set(long millis, int week) {
-        verifyValueBounds(week, 1, getMaximumValue(millis));
-        int thisWeek = get(millis);
-        return millis + (week - thisWeek) * (long)DateTimeConstants.MILLIS_PER_WEEK;
-    }
-
-    public long getUnitMillis() {
-        return DateTimeConstants.MILLIS_PER_WEEK;
-    }
-
-    public long getRangeMillis() {
-        return iChronology.getRoughMillisPerYear();
+    public long remainder(long instant) {
+        return super.remainder(instant + 3 * DateTimeConstants.MILLIS_PER_DAY);
     }
 
     public int getMinimumValue() {
-        return MIN;
+        return 1;
     }
 
     public int getMaximumValue() {
-        return MAX;
+        return 53;
     }
 
-    public int getMaximumValue(long millis) {
-        int thisYear = iChronology.weekyear().get(millis);
+    public int getMaximumValue(long instant) {
+        int thisYear = iChronology.weekyear().get(instant);
         return iChronology.getWeeksInYear(thisYear);
     }
 
-    public long roundFloor(long millis) {
-        DateTimeField dowField = iChronology.dayOfWeek();
-        millis = dowField.roundFloor(millis);
-        int dow = dowField.get(millis);
-        if (dow > 1) {
-            millis = dowField.add(millis, 1 - dow);
-        }
-        return millis;
-    }
-
-    public long remainder(long millis) {
-        return millis - roundFloor(millis);
-    }
-
     /**
      * Serialization singleton
      */
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekyearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekyearDateTimeField.java
index 2a7be442f..5004d9ad8 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekyearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekyearDateTimeField.java
@@ -55,6 +55,9 @@
 
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+import org.joda.time.chrono.ImpreciseDateTimeField;
+import org.joda.time.chrono.Utils;
 
 /**
  * Provides time calculations for the week of the weekyear component of time.
@@ -66,8 +69,10 @@
  * @since 1.0
  * @see org.joda.time.DateTimeField
  */
-final class GJWeekyearDateTimeField extends DateTimeField {
+final class GJWeekyearDateTimeField extends ImpreciseDateTimeField {
     
+    static final long serialVersionUID = 6215066916806820644L;
+
     private static final long WEEK_53 = (53L - 1) * DateTimeConstants.MILLIS_PER_WEEK;
 
     private final ProlepticChronology iChronology;
@@ -76,25 +81,29 @@
      * Restricted constructor
      */
     GJWeekyearDateTimeField(ProlepticChronology chronology) {
-        super("weekyear");
+        super("weekyear", "weekyears", chronology.getRoughMillisPerYear());
         iChronology = chronology;
     }
 
+    public boolean isLenient() {
+        return false;
+    }
+
     /**
      * Get the Year of a week based year component of the specified time instant.
      * 
      * @see org.joda.time.DateTimeField#get
-     * @param millis  the time instant in millis to query.
+     * @param instant  the time instant in millis to query.
      * @return the year extracted from the input.
      */
-    public int get(long millis) {
-        int week = iChronology.weekOfWeekyear().get(millis);
+    public int get(long instant) {
+        int week = iChronology.weekOfWeekyear().get(instant);
         if (week == 1) {
-            return iChronology.year().get(millis + DateTimeConstants.MILLIS_PER_WEEK);
+            return iChronology.year().get(instant + DateTimeConstants.MILLIS_PER_WEEK);
         } else if (week > 51) {
-            return iChronology.year().get(millis - (2 * DateTimeConstants.MILLIS_PER_WEEK));
+            return iChronology.year().get(instant - (2 * DateTimeConstants.MILLIS_PER_WEEK));
         } else {
-            return iChronology.year().get(millis);
+            return iChronology.year().get(instant);
         }
     }
 
@@ -102,19 +111,19 @@ public int get(long millis) {
      * Add the specified years to the specified time instant.
      * 
      * @see org.joda.time.DateTimeField#add
-     * @param millis  the time instant in millis to update.
+     * @param instant  the time instant in millis to update.
      * @param years  the years to add (can be negative).
      * @return the updated time instant.
      */
-    public long add(long millis, int years) {
+    public long add(long instant, int years) {
         if (years == 0) {
-            return millis;
+            return instant;
         }
-        return set(millis, get(millis) + years);
+        return set(instant, get(instant) + years);
     }
 
-    public long add(long millis, long value) {
-        return addLong(millis, value);
+    public long add(long instant, long value) {
+        return add(instant, Utils.safeToInt(value));
     }
 
     /**
@@ -122,24 +131,24 @@ public long add(long millis, long value) {
      * wrapping around within that component if necessary.
      * 
      * @see org.joda.time.DateTimeField#addWrapped
-     * @param millis  the time instant in millis to update.
+     * @param instant  the time instant in millis to update.
      * @param years  the years to add (can be negative).
      * @return the updated time instant.
      */
-    public long addWrapped(long millis, int years) {
-        return add(millis, years);
+    public long addWrapped(long instant, int years) {
+        return add(instant, years);
     }
 
-    public long getDifference(long minuendMillis, long subtrahendMillis) {
-        if (minuendMillis < subtrahendMillis) {
-            return -getDifference(subtrahendMillis, minuendMillis);
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        if (minuendInstant < subtrahendInstant) {
+            return -getDifference(subtrahendInstant, minuendInstant);
         }
 
-        int minuendWeekyear = get(minuendMillis);
-        int subtrahendWeekyear = get(subtrahendMillis);
+        int minuendWeekyear = get(minuendInstant);
+        int subtrahendWeekyear = get(subtrahendInstant);
 
-        long minuendRem = remainder(minuendMillis);
-        long subtrahendRem = remainder(subtrahendMillis);
+        long minuendRem = remainder(minuendInstant);
+        long subtrahendRem = remainder(subtrahendInstant);
 
         // Balance leap weekyear differences on remainders.
         if (subtrahendRem >= WEEK_53 && iChronology.getWeeksInYear(minuendWeekyear) <= 52) {
@@ -157,25 +166,25 @@ public long getDifference(long minuendMillis, long subtrahendMillis) {
      * Set the Year of a week based year component of the specified time instant.
      *
      * @see org.joda.time.DateTimeField#set
-     * @param millis  the time instant in millis to update.
+     * @param instant  the time instant in millis to update.
      * @param year  the year (-9999,9999) to set the date to.
      * @return the updated DateTime.
      * @throws IllegalArgumentException  if year is invalid.
      */
-    public long set(long millis, int year) {
-        super.verifyValueBounds(Math.abs(year),
+    public long set(long instant, int year) {
+        Utils.verifyValueBounds(this, Math.abs(year),
                                 iChronology.getMinYear(), iChronology.getMaxYear());
         //
         // Do nothing if no real change is requested.
         //
-        int thisWeekyear = get( millis );
+        int thisWeekyear = get( instant );
         if ( thisWeekyear == year ) {
-            return millis;
+            return instant;
         }
         //
         // Calculate the DayOfWeek (to be preserved).
         //
-        int thisDow = iChronology.dayOfWeek().get( millis );
+        int thisDow = iChronology.dayOfWeek().get( instant );
         //
         // Calculate the maximum weeks in the target year.
         //
@@ -189,7 +198,7 @@ public long set(long millis, int year) {
         // for the target weekyear.  In that case it is adjusted
         // to the maximum possible.
         //
-        int setToWeek = iChronology.weekOfWeekyear().get( millis );
+        int setToWeek = iChronology.weekOfWeekyear().get( instant );
         if ( setToWeek > maxOutWeeks ) {
             setToWeek = maxOutWeeks;
         }
@@ -197,74 +206,63 @@ public long set(long millis, int year) {
         // Get a wroking copy of the current date-time.
         // This can be a convenience for debugging.
         //
-        long workMillis = millis; // Get a copy
+        long workInstant = instant; // Get a copy
         //
         // Attempt to get close to the proper weekyear.
         // Note - we cannot currently call ourself, so we just call
         // set for the year.  This at least gets us close.
         //
-        workMillis = iChronology.year().set( workMillis, year );
+        workInstant = iChronology.year().set( workInstant, year );
         //
         // Calculate the weekyear number for the get close to value
         // (which might not be equal to the year just set).
         //
-        int workWoyYear = iChronology.weekyear().get( workMillis );
-
-        // *TEMP Debugging
-        /*
-        MutableDateTime temp = new MutableDateTime(workMillis,
-            ISOChronology.getInstance());
-        System.out.println("Current mdt value 01: "
-            + temp
-            + " " + workWoyYear
-        );
-        System.out.println("->Temp: " + temp.toString()
-            + " WOYYr=" + temp.getWeekyear()
-            + " WOYWk=" + temp.getWeekOfWeekyear()
-            + " DoW=" + temp.getDayOfWeek()
-        );
-        */
+        int workWoyYear = iChronology.weekyear().get( workInstant );
 
         //
         // At most we are off by one year, which can be "fixed" by
         // adding/subtracting a week.
         //
         if ( workWoyYear < year ) {
-            // System.out.println("Year: Adding "+workWoyYear+" "+year);
-            workMillis += DateTimeConstants.MILLIS_PER_WEEK;
+            workInstant += DateTimeConstants.MILLIS_PER_WEEK;
         } else if ( workWoyYear > year ) {
-            // System.out.println("Year: Subing "+workWoyYear+" "+year);
-            workMillis -= DateTimeConstants.MILLIS_PER_WEEK;
+            workInstant -= DateTimeConstants.MILLIS_PER_WEEK;
         }
         //
         // Set the proper week in the current weekyear.
         //
 
         // BEGIN: possible set WeekOfWeekyear logic.
-        int currentWoyWeek = iChronology.weekOfWeekyear().get( workMillis );
+        int currentWoyWeek = iChronology.weekOfWeekyear().get( workInstant );
         // No range check required (we already know it is OK).
-        workMillis = workMillis + (setToWeek - currentWoyWeek)
+        workInstant = workInstant + (setToWeek - currentWoyWeek)
             * (long)DateTimeConstants.MILLIS_PER_WEEK;
         // END: possible set WeekOfWeekyear logic.
 
         //
         // Reset DayOfWeek to previous value.
         //
-        workMillis = iChronology.dayOfWeek().set( workMillis, thisDow );
+        workInstant = iChronology.dayOfWeek().set( workInstant, thisDow );
         //
         // Return result.
         //
-        return workMillis;
+        return workInstant;
+    }
+
+    public DurationField getRangeDurationField() {
+        return null;
+    }
+
+    public boolean isLeap(long instant) {
+        return iChronology.weekOfWeekyear().getMaximumValue(instant) > 52;
     }
 
-    public long getUnitMillis() {
-        return iChronology.getRoughMillisPerYear();
+    public int getLeapAmount(long instant) {
+        return iChronology.weekOfWeekyear().getMaximumValue(instant) - 52;
     }
 
-    public long getRangeMillis() {
-        // Should actually be double this, but that is not possible since Java
-        // doesn't support unsigned types.
-        return Long.MAX_VALUE;
+    public DurationField getLeapDurationField() {
+        return iChronology.weeks();
     }
 
     public int getMinimumValue() {
@@ -275,18 +273,18 @@ public int getMaximumValue() {
         return iChronology.getMaxYear();
     }
 
-    public long roundFloor(long millis) {
+    public long roundFloor(long instant) {
         DateTimeField wowField = iChronology.weekOfWeekyear();
-        millis = wowField.roundFloor(millis);
-        int wow = wowField.get(millis);
+        instant = wowField.roundFloor(instant);
+        int wow = wowField.get(instant);
         if (wow > 1) {
-            millis = wowField.add(millis, 1 - wow);
+            instant = wowField.add(instant, 1 - wow);
         }
-        return millis;
+        return instant;
     }
 
-    public long remainder(long millis) {
-        return millis - roundFloor(millis);
+    public long remainder(long instant) {
+        return instant - roundFloor(instant);
     }
 
     /**
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJYearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJYearDateTimeField.java
index 1ec899b45..859d50382 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJYearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJYearDateTimeField.java
@@ -55,7 +55,9 @@
 package org.joda.time.chrono.gj;
 
 import org.joda.time.DateTimeConstants;
-import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+import org.joda.time.chrono.ImpreciseDateTimeField;
+import org.joda.time.chrono.Utils;
 
 /**
  * Provides time calculations for the year component of time.
@@ -65,84 +67,83 @@
  * @author Brian S O'Neill
  * @since 1.0
  */
-final class GJYearDateTimeField extends DateTimeField {
+final class GJYearDateTimeField extends ImpreciseDateTimeField {
+
+    static final long serialVersionUID = -679076949530018869L;
 
     private static final long FEB_29 = (31L + 29 - 1) * DateTimeConstants.MILLIS_PER_DAY;
 
     private final ProlepticChronology iChronology;
-    private final transient long iRoughMillisPerYear;
 
     /**
      * Restricted constructor
      */
     GJYearDateTimeField(ProlepticChronology chronology) {
-        super("year");
+        super("year", "years", chronology.getRoughMillisPerYear());
         iChronology = chronology;
-        iRoughMillisPerYear = chronology.getRoughMillisPerYear();
+    }
+
+    public boolean isLenient() {
+        return false;
     }
 
     /**
      * Get the Year component of the specified time instant.
      * 
-     * @param millis  the time instant in millis to query.
+     * @param instant  the time instant in millis to query.
      * @return the year extracted from the input.
      */
-    public int get(long millis) {
-        // Get an initial estimate of the year, and the millis value
-        // that represents the start of that year.
-        int year = 1970 + (int) (millis / iRoughMillisPerYear);
-        long yearStartMillis = iChronology.getYearMillis(year);
+    public int get(long instant) {
+        // Get an initial estimate of the year, and the millis value that
+        // represents the start of that year. Then verify estimate and fix if
+        // necessary.
 
-        if (millis > yearStartMillis) {
-            for (;;) {
-                // Actual year may be greater than what we estimated. Check if
-                // year should advance.
-                if (iChronology.isLeapYear(year)) {
-                    yearStartMillis += DateTimeConstants.MILLIS_PER_DAY * 366L;
-                } else {
-                    yearStartMillis += DateTimeConstants.MILLIS_PER_DAY * 365L;
-                }
-                if (millis < yearStartMillis) {
-                    // Year was correct, no need to advance.
-                    break;
-                }
-                year++;
-                if (millis == yearStartMillis) {
-                    // Millis is at start of year; year is now correct, so no
-                    // need to check anymore.
-                    break;
-                }
-                if ((millis ^ yearStartMillis) < 0) {
-                    // Sign mismatch, operation overflowed.
-                    return getOverflow(millis);
-                }
+        int year;
+
+        long unitMillis = getDurationUnitMillis();
+        if (instant >= 0) {
+            year = 1970 + (int) (instant / unitMillis);
+        } else {
+            year = 1970 + (int) ((instant - unitMillis + 1) / unitMillis);
+        }
+
+        long yearStart = iChronology.getYearMillis(year);
+        if ((yearStart ^ instant) < 0) {
+            // Sign mismatch, operation overflowed.
+            return getOverflow(instant);
+        }
+
+        long diff = instant - yearStart;
+
+        if (diff < 0) {
+            // Subtract one year to fix estimate.
+            year--;
+        } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) {
+            // One year may need to be added to fix estimate.
+            long oneYear;
+            if (iChronology.isLeapYear(year)) {
+                oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L;
+            } else {
+                oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L;
             }
-        } else if (millis < yearStartMillis) {
-            for (;;) {
-                // Actual year less than what we estimated. Go to previous year
-                // and check.
-                year--;
-                if (iChronology.isLeapYear(year)) {
-                    yearStartMillis -= DateTimeConstants.MILLIS_PER_DAY * 366L;
-                } else {
-                    yearStartMillis -= DateTimeConstants.MILLIS_PER_DAY * 365L;
-                }
-                if (millis >= yearStartMillis) {
-                    // Year is now correct.
-                    break;
-                }
-                if ((millis ^ yearStartMillis) < 0) {
-                    // Sign mismatch, operation overflowed.
-                    return getOverflow(millis);
-                }
+
+            yearStart += oneYear;
+            if ((yearStart ^ instant) < 0) {
+                // Sign mismatch, operation overflowed.
+                return getOverflow(instant);
+            }
+
+            if (yearStart <= instant) {
+                // Didn't go too far, so actually add one year.
+                year++;
             }
         }
 
         return year;
     }
 
-    private int getOverflow(long millis) {
-        if (millis > 0) {
+    private int getOverflow(long instant) {
+        if (instant > 0) {
             int year = iChronology.getMaxYear();
             long yearStartMillis = iChronology.getYearMillis(year);
             if (iChronology.isLeapYear(year)) {
@@ -152,21 +153,21 @@ private int getOverflow(long millis) {
             }
             long yearEndMillis = yearStartMillis - 1;
 
-            if (millis <= yearEndMillis) {
+            if (instant <= yearEndMillis) {
                 return year;
             }
 
             throw new IllegalArgumentException
-                ("Instant too large: " + millis + " > " + yearEndMillis);
+                ("Instant too large: " + instant + " > " + yearEndMillis);
         } else {
             int year = iChronology.getMinYear();
             long yearStartMillis = iChronology.getYearMillis(year);
-            if (millis >= yearStartMillis) {
+            if (instant >= yearStartMillis) {
                 return year;
             }
 
             throw new IllegalArgumentException
-                ("Instant too small: " + millis + " < " + yearStartMillis);
+                ("Instant too small: " + instant + " < " + yearStartMillis);
         }
     }
 
@@ -174,53 +175,53 @@ private int getOverflow(long millis) {
      * Add the specified year to the specified time instant.
      * The amount added may be negative.
      * 
-     * @param millis  the time instant in millis to update.
+     * @param instant  the time instant in millis to update.
      * @param years  the years to add (can be negative).
      * @return the updated time instant.
      */
-    public long add(long millis, int years) {
+    public long add(long instant, int years) {
         if (years == 0) {
-            return millis;
+            return instant;
         }
-        int thisYear = get(millis);
+        int thisYear = get(instant);
         int newYear = thisYear + years;
-        return set(millis, newYear);
+        return set(instant, newYear);
     }
 
-    public long add(long millis, long years) {
-        return addLong(millis, years);
+    public long add(long instant, long years) {
+        return add(instant, Utils.safeToInt(years));
     }
 
     /**
      * Add to the Year component of the specified time instant
      * wrapping around within that component if necessary.
      * 
-     * @param millis  the time instant in millis to update.
+     * @param instant  the time instant in millis to update.
      * @param years  the years to add (can be negative).
      * @return the updated time instant.
      */
-    public long addWrapped(long millis, int years) {
+    public long addWrapped(long instant, int years) {
         if (years == 0) {
-            return millis;
+            return instant;
         }
         // Return newly calculated millis value
-        int thisYear = iChronology.year().get(millis);
-        int wrappedYear = getWrappedValue
+        int thisYear = iChronology.year().get(instant);
+        int wrappedYear = Utils.getWrappedValue
             (thisYear, years, iChronology.getMinYear(), iChronology.getMaxYear());
-        return set(millis, wrappedYear);
+        return set(instant, wrappedYear);
     }
 
-    public long getDifference(long minuendMillis, long subtrahendMillis) {
-        if (minuendMillis < subtrahendMillis) {
-            return -getDifference(subtrahendMillis, minuendMillis);
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        if (minuendInstant < subtrahendInstant) {
+            return -getDifference(subtrahendInstant, minuendInstant);
         }
 
-        int minuendYear = get(minuendMillis);
-        int subtrahendYear = get(subtrahendMillis);
+        int minuendYear = get(minuendInstant);
+        int subtrahendYear = get(subtrahendInstant);
 
         // Inlined remainder method to avoid duplicate calls to get.
-        long minuendRem = minuendMillis - iChronology.getYearMillis(minuendYear);
-        long subtrahendRem = subtrahendMillis - iChronology.getYearMillis(subtrahendYear);
+        long minuendRem = minuendInstant - iChronology.getYearMillis(minuendYear);
+        long subtrahendRem = subtrahendInstant - iChronology.getYearMillis(subtrahendYear);
 
         // Balance leap year differences on remainders.
         if (subtrahendRem >= FEB_29) {
@@ -243,19 +244,20 @@ public long getDifference(long minuendMillis, long subtrahendMillis) {
     /**
      * Set the Year component of the specified time instant.
      * 
-     * @param millis  the time instant in millis to update.
+     * @param instant  the time instant in millis to update.
      * @param year  the year (-292269055,292278994) to update the time to.
      * @return the updated time instant.
      * @throws IllegalArgumentException  if year is invalid.
      */
-    public long set(long millis, int year) {
-        super.verifyValueBounds(year, iChronology.getMinYear(), iChronology.getMaxYear());
+    public long set(long instant, int year) {
+        Utils.verifyValueBounds
+            (this, year, iChronology.getMinYear(), iChronology.getMaxYear());
 
-        int dayOfYear = iChronology.dayOfYear().get(millis);
-        int millisOfDay = iChronology.millisOfDay().get(millis);
+        int dayOfYear = iChronology.dayOfYear().get(instant);
+        int millisOfDay = iChronology.millisOfDay().get(instant);
 
         if (dayOfYear > (31 + 28)) { // after Feb 28
-            if (isLeap(millis)) {
+            if (isLeap(instant)) {
                 // Old date is Feb 29 or later.
                 if (!iChronology.isLeapYear(year)) {
                     // Moving to a non-leap year, Feb 29 does not exist.
@@ -270,32 +272,30 @@ public long set(long millis, int year) {
             }
         }
 
-        millis = iChronology.getYearMonthDayMillis(year, 1, dayOfYear);
-        millis += millisOfDay;
+        instant = iChronology.getYearMonthDayMillis(year, 1, dayOfYear);
+        instant += millisOfDay;
 
-        return millis;
+        return instant;
     }
 
-    public boolean isLeap(long millis) {
-        return iChronology.isLeapYear(get(millis));
+    public DurationField getRangeDurationField() {
+        return null;
     }
 
-    public int getLeapAmount(long millis) {
-        if (iChronology.isLeapYear(get(millis))) {
+    public boolean isLeap(long instant) {
+        return iChronology.isLeapYear(get(instant));
+    }
+
+    public int getLeapAmount(long instant) {
+        if (iChronology.isLeapYear(get(instant))) {
             return 1;
         } else {
             return 0;
         }
     }
 
-    public long getUnitMillis() {
-        return iRoughMillisPerYear;
-    }
-
-    public long getRangeMillis() {
-        // Should actually be double this, but that is not possible since Java
-        // doesn't support unsigned types.
-        return Long.MAX_VALUE;
+    public DurationField getLeapDurationField() {
+        return iChronology.days();
     }
 
     public int getMinimumValue() {
@@ -306,22 +306,22 @@ public int getMaximumValue() {
         return iChronology.getMaxYear();
     }
 
-    public long roundFloor(long millis) {
-        return iChronology.getYearMillis(get(millis));
+    public long roundFloor(long instant) {
+        return iChronology.getYearMillis(get(instant));
     }
 
-    public long roundCeiling(long millis) {
-        int year = get(millis);
+    public long roundCeiling(long instant) {
+        int year = get(instant);
         long yearStartMillis = iChronology.getYearMillis(year);
-        if (millis != yearStartMillis) {
+        if (instant != yearStartMillis) {
             // Bump up to start of next year.
-            millis = iChronology.getYearMillis(year + 1);
+            instant = iChronology.getYearMillis(year + 1);
         }
-        return millis;
+        return instant;
     }
 
-    public long remainder(long millis) {
-        return millis - roundFloor(millis);
+    public long remainder(long instant) {
+        return instant - roundFloor(instant);
     }
 
     /**
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJYearOfEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJYearOfEraDateTimeField.java
index 1a2256e59..216b1b279 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJYearOfEraDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJYearOfEraDateTimeField.java
@@ -56,31 +56,36 @@
 
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeField;
+import org.joda.time.chrono.DecoratedDateTimeField;
+import org.joda.time.chrono.Utils;
 
 /**
  * Provides time calculations for the year of era component of time.
  * 
  * @author Brian S O'Neill
  */
-final class GJYearOfEraDateTimeField extends DateTimeField {
+final class GJYearOfEraDateTimeField extends DecoratedDateTimeField {
+
+    static final long serialVersionUID = -5961050944769862059L;
+
     private final ProlepticChronology iChronology;
 
     /**
-     * Restricted constructor
+     * Restricted constructor.
      */
-    GJYearOfEraDateTimeField(ProlepticChronology chronology) {
-        super("yearOfEra");
+    GJYearOfEraDateTimeField(DateTimeField yearField, ProlepticChronology chronology) {
+        super(yearField, "yearOfEra");
         iChronology = chronology;
     }
 
     /**
      * Get the year of era component of the specified time instant.
      * 
-     * @param millis  the time instant in millis to query.
+     * @param instant  the time instant in millis to query.
      * @return the year of era extracted from the input.
      */
-    public int get(long millis) {
-        int year = iChronology.year().get(millis);
+    public int get(long instant) {
+        int year = getWrappedField().get(instant);
         if (year <= 0) {
             year = 1 - year;
         }
@@ -91,77 +96,73 @@ public int get(long millis) {
      * Add the specified year to the specified time instant.
      * The amount added may be negative.
      * 
-     * @param millis  the time instant in millis to update.
+     * @param instant  the time instant in millis to update.
      * @param years  the years to add (can be negative).
      * @return the updated time instant.
      */
-    public long add(long millis, int years) {
-        return iChronology.year().add(millis, years);
+    public long add(long instant, int years) {
+        return getWrappedField().add(instant, years);
     }
 
-    public long add(long millis, long years) {
-        return addLong(millis, years);
+    public long add(long instant, long years) {
+        return getWrappedField().add(instant, years);
     }
 
     /**
      * Add to the year component of the specified time instant
      * wrapping around within that component if necessary.
      * 
-     * @param millis  the time instant in millis to update.
+     * @param instant  the time instant in millis to update.
      * @param years  the years to add (can be negative).
      * @return the updated time instant.
      */
-    public long addWrapped(long millis, int years) {
-        return iChronology.year().addWrapped(millis, years);
+    public long addWrapped(long instant, int years) {
+        return getWrappedField().addWrapped(instant, years);
+    }
+
+    public int getDifference(long minuendInstant, long subtrahendInstant) {
+        return getWrappedField().getDifference(minuendInstant, subtrahendInstant);
     }
 
-    public long getDifference(long minuendMillis, long subtrahendMillis) {
-        return iChronology.year().getDifference(minuendMillis, subtrahendMillis);
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant);
     }
 
     /**
      * Set the year component of the specified time instant.
      * 
-     * @param millis  the time instant in millis to update.
+     * @param instant  the time instant in millis to update.
      * @param year  the year (0,292278994) to update the time to.
      * @return the updated time instant.
      * @throws IllegalArgumentException  if year is invalid.
      */
-    public long set(long millis, int year) {
-        super.verifyValueBounds(year, 1, iChronology.getMaxYear());
-        if (iChronology.era().get(millis) == DateTimeConstants.BCE) {
-            return iChronology.year().set(millis, 1 - year);
+    public long set(long instant, int year) {
+        Utils.verifyValueBounds(this, year, 1, getMaximumValue());
+        if (iChronology.era().get(instant) == DateTimeConstants.BCE) {
+            return super.set(instant, 1 - year);
         } else {
-            return iChronology.year().set(millis, year);
+            return super.set(instant, year);
         }
     }
 
-    public long getUnitMillis() {
-        return iChronology.getRoughMillisPerYear();
-    }
-
-    public long getRangeMillis() {
-        return Long.MAX_VALUE;
-    }
-
     public int getMinimumValue() {
         return 1;
     }
 
     public int getMaximumValue() {
-        return iChronology.getMaxYear();
+        return getWrappedField().getMaximumValue();
     }
 
-    public long roundFloor(long millis) {
-        return iChronology.year().roundFloor(millis);
+    public long roundFloor(long instant) {
+        return getWrappedField().roundFloor(instant);
     }
 
-    public long roundCeiling(long millis) {
-        return iChronology.year().roundCeiling(millis);
+    public long roundCeiling(long instant) {
+        return getWrappedField().roundCeiling(instant);
     }
 
-    public long remainder(long millis) {
-        return iChronology.year().remainder(millis);
+    public long remainder(long instant) {
+        return getWrappedField().remainder(instant);
     }
 
     /**
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJZonedChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJZonedChronology.java
index 5521144a5..adf28de3f 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJZonedChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJZonedChronology.java
@@ -58,45 +58,24 @@
 import org.joda.time.chrono.ZonedChronology;
 
 /**
- * A specialism of zoned chronology for the GJ chronology.
+ * A special zoned chronology for the GJ chronology.
  * 
  * @author Brian S O'Neill
  * @author Stephen Colebourne
  * @since 1.0
  */
-class GJZonedChronology extends GJChronology {
+final class GJZonedChronology extends GJChronology {
+
+    static final long serialVersionUID = -4148749408058922172L;
+
     private final GJChronology iChronology;
     private final DateTimeZone iZone;
+    private final ZonedChronology iZonedChronology;
 
     GJZonedChronology(GJChronology chrono, DateTimeZone zone) {
         iChronology = chrono;
         iZone = zone;
-
-        Chronology zc = new ZonedChronology(chrono, zone);
-
-        iYearField = zc.year();
-        iYearOfEraField = zc.yearOfEra();
-        iYearOfCenturyField = zc.yearOfCentury();
-        iCenturyOfEraField = zc.centuryOfEra();
-        iEraField = zc.era();
-        iDayOfMonthField = zc.dayOfMonth();
-        iDayOfWeekField = zc.dayOfWeek();
-        iDayOfYearField = zc.dayOfYear();
-        iMonthOfYearField = zc.monthOfYear();
-        iWeekOfWeekyearField = zc.weekOfWeekyear();
-        iWeekyearField = zc.weekyear();
-        
-        iMillisOfSecondField = zc.millisOfSecond();
-        iMillisOfDayField = zc.millisOfDay();
-        iSecondOfMinuteField = zc.secondOfMinute();
-        iSecondOfDayField = zc.secondOfDay();
-        iMinuteOfHourField = zc.minuteOfHour();
-        iMinuteOfDayField = zc.minuteOfDay();
-        iHourOfDayField = zc.hourOfDay();
-        iHourOfHalfdayField = zc.hourOfHalfday();
-        iClockhourOfDayField = zc.clockhourOfDay();
-        iClockhourOfHalfdayField = zc.clockhourOfHalfday();
-        iHalfdayOfDayField = zc.halfdayOfDay();
+        copyFields(iZonedChronology = new ZonedChronology(chrono, zone));
     }
 
     public DateTimeZone getDateTimeZone() {
@@ -107,6 +86,47 @@ public Chronology withUTC() {
         return iChronology;
     }
 
+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
+        throws IllegalArgumentException
+    {
+        return iZonedChronology.getDateOnlyMillis(year, monthOfYear, dayOfMonth);
+    }
+
+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
+                                        int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        return iZonedChronology.getTimeOnlyMillis
+            (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+    }
+
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                        int millisOfDay)
+        throws IllegalArgumentException
+    {
+        return iZonedChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);
+    }
+
+    public long getDateTimeMillis(long instant,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        return iZonedChronology.getDateTimeMillis
+            (instant,
+             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+    }
+
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        return iZonedChronology.getDateTimeMillis
+            (year, monthOfYear, dayOfMonth,
+             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+    }
+
     public long getGregorianJulianCutoverMillis() {
         return iChronology.getGregorianJulianCutoverMillis();
     }
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GregorianChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/GregorianChronology.java
index 40faadee3..3f2a81bd1 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GregorianChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GregorianChronology.java
@@ -62,6 +62,9 @@
  * @author Brian S O'Neill
  */
 final class GregorianChronology extends ProlepticChronology {
+
+    static final long serialVersionUID = 3691407383323710523L;
+
     GregorianChronology(int minDaysInFirstWeek) {
         super(minDaysInFirstWeek);
     }
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/JulianChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/JulianChronology.java
index 1aa77efa3..6fe2acada 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/JulianChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/JulianChronology.java
@@ -55,7 +55,8 @@
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.DelegateDateTimeField;
+import org.joda.time.chrono.DelegatedDateTimeField;
+import org.joda.time.chrono.Utils;
 
 /**
  * Year zero is dropped from the year and weekyear fields.
@@ -63,6 +64,9 @@
  * @author Brian S O'Neill
  */
 final class JulianChronology extends GJChronology {
+
+    static final long serialVersionUID = -8731039522547897247L;
+
     private final JulianWithYearZeroChronology iChronology;
 
     /**
@@ -72,36 +76,62 @@
         JulianWithYearZeroChronology chrono =
             new JulianWithYearZeroChronology(minDaysInFirstWeek);
         iChronology = chrono;
+        copyFields(chrono);
+
+        // Override only the fields that differ.
 
         iYearField = new NoYearZeroField(chrono.year());
-        iYearOfEraField = chrono.yearOfEra();
-        iYearOfCenturyField = chrono.yearOfCentury();
-        iCenturyOfEraField = chrono.centuryOfEra();
-        iEraField = chrono.era();
-        iDayOfMonthField = chrono.dayOfMonth();
-        iDayOfWeekField = chrono.dayOfWeek();
-        iDayOfYearField = chrono.dayOfYear();
-        iMonthOfYearField = chrono.monthOfYear();
-        iWeekOfWeekyearField = chrono.weekOfWeekyear();
         iWeekyearField = new NoWeekyearZeroField(chrono.weekyear());
-        
-        iMillisOfSecondField = chrono.millisOfSecond();
-        iMillisOfDayField = chrono.millisOfDay();
-        iSecondOfMinuteField = chrono.secondOfMinute();
-        iSecondOfDayField = chrono.secondOfDay();
-        iMinuteOfHourField = chrono.minuteOfHour();
-        iMinuteOfDayField = chrono.minuteOfDay();
-        iHourOfDayField = chrono.hourOfDay();
-        iHourOfHalfdayField = chrono.hourOfHalfday();
-        iClockhourOfDayField = chrono.clockhourOfDay();
-        iClockhourOfHalfdayField = chrono.clockhourOfHalfday();
-        iHalfdayOfDayField = chrono.halfdayOfDay();
     }
 
     public Chronology withUTC() {
         return this;
     }
 
+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
+        throws IllegalArgumentException
+    {
+        year = adjustYearForSet(year);
+        return iChronology.getDateOnlyMillis(year, monthOfYear, dayOfMonth);
+    }
+
+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        return iChronology.getTimeOnlyMillis
+            (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+    }
+
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int millisOfDay)
+        throws IllegalArgumentException
+    {
+        year = adjustYearForSet(year);
+        return iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);
+    }
+
+    public long getDateTimeMillis(long instant,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        return iChronology.getDateTimeMillis
+            (instant,
+             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+    }
+
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        year = adjustYearForSet(year);
+        return iChronology.getDateTimeMillis
+            (year, monthOfYear, dayOfMonth,
+             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+    }
+
     public long getGregorianJulianCutoverMillis() {
         return iChronology.getGregorianJulianCutoverMillis();
     }
@@ -114,7 +144,19 @@ public int getMinimumDaysInFirstWeek() {
         return iChronology.getMinimumDaysInFirstWeek();
     }
 
-    private class NoYearZeroField extends DelegateDateTimeField {
+    int adjustYearForSet(int year) {
+        if (year <= 0) {
+            if (year == 0) {
+                throw new IllegalArgumentException("Invalid year: " + year);
+            }
+            year++;
+        }
+        return year;
+    }
+
+    private class NoYearZeroField extends DelegatedDateTimeField {
+        static final long serialVersionUID = -8869148464118507846L;
+
         private transient int iMinYear;
 
         NoYearZeroField(DateTimeField field) {
@@ -131,14 +173,8 @@ public int get(long millis) {
         }
 
         public long set(long millis, int year) {
-            super.verifyValueBounds(year, iMinYear, getMaximumValue());
-            if (year <= 0) {
-                if (year == 0) {
-                    throw new IllegalArgumentException("Invalid year: " + year);
-                }
-                year++;
-            }
-            return super.set(millis, year);
+            Utils.verifyValueBounds(this, year, iMinYear, getMaximumValue());
+            return super.set(millis, adjustYearForSet(year));
         }
 
         public int getMinimumValue() {
@@ -151,6 +187,8 @@ private Object readResolve() {
     }
 
     private final class NoWeekyearZeroField extends NoYearZeroField {
+        static final long serialVersionUID = -5013429014495501104L;
+
         NoWeekyearZeroField(DateTimeField field) {
             super(field);
         }
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/JulianWithYearZeroChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/JulianWithYearZeroChronology.java
index 2543fe279..ca0bd68fb 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/JulianWithYearZeroChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/JulianWithYearZeroChronology.java
@@ -63,6 +63,9 @@
  * @author Stephen Colebourne
  */
 final class JulianWithYearZeroChronology extends ProlepticChronology {
+
+    static final long serialVersionUID = 9044685826106463217L;
+
     JulianWithYearZeroChronology(int minDaysInFirstWeek) {
         super(minDaysInFirstWeek);
     }
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/ProlepticChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/ProlepticChronology.java
index dc100cdd0..08b0eee9f 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/ProlepticChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/ProlepticChronology.java
@@ -58,11 +58,14 @@
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
 import org.joda.time.chrono.DividedDateTimeField;
-import org.joda.time.chrono.FractionalDateTimeField;
-//import org.joda.time.chrono.OneBasedFractionalDateTimeField;
+import org.joda.time.chrono.MillisDurationField;
 import org.joda.time.chrono.NonZeroDateTimeField;
 import org.joda.time.chrono.RemainderDateTimeField;
+import org.joda.time.chrono.PreciseDateTimeField;
+import org.joda.time.chrono.PreciseDurationField;
+import org.joda.time.chrono.Utils;
 
 /**
  * ProlepticChronology uses a consistent set of rules for all dates and
@@ -73,6 +76,9 @@
  * @since 1.0
  */
 abstract class ProlepticChronology extends GJChronology {
+
+    static final long serialVersionUID = 541866437970475456L;
+
     static final long MILLIS_1970_TO_2000 = 946684800000L;
 
     // These arrays are NOT public. We trust ourselves not to alter the array.
@@ -90,6 +96,14 @@
     private static final long[] MIN_TOTAL_MILLIS_BY_MONTH_ARRAY;
     private static final long[] MAX_TOTAL_MILLIS_BY_MONTH_ARRAY;
 
+    private static final DurationField cMillisField;
+    private static final DurationField cSecondsField;
+    private static final DurationField cMinutesField;
+    private static final DurationField cHoursField;
+    private static final DurationField cHalfdaysField;
+    private static final DurationField cDaysField;
+    private static final DurationField cWeeksField;
+
     private static final DateTimeField cMillisOfSecondField;
     private static final DateTimeField cMillisOfDayField;
     private static final DateTimeField cSecondOfMinuteField;
@@ -120,51 +134,49 @@
             MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[i] = maxSum;
         }
 
-        cMillisOfSecondField = new FractionalDateTimeField
-            ("millisOfSecond",
-             1,
-             DateTimeConstants.MILLIS_PER_SECOND);
-
-        cMillisOfDayField = new FractionalDateTimeField
-            ("millisOfDay",
-             1,
-             DateTimeConstants.MILLIS_PER_DAY);
-
-        cSecondOfMinuteField = new FractionalDateTimeField
-            ("secondOfMinute", 
-             DateTimeConstants.MILLIS_PER_SECOND, 
-             DateTimeConstants.SECONDS_PER_MINUTE);
-
-        cSecondOfDayField = new FractionalDateTimeField
-            ("secondOfDay",
-             DateTimeConstants.MILLIS_PER_SECOND,
-             DateTimeConstants.SECONDS_PER_DAY);
-
-        cMinuteOfHourField = new FractionalDateTimeField
-            ("minuteOfHour",
-             DateTimeConstants.MILLIS_PER_MINUTE,
-             DateTimeConstants.MINUTES_PER_HOUR);
-
-        cMinuteOfDayField = new FractionalDateTimeField
-            ("minuteOfDay",
-             DateTimeConstants.MILLIS_PER_MINUTE,
-             DateTimeConstants.MINUTES_PER_DAY);
-
-        cHourOfDayField = new FractionalDateTimeField
-            ("hourOfDay",
-             DateTimeConstants.MILLIS_PER_HOUR,
-             DateTimeConstants.HOURS_PER_DAY);
-
-        cHourOfHalfdayField = new FractionalDateTimeField
-            ("hourOfHalfday",
-             DateTimeConstants.MILLIS_PER_HOUR,
-             DateTimeConstants.HOURS_PER_DAY / 2);
+        cMillisField = MillisDurationField.INSTANCE;
+        cSecondsField = new PreciseDurationField
+            ("seconds", DateTimeConstants.MILLIS_PER_SECOND);
+        cMinutesField = new PreciseDurationField
+            ("minutes", DateTimeConstants.MILLIS_PER_MINUTE);
+        cHoursField = new PreciseDurationField
+            ("hours", DateTimeConstants.MILLIS_PER_HOUR);
+        cHalfdaysField = new PreciseDurationField
+            ("halfdays", DateTimeConstants.MILLIS_PER_DAY / 2);
+        cDaysField = new PreciseDurationField
+            ("days", DateTimeConstants.MILLIS_PER_DAY);
+        cWeeksField = new PreciseDurationField
+            ("weeks", DateTimeConstants.MILLIS_PER_WEEK);
+
+        cMillisOfSecondField = new PreciseDateTimeField
+            ("millisOfSecond", cMillisField, cSecondsField);
+
+        cMillisOfDayField = new PreciseDateTimeField
+            ("millisOfDay", cMillisField, cDaysField);
+             
+        cSecondOfMinuteField = new PreciseDateTimeField
+            ("secondOfMinute", cSecondsField, cMinutesField);
+
+        cSecondOfDayField = new PreciseDateTimeField
+            ("secondOfDay", cSecondsField, cDaysField);
+
+        cMinuteOfHourField = new PreciseDateTimeField
+            ("minuteOfHour", cMinutesField, cHoursField);
+
+        cMinuteOfDayField = new PreciseDateTimeField
+            ("minuteOfDay", cMinutesField, cDaysField);
+
+        cHourOfDayField = new PreciseDateTimeField
+            ("hourOfDay", cHoursField, cDaysField);
+
+        cHourOfHalfdayField = new PreciseDateTimeField
+            ("hourOfHalfday", cHoursField, cHalfdaysField);
 
         cClockhourOfDayField = new NonZeroDateTimeField
-            ("clockhourOfDay", cHourOfDayField);
+            (cHourOfDayField, "clockhourOfDay");
 
         cClockhourOfHalfdayField = new NonZeroDateTimeField
-            ("clockhourOfHalfday", cHourOfHalfdayField);
+            (cHourOfHalfdayField, "clockhourOfHalfday");
 
         cHalfdayOfDayField = new HalfdayField();
     }
@@ -178,32 +190,41 @@
         super();
         iMinDaysInFirstWeek = minDaysInFirstWeek;
 
-        Integer i = Integer.getInteger("org.joda.time.gj.ProlepticChronology.yearInfoCacheSize");
-        int cacheSize = (i == null) ? 1024 : i.intValue();
-        // Ensure cache size is even power of 2.
-        cacheSize--;
-        int shift = 0;
-        while (cacheSize > 0) {
-            shift++;
-            cacheSize >>= 1;
+        Integer i;
+        try {
+            i = Integer.getInteger("org.joda.time.gj.ProlepticChronology.yearInfoCacheSize");
+        } catch (SecurityException e) {
+            i = null;
         }
-        cacheSize = 1 << shift;
+
+        int cacheSize;
+        if (i == null) {
+            cacheSize = 1024; // (1 << 10)
+        } else {
+            cacheSize = i.intValue();
+            // Ensure cache size is even power of 2.
+            cacheSize--;
+            int shift = 0;
+            while (cacheSize > 0) {
+                shift++;
+                cacheSize >>= 1;
+            }
+            cacheSize = 1 << shift;
+        }
+
         iYearInfoCache = new YearInfo[cacheSize];
         iYearInfoCacheMask = cacheSize - 1;
 
-        iYearField = new GJYearDateTimeField(this);
-        iYearOfEraField = new GJYearOfEraDateTimeField(this);
+        // First copy fields that are the same for all Gregorian and Julian
+        // chronologies.
 
-        iCenturyOfEraField = new DividedDateTimeField("centuryOfEra", iYearOfEraField, 100);
-        iYearOfCenturyField = new RemainderDateTimeField("yearOfCentury", iYearOfEraField, 100);
-
-        iEraField = new GJEraDateTimeField(this);
-        iDayOfWeekField = new GJDayOfWeekDateTimeField(this);
-        iDayOfMonthField = new GJDayOfMonthDateTimeField(this);
-        iDayOfYearField = new GJDayOfYearDateTimeField(this);
-        iMonthOfYearField = new GJMonthOfYearDateTimeField(this);
-        iWeekOfWeekyearField = new GJWeekOfWeekyearDateTimeField(this);
-        iWeekyearField = new GJWeekyearDateTimeField(this);
+        iMillisField = cMillisField;
+        iSecondsField = cSecondsField;
+        iMinutesField = cMinutesField;
+        iHoursField = cHoursField;
+        //iHalfdaysField = cHalfdaysField;  Doesn't exist in public interface
+        iDaysField = cDaysField;
+        iWeeksField = cWeeksField;
 
         iMillisOfSecondField = cMillisOfSecondField;
         iMillisOfDayField = cMillisOfDayField;
@@ -216,12 +237,121 @@
         iClockhourOfDayField = cClockhourOfDayField;
         iClockhourOfHalfdayField = cClockhourOfHalfdayField;
         iHalfdayOfDayField = cHalfdayOfDayField;
+
+        // Now create fields that have unique behavior for Gregorian and Julian
+        // chronologies.
+
+        iYearField = new GJYearDateTimeField(this);
+        iYearOfEraField = new GJYearOfEraDateTimeField(iYearField, this);
+
+        iCenturyOfEraField = new DividedDateTimeField
+            (iYearOfEraField, "centuryOfEra", "centuries", 100);
+        iYearOfCenturyField = new RemainderDateTimeField
+            ((DividedDateTimeField)iCenturyOfEraField, "yearOfCentury");
+
+        iEraField = new GJEraDateTimeField(this);
+        iDayOfWeekField = new GJDayOfWeekDateTimeField(this, iDaysField);
+        iDayOfMonthField = new GJDayOfMonthDateTimeField(this, iDaysField);
+        iDayOfYearField = new GJDayOfYearDateTimeField(this, iDaysField);
+        iMonthOfYearField = new GJMonthOfYearDateTimeField(this);
+        iWeekyearField = new GJWeekyearDateTimeField(this);
+        iWeekOfWeekyearField = new GJWeekOfWeekyearDateTimeField(this, iWeeksField);
+
+        // The remaining (imprecise) durations are available from the newly
+        // created datetime fields.
+
+        iYearsField = iYearField.getDurationField();
+        iCenturiesField = iCenturyOfEraField.getDurationField();
+        iMonthsField = iMonthOfYearField.getDurationField();
+        iWeekyearsField = iWeekyearField.getDurationField();
     }
 
     public Chronology withUTC() {
         return this;
     }
 
+    /**
+     * Override the default implementation
+     */
+    public final long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
+        throws IllegalArgumentException
+    {
+        boolean isLeap = isLeapYear(year);
+
+        Utils.verifyValueBounds("monthOfYear", monthOfYear, 1, 12);
+        Utils.verifyValueBounds("dayOfMonth", dayOfMonth, 1,
+                                (isLeap ? MAX_DAYS_PER_MONTH_ARRAY : MIN_DAYS_PER_MONTH_ARRAY)
+                                [monthOfYear - 1]);
+
+        long instant = getYearMillis(year);
+
+        if (monthOfYear > 1) {
+            instant += 
+                (isLeap ? MAX_TOTAL_MILLIS_BY_MONTH_ARRAY : MIN_TOTAL_MILLIS_BY_MONTH_ARRAY)
+                [monthOfYear - 2];
+        }
+
+        if (dayOfMonth != 1) {
+            instant += (dayOfMonth - 1) * (long)DateTimeConstants.MILLIS_PER_DAY;
+        }
+
+        return instant;
+    }
+
+    /**
+     * Override the default implementation
+     */
+    public final long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
+                                        int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+
+        Utils.verifyValueBounds("hourOfDay", hourOfDay, 0, 23);
+        Utils.verifyValueBounds("minuteOfHour", minuteOfHour, 0, 59);
+        Utils.verifyValueBounds("secondOfMinute", secondOfMinute, 0, 59);
+        Utils.verifyValueBounds("millisOfSecond", millisOfSecond, 0, 999);
+
+        return hourOfDay * DateTimeConstants.MILLIS_PER_HOUR
+            + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE
+            + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND
+            + millisOfSecond;
+    }
+
+    /**
+     * Override the default implementation
+     */
+    public final long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                        int millisOfDay)
+        throws IllegalArgumentException
+    {
+        Utils.verifyValueBounds("millisOfDay", millisOfDay, 0, DateTimeConstants.MILLIS_PER_DAY);
+        return getDateOnlyMillis(year, monthOfYear, dayOfMonth) + millisOfDay;
+    }
+
+    /**
+     * Override the default implementation
+     */
+    public final long getDateTimeMillis(long instant,
+                                        int hourOfDay, int minuteOfHour,
+                                        int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        return getDateOnlyMillis(instant)
+            + getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+    }
+
+    /**
+     * Override the default implementation
+     */
+    public final long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                        int hourOfDay, int minuteOfHour,
+                                        int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        return getDateOnlyMillis(year, monthOfYear, dayOfMonth)
+            + getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+    }
+
     public final boolean isCenturyISO() {
         return true;
     }
@@ -433,9 +563,11 @@ private YearInfo getYearInfo(int year) {
         return info;
     }
 
-    private static class HalfdayField extends FractionalDateTimeField {
+    private static class HalfdayField extends PreciseDateTimeField {
+        static final long serialVersionUID = 581601443656929254L;
+
         HalfdayField() {
-            super("halfdayOfDay", DateTimeConstants.MILLIS_PER_HOUR * 12, 2);
+            super("halfdayOfDay", cHalfdaysField, cDaysField);
         }
 
         public String getAsText(long millis, Locale locale) {
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/package.html b/JodaTime/src/java/org/joda/time/chrono/gj/package.html
index 30ed1a456..13ad62c8c 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/package.html
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/package.html
@@ -1,12 +1,74 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<html>
+<head>
+<title>org.joda.time.chrono.gj package</title>
+<!--
+
+   Joda Software License, Version 1.0
+  
+  
+   Copyright (c) 2001-03 Stephen Colebourne.
+   All rights reserved.
+  
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions
+   are met:
+  
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+  
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+  
+   3. The end-user documentation included with the redistribution,
+      if any, must include the following acknowledgment:
+         "This product includes software developed by the
+          Joda project (http://www.joda.org/)."
+      Alternately, this acknowledgment may appear in the software itself,
+      if and wherever such third-party acknowledgments normally appear.
+  
+   4. The name "Joda" must not be used to endorse or promote products
+      derived from this software without prior written permission. For
+      written permission, please contact licence@joda.org.
+  
+   5. Products derived from this software may not be called "Joda",
+      nor may "Joda" appear in their name, without prior written
+      permission of the Joda project.
+  
+   THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+   USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+   OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+   SUCH DAMAGE.
+   ====================================================================
+  
+   This software consists of voluntary contributions made by many
+   individuals on behalf of the Joda project and was originally
+   created by Stephen Colebourne <scolebourne@joda.org>. For more
+   information on the Joda project, please see <http://www.joda.org/>.
+
+-->
+</head>
 <body>
-<h3>Gregorian/Julian Chronology.</h3>
 <p>
-The Gregorian/Julian calendar system (shortened to GJ) is the most commonly used 
-system on the planet. The Julian system defined a leap year once every 4 years, whereas
-the Gregorian calendar has additional special rules for every 100 and 400 years.
-This package provides the classes necessary to support the GJ calendar system, including
-different cutover dates, the presence or absence of a year zero, an all Gregorian calendar
-or an all Julian calendar.
+Provides a Gregorian/Julian Chronology implementation. The Gregorian/Julian
+calendar system (shortened to GJ) is the most commonly used system on the
+planet. The Julian system defined a leap year once every 4 years, whereas the
+Gregorian calendar has additional special rules for every 100 and 400 years.
+</p>
+<p>
+This package provides the classes necessary to support the GJ calendar system,
+including different cutover dates, the presence or absence of a year zero, a
+pure Gregorian calendar, or a pure Julian calendar.
 </p>
 </body>
-
+</html>
diff --git a/JodaTime/src/java/org/joda/time/chrono/iso/ISOChronology.java b/JodaTime/src/java/org/joda/time/chrono/iso/ISOChronology.java
index 807b47988..336ef8319 100644
--- a/JodaTime/src/java/org/joda/time/chrono/iso/ISOChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/iso/ISOChronology.java
@@ -53,12 +53,16 @@
  */
 package org.joda.time.chrono.iso;
 
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.Serializable;
 import java.util.HashMap;
 import java.util.Map;
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeZone;
-import org.joda.time.chrono.DelegateChronology;
+import org.joda.time.chrono.DelegatedChronology;
 import org.joda.time.chrono.gj.GJChronology;
 
 /**
@@ -66,17 +70,26 @@
  * for the ISO8601 defined chronological calendar system. When ISO 
  * does not define a field, but it can be determined (such as AM/PM)
  * it is included.
+ * <p>
+ * ISOChronology is thread-safe and immutable.
  *
  * @author Stephen Colebourne
  * @author Brian S O'Neill
  * @since 1.0
  */
-public final class ISOChronology extends DelegateChronology {
+public final class ISOChronology extends DelegatedChronology {
     
+    static final long serialVersionUID = -6212696554273812441L;
+
     /** Singleton instance of a UTC ISOChronology */
     private static final ISOChronology INSTANCE_UTC =
         new ISOChronology(GJChronology.getInstance(DateTimeZone.UTC, Long.MIN_VALUE, true));
         
+    private static final int FAST_CACHE_SIZE = 64;
+
+    /** Fast cache of zone to chronology */
+    private static final ISOChronology[] cFastCache = new ISOChronology[FAST_CACHE_SIZE];
+
     /** Cache of zone to chronology */
     private static final Map cCache = new HashMap();
     static {
@@ -108,15 +121,24 @@ public static ISOChronology getInstance() {
      * @param zone  the time zone to get the chronology in, null is default
      * @return a chronology in the specified time zone
      */
-    public static synchronized ISOChronology getInstance(DateTimeZone zone) {
+    public static ISOChronology getInstance(DateTimeZone zone) {
         if (zone == null) {
             zone = DateTimeZone.getDefault();
         }
-        ISOChronology chrono = (ISOChronology) cCache.get(zone);
-        if (chrono == null) {
-            chrono = new ISOChronology(GJChronology.getInstance(zone, Long.MIN_VALUE, true));
-            cCache.put(zone, chrono);
+        int index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);
+        ISOChronology chrono = cFastCache[index];
+        if (chrono != null && chrono.getDateTimeZone() == zone) {
+            return chrono;
         }
+        synchronized (cCache) {
+            chrono = (ISOChronology) cCache.get(zone);
+            if (chrono == null) {
+                chrono = new ISOChronology
+                    (GJChronology.getInstance(zone, Long.MIN_VALUE, true));
+                cCache.put(zone, chrono);
+            }
+        }
+        cFastCache[index] = chrono;
         return chrono;
     }
 
@@ -130,10 +152,11 @@ private ISOChronology(GJChronology gjChronology) {
     }
 
     /**
-     * Serialization singleton
+     * Serialize ISOChronology instances using a small stub. This reduces the
+     * serialized size, and deserialized instances come from the cache.
      */
-    private Object readResolve() {
-        return getInstance(getChronology().getDateTimeZone());
+    private Object writeReplace() {
+        return new Stub(getDateTimeZone());
     }
 
     // Conversion
@@ -171,8 +194,36 @@ public Chronology withDateTimeZone(DateTimeZone zone) {
      * @return a debugging string
      */
     public String toString() {
+        String str = "ISOChronology";
         DateTimeZone zone = getDateTimeZone();
-        return "ISOChronology[" + (zone == null ? "" : zone.getID()) + "]";
+        if (zone != null) {
+            str = str + '[' + zone.getID() + ']';
+        }
+        return str;
     }
-   
+
+    private static final class Stub implements Serializable {
+        static final long serialVersionUID = -6212696554273812441L;
+
+        private transient DateTimeZone iZone;
+
+        Stub(DateTimeZone zone) {
+            iZone = zone;
+        }
+
+        private Object readResolve() {
+            return ISOChronology.getInstance(iZone);
+        }
+
+        private void writeObject(ObjectOutputStream out) throws IOException {
+            out.writeObject(iZone);
+        }
+
+        private void readObject(ObjectInputStream in)
+            throws IOException, ClassNotFoundException
+        {
+            iZone = (DateTimeZone)in.readObject();
+        }
+    }
+
 }
diff --git a/JodaTime/src/java/org/joda/time/chrono/iso/package.html b/JodaTime/src/java/org/joda/time/chrono/iso/package.html
index f05b257d1..03787f818 100644
--- a/JodaTime/src/java/org/joda/time/chrono/iso/package.html
+++ b/JodaTime/src/java/org/joda/time/chrono/iso/package.html
@@ -1,10 +1,70 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<html>
+<head>
+<title>org.joda.time.chrono.iso package</title>
+<!--
+
+   Joda Software License, Version 1.0
+  
+  
+   Copyright (c) 2001-03 Stephen Colebourne.
+   All rights reserved.
+  
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions
+   are met:
+  
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+  
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+  
+   3. The end-user documentation included with the redistribution,
+      if any, must include the following acknowledgment:
+         "This product includes software developed by the
+          Joda project (http://www.joda.org/)."
+      Alternately, this acknowledgment may appear in the software itself,
+      if and wherever such third-party acknowledgments normally appear.
+  
+   4. The name "Joda" must not be used to endorse or promote products
+      derived from this software without prior written permission. For
+      written permission, please contact licence@joda.org.
+  
+   5. Products derived from this software may not be called "Joda",
+      nor may "Joda" appear in their name, without prior written
+      permission of the Joda project.
+  
+   THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+   USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+   OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+   SUCH DAMAGE.
+   ====================================================================
+  
+   This software consists of voluntary contributions made by many
+   individuals on behalf of the Joda project and was originally
+   created by Stephen Colebourne <scolebourne@joda.org>. For more
+   information on the Joda project, please see <http://www.joda.org/>.
+
+-->
+</head>
 <body>
-<h3>ISO Chronology</h3>
 <p>
-The ISO calendar system is that defined by the ISO8601 standard. It is in fact a special
-case of the Gregorian calendar system. It is defined as Gregorian over all time (proleptic)
-and includes the year 0 (which never actually occurred). All XML date and time transfers
-are recommended to use the ISO8601 standard.
+Provides an ISO Chronology implementation. The ISO calendar system is defined
+by the ISO8601 standard, which is in fact a special case of the Gregorian
+calendar system. It is defined as Gregorian over all time (proleptic) and
+includes the year 0 (which never actually occurred). All XML date and time
+transfers are recommended to use the ISO8601 standard.
 </p>
 </body>
-
+</html>
diff --git a/JodaTime/src/java/org/joda/time/chrono/package.html b/JodaTime/src/java/org/joda/time/chrono/package.html
index 166efb34b..1d411cd6a 100644
--- a/JodaTime/src/java/org/joda/time/chrono/package.html
+++ b/JodaTime/src/java/org/joda/time/chrono/package.html
@@ -1,7 +1,68 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<html>
+<head>
+<title>org.joda.time.chrono package</title>
+<!--
+
+   Joda Software License, Version 1.0
+  
+  
+   Copyright (c) 2001-03 Stephen Colebourne.
+   All rights reserved.
+  
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions
+   are met:
+  
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+  
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+  
+   3. The end-user documentation included with the redistribution,
+      if any, must include the following acknowledgment:
+         "This product includes software developed by the
+          Joda project (http://www.joda.org/)."
+      Alternately, this acknowledgment may appear in the software itself,
+      if and wherever such third-party acknowledgments normally appear.
+  
+   4. The name "Joda" must not be used to endorse or promote products
+      derived from this software without prior written permission. For
+      written permission, please contact licence@joda.org.
+  
+   5. Products derived from this software may not be called "Joda",
+      nor may "Joda" appear in their name, without prior written
+      permission of the Joda project.
+  
+   THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+   USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+   OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+   SUCH DAMAGE.
+   ====================================================================
+  
+   This software consists of voluntary contributions made by many
+   individuals on behalf of the Joda project and was originally
+   created by Stephen Colebourne <scolebourne@joda.org>. For more
+   information on the Joda project, please see <http://www.joda.org/>.
+
+-->
+</head>
 <body>
-<h3>Basic chronology support for DateTime objects.</h3>
 <p>
-This package contains implementation utility classes not part of the main API.
+Provides Chronology implementaions and support. The base package contains
+classes that aid in making new chronologies and fields, and the sub-packages
+contain complete implementations.
 </p>
 </body>
-
+</html>
diff --git a/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java b/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java
new file mode 100644
index 000000000..bdd3f8c0f
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java
@@ -0,0 +1,165 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.convert;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeZone;
+import org.joda.time.chrono.iso.ISOChronology;
+
+/**
+ * AbstractConverter simplifies the process of implementing a converter.
+ *
+ * @author Stephen Colebourne
+ * @since 1.0
+ */
+public abstract class AbstractConverter implements Converter {
+    
+    /**
+     * Restricted constructor.
+     */
+    protected AbstractConverter() {
+        super();
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Extracts the millis from an object of this convertor's type.
+     * <p>
+     * This implementation calls {@link #getInstantMillis(Object, DateTimeZone)}.
+     * 
+     * @param object  the object to convert, must not be null
+     * @return the millisecond value
+     * @throws ClassCastException if the object is invalid
+     */
+    public long getInstantMillis(Object object) {
+        return getInstantMillis(object, (DateTimeZone) null);
+    }
+    
+    /**
+     * Extracts the millis from an object of this convertor's type.
+     * <p>
+     * This implementation calls {@link #getInstantMillis(Object)}.
+     * 
+     * @param object  the object to convert, must not be null
+     * @param zone  the zone to use, null means default zone
+     * @return the millisecond value
+     * @throws ClassCastException if the object is invalid
+     */
+    public long getInstantMillis(Object object, DateTimeZone zone) {
+        return getInstantMillis(object);
+    }
+    
+    /**
+     * Extracts the millis from an object of this convertor's type.
+     * <p>
+     * This implementation calls {@link #getInstantMillis(Object)}.
+     * 
+     * @param object  the object to convert, must not be null
+     * @param chrono  the chronology to use, null means ISOChronology
+     * @return the millisecond value
+     * @throws ClassCastException if the object is invalid
+     */
+    public long getInstantMillis(Object object, Chronology chrono) {
+        return getInstantMillis(object);
+    }
+    //-----------------------------------------------------------------------
+    
+    /**
+     * Extracts the chronology from an object of this convertor's type.
+     * <p>
+     * This implementation returns the ISOChronology.
+     * 
+     * @param object  the object to convert, must not be null
+     * @return the chronology, never null
+     * @throws ClassCastException if the object is invalid
+     */
+    public Chronology getChronology(Object object) {
+        return ISOChronology.getInstance();
+    }
+    
+    /**
+     * Extracts the chronology from an object of this convertor's type
+     * where the time zone is specified.
+     * <p>
+     * This implementation returns the ISOChronology.
+     * 
+     * @param object  the object to convert, must not be null
+     * @param zone  the specified zone to use, null means default zone
+     * @return the chronology, never null
+     * @throws ClassCastException if the object is invalid
+     */
+    public Chronology getChronology(Object object, DateTimeZone zone) {
+        return ISOChronology.getInstance(zone);
+    }
+    
+    /**
+     * Extracts the chronology from an object of this convertor's type
+     * where the chronology is specified.
+     * <p>
+     * This implementation returns the chronology specified, or the
+     * ISOChronology in the default zone if null passed in.
+     * 
+     * @param object  the object to convert, must not be null
+     * @param chrono  the chronology to use, null means ISOChronology
+     * @return the chronology, never null
+     * @throws ClassCastException if the object is invalid
+     */
+    public Chronology getChronology(Object object, Chronology chrono) {
+        if (chrono == null) {
+            return ISOChronology.getInstance();
+        }
+        return chrono;
+    }
+    
+}
diff --git a/JodaTime/src/java/org/joda/time/convert/CalendarConverter.java b/JodaTime/src/java/org/joda/time/convert/CalendarConverter.java
new file mode 100644
index 000000000..201f0c94a
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/convert/CalendarConverter.java
@@ -0,0 +1,149 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.convert;
+
+import java.util.Calendar;
+import java.util.GregorianCalendar;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeZone;
+import org.joda.time.chrono.buddhist.BuddhistChronology;
+import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.iso.ISOChronology;
+
+/**
+ * CalendarConverter converts a java util Calendar to milliseconds in the
+ * chronology that best matches the calendar.
+ *
+ * @author Stephen Colebourne
+ * @since 1.0
+ */
+final class CalendarConverter extends AbstractConverter implements InstantConverter {
+    
+    /**
+     * Singleton instance.
+     */
+    static final CalendarConverter INSTANCE = new CalendarConverter();
+    
+    /**
+     * Restricted constructor.
+     */
+    protected CalendarConverter() {
+        super();
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the millis, which is the Calendar millis value.
+     * 
+     * @param object  the object to convert, must not be null
+     * @return the millisecond value
+     */
+    public long getInstantMillis(Object object) {
+        return ((Calendar) object).getTime().getTime();
+    }
+    
+    /**
+     * Gets the chronology, which is the GJChronology if a GregorianCalendar is used,
+     * BuddhistChronology if a BuddhistCalendar is used or ISOChronology otherwise.
+     * The time zone is extracted from the calendar if possible, default used if not.
+     * 
+     * @param object  the object to convert, must not be null
+     * @return the chronology, never null
+     */
+    public Chronology getChronology(Object object) {
+        Calendar cal = (Calendar) object;
+        DateTimeZone zone = null;
+        try {
+            zone = DateTimeZone.getInstance(cal.getTimeZone());
+            
+        } catch (IllegalArgumentException ex) {
+            zone = DateTimeZone.getDefault();
+        }
+        return getChronology(cal, zone);
+    }
+    
+    /**
+     * Gets the chronology, which is the GJChronology if a GregorianCalendar is used,
+     * BuddhistChronology if a BuddhistCalendar is used or ISOChronology otherwise.
+     * The time zone specified is used in preference to that on the calendar.
+     * 
+     * @param object  the object to convert, must not be null
+     * @param zone  the specified zone to use, null means default zone
+     * @return the chronology, never null
+     */
+    public Chronology getChronology(Object object, DateTimeZone zone) {
+        if (object instanceof GregorianCalendar) {
+            GregorianCalendar gc = (GregorianCalendar) object;
+            return GJChronology.getInstance(zone, gc.getGregorianChange().getTime(), false);
+            
+        } else if (object.getClass().getName().endsWith(".BuddhistCalendar")) {
+            return BuddhistChronology.getInstance(zone);
+            
+        } else {
+            return ISOChronology.getInstance(zone);
+        }
+    }
+    
+    //-----------------------------------------------------------------------
+    /**
+     * Returns Calendar.class.
+     * 
+     * @return Calendar.class
+     */
+    public Class getSupportedType() {
+        return Calendar.class;
+    }
+    
+}
diff --git a/JodaTime/src/java/org/joda/time/convert/Converter.java b/JodaTime/src/java/org/joda/time/convert/Converter.java
new file mode 100644
index 000000000..ff7716f96
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/convert/Converter.java
@@ -0,0 +1,70 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.convert;
+
+/**
+ * Basic converter interface for specifying what object type can be converted.
+ *
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+public interface Converter {
+    /**
+     * Returns the object type that this converter supports, which may
+     * specified by a class, superclass, abstract class, interface, or null.
+     * 
+     * @return the object type that this converter supports
+     */
+    Class getSupportedType();
+}
diff --git a/JodaTime/src/java/org/joda/time/convert/ConverterManager.java b/JodaTime/src/java/org/joda/time/convert/ConverterManager.java
new file mode 100644
index 000000000..bb74326f8
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/convert/ConverterManager.java
@@ -0,0 +1,302 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.convert;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * ConverterManager controls the date and time converters.
+ * <p>
+ * This class enables additional conversion classes to be added via
+ * {@link #addInstantConverter(InstantConverter)}, which may replace an
+ * existing converter. Similar methods exist for duration converters.
+ * <p>
+ * This class is threadsafe, so adding/removing converters can be done at any
+ * time. Updating the set of convertors is relatively expensive, and so should
+ * not be performed often.
+ * <p>
+ * The default instant converters are:
+ * <ul>
+ * <li>ReadableInstant
+ * <li>PartialInstant
+ * <li>String
+ * <li>Calendar
+ * <li>Date
+ * <li>Long
+ * </ul>
+ * The default duration converters are:
+ * <ul>
+ * <li>ReadableDuration
+ * <li>Long
+ * </ul>
+ *
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+public final class ConverterManager {
+
+    /**
+     * Singleton instance, lazily loaded to avoid class loading.
+     */
+    private static ConverterManager INSTANCE;
+
+    public static ConverterManager getInstance() {
+        if (INSTANCE == null) {
+            INSTANCE = new ConverterManager();
+        }
+        return INSTANCE;
+    }
+    
+    private ConverterSet iInstantConverters;
+    private ConverterSet iDurationConverters;
+    
+    /**
+     * Restricted constructor.
+     */
+    protected ConverterManager() {
+        super();
+
+        iInstantConverters = new ConverterSet(new Converter[] {
+            ReadableInstantConverter.INSTANCE,
+            PartialInstantConverter.INSTANCE,
+            StringConverter.INSTANCE,
+            CalendarConverter.INSTANCE,
+            DateConverter.INSTANCE,
+            LongConverter.INSTANCE,
+        });
+
+        iDurationConverters = new ConverterSet(new Converter[] {
+            ReadableDurationConverter.INSTANCE,
+            LongConverter.INSTANCE,
+        });
+    }
+    
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the best converter for the object specified.
+     * 
+     * @param object  the object to convert
+     * @return the converter to use
+     * @throws IllegalArgumentException if no suitable converter
+     * @throws IllegalStateException if multiple converters match the type
+     * equally well
+     */
+    public InstantConverter getInstantConverter(Object object) {
+        InstantConverter converter =
+            (InstantConverter)iInstantConverters.select(object == null ? null : object.getClass());
+        if (converter != null) {
+            return converter;
+        }
+        throw new IllegalArgumentException("No instant converter found for type: " +
+            (object == null ? "null" : object.getClass().getName()));
+    }
+    
+    //-----------------------------------------------------------------------
+    /**
+     * Gets a copy of the set of converters.
+     * 
+     * @return the converters, a copy of the real data, never null
+     */
+    public InstantConverter[] getInstantConverters() {
+        ConverterSet set = iInstantConverters;
+        InstantConverter[] converters = new InstantConverter[set.size()];
+        set.copyInto(converters);
+        return converters;
+    }
+    
+    /**
+     * Adds a converter to the set of converters. If a matching converter is
+     * already in the set, the given converter replaces it. If the converter is
+     * exactly the same as one already in the set, no changes are made.
+     * <p>
+     * The order in which converters are added is not relevent. The best
+     * converter is selected by examining the object hierarchy.
+     * 
+     * @param converter  the converter to add, null ignored
+     * @return replaced converter, or null
+     */
+    public InstantConverter addInstantConverter(InstantConverter converter) {
+        if (converter == null) {
+            return null;
+        }
+        InstantConverter[] removed = new InstantConverter[1];
+        iInstantConverters = iInstantConverters.add(converter, removed);
+        return removed[0];
+    }
+    
+    /**
+     * Removes a converter from the set of converters. If the converter was
+     * not in the set, no changes are made.
+     * 
+     * @param converter  the converter to remove, null ignored
+     * @return replaced converter, or null
+     */
+    public InstantConverter removeInstantConverter(InstantConverter converter) {
+        if (converter == null) {
+            return null;
+        }
+        InstantConverter[] removed = new InstantConverter[1];
+        iInstantConverters = iInstantConverters.remove(converter, removed);
+        return removed[0];
+    }
+    
+    /**
+     * Removes a converter from the set of converters, by index.
+     * 
+     * @param index  the index to remove
+     * @return replaced converter, or null
+     * @throws IndexOutOfBoundsException if the index is invalid
+     */
+    public InstantConverter removeInstantConverter(int index) {
+        InstantConverter[] removed = new InstantConverter[1];
+        iInstantConverters = iInstantConverters.remove(index, removed);
+        return removed[0];
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the best converter for the object specified.
+     * 
+     * @param object  the object to convert
+     * @return the converter to use
+     * @throws IllegalArgumentException if no suitable converter
+     * @throws IllegalStateException if multiple converters match the type
+     * equally well
+     */
+    public DurationConverter getDurationConverter(Object object) {
+        DurationConverter converter =
+            (DurationConverter)iDurationConverters.select(object == null ? null : object.getClass());
+        if (converter != null) {
+            return converter;
+        }
+        throw new IllegalArgumentException("No duration converter found for type: " +
+            (object == null ? "null" : object.getClass().getName()));
+    }
+    
+    //-----------------------------------------------------------------------
+    /**
+     * Gets a copy of the list of converters.
+     * 
+     * @return the converters, a copy of the real data, never null
+     */
+    public DurationConverter[] getDurationConverters() {
+        ConverterSet set = iDurationConverters;
+        DurationConverter[] converters = new DurationConverter[set.size()];
+        set.copyInto(converters);
+        return converters;
+    }
+    
+    /**
+     * Adds a converter to the set of converters. If a matching converter is
+     * already in the set, the given converter replaces it. If the converter is
+     * exactly the same as one already in the set, no changes are made.
+     * <p>
+     * The order in which converters are added is not relevent. The best
+     * converter is selected by examining the object hierarchy.
+     * 
+     * @param converter  the converter to add, null ignored
+     * @return replaced converter, or null
+     */
+    public DurationConverter addDurationConverter(DurationConverter converter) {
+        if (converter == null) {
+            return null;
+        }
+        DurationConverter[] removed = new DurationConverter[1];
+        iDurationConverters = iDurationConverters.add(converter, removed);
+        return removed[0];
+    }
+    
+    /**
+     * Removes a converter from the set of converters. If the converter was
+     * not in the set, no changes are made.
+     * 
+     * @param converter  the converter to remove, null ignored
+     * @return replaced converter, or null
+     */
+    public DurationConverter removeDurationConverter(DurationConverter converter) {
+        if (converter == null) {
+            return null;
+        }
+        DurationConverter[] removed = new DurationConverter[1];
+        iDurationConverters = iDurationConverters.remove(converter, removed);
+        return removed[0];
+    }
+    
+    /**
+     * Removes a converter from the set of converters, by index.
+     * 
+     * @param index  the index to remove
+     * @return replaced converter, or null
+     * @throws IndexOutOfBoundsException if the index is invalid
+     */
+    public DurationConverter removeDurationConverter(int index) {
+        DurationConverter[] removed = new DurationConverter[1];
+        iDurationConverters = iDurationConverters.remove(index, removed);
+        return removed[0];
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets a debug representation of the object
+     */
+    public String toString() {
+        return "ConverterManager[" +
+            iInstantConverters.size() + " instant converters," +
+            iDurationConverters.size() + " duration converters]";
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/convert/ConverterSet.java b/JodaTime/src/java/org/joda/time/convert/ConverterSet.java
new file mode 100644
index 000000000..fb4711599
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/convert/ConverterSet.java
@@ -0,0 +1,370 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.convert;
+
+/**
+ * A set of converters, which allows exact converters to be quickly
+ * selected. This class is threadsafe because it is (essentially) immutable.
+ *
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+class ConverterSet {
+    private final Converter[] iConverters;
+
+    // A simple immutable hashtable: closed hashing, linear probing, sized
+    // power of 2, at least one null slot.
+    private Entry[] iSelectEntries;
+
+    ConverterSet(Converter[] converters) {
+        // Since this is a package private constructor, we trust ourselves not
+        // to alter the array outside this class.
+        iConverters = converters;
+        iSelectEntries = new Entry[1 << 4]; // 16
+    }
+
+    /**
+     * Returns the closest matching converter for the given type, or null if
+     * none found.
+     *
+     * @param type type to select, which may be null
+     * @throws IllegalStateException if multiple converters match the type
+     * equally well
+     */
+    public Converter select(Class type) throws IllegalStateException {
+        // Check the hashtable first.
+        Entry[] entries = iSelectEntries;
+        int length = entries.length;
+        int index = type == null ? 0 : type.hashCode() & (length - 1);
+
+        Entry e;
+        // This loop depends on there being at least one null slot.
+        while ((e = entries[index]) != null) {
+            if (e.iType == type) {
+                return e.iConverter;
+            }
+            if (++index >= length) {
+                index = 0;
+            }
+        }
+
+        // Not found in the hashtable, so do actual work.
+
+        Converter converter = selectSlow(this, type);
+        e = new Entry(type, converter);
+
+        // Save the entry for future selects. This class must be threadsafe,
+        // but there is no synchronization. Since the hashtable is being used
+        // as a cache, it is okay to destroy existing entries. This isn't
+        // likely to occur unless there is a high amount of concurrency. As
+        // time goes on, cache updates will occur less often, and the cache
+        // will fill with all the necessary entries.
+
+        // Do all updates on a copy: slots in iSelectEntries must not be
+        // updated by multiple threads as this can allow all null slots to be
+        // consumed.
+        entries = (Entry[])entries.clone();
+
+        // Add new entry.
+        entries[index] = e;
+
+        // Verify that at least one null slot exists!
+        for (int i=0; i<length; i++) {
+            if (entries[i] == null) {
+                // Found a null slot, swap in new hashtable.
+                iSelectEntries = entries;
+                return converter;
+            }
+        }
+
+        // Double capacity and re-hash.
+
+        int newLength = length << 1;
+        Entry[] newEntries = new Entry[newLength];
+        for (int i=0; i<length; i++) {
+            e = entries[i];
+            type = e.iType;
+            index = type == null ? 0 : type.hashCode() & (newLength - 1);
+            while (newEntries[index] != null) {
+                if (++index >= newLength) {
+                    index = 0;
+                }
+            }
+            newEntries[index] = e;
+        }
+
+        // Swap in new hashtable.
+        iSelectEntries = newEntries;
+        return converter;
+    }
+
+    /**
+     * Returns the amount of converters in the set.
+     */
+    public int size() {
+        return iConverters.length;
+    }
+
+    /**
+     * Copies all the converters in the set to the given array.
+     */
+    public void copyInto(Converter[] converters) {
+        System.arraycopy(iConverters, 0, converters, 0, iConverters.length);
+    }
+
+    /**
+     * Returns a copy of this set, with the given converter added. If a
+     * matching converter is already in the set, the given converter replaces
+     * it. If the converter is exactly the same as one already in the set, the
+     * original set is returned.
+     *
+     * @param converter converter to add
+     * @param removed if not null, element 0 is set to the removed converter
+     * @throws IllegalArgumentException if converter is null
+     */
+    public ConverterSet add(Converter converter, Converter[] removed) {
+        if (converter == null) {
+            throw new IllegalArgumentException();
+        }
+
+        Converter[] converters = iConverters;
+        int length = converters.length;
+
+        for (int i=0; i<length; i++) {
+            Converter existing = converters[i];
+            if (converter.equals(existing)) {
+                // Already in the set.
+                if (removed != null) {
+                    removed[0] = null;
+                }
+                return this;
+            }
+            
+            if (converter.getSupportedType() == existing.getSupportedType()) {
+                // Replace the converter.
+                Converter[] copy = new Converter[length];
+                    
+                for (int j=0; j<length; j++) {
+                    if (j != i) {
+                        copy[j] = converters[j];
+                    } else {
+                        copy[j] = converter;
+                    }
+                }
+
+                if (removed != null) {
+                    removed[0] = existing;
+                }
+                return new ConverterSet(copy);
+            }
+        }
+
+        // Not found, so add it.
+        Converter[] copy = new Converter[length + 1];
+        System.arraycopy(converters, 0, copy, 0, length);
+        copy[length] = converter;
+        
+        if (removed != null) {
+            removed[0] = null;
+        }
+        return new ConverterSet(copy);
+    }
+
+    /**
+     * Returns a copy of this set, with the given converter removed. If the
+     * converter was not in the set, the original set is returned.
+     *
+     * @param converter converter to remove
+     * @param removed if not null, element 0 is set to the removed converter
+     * @throws NullPointerException if converter is null
+     */
+    public ConverterSet remove(Converter converter, Converter[] removed) {
+        Converter[] converters = iConverters;
+        int length = converters.length;
+
+        for (int i=0; i<length; i++) {
+            if (converter.equals(converters[i])) {
+                return remove(i, removed);
+            }
+        }
+
+        // Not found.
+        if (removed != null) {
+            removed[0] = null;
+        }
+        return this;
+    }
+
+    /**
+     * Returns a copy of this set, with the converter at the given index
+     * removed.
+     *
+     * @param converter converter to remove
+     * @param removed if not null, element 0 is set to the removed converter
+     * @throws IndexOutOfBoundsException if the index is invalid
+     */
+    public ConverterSet remove(final int index, Converter[] removed) {
+        Converter[] converters = iConverters;
+        int length = converters.length;
+        if (index >= length) {
+            throw new IndexOutOfBoundsException();
+        }
+
+        if (removed != null) {
+            removed[0] = converters[index];
+        }
+
+        Converter[] copy = new Converter[length - 1];
+                
+        int j = 0;
+        for (int i=0; i<length; i++) {
+            if (i != index) {
+                copy[j++] = converters[i];
+            }
+        }
+        
+        return new ConverterSet(copy);
+    }
+
+    /**
+     * Returns the closest matching converter for the given type, but not very
+     * efficiently.
+     */
+    private static Converter selectSlow(ConverterSet set, Class type) {
+        Converter[] converters = set.iConverters;
+        int length = converters.length;
+        Converter converter;
+
+        for (int i=length; --i>=0; ) {
+            converter = converters[i];
+            Class supportedType = converter.getSupportedType();
+
+            if (supportedType == type) {
+                // Exact match.
+                return converter;
+            }
+
+            if (supportedType == null || (type != null && !supportedType.isAssignableFrom(type))) {
+                // Eliminate the impossible.
+                set = set.remove(i, null);
+                converters = set.iConverters;
+                length = converters.length;
+            }
+        }
+
+        // Haven't found exact match, so check what remains in the set.
+
+        if (type == null || length == 0) {
+            return null;
+        }
+        if (length == 1) {
+            // Found the one best match.
+            return converters[0];
+        }
+
+        // At this point, there exist multiple potential converters.
+
+        // Eliminate supertypes.
+        for (int i=length; --i>=0; ) {
+            converter = converters[i];
+            Class supportedType = converter.getSupportedType();
+            for (int j=length; --j>=0; ) {
+                if (j != i && converters[j].getSupportedType().isAssignableFrom(supportedType)) {
+                    // Eliminate supertype.
+                    set = set.remove(j, null);
+                    converters = set.iConverters;
+                    length = converters.length;
+                    i = length - 1;
+                }
+            }
+        }        
+        
+        // Check what remains in the set.
+
+        if (length == 1) {
+            // Found the one best match.
+            return converters[0];
+        }
+
+        // Class c implements a, b {}
+        // Converters exist only for a and b. Which is better? Neither.
+
+        StringBuffer msg = new StringBuffer();
+        msg.append("Unable to find best converter for type \"");
+        msg.append(type.getName());
+        msg.append("\" from remaining set: ");
+        for (int i=0; i<length; i++) {
+            converter = converters[i];
+            Class supportedType = converter.getSupportedType();
+
+            msg.append(converter.getClass().getName());
+            msg.append('[');
+            msg.append(supportedType == null ? null : supportedType.getName());
+            msg.append("], ");
+        }
+
+        throw new IllegalStateException(msg.toString());
+    }
+
+    private static class Entry {
+        public final Class iType;
+        public final Converter iConverter;
+
+        Entry(Class type, Converter converter) {
+            iType = type;
+            iConverter = converter;
+        }
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/convert/DateConverter.java b/JodaTime/src/java/org/joda/time/convert/DateConverter.java
new file mode 100644
index 000000000..fae82f092
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/convert/DateConverter.java
@@ -0,0 +1,99 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.convert;
+
+import java.util.Date;
+
+/**
+ * DateConverter converts a java util Date to milliseconds in the ISOChronology.
+ *
+ * @author Stephen Colebourne
+ * @since 1.0
+ */
+final class DateConverter extends AbstractConverter implements InstantConverter {
+    
+    /**
+     * Singleton instance.
+     */
+    static final DateConverter INSTANCE = new DateConverter();
+    
+    /**
+     * Restricted constructor.
+     */
+    protected DateConverter() {
+        super();
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the millis, which is the Date millis value.
+     * 
+     * @param object  the object to convert, must not be null
+     * @return the millisecond value
+     */
+    public long getInstantMillis(Object object) {
+        return ((Date) object).getTime();
+    }
+    
+    //-----------------------------------------------------------------------
+    /**
+     * Returns Date.class.
+     * 
+     * @return Date.class
+     */
+    public Class getSupportedType() {
+        return Date.class;
+    }
+    
+}
diff --git a/JodaTime/src/java/org/joda/time/convert/DurationConverter.java b/JodaTime/src/java/org/joda/time/convert/DurationConverter.java
new file mode 100644
index 000000000..3bd56c076
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/convert/DurationConverter.java
@@ -0,0 +1,73 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.convert;
+
+/**
+ * DurationConverter defines how an object is converted to a millisecond duration.
+ *
+ * @author Stephen Colebourne
+ * @since 1.0
+ */
+public interface DurationConverter extends Converter {
+
+    /**
+     * Extracts the millis from an object of this convertor's type.
+     * 
+     * @param object  the object to convert, must not be null
+     * @return the millisecond duration
+     * @throws IllegalArgumentException if the object is invalid
+     */
+    long getDurationMillis(Object object);
+    
+}
diff --git a/JodaTime/src/java/org/joda/time/convert/InstantConverter.java b/JodaTime/src/java/org/joda/time/convert/InstantConverter.java
new file mode 100644
index 000000000..4a4b0ffda
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/convert/InstantConverter.java
@@ -0,0 +1,132 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.convert;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeZone;
+
+/**
+ * InstantConverter defines how an object is converted to milliseconds/chronology.
+ *
+ * @author Stephen Colebourne
+ * @since 1.0
+ */
+public interface InstantConverter extends Converter {
+
+    /**
+     * Extracts the millis from an object of this convertor's type.
+     * 
+     * @param object  the object to convert, must not be null
+     * @return the millisecond instant
+     * @throws ClassCastException if the object is invalid
+     */
+    long getInstantMillis(Object object);
+    
+    /**
+     * Extracts the millis from an object of this convertor's type. The zone
+     * parameter is a hint to the converter, should it require a time zone to
+     * aid in conversion.
+     * 
+     * @param object  the object to convert, must not be null
+     * @param zone  the zone to use, null means default zone
+     * @return the millisecond instant
+     * @throws ClassCastException if the object is invalid
+     */
+    long getInstantMillis(Object object, DateTimeZone zone);
+    
+    /**
+     * Extracts the millis from an object of this convertor's type. The chrono
+     * parameter is a hint to the converter, should it require a chronology to
+     * aid in conversion.
+     * 
+     * @param object  the object to convert, must not be null
+     * @param chrono  the chronology to use, null means ISOChronology
+     * @return the millisecond instant
+     * @throws ClassCastException if the object is invalid
+     */
+    long getInstantMillis(Object object, Chronology chrono);
+    
+    //-----------------------------------------------------------------------
+    /**
+     * Extracts the chronology from an object of this convertor's type.
+     * 
+     * @param object  the object to convert, must not be null
+     * @return the chronology, never null
+     * @throws ClassCastException if the object is invalid
+     */
+    Chronology getChronology(Object object);
+    
+    /**
+     * Extracts the chronology from an object of this convertor's type
+     * where the time zone is specified.
+     * 
+     * @param object  the object to convert, must not be null
+     * @param zone  the specified zone to use, null means default zone
+     * @return the chronology, never null
+     * @throws ClassCastException if the object is invalid
+     */
+    Chronology getChronology(Object object, DateTimeZone zone);
+    
+    /**
+     * Extracts the chronology from an object of this convertor's type
+     * where the chronology is specified.
+     * 
+     * @param object  the object to convert, must not be null
+     * @param chrono  the chronology to use, null means ISOChronology
+     * @return the chronology, never null
+     * @throws ClassCastException if the object is invalid
+     */
+    Chronology getChronology(Object object, Chronology chrono);
+    
+}
diff --git a/JodaTime/src/java/org/joda/time/convert/LongConverter.java b/JodaTime/src/java/org/joda/time/convert/LongConverter.java
new file mode 100644
index 000000000..93c876444
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/convert/LongConverter.java
@@ -0,0 +1,108 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.convert;
+
+
+/**
+ * LongConverter converts a Long to milliseconds in the ISOChronology.
+ *
+ * @author Stephen Colebourne
+ * @since 1.0
+ */
+class LongConverter extends AbstractConverter implements InstantConverter, DurationConverter {
+    
+    /**
+     * Singleton instance.
+     */
+    static final LongConverter INSTANCE = new LongConverter();
+    
+    /**
+     * Restricted constructor.
+     */
+    protected LongConverter() {
+        super();
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the millisecond instant, which is the Long value.
+     * 
+     * @param object  the object to convert, must not be null
+     * @return the millisecond instant
+     */
+    public long getInstantMillis(Object object) {
+        return ((Long) object).longValue();
+    }
+    
+    /**
+     * Gets the millisecond duration, which is the Long value.
+     * 
+     * @param object  the object to convert, must not be null
+     * @return the millisecond duration
+     */
+    public long getDurationMillis(Object object) {
+        return ((Long) object).longValue();
+    }
+    
+    //-----------------------------------------------------------------------
+    /**
+     * Returns Long.class.
+     * 
+     * @return Long.class
+     */
+    public Class getSupportedType() {
+        return Long.class;
+    }
+    
+}
diff --git a/JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java b/JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java
new file mode 100644
index 000000000..403bff81a
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java
@@ -0,0 +1,156 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.convert;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeZone;
+import org.joda.time.PartialInstant;
+import org.joda.time.chrono.iso.ISOChronology;
+
+/**
+ * PartialInstantConverter extracts milliseconds and chronology from a
+ * PartialInstant. Since supplying a time zone requires special attention, the
+ * regular ReadableInstantConverter is not quite right.
+ *
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+class PartialInstantConverter extends ReadableInstantConverter {
+    /**
+     * Singleton instance.
+     */
+    static final PartialInstantConverter INSTANCE = new PartialInstantConverter();
+
+    /**
+     * Restricted constructor.
+     */
+    protected PartialInstantConverter() {
+        super();
+    }
+
+    /**
+     * Extracts the millis from an object of this convertor's type.
+     * 
+     * @param object  the object to convert, must not be null
+     * @return the millisecond instant
+     */
+    public long getInstantMillis(Object object) {
+        return getInstantMillis(object, (DateTimeZone) null);
+    }
+    
+    /**
+     * Extracts the millis from an object of this convertor's type.
+     * 
+     * @param object  the object to convert, must not be null
+     * @param zone  the zone to use, null means default zone
+     * @return the millisecond instant
+     */
+    public long getInstantMillis(Object object, DateTimeZone zone) {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        long millis = ((PartialInstant) object).getMillis();
+        return millis - zone.getOffsetFromLocal(millis);
+    }
+    
+    /**
+     * Extracts the millis from an object of this convertor's type.
+     * 
+     * @param object  the object to convert, must not be null
+     * @param chrono  the chronology to use, null means ISOChronology
+     * @return the millisecond instant
+     */
+    public long getInstantMillis(Object object, Chronology chrono) {
+        long millis = ((PartialInstant) object).getMillis();
+        DateTimeZone zone;
+        if (chrono == null) {
+            zone = DateTimeZone.getDefault();
+        } else {
+            zone = chrono.getDateTimeZone();
+        }
+        if (zone != null) {
+            millis -= zone.getOffsetFromLocal(millis);
+        }
+        return millis;
+    }
+    
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the chronology, which is taken from the PartialDateTime.  If the
+     * chronology on the datetime is null, the ISOChronology in the default
+     * time zone is used. Otherwise, the chronology is returned in the default
+     * time zone.
+     * 
+     * @param object  the object to convert, must not be null
+     * @return the chronology, never null
+     */
+    public Chronology getChronology(Object object) {
+        Chronology chrono = ((PartialInstant) object).getChronology();
+        if (chrono == null) {
+            return ISOChronology.getInstance();
+        }
+        return chrono.withDateTimeZone(DateTimeZone.getDefault());
+    }
+    
+    //-----------------------------------------------------------------------
+    /**
+     * Returns PartialDateTime.class.
+     * 
+     * @return PartialDateTime.class
+     */
+    public Class getSupportedType() {
+        return PartialInstant.class;
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java b/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java
new file mode 100644
index 000000000..a5385b655
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java
@@ -0,0 +1,99 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.convert;
+
+import org.joda.time.ReadableDuration;
+
+/**
+ * ReadableDurationConverter extracts milliseconds and chronology from a ReadableDuration.
+ *
+ * @author Stephen Colebourne
+ * @since 1.0
+ */
+class ReadableDurationConverter extends AbstractConverter implements DurationConverter {
+    
+    /**
+     * Singleton instance.
+     */
+    static final ReadableDurationConverter INSTANCE = new ReadableDurationConverter();
+    
+    /**
+     * Restricted constructor.
+     */
+    protected ReadableDurationConverter() {
+        super();
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Extracts the millis from an object of this convertor's type.
+     * 
+     * @param object  the object to convert, must not be null
+     * @return the millisecond value
+     */
+    public long getDurationMillis(Object object) {
+        return ((ReadableDuration) object).getTotalMillis();
+    }
+    
+    //-----------------------------------------------------------------------
+    /**
+     * Returns ReadableDuration.class.
+     * 
+     * @return ReadableDuration.class
+     */
+    public Class getSupportedType() {
+        return ReadableDuration.class;
+    }
+    
+}
diff --git a/JodaTime/src/java/org/joda/time/convert/ReadableInstantConverter.java b/JodaTime/src/java/org/joda/time/convert/ReadableInstantConverter.java
new file mode 100644
index 000000000..f5a30348b
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/convert/ReadableInstantConverter.java
@@ -0,0 +1,144 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.convert;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeZone;
+import org.joda.time.ReadableInstant;
+import org.joda.time.chrono.iso.ISOChronology;
+
+/**
+ * ReadableInstantConverter extracts milliseconds and chronology from a ReadableInstant.
+ *
+ * @author Stephen Colebourne
+ * @since 1.0
+ */
+class ReadableInstantConverter extends AbstractConverter implements InstantConverter {
+    
+    /**
+     * Singleton instance.
+     */
+    static final ReadableInstantConverter INSTANCE = new ReadableInstantConverter();
+    
+    /**
+     * Restricted constructor.
+     */
+    protected ReadableInstantConverter() {
+        super();
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Extracts the millis from an object of this convertor's type.
+     * 
+     * @param object  the object to convert, must not be null
+     * @return the millisecond value
+     */
+    public long getInstantMillis(Object object) {
+        return ((ReadableInstant) object).getMillis();
+    }
+    
+    /**
+     * Gets the chronology, which is taken from the ReadableInstant.
+     * If the chronology on the instant is null, the ISOChronology in the
+     * default time zone is used.
+     * 
+     * @param object  the object to convert, must not be null
+     * @return the chronology, never null
+     */
+    public Chronology getChronology(Object object) {
+        Chronology chrono = ((ReadableInstant) object).getChronology();
+        if (chrono == null) {
+            return ISOChronology.getInstance();
+        }
+        return chrono;
+    }
+    
+    /**
+     * Gets the chronology, which is taken from the ReadableInstant.
+     * If the chronology on the instant is null, the ISOChronology in the
+     * specified time zone is used.
+     * If the chronology on the instant is not in the specified zone, it is
+     * adapted.
+     * 
+     * @param object  the object to convert, must not be null
+     * @param zone  the specified zone to use, null means default zone
+     * @return the chronology, never null
+     */
+    public Chronology getChronology(Object object, DateTimeZone zone) {
+        Chronology chrono = ((ReadableInstant) object).getChronology();
+        if (chrono == null) {
+            return ISOChronology.getInstance(zone);
+        }
+        DateTimeZone chronoZone = chrono.getDateTimeZone();
+        if (chronoZone != zone) {
+            chrono = chrono.withDateTimeZone(zone);
+            if (chrono == null) {
+                return ISOChronology.getInstance(zone);
+            }
+        }
+        return chrono;
+    }
+    
+    //-----------------------------------------------------------------------
+    /**
+     * Returns ReadableInstant.class.
+     * 
+     * @return ReadableInstant.class
+     */
+    public Class getSupportedType() {
+        return ReadableInstant.class;
+    }
+    
+}
diff --git a/JodaTime/src/java/org/joda/time/convert/StringConverter.java b/JodaTime/src/java/org/joda/time/convert/StringConverter.java
new file mode 100644
index 000000000..797bfd6f4
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/convert/StringConverter.java
@@ -0,0 +1,123 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.convert;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeZone;
+import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.format.DateTimeParser;
+import org.joda.time.format.ISODateTimeFormat;
+
+/**
+ * StringConverter converts a String to milliseconds in the ISOChronology.
+ *
+ * @author Stephen Colebourne
+ * @since 1.0
+ */
+class StringConverter extends AbstractConverter implements InstantConverter {
+    
+    /**
+     * Singleton instance.
+     */
+    static final StringConverter INSTANCE = new StringConverter();
+    
+    /**
+     * Restricted constructor.
+     */
+    protected StringConverter() {
+        super();
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the millis, which is the ISO parsed string value.
+     * 
+     * @param object  the object to convert, must not be null
+     * @param zone  the zone to use, null means default zone
+     * @return the millisecond value
+     * @throws IllegalArgumentException if the value if invalid
+     */
+    public long getInstantMillis(Object object, DateTimeZone zone) {
+        String str = (String) object;
+        Chronology chrono = ISOChronology.getInstance(zone);
+        DateTimeParser p = ISODateTimeFormat.getInstance(chrono).dateTimeParser();
+        return p.parseMillis(str);
+    }
+    
+    /**
+     * Gets the millis, which is the ISO parsed string value.
+     * 
+     * @param object  the object to convert, must not be null
+     * @param chrono  the chronology to use, null means ISOChronology
+     * @return the millisecond value
+     * @throws IllegalArgumentException if the value if invalid
+     */
+    public long getInstantMillis(Object object, Chronology chrono) {
+        String str = (String) object;
+        chrono = getChronology(object, chrono);
+        DateTimeParser p = ISODateTimeFormat.getInstance(chrono).dateTimeParser();
+        return p.parseMillis(str);
+    }
+    
+    //-----------------------------------------------------------------------
+    /**
+     * Returns String.class.
+     * 
+     * @return String.class
+     */
+    public Class getSupportedType() {
+        return String.class;
+    }
+    
+}
diff --git a/JodaTime/src/java/org/joda/time/convert/package.html b/JodaTime/src/java/org/joda/time/convert/package.html
new file mode 100644
index 000000000..68cb4c636
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/convert/package.html
@@ -0,0 +1,68 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<html>
+<head>
+<title>org.joda.time.convert package</title>
+<!--
+
+   Joda Software License, Version 1.0
+  
+  
+   Copyright (c) 2001-03 Stephen Colebourne.
+   All rights reserved.
+  
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions
+   are met:
+  
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+  
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+  
+   3. The end-user documentation included with the redistribution,
+      if any, must include the following acknowledgment:
+         "This product includes software developed by the
+          Joda project (http://www.joda.org/)."
+      Alternately, this acknowledgment may appear in the software itself,
+      if and wherever such third-party acknowledgments normally appear.
+  
+   4. The name "Joda" must not be used to endorse or promote products
+      derived from this software without prior written permission. For
+      written permission, please contact licence@joda.org.
+  
+   5. Products derived from this software may not be called "Joda",
+      nor may "Joda" appear in their name, without prior written
+      permission of the Joda project.
+  
+   THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+   USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+   OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+   SUCH DAMAGE.
+   ====================================================================
+  
+   This software consists of voluntary contributions made by many
+   individuals on behalf of the Joda project and was originally
+   created by Stephen Colebourne <scolebourne@joda.org>. For more
+   information on the Joda project, please see <http://www.joda.org/>.
+
+-->
+</head>
+<body>
+<p>
+Provides support for converting objects into instants and durations. Converters
+are used internally by many of the standard classes, like DateTime. Most
+applications have no need to use these classes directly.
+</p>
+</body>
+</html>
diff --git a/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java b/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java
index d12b38736..cd8915eff 100644
--- a/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java
+++ b/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java
@@ -55,8 +55,6 @@
 
 import java.io.IOException;
 import java.io.Writer;
-import java.lang.reflect.Method;
-import java.text.ParseException;
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTime;
@@ -78,30 +76,16 @@
  * Likewise, the parse methods assume that your subclass has implemented
  * DateTimeParser or DateTimeFormatter. If not, a ClassCastException is thrown
  * when calling the parse methods.
+ * <p>
+ * AbstractDateTimeFormatter is thread-safe and immutable.
  *
  * @author Brian S O'Neill
+ * @since 1.0
  */
 public abstract class AbstractDateTimeFormatter {
 
-    private static Method cInitCauseMethod;
-
-    static {
-        // cope with JDK 1.4 enhancements
-        Method initCauseMethod = null;
-        try {
-            initCauseMethod = Throwable.class.getMethod
-                ("initCause", new Class[] {Throwable.class});
-            
-        } catch (NoSuchMethodException ex) {
-            // ignore
-        } catch (SecurityException ex) {
-            // ignore
-        }
-        cInitCauseMethod = initCauseMethod;
-    }
-
     // Accessed also by AbstractDurationFormatter.
-    static String createErrorMessage(String text, int errorPos) {
+    static String createErrorMessage(final String text, final int errorPos) {
         int sampleLen = errorPos + 20;
         String sampleText;
         if (text.length() <= sampleLen) {
@@ -122,98 +106,97 @@ static String createErrorMessage(String text, int errorPos) {
             sampleText.substring(errorPos) + '"';
     }
 
-    private static void setCause(ParseException pe, Throwable initCause) {
-        if (cInitCauseMethod != null) {
-            try {
-                cInitCauseMethod.invoke(pe, new Object[]{initCause});
-            } catch (Exception e) {
-                cInitCauseMethod = null;
-            }
-        }
-    }
-
     /**
      * Returns the Chronology being used by the formatter, or null if none.
      */
     public abstract Chronology getChronology();
 
-    public void printTo(StringBuffer buf, ReadableInstant instant) {
+    /**
+     * Returns the DateTimeZone from the formatter's Chronology, defaulting to
+     * UTC if the Chronology or its DateTimeZone is null.
+     */
+    public DateTimeZone getDateTimeZone() {
+        Chronology chrono = getChronology();
+        if (chrono == null) {
+            return DateTimeZone.UTC;
+        }
+        DateTimeZone zone = chrono.getDateTimeZone();
+        return zone == null ? DateTimeZone.UTC : zone;
+    }
+
+    public void printTo(final StringBuffer buf, final ReadableInstant instant) {
         long millisUTC = instant.getMillis();
         Chronology chrono;
         if ((chrono = instant.getChronology()) != null) {
             printTo(buf, millisUTC, chrono.getDateTimeZone());
         } else {
-            ((DateTimePrinter)this).printTo(buf, millisUTC, null, millisUTC);
+            ((DateTimePrinter)this).printTo(buf, millisUTC, null);
         }
     }
 
-    public void printTo(Writer out, ReadableInstant instant) throws IOException {
+    public void printTo(final Writer out, final ReadableInstant instant) throws IOException {
         long millisUTC = instant.getMillis();
         Chronology chrono;
         if ((chrono = instant.getChronology()) != null) {
             printTo(out, millisUTC, chrono.getDateTimeZone());
         } else {
-            ((DateTimePrinter)this).printTo(out, millisUTC, null, millisUTC);
+            ((DateTimePrinter)this).printTo(out, millisUTC, null);
         }
     }
 
-    public void printTo(StringBuffer buf, long millisUTC) {
-        printTo(buf, millisUTC, null);
+    public void printTo(final StringBuffer buf, final long instant) {
+        printTo(buf, instant, null);
     }
 
-    public void printTo(Writer out, long millisUTC) throws IOException {
-        printTo(out, millisUTC, null);
+    public void printTo(final Writer out, final long instant) throws IOException {
+        printTo(out, instant, null);
     }
 
-    public void printTo(StringBuffer buf, long millisUTC, DateTimeZone zone) {
-        if (zone != null) {
-            ((DateTimePrinter)this).printTo
-                (buf, millisUTC, zone, millisUTC + zone.getOffset(millisUTC));
-        } else {
-            ((DateTimePrinter)this).printTo(buf, millisUTC, null, millisUTC);
+    public void printTo(final StringBuffer buf, final long instant, DateTimeZone zone) {
+        if (zone == null) {
+            zone = getDateTimeZone();
         }
+        ((DateTimePrinter) this).printTo
+            (buf, instant, zone, instant + zone.getOffset(instant));
     }
 
-    public void printTo(Writer out, long millisUTC, DateTimeZone zone) throws IOException {
-        if (zone != null) {
-            ((DateTimePrinter)this).printTo
-                (out, millisUTC, zone, millisUTC + zone.getOffset(millisUTC));
-        } else {
-            ((DateTimePrinter)this).printTo(out, millisUTC, null, millisUTC);
+    public void printTo(final Writer out, final long instant, DateTimeZone zone) throws IOException {
+        if (zone == null) {
+            zone = getDateTimeZone();
         }
+        ((DateTimePrinter) this).printTo
+            (out, instant, zone, instant + zone.getOffset(instant));
     }
 
-    public String print(ReadableInstant instant) {
+    public String print(final ReadableInstant instant) {
         long millisUTC = instant.getMillis();
         Chronology chrono;
         if ((chrono = instant.getChronology()) != null) {
             return print(millisUTC, chrono.getDateTimeZone());
         } else {
-            return print(millisUTC, null, millisUTC);
+            return print(millisUTC, null);
         }
     }
 
-    public String print(long millisUTC) {
-        return print(millisUTC, null);
+    public String print(final long instant) {
+        return print(instant, null);
     }
 
-    public String print(long millisUTC, DateTimeZone zone) {
-        if (zone != null) {
-            return print
-                (millisUTC, zone, millisUTC + zone.getOffset(millisUTC));
-        } else {
-            return print(millisUTC, null, millisUTC);
+    public String print(final long instant, DateTimeZone zone) {
+        if (zone == null) {
+            zone = getDateTimeZone();
         }
+        return print(instant, zone, instant + zone.getOffset(instant));
     }
 
-    public String print(long millisUTC, DateTimeZone zone, long millisLocal) {
+    public String print(final long instant, final DateTimeZone zone, final long instantLocal) {
         DateTimePrinter p = (DateTimePrinter)this;
         StringBuffer buf = new StringBuffer(p.estimatePrintedLength());
-        p.printTo(buf, millisUTC, zone, millisLocal);
+        p.printTo(buf, instant, zone, instantLocal);
         return buf.toString();
     }
 
-    public int parseInto(ReadWritableInstant instant, String text, int position) {
+    public int parseInto(final ReadWritableInstant instant, final String text, final int position) {
         DateTimeParser p = (DateTimeParser)this;
 
         long millis = instant.getMillis();
@@ -227,46 +210,62 @@ public int parseInto(ReadWritableInstant instant, String text, int position) {
         }
 
         DateTimeParserBucket bucket = createBucket(millis);
-        position = p.parseInto(bucket, text, position);
+        int resultPos = p.parseInto(bucket, text, position);
         instant.setMillis(bucket.computeMillis());
-        return position;
+        return resultPos;
     }
     
-    public long parseMillis(String text) throws ParseException {
+    public long parseMillis(final String text) {
         return parseMillis(text, 0);
     }
 
-    public long parseMillis(String text, long millis) throws ParseException {
+    public long parseMillis(final String text, final long instantLocal) {
         DateTimeParser p = (DateTimeParser)this;
-        DateTimeParserBucket bucket = createBucket(millis);
+        DateTimeParserBucket bucket = createBucket(instantLocal);
 
         int newPos = p.parseInto(bucket, text, 0);
         if (newPos >= 0) {
             if (newPos >= text.length()) {
-                try {
-                    return bucket.computeMillis();
-                } catch (IllegalArgumentException ex) {
-                    ParseException pe = new ParseException(ex.getMessage(), 0);
-                    setCause(pe, ex);
-                    throw pe;
-                }
+                return bucket.computeMillis();
             }
         } else {
             newPos = ~newPos;
         }
 
-        throw new ParseException(createErrorMessage(text, newPos), newPos);
+        throw new IllegalArgumentException(createErrorMessage(text, newPos));
     }
 
-    public DateTime parseDateTime(String text) throws ParseException {
+    public DateTime parseDateTime(final String text) {
         return new DateTime(parseMillis(text), getChronology());
     }
 
-    public MutableDateTime parseMutableDateTime(String text) throws ParseException {
+    public DateTime parseDateTime(final String text, final ReadableInstant instant) {
+        return new DateTime(parseMillis(text, getInstantLocal(instant)), getChronology());
+    }
+
+    public MutableDateTime parseMutableDateTime(final String text) {
         return new MutableDateTime(parseMillis(text), getChronology());
     }
 
-    private DateTimeParserBucket createBucket(long millis) {
+    public MutableDateTime parseMutableDateTime(final String text, final ReadableInstant instant) {
+        return new MutableDateTime(parseMillis(text, getInstantLocal(instant)), getChronology());
+    }
+
+    private long getInstantLocal(ReadableInstant instant) {
+        long instantLocal;
+        if (instant == null) {
+            instantLocal = 0;
+        } else {
+            instantLocal = instant.getMillis();
+            DateTimeZone zone = instant.getDateTimeZone();
+            if (zone != null) {
+                instantLocal += zone.getOffset(instantLocal);
+            }
+        }
+        return instantLocal;
+    }
+
+    private DateTimeParserBucket createBucket(final long millis) {
         DateTimeParserBucket bucket = new DateTimeParserBucket(millis);
         Chronology chrono = getChronology();
         if (chrono != null) {
diff --git a/JodaTime/src/java/org/joda/time/format/AbstractDurationFormatter.java b/JodaTime/src/java/org/joda/time/format/AbstractDurationFormatter.java
new file mode 100644
index 000000000..73fb429c4
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/format/AbstractDurationFormatter.java
@@ -0,0 +1,111 @@
+/**
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.format;
+
+import org.joda.time.Duration;
+import org.joda.time.DurationType;
+import org.joda.time.MutableDuration;
+import org.joda.time.ReadableDuration;
+
+/**
+ * Abstract base class for implementing {@link DurationPrinter}s,
+ * {@link DurationParser}s, and {@link DurationFormatter}s. This class
+ * intentionally does not implement any of those interfaces. You can subclass
+ * and implement only the interfaces that you need to.
+ * <p>
+ * The print methods assume that your subclass has implemented DurationPrinter or
+ * DurationFormatter. If not, a ClassCastException is thrown when calling those
+ * methods.
+ * <p>
+ * Likewise, the parse methods assume that your subclass has implemented
+ * DurationParser or DurationFormatter. If not, a ClassCastException is thrown
+ * when calling the parse methods.
+ * 
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+public abstract class AbstractDurationFormatter {
+    
+    public int countFieldsToPrint(ReadableDuration duration) {
+        return ((DurationPrinter) this).countFieldsToPrint(duration, Integer.MAX_VALUE);
+    }
+
+    public String print(ReadableDuration duration) {
+        DurationPrinter p = (DurationPrinter) this;
+        StringBuffer buf = new StringBuffer(p.calculatePrintedLength(duration));
+        p.printTo(buf, duration);
+        return buf.toString();
+    }
+
+    public Duration parseDuration(DurationType type, String text) {
+        return parseMutableDuration(type, text).toDuration();
+    }
+
+    public MutableDuration parseMutableDuration(DurationType type, String text) {
+        DurationParser p = (DurationParser) this;
+        MutableDuration duration = new MutableDuration(type, 0);
+
+        int newPos = p.parseInto(duration, text, 0);
+        if (newPos >= 0) {
+            if (newPos >= text.length()) {
+                return duration;
+            }
+        } else {
+            newPos = ~newPos;
+        }
+
+        throw new IllegalArgumentException(AbstractDateTimeFormatter
+                                           .createErrorMessage(text, newPos));
+    }
+}
diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java b/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java
index c3ac0881a..25c79fe10 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java
@@ -56,7 +56,6 @@
 import java.io.IOException;
 import java.io.Writer;
 import java.text.DateFormat;
-import java.text.ParseException;
 import java.text.SimpleDateFormat;
 import java.util.HashMap;
 import java.util.Locale;
@@ -64,58 +63,176 @@
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTime;
+import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeZone;
 import org.joda.time.MutableDateTime;
 import org.joda.time.ReadWritableInstant;
 import org.joda.time.ReadableInstant;
+import org.joda.time.chrono.RemainderDateTimeField;
 import org.joda.time.chrono.iso.ISOChronology;
 
 /**
  * DateTimeFormat provides localized printing and parsing capabilities for all
  * dates and times.
+ * <p>
+ * This class provides access to the actual DateTimeFormatter instances in two ways:
+ * <ul>
+ * <li>{@link #forPattern(String) Pattern} provides a DateTimeFormatter based on
+ * a pattern string that is compatible with the JDK date patterns.
+ * <li>{@link #forStyle(String) Style} provides a DateTimeFormatter based on a
+ * two character style, representing short, medium, long and full.
+ * </ul>
+ * <p>
+ * For example, to use a patterm:
+ * <pre>
+ * DateTime dt = new DateTime();
+ * DateTimeFormatter fmt = DateTimeFormat.getInstance().forPattern("MMMM, yyyy");
+ * String str = fmt.print(dt);
+ * </pre>
+ *
+ * The pattern syntax is compatible with java.text.SimpleDateFormat, but a few
+ * more symbols are also supported. All ASCII letters are reserved as pattern
+ * letters, which are defined as the following:
+ * <blockquote>
+ * <pre>
+ * Symbol  Meaning                      Presentation  Examples
+ * ------  -------                      ------------  -------
+ * G       era                          text          AD
+ * C       century of era (&gt;=0)         number        20
+ * Y       year of era (&gt;=0)            year          1996
+ *
+ * x       weekyear                     year          1996
+ * w       week of weekyear             number        27
+ * e       day of week                  number        2
+ * E       day of week                  text          Tuesday; Tue
+ *
+ * y       year                         year          1996
+ * D       day of year                  number        189
+ * M       month of year                month         July; Jul; 07
+ * d       day of month                 number        10
+ *
+ * a       halfday of day               text          PM
+ * K       hour of halfday (0~11)       number        0
+ * h       clockhour of halfday (1~12)  number        12
+ *
+ * H       hour of day (0~23)           number        0
+ * k       clockhour of day (1~24)      number        24
+ * m       minute of hour               number        30
+ * s       second of minute             number        55
+ * S       fraction of second           number        978
+ *
+ * z       time zone                    text          Pacific Standard Time; PST
+ * Z       time zone offset             text          -08:00; -0800
+ *
+ * '       escape for text              delimiter
+ * ''      single quote                 literal       '
+ * </pre>
+ * </blockquote>
+ * The count of pattern letters determine the format.
+ * <p>
+ * <strong>Text</strong>: If the number of pattern letters is 4 or more,
+ * the full form is used; otherwise a short or abbreviated form is used if
+ * available.
+ * <p>
+ * <strong>Number</strong>: The minimum number of digits. Shorter numbers
+ * are zero-padded to this amount.
+ * <p>
+ * <strong>Year</strong>: Numeric presentation for year and weekyear fields
+ * are handled specially. For example, if the count of 'y' is 2, the year
+ * will be displayed as the zero-based year of the century, which is two
+ * digits.
+ * <p>
+ * <strong>Month</strong>: 3 or over, use text, otherwise use number.
+ * <p>
+ * Any characters in the pattern that are not in the ranges of ['a'..'z']
+ * and ['A'..'Z'] will be treated as quoted text. For instance, characters
+ * like ':', '.', ' ', '#' and '@' will appear in the resulting time text
+ * even they are not embraced within single quotes.
+ * <p>
+ * DateTimeFormat is thread-safe and immutable, and the formatters it returns
+ * are as well.
  *
  * @author Brian S O'Neill
+ * @since 1.0
  * @see ISODateTimeFormat
  * @see DateTimeFormatterBuilder
  */
 public class DateTimeFormat {
 
-    // Maps Chronology instances to maps that map Locales to DateTimeFormat instances.
+    /**
+     * Cache that maps Chronology instances to maps that map
+     * Locales to DateTimeFormat instances.
+     */
     private static Map cInstanceCache = new HashMap(7);
 
+    /**
+     * Gets an instance of a formatter that works using the ISOChronology in UTC
+     * in the default locale.
+     * 
+     * @return a format provider
+     */
     public static DateTimeFormat getInstanceUTC() {
         return getInstance(ISOChronology.getInstanceUTC(), Locale.getDefault());
     }
 
+    /**
+     * Gets an instance of a formatter that works using the ISOChronology in the
+     * default time zone and the default locale.
+     * 
+     * @return a format provider
+     */
     public static DateTimeFormat getInstance() {
         return getInstance(ISOChronology.getInstance(), Locale.getDefault());
     }
 
-    public static DateTimeFormat getInstance(DateTimeZone zone) {
+    /**
+     * Gets an instance of a formatter that works using the ISOChronology in the
+     * specified time zone and the default locale.
+     * 
+     * @param zone  the time zone to use, null for default zone
+     * @return a format provider
+     */
+    public static DateTimeFormat getInstance(final DateTimeZone zone) {
         return getInstance(ISOChronology.getInstance(zone), Locale.getDefault());
     }
 
-    public static DateTimeFormat getInstance(DateTimeZone zone, Locale locale) {
+    /**
+     * Gets an instance of a formatter that works using the ISOChronology in the
+     * specified time zone and locale.
+     * 
+     * @param zone  the time zone to use, null for default zone
+     * @param locale  the Locale to use, null for default locale
+     * @return a format provider
+     */
+    public static DateTimeFormat getInstance(final DateTimeZone zone, final Locale locale) {
         return getInstance(ISOChronology.getInstance(zone), locale);
     }
 
     /**
-     * @param chrono Chronology to use
+     * Gets an instance of a formatter that works using the specified chronology
+     * in the default locale.
+     * 
+     * @param chrono  the chronology to use, null means ISOChronology in the default time zone
+     * @return a format provider
      */
-    public static DateTimeFormat getInstance(Chronology chrono) {
+    public static DateTimeFormat getInstance(final Chronology chrono) {
         return getInstance(chrono, Locale.getDefault());
     }
 
     /**
-     * @param chrono Chronology to use
-     * @param locale Locale to use
+     * Gets an instance of a formatter that works using the specified chronology
+     * and locale.
+     * 
+     * @param chrono  the chronology to use, null means ISOChronology in the default time zone
+     * @param locale  the Locale to use, null for default locale
+     * @return a format provider
      */
     public static synchronized DateTimeFormat getInstance(Chronology chrono, Locale locale) {
         if (chrono == null) {
-            throw new IllegalArgumentException("The Chronology must not be null");
+            chrono = ISOChronology.getInstance();
         }
         if (locale == null) {
-            throw new IllegalArgumentException("The Locale must not be null");
+            locale = Locale.getDefault();
         }
         Map map = (Map)cInstanceCache.get(chrono);
         if (map == null) {
@@ -130,29 +247,292 @@ public static synchronized DateTimeFormat getInstance(Chronology chrono, Locale
         return dtf;
     }
 
+    /**
+     * Parses the given pattern and appends the rules to the given
+     * DateTimeFormatterBuilder.
+     *
+     * @param pattern  pattern specification
+     * @throws IllegalArgumentException if the pattern is invalid
+     * @see #forPattern
+     */
+    public static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {
+        int length = pattern.length();
+        int[] indexRef = new int[1];
+
+        for (int i=0; i<length; i++) {
+            indexRef[0] = i;
+            String token = parseToken(pattern, indexRef);
+            i = indexRef[0];
+
+            int tokenLen = token.length();
+            if (tokenLen == 0) {
+                break;
+            }
+            char c = token.charAt(0);
+
+            switch (c) {
+            case 'G': // era designator (text)
+                builder.appendEraText();
+                break;
+            case 'C': // century of era (number)
+                builder.appendCenturyOfEra(tokenLen, tokenLen);
+                break;
+            case 'x': // weekyear (number)
+            case 'y': // year (number)
+            case 'Y': // year of era (number)
+                if (tokenLen == 2) {
+                    // Use a new RemainderDateTimeField to ensure that the year
+                    // of century is zero-based.
+                    DateTimeField field;
+                    Chronology chronoUTC = builder.getChronology().withUTC();
+                    switch (c) {
+                    case 'x':
+                        field = new RemainderDateTimeField
+                            (chronoUTC.weekyear(), "weekyearOfCentury", "centuries", 100);
+                        break;
+                    case 'y': default:
+                        field = new RemainderDateTimeField
+                            (chronoUTC.year(), "yearOfCentury", "centuries", 100);
+                        break;
+                    case 'Y':
+                        field = new RemainderDateTimeField
+                            (chronoUTC.yearOfEra(), "yearOfCentury", "centuries", 100);
+                        break;
+                    }
+                    builder.appendNumeric(field, 2, 2);
+                } else {
+                    // Try to support long year values.
+                    int maxDigits = 9;
+
+                    // Peek ahead to next token.
+                    if (i + 1 < length) {
+                        indexRef[0]++;
+                        if (isNumericToken(parseToken(pattern, indexRef))) {
+                            // If next token is a number, cannot support long years.
+                            maxDigits = tokenLen;
+                        }
+                        indexRef[0]--;
+                    }
+
+                    switch (c) {
+                    case 'x':
+                        builder.appendWeekyear(tokenLen, maxDigits);
+                        break;
+                    case 'y':
+                        builder.appendYear(tokenLen, maxDigits);
+                        break;
+                    case 'Y':
+                        builder.appendYearOfEra(tokenLen, maxDigits);
+                        break;
+                    }
+                }
+                break;
+            case 'M': // month of year (text and number)
+                if (tokenLen >= 3) {
+                    if (tokenLen >= 4) {
+                        builder.appendMonthOfYearText();
+                    } else {
+                        builder.appendMonthOfYearShortText();
+                    }
+                } else {
+                    builder.appendMonthOfYear(tokenLen);
+                }
+                break;
+            case 'd': // day of month (number)
+                builder.appendDayOfMonth(tokenLen);
+                break;
+            case 'h': // hour of day (number, 1..12)
+                builder.appendClockhourOfHalfday(tokenLen);
+                break;
+            case 'H': // hour of day (number, 0..23)
+                builder.appendHourOfDay(tokenLen);
+                break;
+            case 'm': // minute of hour (number)
+                builder.appendMinuteOfHour(tokenLen);
+                break;
+            case 's': // second of minute (number)
+                builder.appendSecondOfMinute(tokenLen);
+                break;
+            case 'S': // fraction of second (number)
+                builder.appendFractionOfSecond(tokenLen, tokenLen);
+                break;
+            case 'e': // day of week (number)
+                builder.appendDayOfWeek(tokenLen);
+                break;
+            case 'E': // dayOfWeek (text)
+                if (tokenLen >= 4) {
+                    builder.appendDayOfWeekText();
+                } else {
+                    builder.appendDayOfWeekShortText();
+                }
+                break;
+            case 'D': // day of year (number)
+                builder.appendDayOfYear(tokenLen);
+                break;
+            case 'w': // week of weekyear (number)
+                builder.appendWeekOfWeekyear(tokenLen);
+                break;
+            case 'a': // am/pm marker (text)
+                builder.appendHalfdayOfDayText();
+                break;
+            case 'k': // hour of day (1..24)
+                builder.appendClockhourOfDay(tokenLen);
+                break;
+            case 'K': // hour of day (0..11)
+                builder.appendClockhourOfHalfday(tokenLen);
+                break;
+            case 'z': // time zone (text)
+                if (tokenLen >= 4) {
+                    builder.appendTimeZoneName();
+                } else {
+                    builder.appendTimeZoneShortName();
+                }
+                break;
+            case 'Z': // time zone offset
+                if (tokenLen >= 4) {
+                    builder.appendTimeZoneOffset(null, true, 2, 2);
+                } else {
+                    builder.appendTimeZoneOffset(null, false, 2, 2);
+                }
+                break;
+            case '\'': // literal text
+                String sub = token.substring(1);
+                if (sub.length() == 1) {
+                    builder.appendLiteral(sub.charAt(0));
+                } else {
+                    // Create copy of sub since otherwise the temporary quoted
+                    // string would still be referenced internally.
+                    builder.appendLiteral(new String(sub));
+                }
+                break;
+            default:
+                throw new IllegalArgumentException
+                    ("Illegal pattern component: " + token);
+            }
+        }
+    }
+
+    private static String parseToken(final String pattern, final int[] indexRef) {
+        StringBuffer buf = new StringBuffer();
+
+        int i = indexRef[0];
+        int length = pattern.length();
+
+        char c = pattern.charAt(i);
+        if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {
+            // Scan a run of the same character, which indicates a time
+            // pattern.
+            buf.append(c);
+
+            while (i + 1 < length) {
+                char peek = pattern.charAt(i + 1);
+                if (peek == c) {
+                    buf.append(c);
+                    i++;
+                } else {
+                    break;
+                }
+            }
+        } else {
+            // This will identify token as text.
+            buf.append('\'');
+
+            boolean inLiteral = false;
+
+            for (; i < length; i++) {
+                c = pattern.charAt(i);
+                
+                if (c == '\'') {
+                    if (i + 1 < length && pattern.charAt(i + 1) == '\'') {
+                        // '' is treated as escaped '
+                        i++;
+                        buf.append(c);
+                    } else {
+                        inLiteral = !inLiteral;
+                    }
+                } else if (!inLiteral &&
+                           (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {
+                    i--;
+                    break;
+                } else {
+                    buf.append(c);
+                }
+            }
+        }
+
+        indexRef[0] = i;
+        return buf.toString();
+    }
+
+    // Returns true if token should be parsed as a numeric field.
+    private static boolean isNumericToken(final String token) {
+        int tokenLen = token.length();
+        if (tokenLen > 0) {
+            char c = token.charAt(0);
+            switch (c) {
+            case 'c': // century (number)
+            case 'C': // century of era (number)
+            case 'x': // weekyear (number)
+            case 'y': // year (number)
+            case 'Y': // year of era (number)
+            case 'd': // day of month (number)
+            case 'h': // hour of day (number, 1..12)
+            case 'H': // hour of day (number, 0..23)
+            case 'm': // minute of hour (number)
+            case 's': // second of minute (number)
+            case 'S': // fraction of second (number)
+            case 'e': // day of week (number)
+            case 'D': // day of year (number)
+            case 'F': // day of week in month (number)
+            case 'w': // week of year (number)
+            case 'W': // week of month (number)
+            case 'k': // hour of day (1..24)
+            case 'K': // hour of day (0..11)
+                return true;
+            case 'M': // month of year (text and number)
+                if (tokenLen <= 2) {
+                    return true;
+                }
+            }
+        }
+            
+        return false;
+    }
+
+    //-----------------------------------------------------------------------
+    /** The chronology to use */
     private final Chronology iChrono;
+    /** The locale to use */
     private final Locale iLocale;
 
-    // Maps patterns to formatters.
-    private Map iPatternedCache = new HashMap(7);
+    /** Maps patterns to formatters */
+    private transient Map iPatternedCache = new HashMap(7);
 
-    // Maps styles to formatters.
-    private Map iStyledCache = new HashMap(7);
+    /** Maps styles to formatters */
+    private transient Map iStyledCache = new HashMap(7);
 
-    private DateTimeFormat(Chronology chrono, Locale locale) {
+    /**
+     * Constructor.
+     * 
+     * @param chrono  the chronology to use, must not be null
+     * @param locale  the locale to use, must not be null
+     */
+    private DateTimeFormat(final Chronology chrono, final Locale locale) {
+        super();
         iChrono = chrono;
         iLocale = locale;
     }
 
+    //-----------------------------------------------------------------------
     /**
-     * Select a format from a custom {@link DateTimeFormatterBuilder#appendPattern pattern}.
+     * Select a format from a custom pattern.
      *
-     * @param pattern pattern specification
-     * @throws IllegalArgumentException
-     * @see DateTimeFormatterBuilder#appendPattern
+     * @param pattern  pattern specification
+     * @throws IllegalArgumentException if the pattern is invalid
+     * @see #appendPatternTo
      */
-    public synchronized DateTimeFormatter forPattern(String pattern) {
-        DateTimeFormatter formatter = (DateTimeFormatter)iPatternedCache.get(pattern);
+    public synchronized DateTimeFormatter forPattern(final String pattern) {
+        DateTimeFormatter formatter = (DateTimeFormatter) iPatternedCache.get(pattern);
         if (formatter != null) {
             return formatter;
         }
@@ -161,8 +541,8 @@ public synchronized DateTimeFormatter forPattern(String pattern) {
             throw new IllegalArgumentException("Invalid pattern specification");
         }
 
-        DateTimeFormatterBuilder builder = 
-            new DateTimeFormatterBuilder(iChrono, iLocale).appendPattern(pattern);
+        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(iChrono, iLocale);
+        appendPatternTo(builder, pattern);
 
         if (builder.canBuildFormatter()) {
             formatter = builder.toFormatter();
@@ -185,10 +565,10 @@ public synchronized DateTimeFormatter forPattern(String pattern) {
      * character of 'S' for short style, 'M' for medium, 'L' for long, and 'F'
      * for full. A date or time may be ommitted by specifying a style character '-'.
      *
-     * @param style two characters from the set {"S", "M", "L", "F", "-"}
-     * @throws IllegalArgumentException
+     * @param style  two characters from the set {"S", "M", "L", "F", "-"}
+     * @throws IllegalArgumentException if the style is invalid
      */
-    public synchronized DateTimeFormatter forStyle(String style) {
+    public synchronized DateTimeFormatter forStyle(final String style) {
         DateTimeFormatter formatter = (DateTimeFormatter)iStyledCache.get(style);
         if (formatter == null) {
             formatter = forPattern(getPatternForStyle(style));
@@ -204,10 +584,10 @@ public synchronized DateTimeFormatter forStyle(String style) {
      * for long, and 'F' for full. A date or time may be ommitted by specifying
      * a style character '-'.
      *
-     * @param style two characters from the set {"S", "M", "L", "F", "-"}
-     * @throws IllegalArgumentException
+     * @param style  two characters from the set {"S", "M", "L", "F", "-"}
+     * @throws IllegalArgumentException if the style is invalid
      */
-    public String getPatternForStyle(String style) {
+    public String getPatternForStyle(final String style) {
         if (style == null || style.length() != 2) {
             throw new IllegalArgumentException("Invalid style specification: " + style);
         }
@@ -224,7 +604,7 @@ public String getPatternForStyle(String style) {
         }
     }
 
-    private String getDatePattern(char style) {
+    private String getDatePattern(final char style) {
         int istyle = selectStyle(style);
         try {
             return ((SimpleDateFormat)DateFormat.getDateInstance(istyle, iLocale)).toPattern();
@@ -233,7 +613,7 @@ private String getDatePattern(char style) {
         }
     }
 
-    private String getTimePattern(char style) {
+    private String getTimePattern(final char style) {
         int istyle = selectStyle(style);
         try {
             return ((SimpleDateFormat)DateFormat.getTimeInstance(istyle, iLocale)).toPattern();
@@ -242,7 +622,7 @@ private String getTimePattern(char style) {
         }
     }
 
-    private String getDateTimePattern(char dateStyle, char timeStyle) {
+    private String getDateTimePattern(final char dateStyle, final char timeStyle) {
         int idateStyle = selectStyle(dateStyle);
         int itimeStyle = selectStyle(dateStyle);
         try {
@@ -253,7 +633,7 @@ private String getDateTimePattern(char dateStyle, char timeStyle) {
         }
     }
 
-    private int selectStyle(char c) {
+    private int selectStyle(final char c) {
         switch (c) {
         case 'S':
             return DateFormat.SHORT;
@@ -268,13 +648,15 @@ private int selectStyle(char c) {
         }
     }
 
+    //-----------------------------------------------------------------------
     /**
      * A fake formatter that can only print.
      */
-    private static class FPrinter implements DateTimeFormatter {
+    static class FPrinter implements DateTimeFormatter {
         private final DateTimePrinter mPrinter;
 
-        FPrinter(DateTimePrinter printer) {
+        FPrinter(final DateTimePrinter printer) {
+            super();
             mPrinter = printer;
         }
 
@@ -286,83 +668,92 @@ public int estimatePrintedLength() {
             return mPrinter.estimatePrintedLength();
         }
 
-        public void printTo(StringBuffer buf, ReadableInstant instant) {
+        public void printTo(final StringBuffer buf, final ReadableInstant instant) {
             mPrinter.printTo(buf, instant);
         }
 
-        public void printTo(Writer out, ReadableInstant instant) throws IOException {
+        public void printTo(final Writer out, final ReadableInstant instant) throws IOException {
             mPrinter.printTo(out, instant);
         }
 
-        public void printTo(StringBuffer buf, long millisUTC) {
-            mPrinter.printTo(buf, millisUTC);
+        public void printTo(final StringBuffer buf, final long instant) {
+            mPrinter.printTo(buf, instant);
         }
 
-        public void printTo(Writer out, long millisUTC) throws IOException {
-            mPrinter.printTo(out, millisUTC);
+        public void printTo(final Writer out, final long instant) throws IOException {
+            mPrinter.printTo(out, instant);
         }
 
-        public void printTo(StringBuffer buf, long millisUTC, DateTimeZone zone) {
-            mPrinter.printTo(buf, millisUTC, zone);
+        public void printTo(final StringBuffer buf, final long instant, final DateTimeZone zone) {
+            mPrinter.printTo(buf, instant, zone);
         }
 
-        public void printTo(Writer out, long millisUTC, DateTimeZone zone)
+        public void printTo(final Writer out, final long instant, final DateTimeZone zone)
             throws IOException {
-            mPrinter.printTo(out, millisUTC, zone);
+            mPrinter.printTo(out, instant, zone);
         }
 
-        public void printTo(StringBuffer buf, long millisUTC,
-                            DateTimeZone zone, long millisLocal) {
-            mPrinter.printTo(buf, millisUTC, zone, millisLocal);
+        public void printTo(final StringBuffer buf, final long instant,
+                            final DateTimeZone zone, final long instantLocal) {
+            mPrinter.printTo(buf, instant, zone, instantLocal);
         }
 
-        public void printTo(Writer out, long millisUTC,
-                            DateTimeZone zone, long millisLocal)
+        public void printTo(final Writer out, final long instant,
+                            final DateTimeZone zone, final long instantLocal)
             throws IOException {
-            mPrinter.printTo(out, millisUTC, zone, millisLocal);
+            mPrinter.printTo(out, instant, zone, instantLocal);
         }
 
-        public String print(ReadableInstant instant) {
+        public String print(final ReadableInstant instant) {
             return mPrinter.print(instant);
         }
 
-        public String print(long millisUTC) {
-            return mPrinter.print(millisUTC);
+        public String print(final long instant) {
+            return mPrinter.print(instant);
         }
 
-        public String print(long millisUTC, DateTimeZone zone) {
-            return mPrinter.print(millisUTC, zone);
+        public String print(final long instant, final DateTimeZone zone) {
+            return mPrinter.print(instant, zone);
         }
 
-        public String print(long millisUTC, DateTimeZone zone, long millisLocal) {
-            return mPrinter.print(millisUTC, zone, millisLocal);
+        public String print(final long instant, final DateTimeZone zone, final long instantLocal) {
+            return mPrinter.print(instant, zone, instantLocal);
         }
 
         public int estimateParsedLength() {
             return 0;
         }
 
-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
+        public int parseInto(final DateTimeParserBucket bucket, final String text, final int position) {
             throw unsupported();
         }
 
-        public int parseInto(ReadWritableInstant instant, String text, int position) {
+        public int parseInto(final ReadWritableInstant instant, final String text, final int position) {
             throw unsupported();
         }
 
-        public long parseMillis(String text) throws ParseException {
+        public long parseMillis(final String text) {
             throw unsupported();
         }
 
-        public long parseMillis(String text, long millis) throws ParseException {
+        public long parseMillis(final String text, final long instantLocal) {
             throw unsupported();
         }
 
-        public DateTime parseDateTime(String text) throws ParseException {
+        public DateTime parseDateTime(final String text) {
             throw unsupported();
         }
 
-        public MutableDateTime parseMutableDateTime(String text) throws ParseException {
+        public DateTime parseDateTime(final String text, final ReadableInstant instant) {
+            throw unsupported();
+        }
+
+        public MutableDateTime parseMutableDateTime(final String text) {
+            throw unsupported();
+        }
+
+        public MutableDateTime parseMutableDateTime(final String text,
+                                                    final ReadableInstant instant) {
             throw unsupported();
         }
 
@@ -371,13 +762,15 @@ private UnsupportedOperationException unsupported() {
         }
     }
 
+    //-----------------------------------------------------------------------
     /**
      * A fake formatter that can only parse.
      */
-    private static class FParser implements DateTimeFormatter {
+    static class FParser implements DateTimeFormatter {
         private final DateTimeParser mParser;
 
-        FParser(DateTimeParser parser) {
+        FParser(final DateTimeParser parser) {
+            super();
             mParser = parser;
         }
 
@@ -389,53 +782,53 @@ public int estimatePrintedLength() {
             return 0;
         }
 
-        public void printTo(StringBuffer buf, ReadableInstant instant) {
+        public void printTo(final StringBuffer buf, final ReadableInstant instant) {
             throw unsupported();
         }
 
-        public void printTo(Writer out, ReadableInstant instant) throws IOException {
+        public void printTo(final Writer out, final ReadableInstant instant) throws IOException {
             throw unsupported();
         }
 
-        public void printTo(StringBuffer buf, long millisUTC) {
+        public void printTo(final StringBuffer buf, final long instant) {
             throw unsupported();
         }
 
-        public void printTo(Writer out, long millisUTC) throws IOException {
+        public void printTo(final Writer out, final long instant) throws IOException {
             throw unsupported();
         }
 
-        public void printTo(StringBuffer buf, long millisUTC, DateTimeZone zone) {
+        public void printTo(final StringBuffer buf, final long instant, final DateTimeZone zone) {
             throw unsupported();
         }
 
-        public void printTo(Writer out, long millisUTC, DateTimeZone zone) {
+        public void printTo(final Writer out, final long instant, final DateTimeZone zone) {
             throw unsupported();
         }
 
-        public void printTo(StringBuffer buf, long millisUTC,
-                            DateTimeZone zone, long millisLocal) {
+        public void printTo(final StringBuffer buf, final long instant,
+                            final DateTimeZone zone, final long instantLocal) {
             throw unsupported();
         }
 
-        public void printTo(Writer out, long millisUTC,
-                            DateTimeZone zone, long millisLocal) {
+        public void printTo(final Writer out, final long instant,
+                            final DateTimeZone zone, final long instantLocal) {
             throw unsupported();
         }
 
-        public String print(ReadableInstant instant) {
+        public String print(final ReadableInstant instant) {
             throw unsupported();
         }
 
-        public String print(long millisUTC) {
+        public String print(final long instant) {
             throw unsupported();
         }
 
-        public String print(long millisUTC, DateTimeZone zone) {
+        public String print(final long instant, final DateTimeZone zone) {
             throw unsupported();
         }
 
-        public String print(long millisUTC, DateTimeZone zone, long millisLocal) {
+        public String print(final long instant, final DateTimeZone zone, final long instantLocal) {
             throw unsupported();
         }
 
@@ -443,30 +836,39 @@ public int estimateParsedLength() {
             return mParser.estimateParsedLength();
         }
 
-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
+        public int parseInto(final DateTimeParserBucket bucket, final String text, final int position) {
             return mParser.parseInto(bucket, text, position);
         }
 
-        public int parseInto(ReadWritableInstant instant, String text, int position) {
+        public int parseInto(final ReadWritableInstant instant, final String text, final int position) {
             return mParser.parseInto(instant, text, position);
         }
 
-        public long parseMillis(String text) throws ParseException {
+        public long parseMillis(final String text) {
             return mParser.parseMillis(text);
         }
 
-        public long parseMillis(String text, long millis) throws ParseException {
-            return mParser.parseMillis(text, millis);
+        public long parseMillis(final String text, final long instantLocal) {
+            return mParser.parseMillis(text, instantLocal);
         }
 
-        public DateTime parseDateTime(String text) throws ParseException {
+        public DateTime parseDateTime(final String text) {
             return mParser.parseDateTime(text);
         }
 
-        public MutableDateTime parseMutableDateTime(String text) throws ParseException {
+        public DateTime parseDateTime(final String text, final ReadableInstant instant) {
+            return mParser.parseDateTime(text, instant);
+        }
+
+        public MutableDateTime parseMutableDateTime(final String text) {
             return mParser.parseMutableDateTime(text);
         }
 
+        public MutableDateTime parseMutableDateTime(final String text,
+                                                    final ReadableInstant instant) {
+            return mParser.parseMutableDateTime(text, instant);
+        }
+
         private UnsupportedOperationException unsupported() {
             return new UnsupportedOperationException("Printing not supported");
         }
diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java b/JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java
index c6a68f0e8..1becd45c6 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java
@@ -53,248 +53,12 @@
  */
 package org.joda.time.format;
 
-import java.io.IOException;
-import java.io.Writer;
-import java.text.ParseException;
-
-import org.joda.time.Chronology;
-import org.joda.time.DateTime;
-import org.joda.time.DateTimeZone;
-import org.joda.time.MutableDateTime;
-import org.joda.time.ReadWritableInstant;
-import org.joda.time.ReadableInstant;
-
 /**
- * Combined interface for printing and parsing.
+ * Defines a combined interface for printing and parsing.
  *
  * @author Brian S O'Neill
  */
 public interface DateTimeFormatter extends DateTimePrinter, DateTimeParser {
     
-    /**
-     * Returns the Chronology being used by the formatter, or null if none.
-     */
-    Chronology getChronology();
-
-    /**
-     * Returns the expected maximum number of characters produced. The actual
-     * amount should rarely exceed this estimate.
-     */
-    int estimatePrintedLength();
-
-    /**
-     * Prints a ReadableInstant, attempting to use the DateTimeZone supplied by
-     * the instant.
-     *
-     * @param buf formatted instant is appended to this buffer
-     * @param instant instant to format
-     */
-    void printTo(StringBuffer buf, ReadableInstant instant);
-
-    /**
-     * Prints a ReadableInstant, attempting to use the DateTimeZone supplied by
-     * the instant.
-     *
-     * @param out formatted instant is written out
-     * @param instant instant to format
-     */
-    void printTo(Writer out, ReadableInstant instant) throws IOException;
-
-    /**
-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
-     * using the formatter's DateTimeZone.
-     *
-     * @param buf formatted instant is appended to this buffer
-     * @param millisUTC millis since 1970-01-01T00:00:00Z
-     */
-    void printTo(StringBuffer buf, long millisUTC);
-
-    /**
-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
-     * using the formatter's DateTimeZone.
-     *
-     * @param out formatted instant is written out
-     * @param millisUTC millis since 1970-01-01T00:00:00Z
-     */
-    void printTo(Writer out, long millisUTC) throws IOException;
-
-    /**
-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
-     * attempting to use the given DateTimeZone.
-     *
-     * @param buf formatted instant is appended to this buffer
-     * @param millisUTC millis since 1970-01-01T00:00:00Z
-     * @param zone DateTimeZone to use, overriding the formatter's own zone if
-     * not null
-     */
-    void printTo(StringBuffer buf, long millisUTC, DateTimeZone zone);
-
-    /**
-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
-     * attempting to use the given DateTimeZone.
-     *
-     * @param out formatted instant is written out
-     * @param millisUTC millis since 1970-01-01T00:00:00Z
-     * @param zone DateTimeZone to use, overriding the formatter's own zone if
-     * not null
-     */
-    void printTo(Writer out, long millisUTC, DateTimeZone zone) throws IOException;
-
-    /**
-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
-     * attempting to use the given DateTimeZone.
-     *
-     * @param buf formatted instant is appended to this buffer
-     * @param millisUTC millis since 1970-01-01T00:00:00Z, used by time zone
-     * printers
-     * @param zone DateTimeZone to use, overriding the formatter's own zone if
-     * not null
-     * @param millisLocal pre-calculated millis since 1970-01-01T00:00:00,
-     * local time
-     */
-    void printTo(StringBuffer buf, long millisUTC,
-                 DateTimeZone zone, long millisLocal);
-
-    /**
-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
-     * attempting to use the given DateTimeZone.
-     *
-     * @param out formatted instant is written out
-     * @param millisUTC millis since 1970-01-01T00:00:00Z, used by time zone
-     * printers
-     * @param zone DateTimeZone to use, overriding the formatter's own zone if
-     * not null
-     * @param millisLocal pre-calculated millis since 1970-01-01T00:00:00,
-     * local time
-     */
-    void printTo(Writer out, long millisUTC,
-                 DateTimeZone zone, long millisLocal) throws IOException;
-
-    /**
-     * Prints a ReadableInstant to a new String, attempting to use the
-     * DateTimeZone supplied by the instant.
-     *
-     * @param instant instant to format
-     * @return the printed result
-     */
-    String print(ReadableInstant instant);
-
-    /**
-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
-     * using the formatter's DateTimeZone.
-     *
-     * @param millisUTC millis since 1970-01-01T00:00:00Z
-     * @return the printed result
-     */
-    String print(long millisUTC);
-
-    /**
-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
-     * attempting to use the given DateTimeZone.
-     *
-     * @param millisUTC millis since 1970-01-01T00:00:00Z
-     * @param zone DateTimeZone to use, overriding the formatter's own zone if
-     * not null
-     * @return the printed result
-     */
-    String print(long millisUTC, DateTimeZone zone);
-
-    /**
-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
-     * attempting to use the given DateTimeZone.
-     *
-     * @param millisUTC millis since 1970-01-01T00:00:00Z
-     * @param zone DateTimeZone to use, overriding the formatter's own zone if
-     * not null
-     * @param millisLocal pre-calculated millis since 1970-01-01T00:00:00,
-     * local time
-     * @return the printed result
-     */
-    String print(long millisUTC, DateTimeZone zone, long millisLocal);
-
-    /**
-     * Returns the expected maximum number of characters consumed. The actual
-     * amount should rarely exceed this estimate.
-     */
-    int estimateParsedLength();
-
-    /**
-     * Parse an element from the given text, saving any fields into the given
-     * DateTimeParserBucket. If the parse succeeds, the return value is the new
-     * text position. Note that the parse may succeed without fully reading the
-     * text.
-     * <p>
-     * If it fails, the return value is negative. To determine the position
-     * where the parse failed, apply the one's complement operator (~) on the
-     * return value.
-     *
-     * @param bucket field are saved into this
-     * @param text the text to parse
-     * @param position position to start parsing from
-     * @return new position, if negative, parse failed. Apply complement
-     * operator (~) to get position of failure
-     * @throws IllegalArgumentException if any field is out of range
-     */
-    int parseInto(DateTimeParserBucket bucket, String text, int position);
-
-    /**
-     * Parses a datetime from the given text, at the given position, saving the
-     * result into the fields of the given ReadWritableInstant. If the parse
-     * succeeds, the return value is the new text position. Note that the parse
-     * may succeed without fully reading the text.
-     * <p>
-     * If it fails, the return value is negative, but the instant may still be
-     * modified. To determine the position where the parse failed, apply the
-     * one's complement operator (~) on the return value.
-     *
-     * @param instant an instant that will be modified
-     * @param text text to parse
-     * @param position position to start parsing from
-     * @return new position, if negative, parse failed. Apply complement
-     * operator (~) to get position of failure
-     * @throws IllegalArgumentException if any field is out of range
-     */
-    int parseInto(ReadWritableInstant instant, String text, int position);
-
-    /**
-     * Parses a datetime from the given text, returning the number of
-     * milliseconds since the epoch, 1970-01-01T00:00:00Z.
-     *
-     * @param text text to parse
-     * @return parsed value expressed in milliseconds since the epoch
-     * @throws ParseException if any field is out of range
-     */
-    long parseMillis(String text) throws ParseException;
-
-    /**
-     * Parses a datetime from the given text, at the given position, returning
-     * the number of milliseconds since the epoch, 1970-01-01T00:00:00Z. An
-     * initial millisecond value is passed in, which is relative to the epoch,
-     * local time.
-     *
-     * @param text text to parse
-     * @param millis initial value of millis, relative to the epoch, local time
-     * @return parsed value expressed in milliseconds since the epoch, UTC
-     * @throws ParseException if any field is out of range
-     */
-    long parseMillis(String text, long millis) throws ParseException;
-
-    /**
-     * Parses a datetime from the given text, returning a new DateTime.
-     *
-     * @param text text to parse
-     * @return parsed value in a DateTime object
-     * @throws ParseException if any field is out of range
-     */
-    DateTime parseDateTime(String text) throws ParseException;
-
-    /**
-     * Parses a datetime from the given text, returning a new MutableDateTime.
-     *
-     * @param text text to parse
-     * @return parsed value in a MutabkeDateTime object
-     * @throws ParseException if any field is out of range
-     */
-    MutableDateTime parseMutableDateTime(String text) throws ParseException;
-    
+    // Methods inherited
 }
diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
index cc51c42e6..06d58a8da 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
@@ -62,15 +62,14 @@
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeZone;
-import org.joda.time.ReadableInstant;
-import org.joda.time.chrono.FractionalDateTimeField;
-import org.joda.time.chrono.RemainderDateTimeField;
+import org.joda.time.chrono.MillisDurationField;
+import org.joda.time.chrono.PreciseDateTimeField;
 import org.joda.time.chrono.iso.ISOChronology;
 
 /**
  * DateTimeFormatterBuilder is used for constructing {@link DateTimeFormatter}s.
- * DateTimeFormatters can be built by appending specific fields, patterns, or
- * other formatters.
+ * DateTimeFormatters can be built by appending specific fields or other
+ * formatters.
  *
  * <p>
  * For example, a formatter that prints month and year, like "January 1970", can
@@ -83,64 +82,15 @@
  *     .appendYear(4, 4)
  *     .toFormatter();
  * </pre>
+ * <p>
+ * DateTimeFormatterBuilder itself is mutable and not thread-safe, but the
+ * formatters that it builds are thread-safe and immutable.
  *
  * @see DateTimeFormat
  * @author Brian S O'Neill
  */
 public class DateTimeFormatterBuilder {
 
-    private static String parseToken(String pattern, int[] indexRef) {
-        StringBuffer buf = new StringBuffer();
-
-        int i = indexRef[0];
-        int length = pattern.length();
-
-        char c = pattern.charAt(i);
-        if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {
-            // Scan a run of the same character, which indicates a time
-            // pattern.
-            buf.append(c);
-
-            while (i + 1 < length) {
-                char peek = pattern.charAt(i + 1);
-                if (peek == c) {
-                    buf.append(c);
-                    i++;
-                } else {
-                    break;
-                }
-            }
-        } else {
-            // This will identify token as text.
-            buf.append('\'');
-
-            boolean inLiteral = false;
-
-            for (; i < length; i++) {
-                c = pattern.charAt(i);
-                
-                if (c == '\'') {
-                    if (i + 1 < length && pattern.charAt(i + 1) == '\'') {
-                        // '' is treated as escaped '
-                        i++;
-                        buf.append(c);
-                    } else {
-                        inLiteral = !inLiteral;
-                    }
-                } else if (!inLiteral &&
-                           (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {
-                    i--;
-                    break;
-                } else {
-                    buf.append(c);
-                }
-            }
-        }
-
-        indexRef[0] = i;
-        return buf.toString();
-    }
-
     private final Chronology iChrono;
     private final Chronology iChronoUTC;
     private final Locale iLocale;
@@ -161,7 +111,7 @@ public DateTimeFormatterBuilder() {
      * Creates a DateTimeFormatterBuilder with {@link ISOChronology}, in the
      * given time zone, with the default locale.
      */
-    public DateTimeFormatterBuilder(DateTimeZone zone) {
+    public DateTimeFormatterBuilder(final DateTimeZone zone) {
         this(ISOChronology.getInstance(zone));
     }
 
@@ -169,7 +119,7 @@ public DateTimeFormatterBuilder(DateTimeZone zone) {
      * Creates a DateTimeFormatterBuilder with {@link ISOChronology}, in the
      * given time zone, with any locale.
      */
-    public DateTimeFormatterBuilder(DateTimeZone zone, Locale locale) {
+    public DateTimeFormatterBuilder(final DateTimeZone zone, final Locale locale) {
         this(ISOChronology.getInstance(zone), locale);
     }
 
@@ -179,22 +129,22 @@ public DateTimeFormatterBuilder(DateTimeZone zone, Locale locale) {
      *
      * @param chrono Chronology to use
      */
-    public DateTimeFormatterBuilder(Chronology chrono) {
+    public DateTimeFormatterBuilder(final Chronology chrono) {
         this(chrono, Locale.getDefault());
     }
 
     /**
      * Creates a DateTimeFormatterBuilder with any chronology and locale.
      *
-     * @param chrono Chronology to use
-     * @param locale Locale to use
+     * @param chrono Chronology to use, or null for default iso
+     * @param locale Locale to use, or null for default
      */
     public DateTimeFormatterBuilder(Chronology chrono, Locale locale) {
         if (chrono == null) {
-            throw new IllegalArgumentException("The Chronology must not be null");
+            chrono = ISOChronology.getInstance();
         }
         if (locale == null) {
-            throw new IllegalArgumentException("The Locale must not be null");
+            locale = Locale.getDefault();
         }
         iChrono = chrono;
         iChronoUTC = chrono.withUTC();
@@ -303,7 +253,7 @@ public void clear() {
      *
      * @throws IllegalArgumentException if formatter is null
      */
-    public DateTimeFormatterBuilder append(DateTimeFormatter formatter)
+    public DateTimeFormatterBuilder append(final DateTimeFormatter formatter)
         throws IllegalArgumentException
     {
         if (formatter == null) {
@@ -318,7 +268,7 @@ public DateTimeFormatterBuilder append(DateTimeFormatter formatter)
      *
      * @throws IllegalArgumentException if printer is null
      */
-    public DateTimeFormatterBuilder append(DateTimePrinter printer)
+    public DateTimeFormatterBuilder append(final DateTimePrinter printer)
         throws IllegalArgumentException
     {
         if (printer == null) {
@@ -333,7 +283,7 @@ public DateTimeFormatterBuilder append(DateTimePrinter printer)
      *
      * @throws IllegalArgumentException if parser is null
      */
-    public DateTimeFormatterBuilder append(DateTimeParser parser) {
+    public DateTimeFormatterBuilder append(final DateTimeParser parser) {
         if (parser == null) {
             throw new IllegalArgumentException("No parser supplied");
         }
@@ -345,8 +295,8 @@ public DateTimeFormatterBuilder append(DateTimeParser parser) {
      *
      * @throws IllegalArgumentException if printer or parser is null
      */
-    public DateTimeFormatterBuilder append(DateTimePrinter printer,
-                                           DateTimeParser parser)
+    public DateTimeFormatterBuilder append(final DateTimePrinter printer,
+                                           final DateTimeParser parser)
         throws IllegalArgumentException
     {
         if (printer == null) {
@@ -371,8 +321,8 @@ public DateTimeFormatterBuilder append(DateTimePrinter printer,
      *
      * @throws IllegalArgumentException if any parser element but the last is null
      */
-    public DateTimeFormatterBuilder append(DateTimePrinter printer,
-                                           DateTimeParser[] parsers)
+    public DateTimeFormatterBuilder append(final DateTimePrinter printer,
+                                           final DateTimeParser[] parsers)
         throws IllegalArgumentException
     {
         if (parsers == null) {
@@ -402,14 +352,14 @@ public DateTimeFormatterBuilder append(DateTimePrinter printer,
      *
      * @throws IllegalArgumentException if parser is null
      */
-    public DateTimeFormatterBuilder appendOptional(DateTimeParser parser) {
+    public DateTimeFormatterBuilder appendOptional(final DateTimeParser parser) {
         if (parser == null) {
             throw new IllegalArgumentException("No parser supplied");
         }
         return append0(null, new MatchingParser(iChrono, new DateTimeParser[] {parser, null}));
     }
 
-    private DateTimeFormatterBuilder append0(Object element) {
+    private DateTimeFormatterBuilder append0(final Object element) {
         iFormatter = null;
         // Add the element as both a printer and parser.
         iElementPairs.add(element);
@@ -417,9 +367,8 @@ private DateTimeFormatterBuilder append0(Object element) {
         return this;
     }
 
-    private DateTimeFormatterBuilder append0(DateTimePrinter printer,
-                                             DateTimeParser parser)
-    {
+    private DateTimeFormatterBuilder append0(
+            final DateTimePrinter printer, final DateTimeParser parser) {
         iFormatter = null;
         iElementPairs.add(printer);
         iElementPairs.add(parser);
@@ -430,15 +379,20 @@ private DateTimeFormatterBuilder append0(DateTimePrinter printer,
      * Instructs the printer to emit a specific character, and the parser to
      * expect it. The parser is case-insensitive.
      */
-    public DateTimeFormatterBuilder appendLiteral(char c) {
+    public DateTimeFormatterBuilder appendLiteral(final char c) {
         return append0(new CharacterLiteral(iChrono, c));
     }
 
     /**
      * Instructs the printer to emit specific text, and the parser to expect
      * it. The parser is case-insensitive.
+     *
+     * @throws IllegalArgumentException if text is null
      */
-    public DateTimeFormatterBuilder appendLiteral(String text) {
+    public DateTimeFormatterBuilder appendLiteral(final String text) {
+        if (text == null) {
+            throw new IllegalArgumentException("Literal must not be null");
+        }
         return append0(new StringLiteral(iChrono, text));
     }
 
@@ -450,10 +404,13 @@ public DateTimeFormatterBuilder appendLiteral(String text) {
      * @param minDigits minumum number of digits to <i>print</i>
      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated
      * maximum number of digits to print
+     * @throws IllegalArgumentException if field is null
      */
-    public DateTimeFormatterBuilder appendNumeric(DateTimeField field,
-                                                  int minDigits, int maxDigits)
-    {
+    public DateTimeFormatterBuilder appendNumeric(
+            DateTimeField field, int minDigits, int maxDigits) {
+        if (field == null) {
+            throw new IllegalArgumentException("Field must not be null");
+        }
         if (maxDigits < minDigits) {
             maxDigits = minDigits;
         }
@@ -475,10 +432,13 @@ public DateTimeFormatterBuilder appendNumeric(DateTimeField field,
      * @param minDigits minumum number of digits to <i>print</i>
      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated
      * maximum number of digits to print
+     * @throws IllegalArgumentException if field is null
      */
-    public DateTimeFormatterBuilder appendSignedNumeric(DateTimeField field,
-                                                        int minDigits, int maxDigits)
-    {
+    public DateTimeFormatterBuilder appendSignedNumeric(
+            DateTimeField field, int minDigits, int maxDigits) {
+        if (field == null) {
+            throw new IllegalArgumentException("Field must not be null");
+        }
         if (maxDigits < minDigits) {
             maxDigits = minDigits;
         }
@@ -498,7 +458,7 @@ public DateTimeFormatterBuilder appendSignedNumeric(DateTimeField field,
      *
      * @param field field should operate in UTC or be time zone agnostic
      */
-    public DateTimeFormatterBuilder appendText(DateTimeField field) {
+    public DateTimeFormatterBuilder appendText(final DateTimeField field) {
         return append0(new TextField(iChrono, field, iLocale, false));
     }
 
@@ -508,64 +468,66 @@ public DateTimeFormatterBuilder appendText(DateTimeField field) {
      *
      * @param field field should operate in UTC or be time zone agnostic
      */
-    public DateTimeFormatterBuilder appendShortText(DateTimeField field) {
+    public DateTimeFormatterBuilder appendShortText(final DateTimeField field) {
         return append0(new TextField(iChrono, field, iLocale, true));
     }
 
     /**
      * Instructs the printer to emit a remainder of time as a decimal fraction,
-     * sans decimal point. For example, if the range is specified as 60000
-     * (milliseconds in one minute) and the time is 12:30:45, the value printed
-     * is 75. A decimal point is implied, so the fraction is 0.75, or three-quarters
-     * of a minute.
+     * sans decimal point. For example, if the field is specified as
+     * minuteOfHour and the time is 12:30:45, the value printed is 75. A
+     * decimal point is implied, so the fraction is 0.75, or three-quarters of
+     * a minute.
      *
+     * @param field field should operate in UTC or be time zone agnostic
      * @param minDigits minumum number of digits to print.
      * @param maxDigits maximum number of digits to print or parse.
-     * @param rangeInMillis range of values in fraction
+     * @throws IllegalArgumentException if field's duration is not precise
      */
-    public DateTimeFormatterBuilder appendFraction(int minDigits, int maxDigits,
-                                                   int rangeInMillis)
-    {
+    public DateTimeFormatterBuilder appendFraction(
+            DateTimeField field, int minDigits, int maxDigits) {
+        if (field.getDurationField().isPrecise() == false) {
+            throw new IllegalArgumentException("Field duration must be precise");
+        }
         if (maxDigits < minDigits) {
             maxDigits = minDigits;
         }
         if (minDigits < 0 || maxDigits <= 0) {
             throw new IllegalArgumentException();
         }
-        return append0(new Fraction(iChrono, minDigits, maxDigits, rangeInMillis));
+        return append0(new Fraction(iChrono, field, minDigits, maxDigits));
     }
 
     /**
      * @param minDigits minumum number of digits to print
      * @param maxDigits maximum number of digits to print or parse
      */
-    public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {
-        return appendFraction(minDigits, maxDigits, DateTimeConstants.MILLIS_PER_SECOND);
+    public DateTimeFormatterBuilder appendFractionOfSecond(final int minDigits, final int maxDigits) {
+        return appendFraction(iChronoUTC.secondOfDay(), minDigits, maxDigits);
     }
 
     /**
      * @param minDigits minumum number of digits to print
      * @param maxDigits maximum number of digits to print or parse
      */
-    public DateTimeFormatterBuilder appendFractionOfMinute(int minDigits, int maxDigits) {
-        return appendFraction(minDigits, maxDigits, DateTimeConstants.MILLIS_PER_MINUTE);
+    public DateTimeFormatterBuilder appendFractionOfMinute(final int minDigits, final int maxDigits) {
+        return appendFraction(iChronoUTC.minuteOfDay(), minDigits, maxDigits);
     }
 
     /**
      * @param minDigits minumum number of digits to print
      * @param maxDigits maximum number of digits to print or parse
      */
-    public DateTimeFormatterBuilder appendFractionOfHour(int minDigits, int maxDigits) {
-        return appendFraction(minDigits, maxDigits, DateTimeConstants.MILLIS_PER_HOUR);
+    public DateTimeFormatterBuilder appendFractionOfHour(final int minDigits, final int maxDigits) {
+        return appendFraction(iChronoUTC.hourOfDay(), minDigits, maxDigits);
     }
 
     /**
      * @param minDigits minumum number of digits to print
      * @param maxDigits maximum number of digits to print or parse
      */
-    public DateTimeFormatterBuilder appendFractionOfDay(int minDigits, int maxDigits) {
-        return appendFraction
-            (minDigits, maxDigits, DateTimeConstants.MILLIS_PER_DAY);
+    public DateTimeFormatterBuilder appendFractionOfDay(final int minDigits, final int maxDigits) {
+        return appendFraction(iChronoUTC.dayOfYear(), minDigits, maxDigits);
     }
 
     /**
@@ -573,7 +535,7 @@ public DateTimeFormatterBuilder appendFractionOfDay(int minDigits, int maxDigits
      *
      * @param minDigits minumum number of digits to print
      */
-    public DateTimeFormatterBuilder appendMillisOfSecond(int minDigits) {
+    public DateTimeFormatterBuilder appendMillisOfSecond(final int minDigits) {
         return appendNumeric(iChronoUTC.millisOfSecond(), minDigits, 3);
     }
 
@@ -582,7 +544,7 @@ public DateTimeFormatterBuilder appendMillisOfSecond(int minDigits) {
      *
      * @param minDigits minumum number of digits to print
      */
-    public DateTimeFormatterBuilder appendMillisOfDay(int minDigits) {
+    public DateTimeFormatterBuilder appendMillisOfDay(final int minDigits) {
         return appendNumeric(iChronoUTC.millisOfDay(), minDigits, 8);
     }
 
@@ -591,7 +553,7 @@ public DateTimeFormatterBuilder appendMillisOfDay(int minDigits) {
      *
      * @param minDigits minumum number of digits to print
      */
-    public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {
+    public DateTimeFormatterBuilder appendSecondOfMinute(final int minDigits) {
         return appendNumeric(iChronoUTC.secondOfMinute(), minDigits, 2);
     }
 
@@ -600,7 +562,7 @@ public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {
      *
      * @param minDigits minumum number of digits to print
      */
-    public DateTimeFormatterBuilder appendSecondOfDay(int minDigits) {
+    public DateTimeFormatterBuilder appendSecondOfDay(final int minDigits) {
         return appendNumeric(iChronoUTC.secondOfDay(), minDigits, 5);
     }
 
@@ -609,7 +571,7 @@ public DateTimeFormatterBuilder appendSecondOfDay(int minDigits) {
      *
      * @param minDigits minumum number of digits to print
      */
-    public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {
+    public DateTimeFormatterBuilder appendMinuteOfHour(final int minDigits) {
         return appendNumeric(iChronoUTC.minuteOfHour(), minDigits, 2);
     }
 
@@ -618,7 +580,7 @@ public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {
      *
      * @param minDigits minumum number of digits to print
      */
-    public DateTimeFormatterBuilder appendMinuteOfDay(int minDigits) {
+    public DateTimeFormatterBuilder appendMinuteOfDay(final int minDigits) {
         return appendNumeric(iChronoUTC.minuteOfDay(), minDigits, 4);
     }
 
@@ -627,7 +589,7 @@ public DateTimeFormatterBuilder appendMinuteOfDay(int minDigits) {
      *
      * @param minDigits minumum number of digits to print
      */
-    public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {
+    public DateTimeFormatterBuilder appendHourOfDay(final int minDigits) {
         return appendNumeric(iChronoUTC.hourOfDay(), minDigits, 2);
     }
 
@@ -636,7 +598,7 @@ public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {
      *
      * @param minDigits minumum number of digits to print
      */
-    public DateTimeFormatterBuilder appendClockhourOfDay(int minDigits) {
+    public DateTimeFormatterBuilder appendClockhourOfDay(final int minDigits) {
         return appendNumeric(iChronoUTC.clockhourOfDay(), minDigits, 2);
     }
 
@@ -645,7 +607,7 @@ public DateTimeFormatterBuilder appendClockhourOfDay(int minDigits) {
      *
      * @param minDigits minumum number of digits to print
      */
-    public DateTimeFormatterBuilder appendHourOfHalfday(int minDigits) {
+    public DateTimeFormatterBuilder appendHourOfHalfday(final int minDigits) {
         return appendNumeric(iChronoUTC.hourOfHalfday(), minDigits, 2);
     }
 
@@ -654,7 +616,7 @@ public DateTimeFormatterBuilder appendHourOfHalfday(int minDigits) {
      *
      * @param minDigits minumum number of digits to print
      */
-    public DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits) {
+    public DateTimeFormatterBuilder appendClockhourOfHalfday(final int minDigits) {
         return appendNumeric(iChronoUTC.clockhourOfHalfday(), minDigits, 2);
     }
 
@@ -663,7 +625,7 @@ public DateTimeFormatterBuilder appendClockhourOfHalfday(int minDigits) {
      *
      * @param minDigits minumum number of digits to print
      */
-    public DateTimeFormatterBuilder appendDayOfWeek(int minDigits) {
+    public DateTimeFormatterBuilder appendDayOfWeek(final int minDigits) {
         return appendNumeric(iChronoUTC.dayOfWeek(), minDigits, 1);
     }
 
@@ -672,7 +634,7 @@ public DateTimeFormatterBuilder appendDayOfWeek(int minDigits) {
      *
      * @param minDigits minumum number of digits to print
      */
-    public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {
+    public DateTimeFormatterBuilder appendDayOfMonth(final int minDigits) {
         return appendNumeric(iChronoUTC.dayOfMonth(), minDigits, 2);
     }
 
@@ -681,7 +643,7 @@ public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {
      *
      * @param minDigits minumum number of digits to print
      */
-    public DateTimeFormatterBuilder appendDayOfYear(int minDigits) {
+    public DateTimeFormatterBuilder appendDayOfYear(final int minDigits) {
         return appendNumeric(iChronoUTC.dayOfYear(), minDigits, 3);
     }
 
@@ -690,7 +652,7 @@ public DateTimeFormatterBuilder appendDayOfYear(int minDigits) {
      *
      * @param minDigits minumum number of digits to print
      */
-    public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) {
+    public DateTimeFormatterBuilder appendWeekOfWeekyear(final int minDigits) {
         return appendNumeric(iChronoUTC.weekOfWeekyear(), minDigits, 2);
     }
 
@@ -701,7 +663,7 @@ public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) {
      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated
      * maximum number of digits to print
      */
-    public DateTimeFormatterBuilder appendWeekyear(int minDigits, int maxDigits) {
+    public DateTimeFormatterBuilder appendWeekyear(final int minDigits, final int maxDigits) {
         return appendNumeric
             (iChronoUTC.weekyear(), minDigits, maxDigits);
     }
@@ -711,7 +673,7 @@ public DateTimeFormatterBuilder appendWeekyear(int minDigits, int maxDigits) {
      *
      * @param minDigits minumum number of digits to print
      */
-    public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {
+    public DateTimeFormatterBuilder appendMonthOfYear(final int minDigits) {
         return appendNumeric(iChronoUTC.monthOfYear(), minDigits, 2);
     }
 
@@ -722,7 +684,7 @@ public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {
      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated
      * maximum number of digits to print
      */
-    public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {
+    public DateTimeFormatterBuilder appendYear(final int minDigits, final int maxDigits) {
         return appendSignedNumeric(iChronoUTC.year(), minDigits, maxDigits);
     }
 
@@ -733,7 +695,7 @@ public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {
      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated
      * maximum number of digits to print
      */
-    public DateTimeFormatterBuilder appendYearOfEra(int minDigits, int maxDigits) {
+    public DateTimeFormatterBuilder appendYearOfEra(final int minDigits, final int maxDigits) {
         return appendNumeric(iChronoUTC.yearOfEra(), minDigits, maxDigits);
     }
 
@@ -744,7 +706,7 @@ public DateTimeFormatterBuilder appendYearOfEra(int minDigits, int maxDigits) {
      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated
      * maximum number of digits to print
      */
-    public DateTimeFormatterBuilder appendYearOfCentury(int minDigits, int maxDigits) {
+    public DateTimeFormatterBuilder appendYearOfCentury(final int minDigits, final int maxDigits) {
         return appendNumeric(iChronoUTC.yearOfCentury(), minDigits, maxDigits);
     }
 
@@ -755,7 +717,7 @@ public DateTimeFormatterBuilder appendYearOfCentury(int minDigits, int maxDigits
      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated
      * maximum number of digits to print
      */
-    public DateTimeFormatterBuilder appendCenturyOfEra(int minDigits, int maxDigits) {
+    public DateTimeFormatterBuilder appendCenturyOfEra(final int minDigits, final int maxDigits) {
         return appendSignedNumeric(iChronoUTC.centuryOfEra(), minDigits, maxDigits);
     }
 
@@ -840,269 +802,13 @@ public DateTimeFormatterBuilder appendTimeZoneShortName() {
      * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction
      * @param maxFields maximum number of fields to print
      */
-    public DateTimeFormatterBuilder appendTimeZoneOffset(String zeroOffsetText,
-                                                         boolean showSeparators,
-                                                         int minFields, int maxFields)
-    {
+    public DateTimeFormatterBuilder appendTimeZoneOffset(
+            final String zeroOffsetText, final boolean showSeparators,
+            final int minFields, final int maxFields) {
         return append0(new TimeZoneOffsetFormatter
                        (iChrono, zeroOffsetText, showSeparators, minFields, maxFields));
     }
 
-    /**
-     * The pattern syntax is compatible with java.text.SimpleDateFormat, but a
-     * few more symbols are also supported.
-     * <p>
-     * To specify the time format use a <em>time pattern</em> string.
-     * In this pattern, all ASCII letters are reserved as pattern letters,
-     * which are defined as the following:
-     * <blockquote>
-     * <pre>
-     * Symbol  Meaning                      Presentation  Examples
-     * ------  -------                      ------------  -------
-     * G       era                          text          AD
-     * C       century of era (&gt;=0)         number        20
-     * Y       year of era (&gt;=0)            year          1996
-     *
-     * x       weekyear                     year          1996
-     * w       week of weekyear             number        27
-     * e       day of week                  number        2
-     * E       day of week                  text          Tuesday; Tue
-     *
-     * y       year                         year          1996
-     * D       day of year                  number        189
-     * M       month of year                month         July; Jul; 07
-     * d       day of month                 number        10
-     *
-     * a       halfday of day               text          PM
-     * K       hour of halfday (0~11)       number        0
-     * h       clockhour of halfday (1~12)  number        12
-     *
-     * H       hour of day (0~23)           number        0
-     * k       clockhour of day (1~24)      number        24
-     * m       minute of hour               number        30
-     * s       second of minute             number        55
-     * S       fraction of second           number        978
-     *
-     * z       time zone                    text          Pacific Standard Time; PST
-     * Z       RFC 822 time zone            text          -0800; -08:00
-     *
-     * '       escape for text              delimiter
-     * ''      single quote                 literal       '
-     * </pre>
-     * </blockquote>
-     * The count of pattern letters determine the format.
-     * <p>
-     * <strong>Text</strong>: If the number of pattern letters is 4 or more,
-     * the full form is used; otherwise a short or abbreviated form is used if
-     * available.
-     * <p>
-     * <strong>Number</strong>: The minimum number of digits. Shorter numbers
-     * are zero-padded to this amount.
-     * <p>
-     * <strong>Year</strong>: Numeric presentation for year and weekyear fields
-     * are handled specially. For example, if the count of 'y' is 2, the year
-     * will be displayed as the zero-based year of the century, which is two
-     * digits.
-     * <p>
-     * <strong>Month</strong>: 3 or over, use text, otherwise use number.
-     * <p>
-     * Any characters in the pattern that are not in the ranges of ['a'..'z']
-     * and ['A'..'Z'] will be treated as quoted text. For instance, characters
-     * like ':', '.', ' ', '#' and '@' will appear in the resulting time text
-     * even they are not embraced within single quotes.
-     */
-    public DateTimeFormatterBuilder appendPattern(String pattern)
-        throws IllegalArgumentException
-    {
-        int length = pattern.length();
-        int[] indexRef = new int[1];
-
-        for (int i=0; i<length; i++) {
-            indexRef[0] = i;
-            String token = parseToken(pattern, indexRef);
-            i = indexRef[0];
-
-            int tokenLen = token.length();
-            if (tokenLen == 0) {
-                break;
-            }
-            char c = token.charAt(0);
-
-            switch (c) {
-            case 'G': // era designator (text)
-                appendEraText();
-                break;
-            case 'C': // century of era (number)
-                appendCenturyOfEra(tokenLen, tokenLen);
-                break;
-            case 'x': // weekyear (number)
-            case 'y': // year (number)
-            case 'Y': // year of era (number)
-                if (tokenLen == 2) {
-                    // Use a new RemainderDateTimeField to ensure that the year
-                    // of century is zero-based.
-                    DateTimeField field;
-                    switch (c) {
-                    case 'x':
-                        field = new RemainderDateTimeField("weekyearOfCentury", iChronoUTC.weekyear(), 100);
-                        break;
-                    case 'y': default:
-                        field = new RemainderDateTimeField("yearOfCentury", iChronoUTC.year(), 100);
-                        break;
-                    case 'Y':
-                        field = new RemainderDateTimeField("yearOfCentury", iChronoUTC.yearOfEra(), 100);
-                        break;
-                    }
-                    appendNumeric(field, 2, 2);
-                } else {
-                    // Try to support long year values.
-                    int maxDigits = 9;
-
-                    // Peek ahead to next token.
-                    if (i + 1 < length) {
-                        indexRef[0]++;
-                        if (isNumericToken(parseToken(pattern, indexRef))) {
-                            // If next token is a number, cannot support long years.
-                            maxDigits = tokenLen;
-                        }
-                        indexRef[0]--;
-                    }
-
-                    switch (c) {
-                    case 'x':
-                        appendWeekyear(tokenLen, maxDigits);
-                        break;
-                    case 'y':
-                        appendYear(tokenLen, maxDigits);
-                        break;
-                    case 'Y':
-                        appendYearOfEra(tokenLen, maxDigits);
-                        break;
-                    }
-                }
-                break;
-            case 'M': // month of year (text and number)
-                if (tokenLen >= 3) {
-                    if (tokenLen >= 4) {
-                        appendMonthOfYearText();
-                    } else {
-                        appendMonthOfYearShortText();
-                    }
-                } else {
-                    appendMonthOfYear(tokenLen);
-                }
-                break;
-            case 'd': // day of month (number)
-                appendDayOfMonth(tokenLen);
-                break;
-            case 'h': // hour of day (number, 1..12)
-                appendClockhourOfHalfday(tokenLen);
-                break;
-            case 'H': // hour of day (number, 0..23)
-                appendHourOfDay(tokenLen);
-                break;
-            case 'm': // minute of hour (number)
-                appendMinuteOfHour(tokenLen);
-                break;
-            case 's': // second of minute (number)
-                appendSecondOfMinute(tokenLen);
-                break;
-            case 'S': // fraction of second (number)
-                appendFractionOfSecond(tokenLen, tokenLen);
-                break;
-            case 'e': // day of week (number)
-                appendDayOfWeek(tokenLen);
-                break;
-            case 'E': // dayOfWeek (text)
-                if (tokenLen >= 4) {
-                    appendDayOfWeekText();
-                } else {
-                    appendDayOfWeekShortText();
-                }
-                break;
-            case 'D': // day of year (number)
-                appendDayOfYear(tokenLen);
-                break;
-            case 'w': // week of weekyear (number)
-                appendWeekOfWeekyear(tokenLen);
-                break;
-            case 'a': // am/pm marker (text)
-                appendHalfdayOfDayText();
-                break;
-            case 'k': // hour of day (1..24)
-                appendClockhourOfDay(tokenLen);
-                break;
-            case 'K': // hour of day (0..11)
-                appendClockhourOfHalfday(tokenLen);
-                break;
-            case 'z': // time zone (text)
-                if (tokenLen >= 4) {
-                    appendTimeZoneName();
-                } else {
-                    appendTimeZoneShortName();
-                }
-                break;
-            case 'Z': // RFC 822 time zone
-                if (tokenLen >= 4) {
-                    appendTimeZoneOffset(null, true, 2, 2);
-                } else {
-                    appendTimeZoneOffset(null, false, 2, 2);
-                }
-                break;
-            case '\'': // literal text
-                String sub = token.substring(1);
-                if (sub.length() == 1) {
-                    appendLiteral(sub.charAt(0));
-                } else {
-                    // Create copy of sub since otherwise the temporary quoted
-                    // string would still be referenced internally.
-                    appendLiteral(new String(sub));
-                }
-                break;
-            default:
-                throw new IllegalArgumentException
-                    ("Illegal pattern component: " + token);
-            }
-        }
-
-        return this;
-    }
-
-    // Returns true if token should be parsed as a numeric field.
-    private boolean isNumericToken(String token) {
-        int tokenLen = token.length();
-        if (tokenLen > 0) {
-            char c = token.charAt(0);
-            switch (c) {
-            case 'c': // century (number)
-            case 'C': // century of era (number)
-            case 'x': // weekyear (number)
-            case 'y': // year (number)
-            case 'Y': // year of era (number)
-            case 'd': // day of month (number)
-            case 'h': // hour of day (number, 1..12)
-            case 'H': // hour of day (number, 0..23)
-            case 'm': // minute of hour (number)
-            case 's': // second of minute (number)
-            case 'S': // fraction of second (number)
-            case 'e': // day of week (number)
-            case 'D': // day of year (number)
-            case 'F': // day of week in month (number)
-            case 'w': // week of year (number)
-            case 'W': // week of month (number)
-            case 'k': // hour of day (1..24)
-            case 'K': // hour of day (0..11)
-                return true;
-            case 'M': // month of year (text and number)
-                if (tokenLen <= 2) {
-                    return true;
-                }
-            }
-        }
-            
-        return false;
-    }
-
     private Object getFormatter() {
         Object f = iFormatter;
 
@@ -1130,7 +836,7 @@ private Object getFormatter() {
         return f;
     }
 
-    private boolean isPrinter(Object f) {
+    private boolean isPrinter(final Object f) {
         if (f instanceof DateTimePrinter) {
             if (f instanceof Composite) {
                 return ((Composite)f).isPrinter();
@@ -1140,7 +846,7 @@ private boolean isPrinter(Object f) {
         return false;
     }
 
-    private boolean isParser(Object f) {
+    private boolean isParser(final Object f) {
         if (f instanceof DateTimeParser) {
             if (f instanceof Composite) {
                 return ((Composite)f).isParser();
@@ -1150,7 +856,7 @@ private boolean isParser(Object f) {
         return false;
     }
 
-    private boolean isFormatter(Object f) {
+    private boolean isFormatter(final Object f) {
         if (f instanceof DateTimeFormatter) {
             if (f instanceof Composite) {
                 return ((Composite)f).isPrinter()
@@ -1171,11 +877,6 @@ private boolean isFormatter(Object f) {
         public Chronology getChronology() {
             return iChrono;
         }
-
-        protected final DateTimeZone getDateTimeZone() {
-            DateTimeZone zone = iChrono.getDateTimeZone();
-            return zone == null ? DateTimeZone.UTC : zone;
-        }
     }
 
     private static class CharacterLiteral extends AbstractFormatter
@@ -1192,17 +893,17 @@ public int estimatePrintedLength() {
             return 1;
         }
 
-        public void printTo(StringBuffer buf, long millisUTC,
-                            DateTimeZone zone, long millisLocal) {
+        public void printTo(StringBuffer buf, long instant,
+                            DateTimeZone zone, long instantLocal) {
             buf.append(iValue);
         }
 
-        public void printTo(Writer out, long millisUTC,
-                            DateTimeZone zone, long millisLocal) throws IOException {
+        public void printTo(Writer out, long instant,
+                            DateTimeZone zone, long instantLocal) throws IOException {
             out.write(iValue);
         }
 
-        public String print(long millisUTC, DateTimeZone zone, long millisLocal) {
+        public String print(long instant, DateTimeZone zone, long instantLocal) {
             return String.valueOf(iValue);
         }
 
@@ -1248,17 +949,17 @@ public int estimatePrintedLength() {
             return iValue.length();
         }
 
-        public void printTo(StringBuffer buf, long millisUTC,
-                            DateTimeZone zone, long millisLocal) {
+        public void printTo(StringBuffer buf, long instant,
+                            DateTimeZone zone, long instantLocal) {
             buf.append(iValue);
         }
 
-        public void printTo(Writer out, long millisUTC,
-                            DateTimeZone zone, long millisLocal) throws IOException {
+        public void printTo(Writer out, long instant,
+                            DateTimeZone zone, long instantLocal) throws IOException {
             out.write(iValue);
         }
 
-        public String print(long millisUTC, DateTimeZone zone, long millisLocal) {
+        public String print(long instant, DateTimeZone zone, long instantLocal) {
             return iValue;
         }
 
@@ -1281,9 +982,9 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
         protected final int iMaxParsedDigits;
         protected final boolean iSigned;
 
-        NumberFormatter(Chronology chrono,
-                        DateTimeField field, int maxParsedDigits,
-                        boolean signed) {
+        NumberFormatter(
+                Chronology chrono, DateTimeField field,
+                int maxParsedDigits, boolean signed) {
             super(chrono);
             iField = field;
             iMaxParsedDigits = maxParsedDigits;
@@ -1351,9 +1052,8 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
     }
 
     private static class UnpaddedNumber extends NumberFormatter {
-        UnpaddedNumber(Chronology chrono,
-                       DateTimeField field, int maxParsedDigits,
-                       boolean signed)
+        UnpaddedNumber(Chronology chrono, DateTimeField field,
+                       int maxParsedDigits, boolean signed)
         {
             super(chrono, field, maxParsedDigits, signed);
         }
@@ -1362,14 +1062,22 @@ public int estimatePrintedLength() {
             return iMaxParsedDigits;
         }
 
-        public void printTo(StringBuffer buf, long millisUTC,
-                            DateTimeZone zone, long millisLocal) {
-            FormatUtils.appendUnpaddedInteger(buf, iField.get(millisLocal));
+        public void printTo(StringBuffer buf, long instant,
+                            DateTimeZone zone, long instantLocal) {
+            try {
+                FormatUtils.appendUnpaddedInteger(buf, iField.get(instantLocal));
+            } catch (RuntimeException e) {
+                buf.append('\ufffd');
+            }
         }
 
-        public void printTo(Writer out, long millisUTC,
-                            DateTimeZone zone, long millisLocal) throws IOException {
-            FormatUtils.writeUnpaddedInteger(out, iField.get(millisLocal));
+        public void printTo(Writer out, long instant,
+                            DateTimeZone zone, long instantLocal) throws IOException {
+            try {
+                FormatUtils.writeUnpaddedInteger(out, iField.get(instantLocal));
+            } catch (RuntimeException e) {
+                out.write('\ufffd');
+            }
         }
     }
 
@@ -1388,16 +1096,28 @@ public int estimatePrintedLength() {
             return iMaxParsedDigits;
         }
 
-        public void printTo(StringBuffer buf, long millisUTC,
-                            DateTimeZone zone, long millisLocal) {
-            FormatUtils.appendPaddedInteger
-                (buf, iField.get(millisLocal), iMinPrintedDigits);
+        public void printTo(StringBuffer buf, long instant,
+                            DateTimeZone zone, long instantLocal) {
+            try {
+                FormatUtils.appendPaddedInteger
+                    (buf, iField.get(instantLocal), iMinPrintedDigits);
+            } catch (RuntimeException e) {
+                for (int i=iMinPrintedDigits; --i>=0; ) {
+                    buf.append('\ufffd');
+                }
+            }
         }
 
-        public void printTo(Writer out, long millisUTC,
-                            DateTimeZone zone, long millisLocal) throws IOException {
-            FormatUtils.writePaddedInteger
-                (out, iField.get(millisLocal), iMinPrintedDigits);
+        public void printTo(Writer out, long instant,
+                            DateTimeZone zone, long instantLocal) throws IOException {
+            try {
+                FormatUtils.writePaddedInteger
+                    (out, iField.get(instantLocal), iMinPrintedDigits);
+            } catch (RuntimeException e) {
+                for (int i=iMinPrintedDigits; --i>=0; ) {
+                    out.write('\ufffd');
+                }
+            }
         }
     }
 
@@ -1408,8 +1128,8 @@ public void printTo(Writer out, long millisUTC,
         private final Locale iLocale;
         private final boolean iShort;
 
-        TextField(Chronology chrono,
-                  DateTimeField field, Locale locale, boolean isShort) {
+        TextField(Chronology chrono, DateTimeField field,
+                  Locale locale, boolean isShort) {
             super(chrono);
             iField = field;
             iLocale = locale;
@@ -1417,28 +1137,40 @@ public void printTo(Writer out, long millisUTC,
         }
 
         public int estimatePrintedLength() {
-            if (iShort) {
-                return iField.getMaximumShortTextLength(iLocale);
-            } else {
-                return iField.getMaximumTextLength(iLocale);
+            try {
+                if (iShort) {
+                    return iField.getMaximumShortTextLength(iLocale);
+                } else {
+                    return iField.getMaximumTextLength(iLocale);
+                }
+            } catch (RuntimeException e) {
+                return 1;
             }
         }
 
-        public void printTo(StringBuffer buf, long millisUTC,
-                            DateTimeZone zone, long millisLocal) {
-            buf.append(print(millisUTC, zone, millisLocal));
+        public void printTo(StringBuffer buf, long instant,
+                            DateTimeZone zone, long instantLocal) {
+            try {
+                buf.append(print(instant, zone, instantLocal));
+            } catch (RuntimeException e) {
+                buf.append('\ufffd');
+            }
         }
     
-        public void printTo(Writer out, long millisUTC,
-                            DateTimeZone zone, long millisLocal) throws IOException {
-            out.write(print(millisUTC, zone, millisLocal));
+        public void printTo(Writer out, long instant,
+                            DateTimeZone zone, long instantLocal) throws IOException {
+            try {
+                out.write(print(instant, zone, instantLocal));
+            } catch (RuntimeException e) {
+                out.write('\ufffd');
+            }
         }
 
-        public final String print(long millisUTC, DateTimeZone zone, long millisLocal) {
+        public final String print(long instant, DateTimeZone zone, long instantLocal) {
             if (iShort) {
-                return iField.getAsShortText(millisLocal, iLocale);
+                return iField.getAsShortText(instantLocal, iLocale);
             } else {
-                return iField.getAsText(millisLocal, iLocale);
+                return iField.getAsText(instantLocal, iLocale);
             }
         }
 
@@ -1473,17 +1205,20 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
     private static class Fraction extends AbstractFormatter
         implements DateTimeFormatter
     {
+        private final DateTimeField iField;
+        private final long iRangeMillis;
         private final int iMinDigits;
         private final int iMaxDigits;
-        private final int iRange;
 
         private final long iScaler;
 
-        private transient DateTimeField iField;
+        private transient DateTimeField iParseField;
 
-        Fraction(Chronology chrono,
-                 int minDigits, int maxDigits, int rangeInMillis) {
+        Fraction(Chronology chrono, DateTimeField field,
+                 int minDigits, int maxDigits) {
             super(chrono);
+            iField = field;
+            iRangeMillis = field.getDurationField().getUnitMillis();
 
             // Limit the precision requirements.
             if (maxDigits > 18) {
@@ -1491,7 +1226,6 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
             }
 
             iMinDigits = minDigits;
-            iRange = rangeInMillis;
 
             long scaler;
             while (true) {
@@ -1516,7 +1250,7 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
                 case 17: scaler = 100000000000000000L; break;
                 case 18: scaler = 1000000000000000000L; break;
                 }
-                if (((rangeInMillis * scaler) / scaler) == rangeInMillis) {
+                if (((iRangeMillis * scaler) / scaler) == iRangeMillis) {
                     break;
                 }
                 // Overflowed: scale down.
@@ -1531,32 +1265,41 @@ public int estimatePrintedLength() {
             return iMaxDigits;
         }
 
-        public void printTo(StringBuffer buf, long millisUTC,
-                            DateTimeZone zone, long millisLocal) {
+        public void printTo(StringBuffer buf, long instant,
+                            DateTimeZone zone, long instantLocal) {
             try {
-                printTo(buf, null, millisLocal);
+                printTo(buf, null, instantLocal);
             } catch (IOException e) {
                 // Not gonna happen.
             }
         }
 
-        public void printTo(Writer out, long millisUTC,
-                            DateTimeZone zone, long millisLocal) throws IOException {
-            printTo(null, out, millisLocal);
+        public void printTo(Writer out, long instant,
+                            DateTimeZone zone, long instantLocal) throws IOException {
+            printTo(null, out, instantLocal);
         }
 
-        private void printTo(StringBuffer buf, Writer out, long millis)
+        private void printTo(StringBuffer buf, Writer out, long instantLocal)
             throws IOException
         {
+            int minDigits = iMinDigits;
+
             long fraction;
-            if (millis >= 0) {
-                fraction = millis % iRange;
-            } else {
-                fraction = iRange - 1 + (millis + 1) % iRange;
+            try {
+                fraction = iField.remainder(instantLocal);
+            } catch (RuntimeException e) {
+                if (buf != null) {
+                    while (--minDigits >= 0) {
+                        buf.append('\ufffd');
+                    }
+                } else {
+                    while (--minDigits >= 0) {
+                        out.write('\ufffd');
+                    }
+                }
+                return;
             }
 
-            int minDigits = iMinDigits;
-
             if (fraction == 0) {
                 if (buf != null) {
                     while (--minDigits >= 0) {
@@ -1571,7 +1314,7 @@ private void printTo(StringBuffer buf, Writer out, long millis)
             }
 
             String str;
-            long scaled = fraction * iScaler / iRange;
+            long scaled = fraction * iScaler / iRangeMillis;
             if ((scaled & 0x7fffffff) == scaled) {
                 str = Integer.toString((int)scaled);
             } else {
@@ -1629,7 +1372,7 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
             int limit = Math.min(iMaxDigits, text.length() - position);
 
             long value = 0;
-            long n = iRange;
+            long n = iRangeMillis;
             int length = 0;
             while (length < limit) {
                 char c = text.charAt(position + length);
@@ -1651,11 +1394,12 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
                 return ~position;
             }
 
-            if (iField == null) {
-                iField = new FractionalDateTimeField("", 1, iRange);
+            if (iParseField == null) {
+                iParseField = new PreciseDateTimeField
+                    ("", MillisDurationField.INSTANCE, iField.getDurationField());
             }
 
-            bucket.saveField(iField, (int)value);
+            bucket.saveField(iParseField, (int)value);
 
             return position + length;
         }
@@ -1699,9 +1443,9 @@ public int estimatePrintedLength() {
             return est;
         }
         
-        public void printTo(StringBuffer buf, long millisUTC,
-                            DateTimeZone zone, long millisLocal) {
-            int offset = (int)(millisLocal - millisUTC);
+        public void printTo(StringBuffer buf, long instant,
+                            DateTimeZone zone, long instantLocal) {
+            int offset = (int)(instantLocal - instant);
 
             if (offset == 0 && iZeroOffsetText != null) {
                 buf.append(iZeroOffsetText);
@@ -1756,9 +1500,9 @@ public void printTo(StringBuffer buf, long millisUTC,
             FormatUtils.appendPaddedInteger(buf, offset, 3);
         }
         
-        public void printTo(Writer out, long millisUTC,
-                            DateTimeZone zone, long millisLocal) throws IOException {
-            int offset = (int)(millisLocal - millisUTC);
+        public void printTo(Writer out, long instant,
+                            DateTimeZone zone, long instantLocal) throws IOException {
+            int offset = (int)(instantLocal - instant);
 
             if (offset == 0 && iZeroOffsetText != null) {
                 out.write(iZeroOffsetText);
@@ -2010,38 +1754,38 @@ public int estimatePrintedLength() {
             return iShortFormat ? 4 : 20;
         }
         
-        public void printTo(StringBuffer buf, long millisUTC,
-                            DateTimeZone zone, long millisLocal) {
+        public void printTo(StringBuffer buf, long instant,
+                            DateTimeZone zone, long instantLocal) {
             if (zone == null) {
                 zone = getDateTimeZone();
             }
             if (iShortFormat) {
-                buf.append(zone.getShortName(millisUTC, this.iLocale));
+                buf.append(zone.getShortName(instant, this.iLocale));
             } else {
-                buf.append(zone.getName(millisUTC, this.iLocale));
+                buf.append(zone.getName(instant, this.iLocale));
             }
         }
         
-        public void printTo(Writer out, long millisUTC,
-                            DateTimeZone zone, long millisLocal) throws IOException {
+        public void printTo(Writer out, long instant,
+                            DateTimeZone zone, long instantLocal) throws IOException {
             if (zone == null) {
                 zone = getDateTimeZone();
             }
             if (iShortFormat) {
-                out.write(zone.getShortName(millisUTC, this.iLocale));
+                out.write(zone.getShortName(instant, this.iLocale));
             } else {
-                out.write(zone.getName(millisUTC, this.iLocale));
+                out.write(zone.getName(instant, this.iLocale));
             }
         }
 
-        public String print(long millisUTC, DateTimeZone zone, long millisLocal) {
+        public String print(long instant, DateTimeZone zone, long instantLocal) {
             if (zone == null) {
                 zone = getDateTimeZone();
             }
             if (iShortFormat) {
-                return zone.getShortName(millisUTC, this.iLocale);
+                return zone.getShortName(instant, this.iLocale);
             } else {
-                return zone.getName(millisUTC, this.iLocale);
+                return zone.getName(instant, this.iLocale);
             }
         }
     }
@@ -2105,8 +1849,8 @@ public int estimatePrintedLength() {
             return iPrintedLengthEstimate;
         }
     
-        public void printTo(StringBuffer buf, long millisUTC,
-                            DateTimeZone zone, long millisLocal) {
+        public void printTo(StringBuffer buf, long instant,
+                            DateTimeZone zone, long instantLocal) {
             DateTimePrinter[] elements = iPrinters;
 
             if (elements == null) {
@@ -2115,12 +1859,12 @@ public void printTo(StringBuffer buf, long millisUTC,
 
             int len = elements.length;
             for (int i=0; i<len; i++) {
-                elements[i].printTo(buf, millisUTC, zone, millisLocal);
+                elements[i].printTo(buf, instant, zone, instantLocal);
             }
         }
 
-        public void printTo(Writer out, long millisUTC,
-                            DateTimeZone zone, long millisLocal) throws IOException {
+        public void printTo(Writer out, long instant,
+                            DateTimeZone zone, long instantLocal) throws IOException {
             DateTimePrinter[] elements = iPrinters;
 
             if (elements == null) {
@@ -2129,7 +1873,7 @@ public void printTo(Writer out, long millisUTC,
 
             int len = elements.length;
             for (int i=0; i<len; i++) {
-                elements[i].printTo(out, millisUTC, zone, millisLocal);
+                elements[i].printTo(out, instant, zone, instantLocal);
             }
         }
 
diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeParser.java b/JodaTime/src/java/org/joda/time/format/DateTimeParser.java
index 2c87f4045..64b00c243 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeParser.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeParser.java
@@ -53,15 +53,14 @@
  */
 package org.joda.time.format;
 
-import java.text.ParseException;
-
 import org.joda.time.Chronology;
 import org.joda.time.DateTime;
 import org.joda.time.MutableDateTime;
+import org.joda.time.ReadableInstant;
 import org.joda.time.ReadWritableInstant;
 
 /**
- * Converts sequences of human-readable characters into datetimes.
+ * Defines an interface for parsing textual representations of datetimes.
  *
  * @author Brian S O'Neill
  * @see DateTimeFormatter
@@ -72,15 +71,20 @@
 
     /**
      * Returns the Chronology being used by the parser, or null if none.
+     * 
+     * @return the chronology in use, may be null if none
      */
     Chronology getChronology();
 
     /**
      * Returns the expected maximum number of characters consumed. The actual
      * amount should rarely exceed this estimate.
+     * 
+     * @return the estimated length
      */
     int estimateParsedLength();
 
+    //-----------------------------------------------------------------------
     /**
      * Parse an element from the given text, saving any fields into the given
      * DateTimeParserBucket. If the parse succeeds, the return value is the new
@@ -91,11 +95,11 @@
      * where the parse failed, apply the one's complement operator (~) on the
      * return value.
      *
-     * @param bucket field are saved into this
-     * @param text the text to parse
-     * @param position position to start parsing from
-     * @return new position, if negative, parse failed. Apply complement
-     * operator (~) to get position of failure
+     * @param bucket  field are saved into this
+     * @param text  the text to parse
+     * @param position  position to start parsing from
+     * @return new position, negative value means parse failed -
+     *  apply complement operator (~) to get position of failure
      * @throws IllegalArgumentException if any field is out of range
      */
     int parseInto(DateTimeParserBucket bucket, String text, int position);
@@ -110,53 +114,78 @@
      * modified. To determine the position where the parse failed, apply the
      * one's complement operator (~) on the return value.
      *
-     * @param instant an instant that will be modified
-     * @param text text to parse
-     * @param position position to start parsing from
-     * @return new position, if negative, parse failed. Apply complement
-     * operator (~) to get position of failure
+     * @param instant  an instant that will be modified
+     * @param text  text to parse
+     * @param position  position to start parsing from
+     * @return new position, negative value means parse failed -
+     *  apply complement operator (~) to get position of failure
      * @throws IllegalArgumentException if any field is out of range
      */
     int parseInto(ReadWritableInstant instant, String text, int position);
 
+    //-----------------------------------------------------------------------
     /**
      * Parses a datetime from the given text, returning the number of
      * milliseconds since the epoch, 1970-01-01T00:00:00Z.
      *
-     * @param text text to parse
+     * @param text  text to parse
      * @return parsed value expressed in milliseconds since the epoch
-     * @throws ParseException if any field is out of range
+     * @throws IllegalArgumentException if the text to parse is invalid
      */
-    long parseMillis(String text) throws ParseException;
+    long parseMillis(String text);
 
     /**
      * Parses a datetime from the given text, at the given position, returning
-     * the number of milliseconds since the epoch, 1970-01-01T00:00:00Z. An
-     * initial millisecond value is passed in, which is relative to the epoch,
+     * the number of milliseconds since the epoch, 1970-01-01T00:00:00Z.
+     * An initial millisecond value is passed in, which is relative to the epoch,
      * local time.
      *
-     * @param text text to parse
-     * @param millis initial value of millis, relative to the epoch, local time
+     * @param text  text to parse
+     * @param instantLocal  initial value of instant, relative to the epoch, local time
      * @return parsed value expressed in milliseconds since the epoch, UTC
-     * @throws ParseException if any field is out of range
+     * @throws IllegalArgumentException if the text to parse is invalid
      */
-    long parseMillis(String text, long millis) throws ParseException;
+    long parseMillis(String text, long instantLocal);
 
+    //-----------------------------------------------------------------------
     /**
      * Parses a datetime from the given text, returning a new DateTime.
      *
-     * @param text text to parse
+     * @param text  text to parse
+     * @return parsed value in a DateTime object
+     * @throws IllegalArgumentException if the text to parse is invalid
+     */
+    DateTime parseDateTime(String text);
+
+    /**
+     * Parses a datetime from the given text, returning a new DateTime, using
+     * the given instant to supply field values that were not parsed.
+     *
+     * @param text  text to parse
+     * @param instant  initial value of DateTime
      * @return parsed value in a DateTime object
-     * @throws ParseException if any field is out of range
+     * @throws IllegalArgumentException if the text to parse is invalid
      */
-    DateTime parseDateTime(String text) throws ParseException;
+    DateTime parseDateTime(String text, ReadableInstant instant);
 
     /**
      * Parses a datetime from the given text, returning a new MutableDateTime.
      *
-     * @param text text to parse
-     * @return parsed value in a MutabkeDateTime object
-     * @throws ParseException if any field is out of range
+     * @param text  text to parse
+     * @return parsed value in a MutableDateTime object
+     * @throws IllegalArgumentException if the text to parse is invalid
+     */
+    MutableDateTime parseMutableDateTime(String text);
+
+    /**
+     * Parses a datetime from the given text, returning a new MutableDateTime,
+     * using the given instant to supply field values that were not parsed.
+     *
+     * @param text  text to parse
+     * @param instant  initial value of DateTime
+     * @return parsed value in a MutableDateTime object
+     * @throws IllegalArgumentException if the text to parse is invalid
      */
-    MutableDateTime parseMutableDateTime(String text) throws ParseException;
+    MutableDateTime parseMutableDateTime(String text, ReadableInstant instant);
+    
 }
diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java b/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java
index 8ba657ace..7cc37ab98 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java
@@ -63,6 +63,8 @@
 /**
  * Allows fields to be saved in any order, but physically set in a consistent
  * order.
+ * <p>
+ * DateTimeParserBucket is mutable and not thread-safe.
  *
  * @author Brian S O'Neill
  */
@@ -77,10 +79,10 @@
     ArrayList iSavedFields = new ArrayList();
 
     /**
-     * @param millis the initial millis from 1970-01-01T00:00:00, local time
+     * @param instantLocal the initial millis from 1970-01-01T00:00:00, local time
      */
-    public DateTimeParserBucket(long millis) {
-        iMillis = millis;
+    public DateTimeParserBucket(long instantLocal) {
+        iMillis = instantLocal;
     }
 
     /**
@@ -106,7 +108,7 @@ public void setDateTimeZone(DateTimeZone zone) {
      * Returns the time zone offset used by computeMillis, unless
      * getDateTimeZone doesn't return null.
      */
-    public long getOffset() {
+    public int getOffset() {
         return iOffset;
     }
 
@@ -226,28 +228,35 @@ long set(long millis) {
         }
 
         /**
-         * The field with the larger range is ordered first. If the ranges
-         * match, then the field with the larger unit is ordered first. This
-         * ordering gives preference to more precise fields. For example,
-         * dayOfYear is chosen over monthOfYear.
+         * The field with the larger range is ordered first, where null is
+         * considered infinite. If the ranges match, then the field with the
+         * larger unit is ordered first. This ordering casues "smaller" fields
+         * to be set last, and thus their value sticks. For example, dayOfMonth
+         * takes precedence over monthOfYear, and dayOfWeek takes precedence
+         * over dayOfMonth.
          */
         public int compareTo(Object obj) {
             DateTimeField other = ((SavedField)obj).iField;
-            long a = iField.getRangeMillis();
-            long b = other.getRangeMillis();
-            if (a > b) {
-                return -1;
-            } else if (a < b) {
-                return 1;
+            int result = compareReverse
+                (iField.getRangeDurationField(), other.getRangeDurationField());
+            if (result != 0) {
+                return result;
             }
-            a = iField.getUnitMillis();
-            b = other.getUnitMillis();
-            if (a > b) {
+            return compareReverse
+                (iField.getDurationField(), other.getDurationField());
+        }
+
+        private int compareReverse(Comparable a, Comparable b) {
+            if (a == null) {
+                if (b == null) {
+                    return 0;
+                }
                 return -1;
-            } else if (a < b) {
+            }
+            if (b == null) {
                 return 1;
             }
-            return 0;
+            return -a.compareTo(b);
         }
     }
 
diff --git a/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java b/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java
index 5d731e512..114a03750 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java
@@ -61,7 +61,7 @@
 import org.joda.time.ReadableInstant;
 
 /**
- * Converts datetimes into a sequence of human-readable characters.
+ * Defines an interface for creating textual representations of datetimes.
  *
  * @author Brian S O'Neill
  * @see DateTimeFormatter
@@ -72,21 +72,26 @@
     
     /**
      * Returns the Chronology being used by the printer, or null if none.
+     * 
+     * @return the chronology in use, may be null if none
      */
     Chronology getChronology();
 
     /**
      * Returns the expected maximum number of characters produced. The actual
      * amount should rarely exceed this estimate.
+     * 
+     * @return the estimated length
      */
     int estimatePrintedLength();
 
+    //-----------------------------------------------------------------------
     /**
      * Prints a ReadableInstant, attempting to use the DateTimeZone supplied by
      * the instant.
      *
-     * @param buf formatted instant is appended to this buffer
-     * @param instant instant to format
+     * @param buf  formatted instant is appended to this buffer
+     * @param instant  instant to format
      */
     void printTo(StringBuffer buf, ReadableInstant instant);
 
@@ -94,86 +99,82 @@
      * Prints a ReadableInstant, attempting to use the DateTimeZone supplied by
      * the instant.
      *
-     * @param out formatted instant is written out
-     * @param instant instant to format
+     * @param out  formatted instant is written out
+     * @param instant  instant to format
      */
     void printTo(Writer out, ReadableInstant instant) throws IOException;
 
+    //-----------------------------------------------------------------------
     /**
      * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
      * using the formatter's DateTimeZone.
      *
-     * @param buf formatted instant is appended to this buffer
-     * @param millisUTC millis since 1970-01-01T00:00:00Z
+     * @param buf  formatted instant is appended to this buffer
+     * @param instant  millis since 1970-01-01T00:00:00Z
      */
-    void printTo(StringBuffer buf, long millisUTC);
+    void printTo(StringBuffer buf, long instant);
 
     /**
      * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
      * using the formatter's DateTimeZone.
      *
-     * @param out formatted instant is written out
-     * @param millisUTC millis since 1970-01-01T00:00:00Z
+     * @param out  formatted instant is written out
+     * @param instant  millis since 1970-01-01T00:00:00Z
      */
-    void printTo(Writer out, long millisUTC) throws IOException;
+    void printTo(Writer out, long instant) throws IOException;
 
+    //-----------------------------------------------------------------------
     /**
      * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
      * attempting to use the given DateTimeZone.
      *
-     * @param buf formatted instant is appended to this buffer
-     * @param millisUTC millis since 1970-01-01T00:00:00Z
-     * @param zone DateTimeZone to use, overriding the formatter's own zone if
-     * not null
+     * @param buf  formatted instant is appended to this buffer
+     * @param instant  millis since 1970-01-01T00:00:00Z
+     * @param zone  DateTimeZone to use, overriding the formatter's own zone if not null
      */
-    void printTo(StringBuffer buf, long millisUTC, DateTimeZone zone);
+    void printTo(StringBuffer buf, long instant, DateTimeZone zone);
 
     /**
      * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
      * attempting to use the given DateTimeZone.
      *
-     * @param out formatted instant is written out
-     * @param millisUTC millis since 1970-01-01T00:00:00Z
-     * @param zone DateTimeZone to use, overriding the formatter's own zone if
-     * not null
+     * @param out  formatted instant is written out
+     * @param instant  millis since 1970-01-01T00:00:00Z
+     * @param zone  DateTimeZone to use, overriding the formatter's own zone if not null
      */
-    void printTo(Writer out, long millisUTC, DateTimeZone zone) throws IOException;
+    void printTo(Writer out, long instant, DateTimeZone zone) throws IOException;
 
+    //-----------------------------------------------------------------------
     /**
      * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
      * attempting to use the given DateTimeZone.
      *
-     * @param buf formatted instant is appended to this buffer
-     * @param millisUTC millis since 1970-01-01T00:00:00Z, used by time zone
-     * printers
-     * @param zone DateTimeZone to use, overriding the formatter's own zone if
-     * not null
-     * @param millisLocal pre-calculated millis since 1970-01-01T00:00:00,
-     * local time
+     * @param buf  formatted instant is appended to this buffer
+     * @param instant  millis since 1970-01-01T00:00:00Z, used by time zone printers
+     * @param zone  DateTimeZone to use, overriding the formatter's own zone if not null
+     * @param instantLocal  pre-calculated millis since 1970-01-01T00:00:00, local time
      */
-    void printTo(StringBuffer buf, long millisUTC,
-                 DateTimeZone zone, long millisLocal);
+    void printTo(StringBuffer buf, long instant,
+                 DateTimeZone zone, long instantLocal);
 
     /**
      * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
      * attempting to use the given DateTimeZone.
      *
-     * @param out formatted instant is written out
-     * @param millisUTC millis since 1970-01-01T00:00:00Z, used by time zone
-     * printers
-     * @param zone DateTimeZone to use, overriding the formatter's own zone if
-     * not null
-     * @param millisLocal pre-calculated millis since 1970-01-01T00:00:00,
-     * local time
+     * @param out  formatted instant is written out
+     * @param instant millis  since 1970-01-01T00:00:00Z, used by time zone printers
+     * @param zone  DateTimeZone to use, overriding the formatter's own zone if not null
+     * @param instantLocal  pre-calculated millis since 1970-01-01T00:00:00, local time
      */
-    void printTo(Writer out, long millisUTC,
-                 DateTimeZone zone, long millisLocal) throws IOException;
+    void printTo(Writer out, long instant,
+                 DateTimeZone zone, long instantLocal) throws IOException;
 
+    //-----------------------------------------------------------------------
     /**
      * Prints a ReadableInstant to a new String, attempting to use the
      * DateTimeZone supplied by the instant.
      *
-     * @param instant instant to format
+     * @param instant  instant to format
      * @return the printed result
      */
     String print(ReadableInstant instant);
@@ -182,32 +183,30 @@ void printTo(Writer out, long millisUTC,
      * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
      * using the formatter's DateTimeZone.
      *
-     * @param millisUTC millis since 1970-01-01T00:00:00Z
+     * @param instant  millis since 1970-01-01T00:00:00Z
      * @return the printed result
      */
-    String print(long millisUTC);
+    String print(long instant);
 
     /**
      * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
      * attempting to use the given DateTimeZone.
      *
-     * @param millisUTC millis since 1970-01-01T00:00:00Z
-     * @param zone DateTimeZone to use, overriding the formatter's own zone if
-     * not null
+     * @param instant  millis since 1970-01-01T00:00:00Z
+     * @param zone  DateTimeZone to use, overriding the formatter's own zone if not null
      * @return the printed result
      */
-    String print(long millisUTC, DateTimeZone zone);
+    String print(long instant, DateTimeZone zone);
 
     /**
      * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
      * attempting to use the given DateTimeZone.
      *
-     * @param millisUTC millis since 1970-01-01T00:00:00Z
-     * @param zone DateTimeZone to use, overriding the formatter's own zone if
-     * not null
-     * @param millisLocal pre-calculated millis since 1970-01-01T00:00:00,
-     * local time
+     * @param instant  millis since 1970-01-01T00:00:00Z
+     * @param zone  DateTimeZone to use, overriding the formatter's own zone if not null
+     * @param instantLocal  pre-calculated millis since 1970-01-01T00:00:00, local time
      * @return the printed result
      */
-    String print(long millisUTC, DateTimeZone zone, long millisLocal);
+    String print(long instant, DateTimeZone zone, long instantLocal);
+    
 }
diff --git a/JodaTime/src/java/org/joda/time/format/DurationFieldAffix.java b/JodaTime/src/java/org/joda/time/format/DurationFieldAffix.java
new file mode 100644
index 000000000..85ca78d21
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/format/DurationFieldAffix.java
@@ -0,0 +1,70 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.format;
+
+import java.io.IOException;
+import java.io.Writer;
+
+/**
+ * Defines a formatted field's prefix or suffix text.
+ *
+ * @author Brian S O'Neill
+ */
+public interface DurationFieldAffix {
+    int calculatePrintedLength(int value);
+
+    void printTo(StringBuffer buf, int value);
+
+    void printTo(Writer out, int value) throws IOException;
+}
diff --git a/JodaTime/src/java/org/joda/time/format/DurationFormatter.java b/JodaTime/src/java/org/joda/time/format/DurationFormatter.java
new file mode 100644
index 000000000..9f0fe5ee6
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/format/DurationFormatter.java
@@ -0,0 +1,67 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.format;
+
+/**
+ * Combined interface for printing and parsing.
+ * <p>
+ * See each extended interface for details of the methods.
+ *
+ * @author Brian S O'Neill
+ * @author Stephen Colebourne
+ * @since 1.0
+ */
+public interface DurationFormatter extends DurationPrinter, DurationParser {
+
+}
diff --git a/JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java b/JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java
new file mode 100644
index 000000000..f87647b3f
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java
@@ -0,0 +1,957 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.format;
+
+import java.io.IOException;
+import java.io.Writer;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.joda.time.DurationField;
+import org.joda.time.DurationType;
+import org.joda.time.ReadableDuration;
+
+/**
+ * 
+ *
+ * @author Brian S O'Neill
+ */
+public class DurationFormatterBuilder {
+    private static final int PRINT_ZERO_NEVER = 0;
+    private static final int PRINT_ZERO_MAYBE = 1;
+    private static final int PRINT_ZERO_ALWAYS = 2;
+
+    private int iMinPrintedDigits = 1;
+    private int iPrintZeroSetting;
+
+    private DurationFieldAffix iPrefix;
+
+    // List of separate DurationFormatters.
+    private List iFormatters;
+
+    public DurationFormatterBuilder() {
+       iFormatters = new ArrayList();
+    }
+
+    /**
+     * Converts to a DurationPrinter that prints using all the appended
+     * elements. Subsequent changes to this builder do not affect the returned
+     * printer.
+     */
+    public DurationPrinter toPrinter() {
+        return toPrinter(iFormatters);
+    }
+
+    /**
+     * Converts to a DurationPrinter that prints using all the appended
+     * elements. Subsequent changes to this builder do not affect the returned
+     * printer.
+     *
+     * @param alternate alternate text to print when printer emits no fields
+     */
+    public DurationPrinter toPrinter(String alternate) {
+        DurationPrinter printer = toPrinter();
+        if (alternate != null) {
+            return new AlternateSelector(printer, new Literal(alternate));
+        }
+        return printer;
+    }
+
+    /**
+     * Converts to a DurationPrinter that prints using all the appended
+     * elements. Subsequent changes to this builder do not affect the returned
+     * printer.
+     *
+     * @param alternate alternate printer to use when printer emits no fields
+     */
+    public DurationPrinter toPrinter(DurationPrinter alternate) {
+        DurationPrinter printer = toPrinter();
+        if (alternate != null) {
+            return new AlternateSelector(printer, alternate);
+        }
+        return printer;
+    }
+
+    private static DurationPrinter toPrinter(List formatters) {
+        int size = formatters.size();
+        if (size >= 2 && formatters.get(1) instanceof Separator) {
+            DurationPrinter before = (DurationPrinter) formatters.get(0);
+            if (size == 2) {
+                // Separator at the end would never print anything.
+                return before;
+            }
+            return ((Separator) formatters.get(1)).finish
+                (before, toPrinter(formatters.subList(2, size)));
+        }
+        return createComposite(formatters);
+    }
+
+    /**
+     * Depending on what rules are applied, a parser may not be buildable due
+     * to ambiguities that may arise during parsing.
+     */
+    /*
+    public boolean canBuildParser() {
+        // TODO
+        return true;
+    }
+    */
+
+    /**
+     * Clears out all the appended elements, allowing this builder to be
+     * reused.
+     */
+    public void clear() {
+        iMinPrintedDigits = 1;
+        iPrintZeroSetting = PRINT_ZERO_NEVER;
+        iPrefix = null;
+        iFormatters.clear();
+    }
+
+    /**
+     * Appends just a printer. With no matching parser, a parser cannot be
+     * built from this DurationFormatterBuilder.
+     */
+    public DurationFormatterBuilder append(DurationPrinter printer)
+        throws IllegalArgumentException
+    {
+        if (printer == null) {
+            throw new IllegalArgumentException("No printer supplied");
+        }
+        clearPrefix();
+        iFormatters.add(printer);
+        return this;
+    }
+
+    /**
+     * Instructs the printer to emit specific text, and the parser to expect
+     * it. The parser is case-insensitive.
+     *
+     * @throws IllegalArgumentException if text is null
+     */
+    public DurationFormatterBuilder appendLiteral(String text) {
+        if (text == null) {
+            throw new IllegalArgumentException("Literal must not be null");
+        }
+        clearPrefix();
+        iFormatters.add(new Literal(text));
+        return this;
+    }
+
+    /**
+     * Set the minimum digits printed for the next and following appended
+     * fields. By default, the minimum digits printed is one. If the field value
+     * is zero, it is not printed unless a printZero rule is applied.
+     */
+    public DurationFormatterBuilder minimumPrintedDigits(int minDigits) {
+        iMinPrintedDigits = minDigits;
+        return this;
+    }
+
+    /**
+     * Set the maximum digits parsed for the next and following appended
+     * fields. By default, the maximum digits parsed is ten.
+     */
+    public DurationFormatterBuilder maximumParsedDigits(int maxDigits) {
+        // TODO
+        return this;
+    }
+
+    /**
+     * Reject signed values when parsing the next and following appended fields.
+     */
+    public DurationFormatterBuilder rejectSignedValues() {
+        // TODO
+        return this;
+    }
+
+    /**
+     * Never print zero values for the next and following appended fields. This
+     * is the default setting.
+     */
+    public DurationFormatterBuilder printZeroNever() {
+        iPrintZeroSetting = PRINT_ZERO_NEVER;
+        return this;
+    }
+
+    /**
+     * Print zero values for the next and following appened fields only if the
+     * duration supports it.
+     */
+    public DurationFormatterBuilder printZeroMaybe() {
+        iPrintZeroSetting = PRINT_ZERO_MAYBE;
+        return this;
+    }
+
+    /**
+     * Always print zero values for the next and following appended fields,
+     * even if the duration doesn't support it.
+     */
+    public DurationFormatterBuilder printZeroAlways() {
+        iPrintZeroSetting = PRINT_ZERO_ALWAYS;
+        return this;
+    }
+
+    /**
+     * Append a field prefix which applies only to the next appended field. If
+     * the field is not printed, neither is the prefix.
+     *
+     * @param text text to print before field only if field is printed
+     * @see #appendSuffix
+     */
+    public DurationFormatterBuilder appendPrefix(String text) {
+        if (text == null) {
+            throw new IllegalArgumentException();
+        }
+        return appendPrefix(new SingularAffix(text));
+    }
+
+    /**
+     * Append a field prefix which applies only to the next appended field. If
+     * the field is not printed, neither is the prefix.
+     * <p>
+     * During parsing, the singular and plural versions are accepted whether
+     * or not the actual value matches plurality.
+     *
+     * @param singularText text to print if field value is one
+     * @param pluralText text to print if field value is not one
+     * @see #appendSuffix
+     */
+    public DurationFormatterBuilder appendPrefix(String singularText,
+                                                 String pluralText) {
+        if (singularText == null || pluralText == null) {
+            throw new IllegalArgumentException();
+        }
+        return appendPrefix(new PluralAffix(singularText, pluralText));
+    }
+
+    /**
+     * Append a field prefix which applies only to the next appended field. If
+     * the field is not printed, neither is the prefix.
+     *
+     * @param prefix custom prefix
+     * @see #appendSuffix
+     */
+    public DurationFormatterBuilder appendPrefix(DurationFieldAffix prefix) {
+        if (prefix == null) {
+            throw new IllegalArgumentException();
+        }
+        if (iPrefix != null) {
+            prefix = new CompositeAffix(iPrefix, prefix);
+        }
+        iPrefix = prefix;
+        return this;
+    }
+
+    /**
+     * Instruct the printer to emit a numeric years field, if supported.
+     */
+    public DurationFormatterBuilder appendYears() {
+        appendField(1);
+        return this;
+    }
+
+    /**
+     * Instruct the printer to emit a numeric years field, if supported.
+     */
+    public DurationFormatterBuilder appendMonths() {
+        appendField(2);
+        return this;
+    }
+
+    /**
+     * Instruct the printer to emit a numeric weeks field, if supported.
+     */
+    public DurationFormatterBuilder appendWeeks() {
+        appendField(3);
+        return this;
+    }
+
+    /**
+     * Instruct the printer to emit a numeric days field, if supported.
+     */
+    public DurationFormatterBuilder appendDays() {
+        appendField(4);
+        return this;
+    }
+
+    /**
+     * Instruct the printer to emit a numeric hours field, if supported.
+     */
+    public DurationFormatterBuilder appendHours() {
+        appendField(5);
+        return this;
+    }
+
+    /**
+     * Instruct the printer to emit a numeric minutes field, if supported.
+     */
+    public DurationFormatterBuilder appendMinutes() {
+        appendField(6);
+        return this;
+    }
+
+    /**
+     * Instruct the printer to emit a numeric seconds field, if supported.
+     */
+    public DurationFormatterBuilder appendSeconds() {
+        appendField(7);
+        return this;
+    }
+
+    /**
+     * Instruct the printer to emit a numeric millis field, if supported.
+     */
+    public DurationFormatterBuilder appendMillis() {
+        appendField(8);
+        return this;
+    }
+
+    private void appendField(int type) {
+        iFormatters.add(new FieldFormatter(iMinPrintedDigits, iPrintZeroSetting,
+                                           type, iPrefix, null));
+        iPrefix = null;
+    }
+
+    /**
+     * Append a field suffix which applies only to the last appended field. If
+     * the field is not printed, neither is the suffix.
+     *
+     * @param text text to print after field only if field is printed
+     * @throws IllegalStateException if no field exists to append to
+     * @see #appendPrefix
+     */
+    public DurationFormatterBuilder appendSuffix(String text) {
+        if (text == null) {
+            throw new IllegalArgumentException();
+        }
+        return appendSuffix(new SingularAffix(text));
+    }
+
+    /**
+     * Append a field suffix which applies only to the last appended field. If
+     * the field is not printed, neither is the suffix.
+     * <p>
+     * During parsing, the singular and plural versions are accepted whether or
+     * not the actual value matches plurality.
+     *
+     * @param singularText text to print if field value is one
+     * @param pluralText text to print if field value is not one
+     * @throws IllegalStateException if no field exists to append to
+     * @see #appendPrefix
+     */
+    public DurationFormatterBuilder appendSuffix(String singularText,
+                                                 String pluralText) {
+        if (singularText == null || pluralText == null) {
+            throw new IllegalArgumentException();
+        }
+        return appendSuffix(new PluralAffix(singularText, pluralText));
+    }
+
+    /**
+     * Append a field suffix which applies only to the last appended field. If
+     * the field is not printed, neither is the suffix.
+     *
+     * @param suffix custom suffix
+     * @throws IllegalStateException if no field exists to append to
+     * @see #appendPrefix
+     */
+    public DurationFormatterBuilder appendSuffix(DurationFieldAffix suffix) {
+        Object f = null;
+        if (iFormatters.size() > 0) {
+            f = iFormatters.get(iFormatters.size() - 1);
+        }
+        if (!(f instanceof FieldFormatter)) {
+            throw new IllegalStateException("No field to apply suffix to");
+        }
+        clearPrefix();
+        f = new FieldFormatter((FieldFormatter) f, suffix);
+        iFormatters.set(iFormatters.size() - 1, f);
+        return this;
+    }
+
+    /**
+     * During printing, separators are only printed if fields are printed
+     * following the latest one.
+     * <p>
+     * Note: appending a separator discontinues any further work on the latest
+     * appended field.
+     */
+    public DurationFormatterBuilder appendSeparator(String text) {
+        return appendSeparator(text, text);
+    }
+
+    /**
+     * During printing, separators are only printed if fields are printed
+     * following the latest one.
+     * <p>
+     * During parsing, either text parameter is accepted, and is
+     * case-insensitive.
+     * <p>
+     * Note: appending a separator discontinues any further work on the latest
+     * appended field.
+     *
+     * @param finalText alternate used if this is the final separator
+     * printed
+     */
+    public DurationFormatterBuilder appendSeparator(String text,
+                                                    String finalText) {
+        if (text == null || finalText == null) {
+            throw new IllegalArgumentException();
+        }
+
+        clearPrefix();
+
+        List formatters = iFormatters;
+
+        if (formatters.size() == 0) {
+            // Separator at the beginning would never print anything.
+            return this;
+        }
+
+        // Create a composite over all the fields between separators.
+        int i;
+        Separator lastSeparator = null;
+        for (i=formatters.size(); --i>=0; ) {
+            if (formatters.get(i) instanceof Separator) {
+                lastSeparator = (Separator) formatters.get(i);
+                formatters = formatters.subList(i + 1, formatters.size());
+                break;
+            }
+        }
+
+        if (lastSeparator != null && formatters.size() == 0) {
+            // Merge two adjacent separators together.
+            iFormatters.set(i, lastSeparator.merge(text, finalText));
+        } else {
+            DurationPrinter composite = createComposite(formatters);
+            formatters.clear();
+            formatters.add(composite);
+            
+            // The separator will be finished later.
+            formatters.add(new Separator(text, finalText));
+        }
+            
+        return this;
+    }
+
+    private void clearPrefix() throws IllegalStateException {
+        if (iPrefix != null) {
+            throw new IllegalStateException("Prefix not followed by field");
+        }
+        iPrefix = null;
+    }
+
+    private static DurationPrinter createComposite(List formatters) {
+        if (formatters.size() == 1) {
+            return (DurationPrinter)formatters.get(0);
+        } else {
+            return new Composite(formatters);
+        }
+    }
+
+    private static final class SingularAffix implements DurationFieldAffix {
+        private final String iText;
+
+        SingularAffix(String text) {
+            iText = text;
+        }
+
+        public int calculatePrintedLength(int value) {
+            return iText.length();
+        }
+
+        public void printTo(StringBuffer buf, int value) {
+            buf.append(iText);
+        }
+
+        public void printTo(Writer out, int value) throws IOException {
+            out.write(iText);
+        }
+    }
+
+    private static final class PluralAffix implements DurationFieldAffix {
+        private final String iSingularText;
+        private final String iPluralText;
+
+        PluralAffix(String singularText, String pluralText) {
+            iSingularText = singularText;
+            iPluralText = pluralText;
+        }
+
+        public int calculatePrintedLength(int value) {
+            return (value == 1 ? iSingularText : iPluralText).length();
+        }
+
+        public void printTo(StringBuffer buf, int value) {
+            buf.append(value == 1 ? iSingularText : iPluralText);
+        }
+
+        public void printTo(Writer out, int value) throws IOException {
+            out.write(value == 1 ? iSingularText : iPluralText);
+        }
+    }
+
+    private static final class CompositeAffix implements DurationFieldAffix {
+        private final DurationFieldAffix iLeft;
+        private final DurationFieldAffix iRight;
+
+        CompositeAffix(DurationFieldAffix left, DurationFieldAffix right) {
+            iLeft = left;
+            iRight = right;
+        }
+
+        public int calculatePrintedLength(int value) {
+            return iLeft.calculatePrintedLength(value)
+                + iRight.calculatePrintedLength(value);
+        }
+
+        public void printTo(StringBuffer buf, int value) {
+            iLeft.printTo(buf, value);
+            iRight.printTo(buf, value);
+        }
+
+        public void printTo(Writer out, int value) throws IOException {
+            iLeft.printTo(out, value);
+            iRight.printTo(out, value);
+        }
+    }
+
+    private static final class FieldFormatter extends AbstractDurationFormatter
+        implements DurationPrinter
+    {
+        private final int iMinPrintedDigits;
+        private final int iPrintZeroSetting;
+
+        private final int iFieldType;
+
+        private final DurationFieldAffix iPrefix;
+        private final DurationFieldAffix iSuffix;
+
+        FieldFormatter(int minPrintedDigits, int printZeroSetting,
+                       int fieldType, DurationFieldAffix prefix, DurationFieldAffix suffix) {
+            iMinPrintedDigits = minPrintedDigits;
+            iPrintZeroSetting = printZeroSetting;
+            iFieldType = fieldType;
+            iPrefix = prefix;
+            iSuffix = suffix;
+        }
+
+        FieldFormatter(FieldFormatter field, DurationFieldAffix suffix) {
+            iMinPrintedDigits = field.iMinPrintedDigits;
+            iPrintZeroSetting = field.iPrintZeroSetting;
+            iFieldType = field.iFieldType;
+            iPrefix = field.iPrefix;
+            if (field.iSuffix != null) {
+                suffix = new CompositeAffix(field.iSuffix, suffix);
+            }
+            iSuffix = suffix;
+        }
+
+        public int countFieldsToPrint(ReadableDuration duration) {
+            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue(duration) >= 0) {
+                return 1;
+            }
+            return 0;
+        }
+
+        public int countFieldsToPrint(ReadableDuration duration, int stopAt) {
+            return stopAt <= 0 ? 0 : countFieldsToPrint(duration);
+        }
+
+        public int calculatePrintedLength(ReadableDuration duration) {
+            long valueLong = getFieldValue(duration);
+            if (valueLong < 0) {
+                return 0;
+            }
+
+            int value = (int)valueLong;
+
+            int sum = Math.max
+                (FormatUtils.calculateDigitCount(value), iMinPrintedDigits);
+            if (value < 0) {
+                // Account for sign character
+                sum++;
+            }
+
+            DurationFieldAffix affix;
+            if ((affix = iPrefix) != null) {
+                sum += affix.calculatePrintedLength(value);
+            }
+            if ((affix = iSuffix) != null) {
+                sum += affix.calculatePrintedLength(value);
+            }
+
+            return sum;
+        }
+        
+        public void printTo(StringBuffer buf, ReadableDuration duration) {
+            long valueLong = getFieldValue(duration);
+            if (valueLong < 0) {
+                return;
+            }
+            int value = (int)valueLong;
+
+            DurationFieldAffix affix;
+            if ((affix = iPrefix) != null) {
+                affix.printTo(buf, value);
+            }
+            int minDigits = iMinPrintedDigits;
+            if (minDigits <= 1) {
+                FormatUtils.appendUnpaddedInteger(buf, value);
+            } else {
+                FormatUtils.appendPaddedInteger(buf, value, minDigits);
+            }
+            if ((affix = iSuffix) != null) {
+                affix.printTo(buf, value);
+            }
+        }
+
+        public void printTo(Writer out, ReadableDuration duration) throws IOException {
+            long valueLong = getFieldValue(duration);
+            if (valueLong < 0) {
+                return;
+            }
+            int value = (int)valueLong;
+
+            DurationFieldAffix affix;
+            if ((affix = iPrefix) != null) {
+                affix.printTo(out, value);
+            }
+            int minDigits = iMinPrintedDigits;
+            if (minDigits <= 1) {
+                FormatUtils.writeUnpaddedInteger(out, value);
+            } else {
+                FormatUtils.writePaddedInteger(out, value, minDigits);
+            }
+            if ((affix = iSuffix) != null) {
+                affix.printTo(out, value);
+            }
+        }
+
+        /**
+         * @return negative value if nothing to print, otherwise lower 32 bits
+         * is signed int value.
+         */
+        long getFieldValue(ReadableDuration duration) {
+            DurationType type;
+            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) {
+                type = null; // Don't need to check if supported.
+            } else {
+                type = duration.getDurationType();
+            }
+
+            int value;
+
+            switch (iFieldType) {
+            default:
+                return -1;
+            case 1:
+                if (type != null && type.years().isSupported() == false) {
+                    return -1;
+                }
+                value = duration.getYears();
+                break;
+            case 2:
+                if (type != null && type.months().isSupported() == false) {
+                    return -1;
+                }
+                value = duration.getMonths();
+                break;
+            case 3:
+                if (type != null && type.weeks().isSupported() == false) {
+                    return -1;
+                }
+                value = duration.getWeeks();
+                break;
+            case 4:
+                if (type != null && type.days().isSupported() == false) {
+                    return -1;
+                }
+                value = duration.getDays();
+                break;
+            case 5:
+                if (type != null && type.hours().isSupported() == false) {
+                    return -1;
+                }
+                value = duration.getHours();
+                break;
+            case 6:
+                if (type != null && type.minutes().isSupported() == false) {
+                    return -1;
+                }
+                value = duration.getMinutes();
+                break;
+            case 7:
+                if (type != null && type.seconds().isSupported() == false) {
+                    return -1;
+                }
+                value = duration.getSeconds();
+                break;
+            case 8:
+                if (type != null && type.millis().isSupported() == false) {
+                    return -1;
+                }
+                value = duration.getMillis();
+                break;
+            }
+
+            if (value == 0 && iPrintZeroSetting == PRINT_ZERO_NEVER) {
+                return -1;
+            }
+
+            return value & 0xffffffffL;
+        }
+    }
+
+    private static final class Literal extends AbstractDurationFormatter
+        implements DurationPrinter
+    {
+        private final String iText;
+
+        Literal(String text) {
+            iText = text;
+        }
+
+        public int countFieldsToPrint(ReadableDuration duration, int stopAt) {
+            return 0;
+        }
+
+        public int calculatePrintedLength(ReadableDuration duration) {
+            return iText.length();
+        }
+
+        public void printTo(StringBuffer buf, ReadableDuration duration) {
+            buf.append(iText);
+        }
+
+        public void printTo(Writer out, ReadableDuration duration) throws IOException {
+            out.write(iText);
+        }
+    }
+
+    private static final class Separator extends AbstractDurationFormatter
+        implements DurationPrinter
+    {
+        private final String iText;
+        private final String iFinalText;
+
+        private final DurationPrinter iBefore;
+        private final DurationPrinter iAfter;
+
+        Separator(String text, String finalText) {
+            this(text, finalText, null, null);
+        }
+
+        Separator(String text, String finalText,
+                  DurationPrinter before, DurationPrinter after) {
+            iText = text;
+            iFinalText = finalText;
+            iBefore = before;
+            iAfter = after;
+        }
+
+        public int countFieldsToPrint(ReadableDuration duration, int stopAt) {
+            int sum = iBefore.countFieldsToPrint(duration, stopAt);
+            if (sum < stopAt) {
+                sum += iAfter.countFieldsToPrint(duration, stopAt);
+            }
+            return sum;
+        }
+
+        public int calculatePrintedLength(ReadableDuration duration) {
+            int sum = iBefore.calculatePrintedLength(duration)
+                + iAfter.calculatePrintedLength(duration);
+
+            if (iBefore.countFieldsToPrint(duration, 1) > 0) {
+                int afterCount = iAfter.countFieldsToPrint(duration, 2);
+                if (afterCount > 0) {
+                    sum += (afterCount > 1 ? iText : iFinalText).length();
+                }
+            }
+
+            return sum;
+        }
+
+        public void printTo(StringBuffer buf, ReadableDuration duration) {
+            DurationPrinter before = iBefore;
+            DurationPrinter after = iAfter;
+
+            before.printTo(buf, duration);
+
+            if (before.countFieldsToPrint(duration, 1) > 0) {
+                int afterCount = after.countFieldsToPrint(duration, 2);
+                if (afterCount > 0) {
+                    buf.append(afterCount > 1 ? iText : iFinalText);
+                }
+            }
+
+            after.printTo(buf, duration);
+        }
+
+        public void printTo(Writer out, ReadableDuration duration) throws IOException {
+            DurationPrinter before = iBefore;
+            DurationPrinter after = iAfter;
+
+            before.printTo(out, duration);
+
+            if (before.countFieldsToPrint(duration, 1) > 0) {
+                int afterCount = after.countFieldsToPrint(duration, 2);
+                if (afterCount > 0) {
+                    out.write(afterCount > 1 ? iText : iFinalText);
+                }
+            }
+
+            after.printTo(out, duration);
+        }
+
+        Separator merge(String text, String finalText) {
+            return new Separator(iText + text, iFinalText + finalText, iBefore, iAfter);
+        }
+
+        Separator finish(DurationPrinter before, DurationPrinter after) {
+            return new Separator(iText, iFinalText, before, after);
+        }
+    }
+
+    private static final class Composite extends AbstractDurationFormatter
+        implements DurationPrinter
+    {
+        private final DurationPrinter[] iFormatters;
+
+        Composite(List formatters) {
+            iFormatters = (DurationPrinter[])formatters.toArray
+                (new DurationPrinter[formatters.size()]);
+        }
+
+        public int countFieldsToPrint(ReadableDuration duration, int stopAt) {
+            int sum = 0;
+            DurationPrinter[] printers = iFormatters;
+            for (int i=printers.length; sum < stopAt && --i>=0; ) {
+                sum += printers[i].countFieldsToPrint(duration);
+            }
+            return sum;
+        }
+
+        public int calculatePrintedLength(ReadableDuration duration) {
+            int sum = 0;
+            DurationPrinter[] printers = iFormatters;
+            for (int i=printers.length; --i>=0; ) {
+                sum += printers[i].calculatePrintedLength(duration);
+            }
+            return sum;
+        }
+
+        public void printTo(StringBuffer buf, ReadableDuration duration) {
+            DurationPrinter[] printers = iFormatters;
+            int len = printers.length;
+            for (int i=0; i<len; i++) {
+                printers[i].printTo(buf, duration);
+            }
+        }
+
+        public void printTo(Writer out, ReadableDuration duration) throws IOException {
+            DurationPrinter[] printers = iFormatters;
+            int len = printers.length;
+            for (int i=0; i<len; i++) {
+                printers[i].printTo(out, duration);
+            }
+        }
+    }
+
+    private static final class AlternateSelector extends AbstractDurationFormatter
+        implements DurationPrinter
+    {
+        private final DurationPrinter iPrimary;
+        private final DurationPrinter iAlternate;
+
+        AlternateSelector(DurationPrinter primary, DurationPrinter alternate) {
+            iPrimary = primary;
+            iAlternate = alternate;
+        }
+
+        public int countFieldsToPrint(ReadableDuration duration, int stopAt) {
+            int count = iPrimary.countFieldsToPrint(duration, stopAt);
+            if (count <= 0) {
+                count = iAlternate.countFieldsToPrint(duration, stopAt);
+            }
+            return count;
+        }
+
+        public int calculatePrintedLength(ReadableDuration duration) {
+            if (iPrimary.countFieldsToPrint(duration, 1) > 0) {
+                return iPrimary.calculatePrintedLength(duration);
+            } else {
+                return iAlternate.calculatePrintedLength(duration);
+            }
+        }
+
+        public void printTo(StringBuffer buf, ReadableDuration duration) {
+            if (iPrimary.countFieldsToPrint(duration, 1) > 0) {
+                iPrimary.printTo(buf, duration);
+            } else {
+                iAlternate.printTo(buf, duration);
+            }
+        }
+
+        public void printTo(Writer out, ReadableDuration duration) throws IOException {
+            if (iPrimary.countFieldsToPrint(duration, 1) > 0) {
+                iPrimary.printTo(out, duration);
+            } else {
+                iAlternate.printTo(out, duration);
+            }
+        }
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/format/DurationParser.java b/JodaTime/src/java/org/joda/time/format/DurationParser.java
new file mode 100644
index 000000000..71ee4f134
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/format/DurationParser.java
@@ -0,0 +1,109 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.format;
+
+import org.joda.time.Duration;
+import org.joda.time.DurationType;
+import org.joda.time.MutableDuration;
+import org.joda.time.ReadWritableDuration;
+
+/**
+ * Converts sequences of human-readable characters into durations.
+ *
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+public interface DurationParser {
+
+    //-----------------------------------------------------------------------
+    /**
+     * Parses a duration from the given text, at the given position, saving the
+     * result into the fields of the given ReadWritableDuration. If the parse
+     * succeeds, the return value is the new text position. Note that the parse
+     * may succeed without fully reading the text.
+     * <p>
+     * If it fails, the return value is negative, but the duration may still be
+     * modified. To determine the position where the parse failed, apply the
+     * one's complement operator (~) on the return value.
+     *
+     * @param duration  a duration that will be modified
+     * @param durationStr  text to parse
+     * @param position position to start parsing from
+     * @return new position, if negative, parse failed. Apply complement
+     * operator (~) to get position of failure
+     * @throws IllegalArgumentException if any field is out of range
+     */
+    int parseInto(ReadWritableDuration duration, String durationStr, int position);
+
+    /**
+     * Parses a duration from the given text, returning a new Duration.
+     *
+     * @param type  defines which fields may be parsed
+     * @param durationStr  text to parse
+     * @return parsed value in a Duration object
+     * @throws IllegalArgumentException if any field is out of range
+     */
+    Duration parseDuration(DurationType type, String durationStr);
+
+    /**
+     * Parses a duration from the given text, returning a new MutableDuration.
+     *
+     * @param type  defines which fields may be parsed
+     * @param durationStr  text to parse
+     * @return parsed value in a MutableDuration object
+     * @throws IllegalArgumentException if any field is out of range
+     */
+    MutableDuration parseMutableDuration(DurationType type, String durationStr);
+
+}
diff --git a/JodaTime/src/java/org/joda/time/format/DurationPrinter.java b/JodaTime/src/java/org/joda/time/format/DurationPrinter.java
new file mode 100644
index 000000000..7d64fdd50
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/format/DurationPrinter.java
@@ -0,0 +1,121 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.format;
+
+import java.io.IOException;
+import java.io.Writer;
+
+import org.joda.time.ReadableDuration;
+
+/**
+ * Converts durations into a sequence of human-readable characters.
+ *
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+public interface DurationPrinter {
+
+    /**
+     * Returns the amount of fields from the given duration that this printer
+     * will print.
+     * 
+     * @param duration duration to use
+     * @return amount of fields printed
+     */
+    int countFieldsToPrint(ReadableDuration duration);
+
+    /**
+     * Returns the amount of fields from the given duration that this printer
+     * will print.
+     * 
+     * @param duration duration to use
+     * @param stopAt stop counting at this value
+     * @return amount of fields printed
+     */
+    int countFieldsToPrint(ReadableDuration duration, int stopAt);
+
+    /**
+     * Returns the exact number of characters produced for the given duration.
+     * 
+     * @param duration duration to use
+     * @return the estimated length
+     */
+    int calculatePrintedLength(ReadableDuration duration);
+
+    //-----------------------------------------------------------------------
+    /**
+     * Prints a ReadableDuration to a StringBuffer.
+     *
+     * @param buf  the formatted duration is appended to this buffer
+     * @param duration  duration to format
+     */
+    void printTo(StringBuffer buf, ReadableDuration duration);
+
+    /**
+     * Prints a ReadableDuration to a Writer.
+     *
+     * @param out  the formatted duration is written out
+     * @param duration  duration to format
+     */
+    void printTo(Writer out, ReadableDuration duration) throws IOException;
+
+    /**
+     * Prints a ReadableDuration to a new String.
+     *
+     * @param duration  duration to format
+     * @return the printed result
+     */
+    String print(ReadableDuration duration);
+
+}
diff --git a/JodaTime/src/java/org/joda/time/format/FormatUtils.java b/JodaTime/src/java/org/joda/time/format/FormatUtils.java
index c73cc2e7b..5ca8238fb 100644
--- a/JodaTime/src/java/org/joda/time/format/FormatUtils.java
+++ b/JodaTime/src/java/org/joda/time/format/FormatUtils.java
@@ -59,11 +59,14 @@
 
 /**
  * Utility methods used by formatters.
+ * <p>
+ * FormatUtils is thread-safe and immutable.
  *
  * @author Brian S O'Neill
  */
-public class FormatUtils {
-    private static final double LOG_10 = Math.log(10);
+// Note: Use strictfp and StrictMath to ensure consistent results on all VMs.
+public strictfp class FormatUtils {
+    private static final double LOG_10 = StrictMath.log(10);
 
     private FormatUtils() {
     }
@@ -109,7 +112,7 @@ public static void appendPaddedInteger(StringBuffer buf, int value, int size) {
             } else if (value < 10000) {
                 digits = 4;
             } else {
-                digits = (int)(Math.log(value) / LOG_10) + 1;
+                digits = (int)(StrictMath.log(value) / LOG_10) + 1;
             }
             for (; size > digits; size--) {
                 buf.append('0');
@@ -147,7 +150,7 @@ public static void appendPaddedInteger(StringBuffer buf, long value, int size) {
                     return;
                 }
             }
-            int digits = (int)(Math.log(value) / LOG_10) + 1;
+            int digits = (int)(StrictMath.log(value) / LOG_10) + 1;
             for (; size > digits; size--) {
                 buf.append('0');
             }
@@ -198,7 +201,7 @@ public static void writePaddedInteger(Writer out, int value, int size)
             } else if (value < 10000) {
                 digits = 4;
             } else {
-                digits = (int)(Math.log(value) / LOG_10) + 1;
+                digits = (int)(StrictMath.log(value) / LOG_10) + 1;
             }
             for (; size > digits; size--) {
                 out.write('0');
@@ -238,7 +241,7 @@ public static void writePaddedInteger(Writer out, long value, int size)
                     return;
                 }
             }
-            int digits = (int)(Math.log(value) / LOG_10) + 1;
+            int digits = (int)(StrictMath.log(value) / LOG_10) + 1;
             for (; size > digits; size--) {
                 out.write('0');
             }
@@ -340,6 +343,26 @@ public static void writeUnpaddedInteger(Writer out, long value)
         }
     }
 
+    /**
+     * Calculates the number of decimal digits for the given value, ignoring
+     * sign.
+     */
+    public static int calculateDigitCount(int value) {
+        if (value < 0) {
+            if (value != Integer.MIN_VALUE) {
+                value = -value;
+            } else {
+                return 10;
+            }
+        }
+        return 
+            (value < 10 ? 1 :
+             (value < 100 ? 2 :
+              (value < 1000 ? 3 :
+               (value < 10000 ? 4 :
+                ((int)(StrictMath.log(value) / LOG_10) + 1)))));
+    }
+
     static int parseTwoDigits(String text, int position) {
         int value = text.charAt(position) - '0';
         return ((value << 3) + (value << 1)) + text.charAt(position + 1) - '0';
diff --git a/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
index 9f8bfe981..48484cc89 100644
--- a/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
+++ b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
@@ -61,37 +61,73 @@
 import org.joda.time.chrono.iso.ISOChronology;
 
 /**
- * Factory methods for many ISO8601 formats (the ISO standard is a framework
- * for outputting data, but not an absolute standard). The most common formats
- * are date, time, and dateTime.
- * 
+ * ISODateTimeFormat provides factory methods for the ISO8601 standard.
+ * <p>
+ * ISO8601 is the international standard for data interchange. It defines a
+ * framework, rather than an absolute standard. As a result this provider has a
+ * number of methods that represent common uses of the framework. The most common
+ * formats are {@link #date() date}, {@link #time() time}, and {@link #dateTime() dateTime}.
+ * <p>
+ * For example, to format a date time in ISO format:
+ * <pre>
+ * DateTime dt = new DateTime();
+ * DateTimeFormatter fmt = DateTimeFormat.getInstance().dateTime();
+ * String str = fmt.print(dt);
+ * </pre>
+ * <p>
+ * ISODateTimeFormat is thread-safe and immutable, and the formatters it
+ * returns are as well.
+ *
  * @author Brian S O'Neill
+ * @since 1.0
  * @see DateTimeFormat
  * @see DateTimeFormatterBuilder
  */
 public class ISODateTimeFormat {
 
-    // Maps Chronology instances to instances.
+    /**
+     * Cache that maps Chronology instances to instances.
+     */
     private static Map cCache = new HashMap(7);
 
+    /**
+     * Gets an instance of a format provider that uses the ISOChronology in UTC.
+     * 
+     * @return a format provider
+     */
     public static ISODateTimeFormat getInstanceUTC() {
         return getInstance(ISOChronology.getInstanceUTC());
     }
 
+    /**
+     * Gets an instance of a format provider that uses the ISOChronology
+     * in the default time zone.
+     * 
+     * @return a format provider
+     */
     public static ISODateTimeFormat getInstance() {
         return getInstance(ISOChronology.getInstance());
     }
 
-    public static ISODateTimeFormat getInstance(DateTimeZone zone) {
+    /**
+     * Gets an instance of a format provider that uses the ISOChronology
+     * in the specified time zone.
+     * 
+     * @return a format provider
+     */
+    public static ISODateTimeFormat getInstance(final DateTimeZone zone) {
         return getInstance(ISOChronology.getInstance(zone));
     }
 
     /**
-     * @param chrono Chronology to use
+     * Gets an instance of a format provider that uses the specified chronology.
+     * 
+     * @param chrono  the chronology to use, null means default chronology
+     * @return a format provider
      */
     public static synchronized ISODateTimeFormat getInstance(Chronology chrono) {
         if (chrono == null) {
-            throw new IllegalArgumentException("The Chronology must not be null");
+            chrono = ISOChronology.getInstance();
         }
         ISODateTimeFormat instance = (ISODateTimeFormat)cCache.get(chrono);
         if (instance == null) {
@@ -101,6 +137,7 @@ public static synchronized ISODateTimeFormat getInstance(Chronology chrono) {
         return instance;
     }
 
+    //-----------------------------------------------------------------------
     private final Chronology iChrono;
 
     private transient DateTimeFormatter
@@ -142,12 +179,18 @@ public static synchronized ISODateTimeFormat getInstance(Chronology chrono) {
         tp, // time parser
         dtp; // date time parser
 
-    private ISODateTimeFormat(Chronology chrono) {
+    /**
+     * Restricted constructor.
+     * 
+     * @param chrono  the chronology to use, must not be null
+     */
+    private ISODateTimeFormat(final Chronology chrono) {
         iChrono = chrono;
     }
 
+    //-----------------------------------------------------------------------
     /**
-     * Returns a generic ISO date parser that accepts formats described by
+     * Returns a generic ISO date parser. It accepts formats described by
      * the following syntax:
      * <pre>
      * date         = date-element ['T' offset]
@@ -170,7 +213,7 @@ public DateTimeParser dateParser() {
     }
 
     /**
-     * Returns a generic ISO date parser that accepts formats described by
+     * Returns a generic ISO date parser. It accepts formats described by
      * the following syntax:
      * <pre>
      * date-element = yyyy ['-' MM ['-' dd]]
@@ -191,7 +234,7 @@ public DateTimeParser dateElementParser() {
     }
 
     /**
-     * Returns a generic ISO time parser that accepts formats described by
+     * Returns a generic ISO time parser. It accepts formats described by
      * the following syntax:
      * <pre>
      * time         = ['T'] time-element [offset]
@@ -214,7 +257,7 @@ public DateTimeParser timeParser() {
     }
 
     /**
-     * Returns a generic ISO time parser that accepts formats described by
+     * Returns a generic ISO time parser. It accepts formats described by
      * the following syntax:
      * <pre>
      * time-element = HH [':' mm [':' ss ['.' SSS]]]
@@ -239,7 +282,7 @@ public DateTimeParser timeElementParser() {
     }
 
     /**
-     * Returns a generic ISO datetime parser that accepts formats described by
+     * Returns a generic ISO datetime parser. It accepts formats described by
      * the following syntax:
      * <pre>
      * datetime     = time | (date-element [time | ('T' offset)])
@@ -279,6 +322,7 @@ public DateTimeParser dateTimeParser() {
         return dtp;
     }
 
+    //-----------------------------------------------------------------------
     /**
      * Returns a formatter for a full date as four digit year, two digit month
      * of year, and two digit day of month. (yyyy-MM-dd)
@@ -318,6 +362,7 @@ public DateTimeFormatter dateTime() {
         return dt;
     }
 
+    //-----------------------------------------------------------------------
     /**
      * Returns a basic formatter for a full date as four digit year, two digit
      * month of year, and two digit day of month. (yyyyMMdd)
@@ -325,7 +370,9 @@ public DateTimeFormatter dateTime() {
     public DateTimeFormatter basicDate() {
         if (bd == null) {
             bd = new DateTimeFormatterBuilder(iChrono)
-                .appendPattern("yyyyMMdd")
+                .appendYear(4, 4)
+                .appendMonthOfYear(2)
+                .appendDayOfMonth(2)
                 .toFormatter();
         }
         return bd;
@@ -339,7 +386,9 @@ public DateTimeFormatter basicDate() {
     public DateTimeFormatter basicTime() {
         if (bt == null) {
             bt = new DateTimeFormatterBuilder(iChrono)
-                .appendPattern("HHmmss")
+                .appendHourOfDay(2)
+                .appendMinuteOfHour(2)
+                .appendSecondOfMinute(2)
                 .appendTimeZoneOffset("", false, 1, 2)
                 .toFormatter();
         }
@@ -361,6 +410,7 @@ public DateTimeFormatter basicDateTime() {
         return bdt;
     }
 
+    //-----------------------------------------------------------------------
     /**
      * Returns a formatter for a four digit year. (yyyy)
      */
@@ -512,6 +562,7 @@ public DateTimeFormatter dateHourMinuteSecondFraction() {
         return dhmsf;
     }
 
+    //-----------------------------------------------------------------------
     private DateTimeFormatter yearElement() {
         if (ye == null) {
             ye = new DateTimeFormatterBuilder(iChrono)
diff --git a/JodaTime/src/java/org/joda/time/format/package.html b/JodaTime/src/java/org/joda/time/format/package.html
index d72edbbba..f2797e736 100644
--- a/JodaTime/src/java/org/joda/time/format/package.html
+++ b/JodaTime/src/java/org/joda/time/format/package.html
@@ -1,8 +1,73 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<html>
+<head>
+<title>org.joda.time.format package</title>
+<!--
+
+   Joda Software License, Version 1.0
+  
+  
+   Copyright (c) 2001-03 Stephen Colebourne.
+   All rights reserved.
+  
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions
+   are met:
+  
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+  
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+  
+   3. The end-user documentation included with the redistribution,
+      if any, must include the following acknowledgment:
+         "This product includes software developed by the
+          Joda project (http://www.joda.org/)."
+      Alternately, this acknowledgment may appear in the software itself,
+      if and wherever such third-party acknowledgments normally appear.
+  
+   4. The name "Joda" must not be used to endorse or promote products
+      derived from this software without prior written permission. For
+      written permission, please contact licence@joda.org.
+  
+   5. Products derived from this software may not be called "Joda",
+      nor may "Joda" appear in their name, without prior written
+      permission of the Joda project.
+  
+   THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+   USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+   OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+   SUCH DAMAGE.
+   ====================================================================
+  
+   This software consists of voluntary contributions made by many
+   individuals on behalf of the Joda project and was originally
+   created by Stephen Colebourne <scolebourne@joda.org>. For more
+   information on the Joda project, please see <http://www.joda.org/>.
+
+-->
+</head>
 <body>
-<h3>Printing and parsing of DateTime objects.</h3>
 <p>
-This package defines classes that enable ReadableInstant objects to be converted
-to and from Strings in a powerful and flexible way.
+Provides printing and parsing support for instants and durations. This package
+contains simple and advanced classes for formatting.
+</p>
+<p>
+Formatters are defined by interfaces, and instances are obtained from factory
+methods. Most datetime formatters can be obtained from
+<code>DateTimeFormat</code> and <code>ISODateTimeFormat</code>. More advanced
+formatters can be built by using <code>DateTimeFormatterBuilder</code>.
 </p>
 </body>
-
+</html>
diff --git a/JodaTime/src/java/org/joda/time/package.html b/JodaTime/src/java/org/joda/time/package.html
index 026673548..dada16c04 100644
--- a/JodaTime/src/java/org/joda/time/package.html
+++ b/JodaTime/src/java/org/joda/time/package.html
@@ -1,19 +1,78 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<html>
+<head>
+<title>org.joda.time package</title>
+<!--
+
+   Joda Software License, Version 1.0
+  
+  
+   Copyright (c) 2001-03 Stephen Colebourne.
+   All rights reserved.
+  
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions
+   are met:
+  
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+  
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+  
+   3. The end-user documentation included with the redistribution,
+      if any, must include the following acknowledgment:
+         "This product includes software developed by the
+          Joda project (http://www.joda.org/)."
+      Alternately, this acknowledgment may appear in the software itself,
+      if and wherever such third-party acknowledgments normally appear.
+  
+   4. The name "Joda" must not be used to endorse or promote products
+      derived from this software without prior written permission. For
+      written permission, please contact licence@joda.org.
+  
+   5. Products derived from this software may not be called "Joda",
+      nor may "Joda" appear in their name, without prior written
+      permission of the Joda project.
+  
+   THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+   USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+   OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+   SUCH DAMAGE.
+   ====================================================================
+  
+   This software consists of voluntary contributions made by many
+   individuals on behalf of the Joda project and was originally
+   created by Stephen Colebourne <scolebourne@joda.org>. For more
+   information on the Joda project, please see <http://www.joda.org/>.
+
+-->
+</head>
 <body>
-<h3>DateTime object creation and manipulation.</h3>
 <p>
-This package aims to provide a full date and time implementation to replace
-the Java Date and Calendar classes. The implementation covers both the
-Gregorian/Julian calendar system and the ISO8601 standard.
-The design aims to be flexible enough to enable other calendar systems, or 
-extensions to the provided ones, to be created.
+Provides support for dates, times, time zones, durations, and intervals. This
+package aims to fully replace the Java Date, Calendar, and TimeZone
+classes. This implementation covers both the Gregorian/Julian calendar system
+and the ISO8601 standard. Additional calendar systems and extensions can be
+created as well.
 </p>
 <p>
-The ISO8601 standard is the international standard for dates, times and time
-periods. It defines a String representation and fixes values for the first day
-of the week, Monday which has the value 1, and the first week in a year. This
-standard is being increasingly used in computer interchange and is the agreed
-format for XML. For most uses, the ISO standard is the same as Gregorian/Julian
-and is thus the preferred format.
+The ISO8601 standard is the international standard for dates, times, durations,
+and intervals. It defines text representations, the first day of the week as
+Monday, and the first week in a year as having a Thursday in it. This standard
+is being increasingly used in computer interchange and is the agreed format for
+XML. For most uses, the ISO standard is the same as Gregorian, and is thus the
+preferred format.
 </p>
 
 <h4>Interfaces</h4>
@@ -22,48 +81,47 @@ <h4>Interfaces</h4>
 </p>
 <ul>
 <li><code>ReadableInstant</code> - an instant in time
-<li><code>ReadWriteableInstant</code> - an instant that can be updated
+<li><code>ReadableDateTime</code> - an instant in time with field accessors
+<li><code>ReadableDuration</code> - a duration broken down into fields
+</ul>
+<ul>
+<li><code>ReadWritableInstant</code> - an instant that can be modified
+<li><code>ReadWritableDateTime</code> - a datetime that can be modified
+<li><code>ReadWritableDuration</code> - a duration that can be modified
 </ul>
 <p>
-These define the public interface to dates and times. The design is
-millisecond based as with java.util.Date and Calendar. This should enable easy
-conversions.
-</p>
-<p>
-It is intended that dates are passed into methods using the interface. Methods
-will utilise the date and if necessary return a specified implementation, preferably
-<code>Instant</code>. By using the interface to pass time in and <code>Instant</code>
-to return time you are not hard coding a locale specific calendar system into your API.
-Within the method you can create an instance of a specific calendar system to work
-with if required.
+These define the public interface to dates, times, and durations. As with
+java.util.Date and Calendar, the design is millisecond based with an epoch of
+1970-01-01. This should enable easy conversions.
 </p>
 
 <h4>Implementations</h4>
 <p>
-The basic implementation of the <code>ReadableInstant</code> interface is 
-<code>Instant</code>. This is a simple immutable class that stores the millisecond
-value and integrates with Java Date and Calendar. If you are dealing with an instant
-in time but do not know, or do not want to specify, which calendar system it refers
-to then you should use this class.
+The basic implementation of the <code>ReadableInstant</code> interface is
+<code>Instant</code>. This is a simple immutable class that stores the
+millisecond value and integrates with Java Date and Calendar. If you are
+dealing with an instant in time but do not know, or do not want to specify,
+which calendar system it refers to, then you should use this class.
 </p>
 <p>
 The main implementation class for datetimes is the <code>DateTime</code> class.
-This implements the <code>ReadableInstant</code> interface, but also provides
-convenient methods to access the fields of the datetime. Conversion methods allow 
-integration with the Java Date and Calendar classes. <code>DateTime</code> has 
-three subclasses at present - <code>ISODateTime</code>, <code>GJDateTime</code> 
-and <code>BuddhistDateTime</code>. These provide the same functionality but with 
-different <i>chronologies</i>.
+This implements the <code>ReadableDateTime</code> interface, providing
+convenient methods to access the fields of the datetime. Conversion methods
+allow integration with the Java Date and Calendar classes.
+</p>
+<p>
+Like <code>Instant</code>, <code>DateTime</code> is <i>immutable</i>, and it
+can be used safely in a multi-threaded environment. Most of the methods in
+<code>DateTime</code> are final, but the class itself is not. Subclasses of
+<code>DateTime</code> can actually be mutable, but they cannot alter the values
+returned by the standard <code>DateTime</code> or superclass methods.
 </p>
 <p>
-These subclasses are <i>immutable</i>, so can be used safely in a multi-threaded
-environment. <code>DateTime</code> itself can be considered to be immutable so 
-long as you only use the methods it or a superclass defines. To be fully immutable
-<code>DateTime</code> would have to be final, but that prevents
-subclasses from adding convenient access methods. The chosen design allows the 
-flexibility of convenience, but at the risk of someone writing potentially mutable
-subclasses. (Note that the millisecond and chronology values are immutable, so the 
-'danger' posed is small.)
+To be fully immutable <code>DateTime</code> would have to be final, but that
+prevents subclasses from adding convenient access methods. Choosing this design
+allows the flexibility of convenience, but at the risk of someone writing
+potentially mutable subclasses. (Note that the internal data values cannot be
+modified, so the "danger" posed is small.)
 </p>
 <p>
 In addition to the datetime classes, there are date and time only classes, 
@@ -71,40 +129,71 @@ <h4>Implementations</h4>
 to <code>DateTime</code>.
 </p>
 <p>
-To enable the easy editing of datetimes, there is a single implementation of the
-<code>ReadWriteableInstant</code> interface, <code>MutableDateTime</code>.
+The concrete implementations of the <code>ReadWritable...</code> interfaces are
+named the same as their immutable counterparts, but with a "Mutable"
+prefix. For example, <code>MutableDateTime</code> implements
+<code>ReadWritableDateTime</code>, making datetime editing easy.
+</p>
+
+<h4>User defined APIs</h4>
+<p>
+User defined methods should generally accept instants and durations specified
+by one of the interfaces. This allows the method to accept more types, and it
+clearly states what operations it requires. A method that declares an input
+parameter of type <code>ReadWritableDateTime</code> is declaring that the
+object will get updated.
+</p>
+<p>
+The interfaces that define read operations, like <code>ReadableDateTime</code>,
+only limit the allowed set of operations, but they do <i>not</i> guarantee that
+the object is immutable. Care must be taken when saving a parameter of this
+type. Calling a conversion method like <code>toDateTime</code> beforehand
+guarantees immutability of the saved object, but does not add any significant
+overhead if the object was already a DateTime.
+</p>
+<p>
+User defined methods that return instants or durations should generally declare
+a concrete return type, like <code>DateTime</code>. Again, the interfaces only
+define permitted operations. Since <code>DateTime</code> is guaranteed
+immutable, callers of the method know that the returned object can be safely
+shared and accessed by multiple threads.
 </p>
 
 <h4>Chronologies and Fields</h4>
 <p>
-In order to enable the package to be easily extended, each field of the datetime,
-such as the month, is calculated by a separate subclass of <code>DateTimeField</code>.
-If desired, applcations can then write their own implementations to retrieve an unusual 
-field from the millisecond value.
+In order to enable the package to be easily extended, each field of the
+datetime, such as the month, is calculated by an implementation of
+<code>DateTimeField</code>. Likewise, duration fields are calculated by
+specialized <code>DurationField</code> instances. If desired, users can write
+their own implementations to retrieve an unusual field from the millisecond
+value.
 </p>
 <p>
-The fields that together represent a calendar system are grouped into a <code>Chonology</code>.
-The chronology represents all the information to convert from a millisecond value to
-human understanable fields in a specific calendar system. Chronologies are provided for 
-ISO and Gregorian/Julian (GJ). (ISO is in fact a special case of GJ).
+The datetime and duration fields that together represent a calendar system are
+grouped into a <code>Chronology</code>. The chronology represents all the
+information to convert from a millisecond value to human understandable fields
+in a specific calendar system. Chronologies are provided for ISO and
+Gregorian/Julian (GJ). (ISO is in fact a special case of GJ).
 </p>
 <p>
-This design results in a low overhead on the date time classes. Java Calendar class
-performs poorly because it has many internal fields that are constantly kept in sync.
-This design only calculates fields when required, resulting in lightweight and simple
-date time classes.
+This design results in a low overhead on the date and time classes. Java
+Calendar class performs poorly because it has many internal fields that are
+constantly kept in sync. This design only calculates fields when required,
+resulting in lightweight and simple date time classes.
 </p>
 
 <h4>Formatting</h4>
 <p>
-Formatting is provided by the <code>format</code> subpackage. Comprehensive support is
-provided for outputting dates and times in multiple formats. A pattern similar to
-Java SimpleDateFormat can be used, but a more advanced programmatic technique is available.
+Formatting is provided by the <code>format</code> subpackage. Comprehensive
+support is provided for outputting dates and times in multiple formats. A
+pattern similar to Java SimpleDateFormat can be used, but a more advanced
+programmatic technique is available.
 </p>
 
 <h4>General</h4>
 <p>
-The package is standalone and has no dependencies other than JDK 1.2.
+This package is standalone and has no dependencies other than JDK 1.2.
 It is licenced under an Apache/BSD style licence.
 </p>
 </body>
+</html>
\ No newline at end of file
diff --git a/JodaTime/src/java/org/joda/time/tz/CachedDateTimeZone.java b/JodaTime/src/java/org/joda/time/tz/CachedDateTimeZone.java
index 4e8f9589e..66306eee0 100644
--- a/JodaTime/src/java/org/joda/time/tz/CachedDateTimeZone.java
+++ b/JodaTime/src/java/org/joda/time/tz/CachedDateTimeZone.java
@@ -60,6 +60,8 @@
  * Improves the performance of requesting time zone offsets and name keys by
  * caching the results. Time zones that have simple rules or are fixed should
  * not be cached, as it is unlikely to improve performance.
+ * <p>
+ * CachedDateTimeZone is thread-safe and immutable.
  * 
  * @author Brian S O'Neill
  */
@@ -67,20 +69,29 @@
     private static final int cInfoCacheMask;
 
     static {
-        Integer i = Integer.getInteger("org.joda.time.tz.CachedDateTimeZone.size");
-
-        // With a cache size of 512, dates that lie within any 69.7 year period
-        // have no cache collisions.
-        int cacheSize = (i == null) ? 512 : i.intValue();
-
-        // Ensure cache size is even power of 2.
-        cacheSize--;
-        int shift = 0;
-        while (cacheSize > 0) {
-            shift++;
-            cacheSize >>= 1;
+        Integer i;
+        try {
+            i = Integer.getInteger("org.joda.time.tz.CachedDateTimeZone.size");
+        } catch (SecurityException e) {
+            i = null;
+        }
+
+        int cacheSize;
+        if (i == null) {
+            // With a cache size of 512, dates that lie within any 69.7 year
+            // period have no cache collisions.
+            cacheSize = 512; // (1 << 9)
+        } else {
+            cacheSize = i.intValue();
+            // Ensure cache size is even power of 2.
+            cacheSize--;
+            int shift = 0;
+            while (cacheSize > 0) {
+                shift++;
+                cacheSize >>= 1;
+            }
+            cacheSize = 1 << shift;
         }
-        cacheSize = 1 << shift;
 
         cInfoCacheMask = cacheSize - 1;
     }
@@ -127,24 +138,28 @@ public DateTimeZone getUncachedZone() {
         return iZone;
     }
 
-    public String getNameKey(long millis) {
-        return getInfo(millis).getNameKey(millis);
+    public String getNameKey(long instant) {
+        return getInfo(instant).getNameKey(instant);
+    }
+
+    public int getOffset(long instant) {
+        return getInfo(instant).getOffset(instant);
     }
 
-    public int getOffset(long millis) {
-        return getInfo(millis).getOffset(millis);
+    public int getStandardOffset(long instant) {
+        return getInfo(instant).getStandardOffset(instant);
     }
 
-    public int getStandardOffset(long millis) {
-        return getInfo(millis).getStandardOffset(millis);
+    public boolean isFixed() {
+        return iZone.isFixed();
     }
 
-    public long nextTransition(long millis) {
-        return iZone.nextTransition(millis);
+    public long nextTransition(long instant) {
+        return iZone.nextTransition(instant);
     }
 
-    public long previousTransition(long millis) {
-        return iZone.previousTransition(millis);
+    public long previousTransition(long instant) {
+        return iZone.previousTransition(instant);
     }
 
     public int hashCode() {
diff --git a/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java b/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java
index 71c4a2b91..19579d102 100644
--- a/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java
+++ b/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java
@@ -76,6 +76,9 @@
  * creating a new DateTimeZone this way is a relatively expensive operation,
  * built zones can be written to a file. Reading back the encoded data is a
  * quick operation.
+ * <p>
+ * DateTimeZoneBuilder itself is mutable and not thread-safe, but the
+ * DateTimeZone objects that it builds are thread-safe and immutable.
  *
  * @author Brian S O'Neill
  * @see ZoneInfoCompiler
@@ -538,7 +541,7 @@ public long setInstant(int year, int standardOffset, int saveMillis) {
         /**
          * @param standardOffset standard offset just before next recurrence
          */
-        public long next(long millis, int standardOffset, int saveMillis) {
+        public long next(long instant, int standardOffset, int saveMillis) {
             int offset;
             if (iMode == 'w') {
                 offset = standardOffset + saveMillis;
@@ -549,21 +552,23 @@ public long next(long millis, int standardOffset, int saveMillis) {
             }
 
             // Convert from UTC to local time.
-            millis += offset;
+            instant += offset;
 
             Chronology chrono = ISOChronology.getInstanceUTC();
-            long next = chrono.monthOfYear().set(millis, iMonthOfYear);
-            next = chrono.millisOfDay().set(next, iMillisOfDay);
+            long next = chrono.monthOfYear().set(instant, iMonthOfYear);
+            // Be lenient with millisOfDay.
+            next = chrono.millisOfDay().set(next, 0);
+            next = chrono.millisOfDay().add(next, iMillisOfDay);
             next = setDayOfMonthNext(chrono, next);
 
             if (iDayOfWeek == 0) {
-                if (next <= millis) {
+                if (next <= instant) {
                     next = chrono.year().add(next, 1);
                     next = setDayOfMonthNext(chrono, next);
                 }
             } else {
                 next = setDayOfWeek(chrono, next);
-                if (next <= millis) {
+                if (next <= instant) {
                     next = chrono.year().add(next, 1);
                     next = chrono.monthOfYear().set(next, iMonthOfYear);
                     next = setDayOfMonthNext(chrono, next);
@@ -578,7 +583,7 @@ public long next(long millis, int standardOffset, int saveMillis) {
         /**
          * @param standardOffset standard offset just before previous recurrence
          */
-        public long previous(long millis, int standardOffset, int saveMillis) {
+        public long previous(long instant, int standardOffset, int saveMillis) {
             int offset;
             if (iMode == 'w') {
                 offset = standardOffset + saveMillis;
@@ -589,21 +594,23 @@ public long previous(long millis, int standardOffset, int saveMillis) {
             }
 
             // Convert from UTC to local time.
-            millis += offset;
+            instant += offset;
 
             Chronology chrono = ISOChronology.getInstanceUTC();
-            long prev = chrono.monthOfYear().set(millis, iMonthOfYear);
-            prev = chrono.millisOfDay().set(prev, iMillisOfDay);
+            long prev = chrono.monthOfYear().set(instant, iMonthOfYear);
+            // Be lenient with millisOfDay.
+            prev = chrono.millisOfDay().set(prev, 0);
+            prev = chrono.millisOfDay().add(prev, iMillisOfDay);
             prev = setDayOfMonthPrevious(chrono, prev);
 
             if (iDayOfWeek == 0) {
-                if (prev >= millis) {
+                if (prev >= instant) {
                     prev = chrono.year().add(prev, -1);
                     prev = setDayOfMonthPrevious(chrono, prev);
                 }
             } else {
                 prev = setDayOfWeek(chrono, prev);
-                if (prev >= millis) {
+                if (prev >= instant) {
                     prev = chrono.year().add(prev, -1);
                     prev = chrono.monthOfYear().set(prev, iMonthOfYear);
                     prev = setDayOfMonthPrevious(chrono, prev);
@@ -692,19 +699,19 @@ private long setDayOfMonthPrevious(Chronology chrono, long prev) {
             return prev;
         }
 
-        private long setDayOfMonth(Chronology chrono, long millis) {
+        private long setDayOfMonth(Chronology chrono, long instant) {
             if (iDayOfMonth >= 0) {
-                millis = chrono.dayOfMonth().set(millis, iDayOfMonth);
+                instant = chrono.dayOfMonth().set(instant, iDayOfMonth);
             } else {
-                millis = chrono.dayOfMonth().set(millis, 1);
-                millis = chrono.monthOfYear().add(millis, 1);
-                millis = chrono.dayOfMonth().add(millis, iDayOfMonth);
+                instant = chrono.dayOfMonth().set(instant, 1);
+                instant = chrono.monthOfYear().add(instant, 1);
+                instant = chrono.dayOfMonth().add(instant, iDayOfMonth);
             }
-            return millis;
+            return instant;
         }
 
-        private long setDayOfWeek(Chronology chrono, long millis) {
-            int dayOfWeek = chrono.dayOfWeek().get(millis);
+        private long setDayOfWeek(Chronology chrono, long instant) {
+            int dayOfWeek = chrono.dayOfWeek().get(instant);
             int daysToAdd = iDayOfWeek - dayOfWeek;
             if (daysToAdd != 0) {
                 if (iAdvance) {
@@ -716,9 +723,9 @@ private long setDayOfWeek(Chronology chrono, long millis) {
                         daysToAdd -= 7;
                     }
                 }
-                millis = chrono.dayOfWeek().add(millis, daysToAdd);
+                instant = chrono.dayOfWeek().add(instant, daysToAdd);
             }
-            return millis;
+            return instant;
         }
     }
 
@@ -747,15 +754,15 @@ public OfYear getOfYear() {
         /**
          * @param standardOffset standard offset just before next recurrence
          */
-        public long next(long millis, int standardOffset, int saveMillis) {
-            return iOfYear.next(millis, standardOffset, saveMillis);
+        public long next(long instant, int standardOffset, int saveMillis) {
+            return iOfYear.next(instant, standardOffset, saveMillis);
         }
 
         /**
          * @param standardOffset standard offset just before previous recurrence
          */
-        public long previous(long millis, int standardOffset, int saveMillis) {
-            return iOfYear.previous(millis, standardOffset, saveMillis);
+        public long previous(long instant, int standardOffset, int saveMillis) {
+            return iOfYear.previous(instant, standardOffset, saveMillis);
         }
 
         public String getNameKey() {
@@ -821,34 +828,34 @@ public int getSaveMillis() {
             return iRecurrence.getSaveMillis();
         }
 
-        public long next(final long millis, int standardOffset, int saveMillis) {
+        public long next(final long instant, int standardOffset, int saveMillis) {
             Chronology chrono = ISOChronology.getInstanceUTC();
 
             final int wallOffset = standardOffset + saveMillis;
-            long testMillis = millis;
+            long testInstant = instant;
 
             int year;
-            if (millis == Long.MIN_VALUE) {
+            if (instant == Long.MIN_VALUE) {
                 year = Integer.MIN_VALUE;
             } else {
-                year = chrono.year().get(millis + wallOffset);
+                year = chrono.year().get(instant + wallOffset);
             }
 
             if (year < iFromYear) {
-                // First advance millis to start of from year.
-                testMillis = chrono.year().set(0, iFromYear) - wallOffset;
+                // First advance instant to start of from year.
+                testInstant = chrono.year().set(0, iFromYear) - wallOffset;
                 // Back off one millisecond to account for next recurrence
                 // being exactly at the beginning of the year.
-                testMillis -= 1;
+                testInstant -= 1;
             }
 
-            long next = iRecurrence.next(testMillis, standardOffset, saveMillis);
+            long next = iRecurrence.next(testInstant, standardOffset, saveMillis);
 
-            if (next > millis) {
+            if (next > instant) {
                 year = chrono.year().get(next + wallOffset);
                 if (year > iToYear) {
                     // Out of range, return original value.
-                    next = millis;
+                    next = instant;
                 }
             }
 
@@ -1062,7 +1069,7 @@ public Transition firstTransition(final long firstMillis) {
          *
          * @param saveMillis savings before next transition
          */
-        public Transition nextTransition(final long millis, final int saveMillis) {
+        public Transition nextTransition(final long instant, final int saveMillis) {
             Chronology chrono = ISOChronology.getInstanceUTC();
 
             // Find next matching rule.
@@ -1072,8 +1079,8 @@ public Transition nextTransition(final long millis, final int saveMillis) {
             Iterator it = iRules.iterator();
             while (it.hasNext()) {
                 Rule rule = (Rule)it.next();
-                long next = rule.next(millis, iStandardOffset, saveMillis);
-                if (next <= millis) {
+                long next = rule.next(instant, iStandardOffset, saveMillis);
+                if (next <= instant) {
                     it.remove();
                     continue;
                 }
@@ -1161,44 +1168,74 @@ static DSTZone readFrom(DataInput in, String id) throws IOException {
             iEndRecurrence = endRecurrence;
         }
 
-        public String getNameKey(long millis) {
-            return findMatchingRecurrence(millis).getNameKey();
+        public String getNameKey(long instant) {
+            return findMatchingRecurrence(instant).getNameKey();
         }
 
-        public int getOffset(long millis) {
-            return iStandardOffset + findMatchingRecurrence(millis).getSaveMillis();
+        public int getOffset(long instant) {
+            return iStandardOffset + findMatchingRecurrence(instant).getSaveMillis();
         }
 
-        public int getStandardOffset(long millis) {
+        public int getStandardOffset(long instant) {
             return iStandardOffset;
         }
 
-        public long nextTransition(long millis) {
+        public boolean isFixed() {
+            return false;
+        }
+
+        public long nextTransition(long instant) {
             int standardOffset = iStandardOffset;
             Recurrence startRecurrence = iStartRecurrence;
             Recurrence endRecurrence = iEndRecurrence;
 
-            long start = startRecurrence.next
-                (millis, standardOffset, endRecurrence.getSaveMillis());
-            long end = endRecurrence.next
-                (millis, standardOffset, startRecurrence.getSaveMillis());
+            long start, end;
+
+            try {
+                start = startRecurrence.next
+                    (instant, standardOffset, endRecurrence.getSaveMillis());
+            } catch (IllegalArgumentException e) {
+                // Overflowed.
+                start = instant;
+            }
+
+            try {
+                end = endRecurrence.next
+                    (instant, standardOffset, startRecurrence.getSaveMillis());
+            } catch (IllegalArgumentException e) {
+                // Overflowed.
+                end = instant;
+            }
 
             return (start > end) ? end : start;
         }
 
-        public long previousTransition(long millis) {
-            // Increment in order to handle the case where millis is exactly at
+        public long previousTransition(long instant) {
+            // Increment in order to handle the case where instant is exactly at
             // a transition.
-            millis++;
+            instant++;
 
             int standardOffset = iStandardOffset;
             Recurrence startRecurrence = iStartRecurrence;
             Recurrence endRecurrence = iEndRecurrence;
 
-            long start = startRecurrence.previous
-                (millis, standardOffset, endRecurrence.getSaveMillis());
-            long end = endRecurrence.previous
-                (millis, standardOffset, startRecurrence.getSaveMillis());
+            long start, end;
+
+            try {
+                start = startRecurrence.previous
+                    (instant, standardOffset, endRecurrence.getSaveMillis());
+            } catch (IllegalArgumentException e) {
+                // Overflowed.
+                start = instant;
+            }
+
+            try {
+                end = endRecurrence.previous
+                    (instant, standardOffset, startRecurrence.getSaveMillis());
+            } catch (IllegalArgumentException e) {
+                // Overflowed.
+                end = instant;
+            }
 
             return ((start > end) ? start : end) - 1;
         }
@@ -1224,15 +1261,28 @@ public void writeTo(DataOutput out) throws IOException {
             iEndRecurrence.writeTo(out);
         }
 
-        private Recurrence findMatchingRecurrence(long millis) {
+        private Recurrence findMatchingRecurrence(long instant) {
             int standardOffset = iStandardOffset;
             Recurrence startRecurrence = iStartRecurrence;
             Recurrence endRecurrence = iEndRecurrence;
 
-            long start = startRecurrence.next
-                (millis, standardOffset, endRecurrence.getSaveMillis());
-            long end = endRecurrence.next
-                (millis, standardOffset, startRecurrence.getSaveMillis());
+            long start, end;
+
+            try {
+                start = startRecurrence.next
+                    (instant, standardOffset, endRecurrence.getSaveMillis());
+            } catch (IllegalArgumentException e) {
+                // Overflowed.
+                start = instant;
+            }
+
+            try {
+                end = endRecurrence.next
+                    (instant, standardOffset, startRecurrence.getSaveMillis());
+            } catch (IllegalArgumentException e) {
+                // Overflowed.
+                end = instant;
+            }
 
             return (start > end) ? startRecurrence : endRecurrence;
         }
@@ -1336,9 +1386,9 @@ static PrecalculatedZone readFrom(DataInput in, String id) throws IOException {
             iTailZone = tailZone;
         }
 
-        public String getNameKey(long millis) {
+        public String getNameKey(long instant) {
             long[] transitions = iTransitions;
-            int i = Arrays.binarySearch(transitions, millis);
+            int i = Arrays.binarySearch(transitions, instant);
             if (i >= 0) {
                 return iNameKeys[i];
             }
@@ -1352,12 +1402,12 @@ public String getNameKey(long millis) {
             if (iTailZone == null) {
                 return iNameKeys[i - 1];
             }
-            return iTailZone.getNameKey(millis);
+            return iTailZone.getNameKey(instant);
         }
 
-        public int getOffset(long millis) {
+        public int getOffset(long instant) {
             long[] transitions = iTransitions;
-            int i = Arrays.binarySearch(transitions, millis);
+            int i = Arrays.binarySearch(transitions, instant);
             if (i >= 0) {
                 return iWallOffsets[i];
             }
@@ -1371,12 +1421,12 @@ public int getOffset(long millis) {
             if (iTailZone == null) {
                 return iWallOffsets[i - 1];
             }
-            return iTailZone.getOffset(millis);
+            return iTailZone.getOffset(instant);
         }
 
-        public int getStandardOffset(long millis) {
+        public int getStandardOffset(long instant) {
             long[] transitions = iTransitions;
-            int i = Arrays.binarySearch(transitions, millis);
+            int i = Arrays.binarySearch(transitions, instant);
             if (i >= 0) {
                 return iStandardOffsets[i];
             }
@@ -1390,34 +1440,38 @@ public int getStandardOffset(long millis) {
             if (iTailZone == null) {
                 return iStandardOffsets[i - 1];
             }
-            return iTailZone.getStandardOffset(millis);
+            return iTailZone.getStandardOffset(instant);
+        }
+
+        public boolean isFixed() {
+            return false;
         }
 
-        public long nextTransition(long millis) {
+        public long nextTransition(long instant) {
             long[] transitions = iTransitions;
-            int i = Arrays.binarySearch(transitions, millis);
+            int i = Arrays.binarySearch(transitions, instant);
             i = (i >= 0) ? (i + 1) : ~i;
             if (i < transitions.length) {
                 return transitions[i];
             }
             if (iTailZone == null) {
-                return millis;
+                return instant;
             }
             long end = transitions[transitions.length - 1];
-            if (millis < end) {
-                millis = end;
+            if (instant < end) {
+                instant = end;
             }
-            return iTailZone.nextTransition(millis);
+            return iTailZone.nextTransition(instant);
         }
 
-        public long previousTransition(long millis) {
+        public long previousTransition(long instant) {
             long[] transitions = iTransitions;
-            int i = Arrays.binarySearch(transitions, millis);
+            int i = Arrays.binarySearch(transitions, instant);
             if (i >= 0) {
-                if (millis > Long.MIN_VALUE) {
-                    return millis - 1;
+                if (instant > Long.MIN_VALUE) {
+                    return instant - 1;
                 }
-                return millis;
+                return instant;
             }
             i = ~i;
             if (i < transitions.length) {
@@ -1427,11 +1481,11 @@ public long previousTransition(long millis) {
                         return prev - 1;
                     }
                 }
-                return millis;
+                return instant;
             }
             if (iTailZone != null) {
-                long prev = iTailZone.previousTransition(millis);
-                if (prev < millis) {
+                long prev = iTailZone.previousTransition(instant);
+                if (prev < instant) {
                     return prev;
                 }
             }
@@ -1439,7 +1493,7 @@ public long previousTransition(long millis) {
             if (prev > Long.MIN_VALUE) {
                 return prev - 1;
             }
-            return millis;
+            return instant;
         }
 
         public boolean equals(Object obj) {
diff --git a/JodaTime/src/java/org/joda/time/tz/DateTimeZonePermission.java b/JodaTime/src/java/org/joda/time/tz/DateTimeZonePermission.java
new file mode 100644
index 000000000..98a74fec0
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/tz/DateTimeZonePermission.java
@@ -0,0 +1,78 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+
+package org.joda.time.tz;
+
+/**
+ * DateTimeZonePermission allows global settings of DateTimeZone to be changed.
+ * The following permission target names are supported:
+ * <pre>
+ * setDefault        Allows a default DateTimeZone to be set
+ * setProvider       Allows a provider of DateTimeZone instances to be set
+ * setNameProvider   Allows a provider of DateTimeZone names to be set
+ * </pre>
+ * <p>
+ * DateTimeZonePermission is thread-safe and immutable.
+ *
+ * @author Brian S O'Neill
+ */
+public class DateTimeZonePermission extends java.security.BasicPermission {
+    public DateTimeZonePermission(String name) {
+        super(name);
+    }
+
+    public DateTimeZonePermission(String name, String actions) {
+        super(name, actions);
+    }
+}
diff --git a/JodaTime/src/java/org/joda/time/tz/DefaultNameProvider.java b/JodaTime/src/java/org/joda/time/tz/DefaultNameProvider.java
index a414ee62d..655cd44d4 100644
--- a/JodaTime/src/java/org/joda/time/tz/DefaultNameProvider.java
+++ b/JodaTime/src/java/org/joda/time/tz/DefaultNameProvider.java
@@ -61,6 +61,8 @@
 /**
  * The default name provider acquires localized names from
  * {@link DateFormatSymbols java.text.DateFormatSymbols}.
+ * <p>
+ * DefaultNameProvider is thread-safe and immutable.
  *
  * @author Brian S O'Neill
  */
diff --git a/JodaTime/src/java/org/joda/time/tz/FixedDateTimeZone.java b/JodaTime/src/java/org/joda/time/tz/FixedDateTimeZone.java
index 61dba5a7f..58aa89f88 100644
--- a/JodaTime/src/java/org/joda/time/tz/FixedDateTimeZone.java
+++ b/JodaTime/src/java/org/joda/time/tz/FixedDateTimeZone.java
@@ -58,6 +58,8 @@
 
 /**
  * Basic DateTimeZone implementation that has a fixed name key and offsets.
+ * <p>
+ * FixedDateTimeZone is thread-safe and immutable.
  * 
  * @author Brian S O'Neill
  */
@@ -74,28 +76,32 @@ public FixedDateTimeZone(String id, String nameKey,
         iStandardOffset = standardOffset;
     }
 
-    public String getNameKey(long millis) {
+    public String getNameKey(long instant) {
         return iNameKey;
     }
 
-    public int getOffset(long millis) {
+    public int getOffset(long instant) {
         return iWallOffset;
     }
 
-    public int getStandardOffset(long millis) {
+    public int getStandardOffset(long instant) {
         return iStandardOffset;
     }
 
-    public int getOffsetFromLocal(long millisLocal) {
+    public int getOffsetFromLocal(long instantLocal) {
         return iWallOffset;
     }
 
-    public long nextTransition(long millis) {
-        return millis;
+    public boolean isFixed() {
+        return true;
     }
 
-    public long previousTransition(long millis) {
-        return millis;
+    public long nextTransition(long instant) {
+        return instant;
+    }
+
+    public long previousTransition(long instant) {
+        return instant;
     }
 
     public boolean equals(Object obj) {
diff --git a/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java b/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java
index 69fefeff2..9442edee2 100644
--- a/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java
+++ b/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java
@@ -55,13 +55,14 @@
 package org.joda.time.tz;
 
 import java.io.BufferedReader;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.ObjectOutputStream;
 import java.io.OutputStream;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -79,6 +80,7 @@
 import org.joda.time.MutableDateTime;
 import org.joda.time.format.DateTimeParser;
 import org.joda.time.format.ISODateTimeFormat;
+import org.joda.time.chrono.LenientChronology;
 import org.joda.time.chrono.iso.ISOChronology;
 
 /**
@@ -86,10 +88,13 @@
  * in the database. {@link DateTimeZoneBuilder} is used to construct and encode
  * compiled data files. {@link ZoneInfoProvider} loads the encoded files and
  * converts them back into {@link DateTimeZone} objects.
- *
- * <p>Although this tool is similar to zic, the binary formats are not
+ * <p>
+ * Although this tool is similar to zic, the binary formats are not
  * compatible. The latest Olson database files may be obtained
  * <a href="http://www.twinsun.com/tz/tz-link.htm">here</a>.
+ * <p>
+ * ZoneInfoCompiler is mutable and not thread-safe, although the main method
+ * may be safely invoked by multiple threads.
  *
  * @author Brian S O'Neill
  */
@@ -128,6 +133,79 @@ private static void printUsage() {
             ("Usage: java ZoneInfoCompiler [-d outputDirectory] sourceFile ...");
     }
 
+    /**
+     * @param zimap maps string ids to DateTimeZone objects.
+     */
+    static void writeZoneInfoMap(DataOutputStream dout, Map zimap) throws IOException {
+        // Build the string pool.
+        Map idToIndex = new HashMap(zimap.size());
+        TreeMap indexToId = new TreeMap();
+
+        Iterator it = zimap.entrySet().iterator();
+        short count = 0;
+        while (it.hasNext()) {
+            Map.Entry entry = (Map.Entry)it.next();
+            String id = (String)entry.getKey();
+            if (!idToIndex.containsKey(id)) {
+                Short index = new Short(count);
+                idToIndex.put(id, index);
+                indexToId.put(index, id);
+                if (++count == 0) {
+                    throw new InternalError("Too many time zone ids");
+                }
+            }
+            id = ((DateTimeZone)entry.getValue()).getID();
+            if (!idToIndex.containsKey(id)) {
+                Short index = new Short(count);
+                idToIndex.put(id, index);
+                indexToId.put(index, id);
+                if (++count == 0) {
+                    throw new InternalError("Too many time zone ids");
+                }
+            }
+        }
+
+        // Write the string pool, ordered by index.
+        dout.writeShort(indexToId.size());
+        it = indexToId.values().iterator();
+        while (it.hasNext()) {
+            dout.writeUTF((String)it.next());
+        }
+
+        // Write the mappings.
+        dout.writeShort(zimap.size());
+        it = zimap.entrySet().iterator();
+        while (it.hasNext()) {
+            Map.Entry entry = (Map.Entry)it.next();
+            String id = (String)entry.getKey();
+            dout.writeShort(((Short)idToIndex.get(id)).shortValue());
+            id = ((DateTimeZone)entry.getValue()).getID();
+            dout.writeShort(((Short)idToIndex.get(id)).shortValue());
+        }
+    }
+
+    /**
+     * @param zimap gets filled with string id to string id mappings
+     */
+    static void readZoneInfoMap(DataInputStream din, Map zimap) throws IOException {
+        // Read the string pool.
+        int size = din.readUnsignedShort();
+        String[] pool = new String[size];
+        for (int i=0; i<size; i++) {
+            pool[i] = din.readUTF().intern();
+        }
+
+        // Read the mappings.
+        size = din.readUnsignedShort();
+        for (int i=0; i<size; i++) {
+            try {
+                zimap.put(pool[din.readUnsignedShort()], pool[din.readUnsignedShort()]);
+            } catch (ArrayIndexOutOfBoundsException e) {
+                throw new IOException("Corrupt zone info map");
+            }
+        }
+    }
+
     static int parseYear(String str, int def) {
         str = str.toLowerCase();
         if (str.equals("minimum") || str.equals("min")) {
@@ -155,7 +233,7 @@ static String parseOptional(String str) {
     }
 
     static int parseTime(String str) {
-        Chronology chrono = ISOChronology.getInstanceUTC();
+        Chronology chrono = new LenientChronology(ISOChronology.getInstanceUTC());
         DateTimeParser p = ISODateTimeFormat
             .getInstance(chrono)
             .hourMinuteSecondFraction();
@@ -361,24 +439,19 @@ public Map compile(String outputDir, String[] sources) throws IOException {
         }
 
         if (dir != null) {
-            Map zimap = new TreeMap();
-            Iterator it = map.entrySet().iterator();
-            while (it.hasNext()) {
-                Map.Entry entry = (Map.Entry)it.next();
-                String id = (String)entry.getKey();
-                DateTimeZone tz = (DateTimeZone)entry.getValue();
-                zimap.put(id, tz.getID());
-            }
-
             System.out.println("Writing ZoneInfoMap");
             File file = new File(dir, "ZoneInfoMap");
             if (!file.getParentFile().exists()) {
                 file.getParentFile().mkdirs();
             }
+
             OutputStream out = new FileOutputStream(file);
-            ObjectOutputStream oout = new ObjectOutputStream(out);
-            oout.writeObject(zimap);
-            oout.close();
+            DataOutputStream dout = new DataOutputStream(out);
+            // Sort and filter out any duplicates that match case.
+            Map zimap = new TreeMap(String.CASE_INSENSITIVE_ORDER);
+            zimap.putAll(map);
+            writeZoneInfoMap(dout, zimap);
+            dout.close();
         }
 
         return map;
diff --git a/JodaTime/src/java/org/joda/time/tz/ZoneInfoProvider.java b/JodaTime/src/java/org/joda/time/tz/ZoneInfoProvider.java
index 22eaaf1a6..978261b2c 100644
--- a/JodaTime/src/java/org/joda/time/tz/ZoneInfoProvider.java
+++ b/JodaTime/src/java/org/joda/time/tz/ZoneInfoProvider.java
@@ -54,35 +54,36 @@
 
 package org.joda.time.tz;
 
+import java.io.DataInputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.ObjectInputStream;
 import java.lang.ref.SoftReference;
 import java.util.Collections;
 import java.util.Map;
 import java.util.Set;
+import java.util.TreeMap;
 
 import org.joda.time.DateTimeZone;
 
 /**
  * ZoneInfoProvider loads compiled data files as generated by
  * {@link ZoneInfoCompiler}.
+ * <p>
+ * ZoneInfoProvider is thread-safe and publicly immutable.
  *
  * @author Brian S O'Neill
  */
 public class ZoneInfoProvider implements Provider {
     private static Map loadZoneInfoMap(InputStream in) throws IOException {
-        ObjectInputStream oin = new ObjectInputStream(in);
-        Map map;
+        Map map = new TreeMap(String.CASE_INSENSITIVE_ORDER);
+        DataInputStream din = new DataInputStream(in);
         try {
-            map = (Map)oin.readObject();
-        } catch (ClassNotFoundException e) {
-            throw new IOException(e.toString());
+            ZoneInfoCompiler.readZoneInfoMap(din, map);
         } finally {
             try {
-                oin.close();
+                din.close();
             } catch (IOException e) {
             }
         }
@@ -92,7 +93,7 @@ private static Map loadZoneInfoMap(InputStream in) throws IOException {
 
     private final File iFileDir;
     private final String iResourcePath;
-    private ClassLoader iLoader;
+    private final ClassLoader iLoader;
 
     // Maps ids to strings or SoftReferences to DateTimeZones.
     private final Map iZoneInfoMap;
@@ -115,6 +116,7 @@ public ZoneInfoProvider(File fileDir) throws IOException {
 
         iFileDir = fileDir;
         iResourcePath = null;
+        iLoader = null;
 
         iZoneInfoMap = loadZoneInfoMap(openResource("ZoneInfoMap"));
     }
@@ -127,8 +129,7 @@ public ZoneInfoProvider(File fileDir) throws IOException {
      * @throws IOException if directory or map file cannot be read
      */
     public ZoneInfoProvider(String resourcePath) throws IOException {
-        this(resourcePath, null);
-        iLoader = getClass().getClassLoader();
+        this(resourcePath, null, false);
     }
 
     /**
@@ -141,6 +142,17 @@ public ZoneInfoProvider(String resourcePath) throws IOException {
      */
     public ZoneInfoProvider(String resourcePath, ClassLoader loader)
         throws IOException
+    {
+        this(resourcePath, loader, true);
+    }
+
+    /**
+     * @param favorSystemLoader when true, use the system class loader if
+     * loader null. When false, use the current class loader if loader is null.
+     */
+    private ZoneInfoProvider(String resourcePath,
+                             ClassLoader loader, boolean favorSystemLoader) 
+        throws IOException
     {
         if (resourcePath == null) {
             throw new IllegalArgumentException("No resource path provided");
@@ -151,6 +163,11 @@ public ZoneInfoProvider(String resourcePath, ClassLoader loader)
 
         iFileDir = null;
         iResourcePath = resourcePath;
+
+        if (loader == null && !favorSystemLoader) {
+            loader = getClass().getClassLoader();
+        }
+
         iLoader = loader;
 
         iZoneInfoMap = loadZoneInfoMap(openResource("ZoneInfoMap"));
@@ -214,7 +231,12 @@ private InputStream openResource(String name) throws IOException {
                 in = ClassLoader.getSystemResourceAsStream(path);
             }
             if (in == null) {
-                throw new IOException("Resource not found: " + path);
+                StringBuffer buf = new StringBuffer(40);
+                buf.append("Resource not found: \"");
+                buf.append(path);
+                buf.append("\" ClassLoader: ");
+                buf.append(iLoader != null ? iLoader.toString() : "system");
+                throw new IOException(buf.toString());
             }
         }
         return in;
diff --git a/JodaTime/src/java/org/joda/time/tz/package.html b/JodaTime/src/java/org/joda/time/tz/package.html
index 194f10ead..01814e75f 100644
--- a/JodaTime/src/java/org/joda/time/tz/package.html
+++ b/JodaTime/src/java/org/joda/time/tz/package.html
@@ -1,8 +1,68 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<html>
+<head>
+<title>org.joda.time.tz package</title>
+<!--
+
+   Joda Software License, Version 1.0
+  
+  
+   Copyright (c) 2001-03 Stephen Colebourne.
+   All rights reserved.
+  
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions
+   are met:
+  
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+  
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+  
+   3. The end-user documentation included with the redistribution,
+      if any, must include the following acknowledgment:
+         "This product includes software developed by the
+          Joda project (http://www.joda.org/)."
+      Alternately, this acknowledgment may appear in the software itself,
+      if and wherever such third-party acknowledgments normally appear.
+  
+   4. The name "Joda" must not be used to endorse or promote products
+      derived from this software without prior written permission. For
+      written permission, please contact licence@joda.org.
+  
+   5. Products derived from this software may not be called "Joda",
+      nor may "Joda" appear in their name, without prior written
+      permission of the Joda project.
+  
+   THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+   USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+   OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+   SUCH DAMAGE.
+   ====================================================================
+  
+   This software consists of voluntary contributions made by many
+   individuals on behalf of the Joda project and was originally
+   created by Stephen Colebourne <scolebourne@joda.org>. For more
+   information on the Joda project, please see <http://www.joda.org/>.
+
+-->
+</head>
 <body>
-<h3>Time zone implementation</h3>
 <p>
-This package contains classes used to implement time zones.
-<a href="../DateTimeZone.html">DateTimeZone</a> uses these classes for
-supporting time zones, but most applications need not use them directly.
+Provides support for implementing time zones. {@link org.joda.time.DateTimeZone}
+uses these classes internally, but most applications need not use them
+directly.
 </p>
 </body>
+</html>
diff --git a/JodaTime/src/java/org/joda/time/tz/src/Readme.txt b/JodaTime/src/java/org/joda/time/tz/src/Readme.txt
index 7ca44fb14..1f03610f4 100644
--- a/JodaTime/src/java/org/joda/time/tz/src/Readme.txt
+++ b/JodaTime/src/java/org/joda/time/tz/src/Readme.txt
@@ -1,2 +1,2 @@
 The data files in this directory were obtained from the public tz database,
-http://www.twinsun.com/tz/tz-link.htm, version 2003a.
+http://www.twinsun.com/tz/tz-link.htm, version 2003d.
diff --git a/JodaTime/src/java/org/joda/time/tz/src/asia b/JodaTime/src/java/org/joda/time/tz/src/asia
index 901a332df..6a1dd7699 100644
--- a/JodaTime/src/java/org/joda/time/tz/src/asia
+++ b/JodaTime/src/java/org/joda/time/tz/src/asia
@@ -1,4 +1,4 @@
-# @(#)asia	7.71
+# @(#)asia	7.72
 
 # This data is by no means authoritative; if you think you know better,
 # go ahead and edit the file (and please send any changes to
@@ -736,44 +736,19 @@ Zone	Asia/Jerusalem	2:20:56 -	LMT	1880
 			2:20:40	-	JMT	1918	# Jerusalem Mean Time?
 			2:00	Zion	I%sT
 
-# From Ephraim Silverberg (2002-07-07):
+# From Ephraim Silverberg (2003-03-23):
 #
-# The Israeli government today adopted a proposal by Minister of Interior
-# Eli Yishai to shorten the period of Daylight Savings Time for the year
-# 2002 (only -- the dates for 2003 and 2004 are, so far, unaffected).
+# Minister of Interior Poraz has announced that he will respect the law
+# passed in July 2000 (proposed at the time jointly by himself and
+# then-MK David Azulai [Shas]) fixing the dates for 2000-2004.  Hence,
+# the dates for 2003 and 2004 remain unchanged....
 #
-# The proposed date to Daylight Savings Time is September 13, 2002 instead
-# of the current date: October 7, 2002.  The hour of changeover has not
-# yet been decided.
-#
-# (2002-07-10):
-# While today the Knesset passed the initial proposal to reduce DST by
-# some three weeks, a new compromise is being worked out between
-# Minister of Justice Meir Sheetrit and Minister of Interior Eli
-# Yishai to revert to standard time for a period of 48-96 _hours_
-# (sic) around the Yom Kippur fast day (September 15-16) and then go
-# *back* to DST until the end of October.  The details of the proposal
-# have yet to be worked out, but the second and final readings of the
-# bill have until July 24 to pass.
-#
-# (2002-07-25):
-# Thanks go to Yitschak Goldberg from E&M for bringing this (Hebrew) article
-# to my attention:
-#
-#	http://www.ynet.co.il/articles/0,7340,L-2019315,00.html
-#
-# Hence, the proposal to shorten DST was withdrawn yesterday and the timezone
-# files that have been in effect since July 2000 are still valid for all of
-# 2002.
-#
-# Please note that the article mentions that the Shas MK's intend to
-# bring up their amendment for future years (2003 and beyond).  What this
-# means exactly is anyone's guess since there are no set dates yet beyond
-# 2004 and the end day set for 2003 and 2004 is already the 7th of Tishrei
-# (i.e. before the fast of Yom Kippur).  The only thing they may want to
-# change is the start date of DST in 2003 from Mar.28.03 (24th of Adar II)
-# to Apr.18.03 (16th of Nisan) so that the Passover Seder will take place
-# during Standard Time.  The start date for 2004 is already Nisan 16th.
+# As far as 2005 and beyond, no dates have been set.  However, the
+# minister has mentioned that he wishes to propose to move Israel's
+# timezone in 2005 from GMT+2 to GMT+3 and upon that have DST during
+# the summer months (i.e. GMT+4).  However, no legislation in this
+# direction is expected until the latter part of 2004 which is a long
+# time off in terms of Israeli politics.
 
 
 
@@ -926,7 +901,7 @@ Zone	Asia/Aqtau	3:21:04	-	LMT	1924 May  2
 			6:00	-	SHET	1982 Apr  1
 			5:00 RussiaAsia	SHE%sT	1991
 			5:00	-	SHET	1991 Dec 16 # independence
-			5:00 RussiaAsia	AQT%sT	1995 Sep lastSun # Aqtau Time
+			5:00 RussiaAsia	AQT%sT	1995 Mar lastSun 2:00 # Aqtau Time
 			4:00 RussiaAsia	AQT%sT
 # West Kazakhstan
 Zone	Asia/Oral	3:25:24	-	LMT	1924 May  2 # or Ural'sk
diff --git a/JodaTime/src/java/org/joda/time/tz/src/australasia b/JodaTime/src/java/org/joda/time/tz/src/australasia
index 594dc699d..f265eece9 100644
--- a/JodaTime/src/java/org/joda/time/tz/src/australasia
+++ b/JodaTime/src/java/org/joda/time/tz/src/australasia
@@ -1,4 +1,4 @@
-# @(#)australasia	7.68
+# @(#)australasia	7.69
 # This file also includes Pacific islands.
 
 # Notes are at the end of this file
@@ -297,45 +297,37 @@ Zone	Pacific/Noumea	11:05:48 -	LMT	1912 Jan 13
 ###############################################################################
 
 # New Zealand
-#
-# From Paul Eggert (2002-10-23):
-# The Department of Internal Affairs (DIA) maintains a brief history;
-# see tz-link.htm for the full reference.
-#
-# Shanks gives 1868 for the introduction of standard time; go with the
-# DIA's more-precise 1868-11-02.  The DIA says that clocks were
-# advanced by half an hour in 1941; go with Shanks's more-precise
-# 1940-09-29 02:00.  The DIA says that starting in 1933 DST began the
-# first Sunday in September; go with Shanks's last Sunday starting in
-# 1934.
 
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
-# Shanks gives 1927 Nov 6 - 1928 Mar 4, 1928 Oct 14 - 1929 Mar 17,
-# 1929 Oct 13 - 1930 Mar 16; go with Whitman.
-Rule	NZ	1927	only	-	Nov	26	2:00	0:30	HD
-Rule	NZ	1928	1929	-	Mar	Sun>=1	2:00	0	S
-Rule	NZ	1928	only	-	Nov	 4	2:00	0:30	HD
-Rule	NZ	1929	only	-	Oct	30	2:00	0:30	HD
-Rule	NZ	1930	1933	-	Mar	Sun>=15	2:00	0	S
-Rule	NZ	1930	1933	-	Oct	Sun>=8	2:00	0:30	HD
-# Whitman says DST went on and off during war years, and the base UT offset
-# didn't change until 1945 Apr 30; go with Shanks.
-Rule	NZ	1934	1940	-	Apr	lastSun	2:00	0	S
-Rule	NZ	1934	1939	-	Sep	lastSun	2:00	0:30	HD
+Rule	NZ	1927	only	-	Nov	 6	2:00	1:00	S
+Rule	NZ	1928	only	-	Mar	 4	2:00	0	M
+Rule	NZ	1928	1933	-	Oct	Sun>=8	2:00	0:30	S
+Rule	NZ	1929	1933	-	Mar	Sun>=15	2:00	0	M
+Rule	NZ	1934	1940	-	Apr	lastSun	2:00	0	M
+Rule	NZ	1934	1940	-	Sep	lastSun	2:00	0:30	S
+Rule	NZ	1946	only	-	Jan	 1	0:00	0	S
+# Since 1957 Chatham has been 45 minutes ahead of NZ, but there's no
+# convenient notation for this so we must duplicate the Rule lines.
 Rule	NZ	1974	only	-	Nov	Sun>=1	2:00s	1:00	D
+Rule	Chatham	1974	only	-	Nov	Sun>=1	2:45s	1:00	D
 Rule	NZ	1975	only	-	Feb	lastSun	2:00s	0	S
+Rule	Chatham	1975	only	-	Feb	lastSun	2:45s	0	S
 Rule	NZ	1975	1988	-	Oct	lastSun	2:00s	1:00	D
+Rule	Chatham	1975	1988	-	Oct	lastSun	2:45s	1:00	D
 Rule	NZ	1976	1989	-	Mar	Sun>=1	2:00s	0	S
+Rule	Chatham	1976	1989	-	Mar	Sun>=1	2:45s	0	S
 Rule	NZ	1989	only	-	Oct	Sun>=8	2:00s	1:00	D
+Rule	Chatham	1989	only	-	Oct	Sun>=8	2:45s	1:00	D
 Rule	NZ	1990	max	-	Oct	Sun>=1	2:00s	1:00	D
-Rule	NZ	1990	max	-	Mar	Sun>=15	2:00s	0	S
 Rule	Chatham	1990	max	-	Oct	Sun>=1	2:45s	1:00	D
-Rule	Chatham	1991	max	-	Mar	Sun>=15	2:45s	0	S
+Rule	NZ	1990	max	-	Mar	Sun>=15	2:00s	0	S
+Rule	Chatham	1990	max	-	Mar	Sun>=15	2:45s	0	S
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone Pacific/Auckland	11:39:04 -	LMT	1868 Nov  2
-			11:30	NZ	NZ%sT	1940 Sep 29 2:00
+			11:30	NZ	NZ%sT	1946 Jan  1
 			12:00	NZ	NZ%sT
-Zone Pacific/Chatham	12:45	Chatham	CHA%sT
+Zone Pacific/Chatham	12:13:48 -	LMT	1957 Jan  1
+			12:45	Chatham	CHA%sT
 
 
 # Auckland Is
@@ -443,6 +435,8 @@ Zone Pacific/Johnston	-10:00	-	HST
 
 # Midway
 Zone Pacific/Midway	-11:49:28 -	LMT	1901
+			-11:00	-	NST	1956 Jun  3
+			-11:00	1:00	NDT	1956 Sep  2
 			-11:00	-	NST	1967 Apr	# N=Nome
 			-11:00	-	BST	1983 Nov 30	# B=Bering
 			-11:00	-	SST			# S=Samoa
@@ -513,7 +507,8 @@ Zone	Pacific/Wallis	12:15:20 -	LMT	1901
 #	 10:00	EST EST	Eastern Australia
 #	 10:00	ChST	Chamorro
 #	 10:30	LHST LHST Lord Howe*
-#	 12:00	NZST NZDT New Zealand
+#	 11:30	NZMT NZST New Zealand through 1945
+#	 12:00	NZST NZDT New Zealand 1946-present
 #	 12:45	CHAST CHADT Chatham*
 #	-11:00	SST	Samoa
 #	-10:00	HST	Hawaii
@@ -1067,11 +1062,14 @@ Zone	Pacific/Wallis	12:15:20 -	LMT	1901
 # time on both the first Sunday in October and the third Sunday in March.
 # As with Australia, we'll assume the tradition is 2:00s, not 2:00.
 #
-# From Paul Eggert (1999-10-29):
-# Shanks gives no time data for Chatham; usno1989 says it's +12:45,
-# usno1995 says it's +12:45/+13:45, and IATA SSIM (1991/1999)
-# gives the NZ rules but with transitions at 2:45 local standard time.
-# Guess that they have been in lock-step with NZ since 1990.
+# From Paul Eggert (2003-05-26):
+# The Department of Internal Affairs (DIA) maintains a brief history,
+# as does Carol Squires; see tz-link.htm for the full references.
+# Use these sources in preference to Shanks.
+#
+# For Chatham, IATA SSIM (1991/1999) gives the NZ rules but with
+# transitions at 2:45 local standard time; this confirms that Chatham
+# is always exactly 45 minutes ahead of Auckland.
 
 ###############################################################################
 
@@ -1154,6 +1152,23 @@ Zone	Pacific/Wallis	12:15:20 -	LMT	1901
 # We don't know when Kosrae switched from UTC+12; assume January 1 for now.
 
 
+# Midway
+
+# From Charles T O'Connor, KMTH DJ (1956),
+# quoted in the KTMH section of the Radio Heritage Collection
+# <http://radiodx.com/spdxr/KMTH.htm> (2002-12-31):
+# For the past two months we've been on what is known as Daylight
+# Saving Time.  This time has put us on air at 5am in the morning,
+# your time down there in New Zealand.  Starting September 2, 1956
+# we'll again go back to Standard Time.  This'll mean that we'll go to
+# air at 6am your time.
+#
+# From Paul Eggert (2003-03-23):
+# We don't know the date of that quote, but we'll guess they
+# started DST on June 3.  Possibly DST was observed other years
+# in Midway, but we have no record of it.
+
+
 # Pitcairn
 
 # From Rives McDow (1999-11-08):
@@ -1277,6 +1292,24 @@ Zone	Pacific/Wallis	12:15:20 -	LMT	1901
 # From Pulu 'Anau (2002-11-05):
 # The law was for 3 years, supposedly to get renewed.  It wasn't.
 
+
+# Wake
+
+# From Vernice Anderson, Personal Secretary to Philip Jessup,
+# US Ambassador At Large (oral history interview, 1971-02-02):
+#
+# Saturday, the 14th [of October, 1950] -- ...  The time was all the
+# more confusing at that point, because we had crossed the
+# International Date Line, thus getting two Sundays.  Furthermore, we
+# discovered that Wake Island had two hours of daylight saving time
+# making calculation of time in Washington difficult if not almost
+# impossible.
+#
+# http://www.trumanlibrary.org/wake/meeting.htm
+
+# From Paul Eggert (2003-03-23):
+# We have no other report of DST in Wake Island, so omit this info for now.
+
 ###############################################################################
 
 # The International Date Line
diff --git a/JodaTime/src/java/org/joda/time/tz/src/backward b/JodaTime/src/java/org/joda/time/tz/src/backward
index 1a2094f5d..766a1e32d 100644
--- a/JodaTime/src/java/org/joda/time/tz/src/backward
+++ b/JodaTime/src/java/org/joda/time/tz/src/backward
@@ -1,4 +1,4 @@
-# @(#)backward	7.23
+# @(#)backward	7.24
 
 # This file provides links between current names for time zones
 # and their old names.  Many names changed in late 1993.
@@ -36,7 +36,7 @@ Link	America/Manaus		Brazil/West
 Link	America/Halifax		Canada/Atlantic
 Link	America/Winnipeg	Canada/Central
 Link	America/Regina		Canada/East-Saskatchewan
-Link	America/Montreal	Canada/Eastern
+Link	America/Toronto		Canada/Eastern
 Link	America/Edmonton	Canada/Mountain
 Link	America/St_Johns	Canada/Newfoundland
 Link	America/Vancouver	Canada/Pacific
diff --git a/JodaTime/src/java/org/joda/time/tz/src/europe b/JodaTime/src/java/org/joda/time/tz/src/europe
index 81572e9b3..d1e7178e8 100644
--- a/JodaTime/src/java/org/joda/time/tz/src/europe
+++ b/JodaTime/src/java/org/joda/time/tz/src/europe
@@ -1,4 +1,4 @@
-# @(#)europe	7.83
+# @(#)europe	7.84
 
 # This data is by no means authoritative; if you think you know better,
 # go ahead and edit the file (and please send any changes to
@@ -24,6 +24,10 @@
 #	Whitman Publishing Co, 2 Niagara Av, Ealing, London (undated),
 #	which I found in the UCLA library.
 #
+#	<a href="http://www.pettswoodvillage.co.uk/Daylight_Savings_William_Willett.pdf">
+#	William Willett, The Waste of Daylight, 19th edition
+#	</a> (1914-03)
+#
 #	Brazil's Departamento Servico da Hora (DSH),
 #	<a href="http://pcdsh01.on.br/HISTHV.htm">
 #	History of Summer Time
@@ -125,7 +129,7 @@
 # transition date for London, namely 1847-12-01.  We don't know as much
 # about Dublin, so we use 1880-08-02, the legal transition time.
 
-# From Paul Eggert (1999-01-30):
+# From Paul Eggert (2003-07-29):
 # Summer Time was first seriously proposed by William Willett (1857-1915),
 # a London builder and member of the Royal Astronomical Society
 # who circulated a pamphlet ``The Waste of Daylight'' (1907)
@@ -133,14 +137,24 @@
 # and retarding them by the same amount on four Sundays in September.
 # A bill was drafted in 1909 and introduced in Parliament several times,
 # but it met with ridicule and opposition, especially from farming interests.
-# One-hour Summer Time was eventually adopted as a wartime measure in 1916.
-# See:
-# <a href="http://www.the-times.co.uk/news/pages/tim/2000/05/18/x-timcrtcrt01011.html">
-# Summer Time Arrives Early, The Times (2000-05-18)
-# </a>
-# A monument was erected in 1927 to Willett, in an open space in a 45-acre wood
-# near Chiselhurst, Kent that was purchased by popular subscription and open
-# to the public.
+# Later editions of the pamphlet proposed one-hour summer time, and
+# it was eventually adopted as a wartime measure in 1916.
+# See: Summer Time Arrives Early, The Times (2000-05-18).
+# A monument to Willett was unveiled on 1927-05-21, in an open space in
+# a 45-acre wood near Chiselhurst, Kent that was purchased by popular
+# subscription and open to the public.  On the south face of the monolith,
+# designed by G. W. Miller, is the the William Willett Memorial Sundial,
+# which is permanently set to Summer Time.
+
+# From Winston Churchill (1934-04-28):
+# It is one of the paradoxes of history that we should owe the boon of
+# summer time, which gives every year to the people of this country
+# between 160 and 170 hours more daylight leisure, to a war which
+# plunged Europe into darkness for four years, and shook the
+# foundations of civilization throughout the world.
+#	-- <a href="http://www.winstonchurchill.org/fh114willett.htm">
+#	"A Silent Toast to William Willett", Pictorial Weekly
+#	</a>
 
 # From Paul Eggert (1996-09-03):
 # The OED Supplement says that the English originally said ``Daylight Saving''
@@ -1323,7 +1337,7 @@ Zone	Europe/Riga	1:36:24	-	LMT	1880
 			2:00	1:00	EEST	1989 Sep lastSun 2:00s
 			2:00	Latvia	EE%sT	1997 Jan 21
 			2:00	EU	EE%sT	2000 Feb 29
-			2:00	-	EET	2001
+			2:00	-	EET	2001 Jan  2
 			2:00	EU	EE%sT
 
 # Liechtenstein
@@ -1750,8 +1764,10 @@ Rule	Port	1980	only	-	Mar	lastSun	 0:00s	1:00	S
 Rule	Port	1981	1982	-	Mar	lastSun	 1:00s	1:00	S
 Rule	Port	1983	only	-	Mar	lastSun	 2:00s	1:00	S
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
+# Shanks says that the transition from LMT to WET occurred 1911-05-24;
+# Willett says 1912-01-01.  Go with Willett.
 Zone	Europe/Lisbon	-0:36:32 -	LMT	1884
-			-0:36:32 -	LMT	1911 May 24   # Lisbon Mean Time
+			-0:36:32 -	LMT	1912 Jan  1  # Lisbon Mean Time
 			 0:00	Port	WE%sT	1966 Apr  3 2:00
 			 1:00	-	CET	1976 Sep 26 1:00
 			 0:00	Port	WE%sT	1983 Sep 25 1:00s
diff --git a/JodaTime/src/java/org/joda/time/tz/src/northamerica b/JodaTime/src/java/org/joda/time/tz/src/northamerica
index e11eaa489..6b7674778 100644
--- a/JodaTime/src/java/org/joda/time/tz/src/northamerica
+++ b/JodaTime/src/java/org/joda/time/tz/src/northamerica
@@ -1,4 +1,4 @@
-# @(#)northamerica	7.62
+# @(#)northamerica	7.63
 # also includes Central America and the Caribbean
 
 # This data is by no means authoritative; if you think you know better,
@@ -685,9 +685,15 @@ Link	Pacific/Honolulu	HST
 # Except where otherwise noted, Shanks is the source for entries through 1990,
 # and IATA SSIM is the source for entries after 1990.
 #
-# Another source occasionally used is Edward W. Whitman, World Time Differences,
-# Whitman Publishing Co, 2 Niagara Av, Ealing, London (undated), which
-# I found in the UCLA library.
+# Other sources occasionally used include:
+#
+#	Edward W. Whitman, World Time Differences,
+#	Whitman Publishing Co, 2 Niagara Av, Ealing, London (undated),
+#	which I found in the UCLA library.
+#
+#	<a href="http://www.pettswoodvillage.co.uk/Daylight_Savings_William_Willett.pdf">
+#	William Willett, The Waste of Daylight, 19th edition
+#	</a> (1914-03)
 #
 # See the `europe' file for Greenland.
 
@@ -743,7 +749,8 @@ Link	Pacific/Honolulu	HST
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 Rule	Canada	1918	only	-	Apr	14	2:00	1:00	D
 Rule	Canada	1918	only	-	Oct	31	2:00	0	S
-Rule	Canada	1942	only	-	Feb	 9	2:00	1:00	W
+Rule	Canada	1942	only	-	Feb	 9	2:00	1:00	W # War
+Rule	Canada	1945	only	-	Aug	14	23:00u	1:00	P # Peace
 Rule	Canada	1945	only	-	Sep	30	2:00	0	S
 Rule	Canada	1974	1986	-	Apr	lastSun	2:00	1:00	D
 Rule	Canada	1974	max	-	Oct	lastSun	2:00	0	S
@@ -759,27 +766,20 @@ Rule	Canada	1987	max	-	Apr	Sun>=1	2:00	1:00	D
 # but excluding, say, Black Tickle.
 
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
-Rule	StJohns	1917	1918	-	Apr	Sun>=8	2:00	1:00	D
+Rule	StJohns	1917	only	-	Apr	 8	2:00	1:00	D
 Rule	StJohns	1917	only	-	Sep	17	2:00	0	S
-Rule	StJohns	1918	only	-	Oct	31	2:00	0	S
 # Whitman gives 1919 Apr 5 and 1920 Apr 5; go with Shanks.
 Rule	StJohns	1919	only	-	May	 5	23:00	1:00	D
 Rule	StJohns	1919	only	-	Aug	12	23:00	0	S
 # For 1931-1935 Whitman gives Apr same date; go with Shanks.
 Rule	StJohns	1920	1935	-	May	Sun>=1	23:00	1:00	D
 Rule	StJohns	1920	1935	-	Oct	lastSun	23:00	0	S
-# For 1936-1941 Shanks gives May Mon>=9 and Oct Mon>=2; go with Whitman.
-Rule	StJohns	1936	1941	-	May	Sun>=8	0:00	1:00	D
-Rule	StJohns	1936	1941	-	Oct	Sun>=1	0:00	0	S
-# Shanks gives 1942 May 11 - 1945 Sep 30; go with Whitman.
-Rule	StJohns	1942	only	-	Mar	 1	0:00	1:00	W
-Rule	StJohns	1942	only	-	Dec	31	0:00	0	S
-Rule	StJohns	1943	only	-	May	30	0:00	1:00	W
-Rule	StJohns	1943	only	-	Sep	 5	0:00	0	S
-Rule	StJohns	1944	only	-	Jul	10	0:00	1:00	W
-Rule	StJohns	1944	only	-	Sep	 2	0:00	0	S
-Rule	StJohns	1945	only	-	Jan	 1	0:00	1:00	W
-Rule	StJohns	1945	only	-	Oct	 7	2:00	0	S
+# For 1936-1941 Whitman gives May Sun>=8 and Oct Sun>=1; go with Shanks.
+Rule	StJohns	1936	1941	-	May	Mon>=9	0:00	1:00	D
+Rule	StJohns	1936	1941	-	Oct	Mon>=2	0:00	0	S
+# Whitman gives the following transitions:
+# 1942 03-01/12-31, 1943 05-30/09-05, 1944 07-10/09-02, 1945 01-01/10-07
+# but go with Shanks and assume they used Canadian rules.
 # For 1946-9 Whitman gives May 5,4,9,1 - Oct 1,5,3,2, and for 1950 he gives
 # Apr 30 - Sep 24; go with Shanks.
 Rule	StJohns	1946	1950	-	May	Sun>=8	2:00	1:00	D
@@ -797,18 +797,24 @@ Rule	StJohns	1989	max	-	Apr	Sun>=1	0:01	1:00	D
 # St John's has an apostrophe, but Posix file names can't have apostrophes.
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone America/St_Johns	-3:30:52 -	LMT	1884
+			-3:30:52 StJohns N%sT	1918
+			-3:30:52 Canada	N%sT	1919
 			-3:30:52 StJohns N%sT	1935 Mar 30
+			-3:30	StJohns	N%sT	1942 May 11
+			-3:30	Canada	N%sT	1946
 			-3:30	StJohns	N%sT
 
-
 # most of east Labrador
 
 # The name `Happy Valley-Goose Bay' is too long; use `Goose Bay'.
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone America/Goose_Bay	-4:01:40 -	LMT	1884 # Happy Valley-Goose Bay
-			-3:30:52 StJohns NST	1919
+			-3:30:52 -	NST	1918
+			-3:30:52 Canada N%sT	1919
 			-3:30:52 -	NST	1935 Mar 30
 			-3:30	-	NST	1936
+			-3:30	StJohns	N%sT	1942 May 11
+			-3:30	Canada	N%sT	1946
 			-3:30	StJohns	N%sT	1966 Mar 15 2:00
 			-4:00	StJohns	A%sT
 
@@ -830,8 +836,6 @@ Zone America/Goose_Bay	-4:01:40 -	LMT	1884 # Happy Valley-Goose Bay
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 Rule Halifax	1916	only	-	Apr	 1	0:00	1:00	D
 Rule Halifax	1916	only	-	Oct	 1	0:00	0	S
-Rule Halifax	1918	only	-	Apr	14	2:00	1:00	D
-Rule Halifax	1918	only	-	Oct	31	2:00	0	S
 Rule Halifax	1920	only	-	May	 9	0:00	1:00	D
 Rule Halifax	1920	only	-	Aug	29	0:00	0	S
 Rule Halifax	1921	only	-	May	 6	0:00	1:00	D
@@ -850,6 +854,7 @@ Rule Halifax	1928	only	-	Sep	 9	0:00	0	S
 Rule Halifax	1929	only	-	Sep	 3	0:00	0	S
 Rule Halifax	1930	only	-	Sep	15	0:00	0	S
 Rule Halifax	1931	1932	-	Sep	Mon>=24	0:00	0	S
+Rule Halifax	1932	only	-	May	 1	0:00	1:00	D
 Rule Halifax	1933	only	-	Apr	30	0:00	1:00	D
 Rule Halifax	1933	only	-	Oct	 2	0:00	0	S
 Rule Halifax	1934	only	-	May	20	0:00	1:00	D
@@ -862,33 +867,55 @@ Rule Halifax	1937	1938	-	May	Sun>=1	0:00	1:00	D
 Rule Halifax	1937	1941	-	Sep	Mon>=24	0:00	0	S
 Rule Halifax	1939	only	-	May	28	0:00	1:00	D
 Rule Halifax	1940	1941	-	May	Sun>=1	0:00	1:00	D
-Rule Halifax	1942	only	-	Feb	9	2:00	1:00	W
-Rule Halifax	1945	1959	-	Sep	lastSun	2:00	0	S
-Rule Halifax	1946	1959	-	Apr	lastSun	2:00	1:00	D
-Rule Halifax	1962	1986	-	Apr	lastSun	2:00	1:00	D
-Rule Halifax	1962	max	-	Oct	lastSun	2:00	0	S
-Rule Halifax	1987	max	-	Apr	Sun>=1	2:00	1:00	D
+Rule Halifax	1946	1949	-	Sep	lastSun	2:00	0	S
+Rule Halifax	1946	1949	-	Apr	lastSun	2:00	1:00	D
+Rule Halifax	1951	1954	-	Sep	lastSun	2:00	0	S
+Rule Halifax	1951	1954	-	Apr	lastSun	2:00	1:00	D
+Rule Halifax	1956	1959	-	Sep	lastSun	2:00	0	S
+Rule Halifax	1956	1959	-	Apr	lastSun	2:00	1:00	D
+Rule Halifax	1962	1973	-	Apr	lastSun	2:00	1:00	D
+Rule Halifax	1962	1973	-	Oct	lastSun	2:00	0	S
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone America/Halifax	-4:14:24 -	LMT	1902 Jun 15
-			-4:00	Halifax	A%sT
+			-4:00	Halifax	A%sT	1918
+			-4:00	Canada	A%sT	1919
+			-4:00	Halifax	A%sT	1942 Feb  9 2:00s
+			-4:00	Canada	A%sT	1946
+			-4:00	Halifax	A%sT	1974
+			-4:00	Canada	A%sT
 Zone America/Glace_Bay	-3:59:48 -	LMT	1902 Jun 15
 			-4:00	Canada	A%sT	1953
 			-4:00	Halifax	A%sT	1954
 			-4:00	-	AST	1972
-			-4:00	Halifax	A%sT
+			-4:00	Halifax	A%sT	1974
+			-4:00	Canada	A%sT
 
 
 # Ontario, Quebec
 
 # From Paul Eggert (1996-06-12):
-# Shanks writes that since 1970 most of this region has been like Montreal.
+# Shanks writes that since 1970 most of Ontario has been like Toronto,
+# and most of Quebec has been like Montreal.
 # Thunder Bay skipped DST in 1973.
 # Many smaller locales did not observe peacetime DST until 1974;
 # Nipigon (EST) and Rainy River (CST) are the largest that we know of.
 # Far west Ontario is like Winnipeg; far east Quebec is like Halifax.
 
+# From Mark Brader (2003-07-26):
+# [According to the Toronto Star] Orillia, Ontario, adopted DST
+# effective Saturday, 1912-06-22, 22:00; the article mentions that
+# Port Arthur (now part of Thunder Bay, Ontario) as well as Moose Jaw
+# have already done so.  In Orillia DST was to run until Saturday,
+# 1912-08-31 (no time mentioned), but it was met with considerable
+# hostility from certain segments of the public, and was revoked after
+# only two weeks -- I copied it as Saturday, 1912-07-07, 22:00, but
+# presumably that should be -07-06.  (1912-06-19, -07-12; also letters
+# earlier in June).
+#
+# Kenora, Ontario, was to abandon DST on 1914-06-01 (-05-21).
+
 # From Paul Eggert (1997-10-17):
-# msb@sq.com writes that an article in the 1997-10-14 Toronto Star
+# Mark Brader writes that an article in the 1997-10-14 Toronto Star
 # says that Atikokan, Ontario currently does not observe DST,
 # but will vote on 11-10 whether to use EST/EDT.
 # He also writes that the
@@ -915,43 +942,99 @@ Zone America/Glace_Bay	-3:59:48 -	LMT	1902 Jun 15
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 Rule	Mont	1917	only	-	Mar	25	2:00	1:00	D
 Rule	Mont	1917	only	-	Apr	24	0:00	0	S
-Rule	Mont	1918	only	-	Apr	14	2:00	1:00	D
-Rule	Mont	1918	only	-	Oct	31	2:00	0	S
 Rule	Mont	1919	only	-	Mar	31	2:30	1:00	D
 Rule	Mont	1919	only	-	Oct	25	2:30	0	S
 Rule	Mont	1920	only	-	May	 2	2:30	1:00	D
-Rule	Mont	1920	only	-	Oct	 3	2:30	0	S
+Rule	Mont	1920	1922	-	Oct	Sun>=1	2:30	0	S
 Rule	Mont	1921	only	-	May	 1	2:00	1:00	D
-Rule	Mont	1921	only	-	Oct	 2	2:30	0	S
 Rule	Mont	1922	only	-	Apr	30	2:00	1:00	D
-Rule	Mont	1922	only	-	Oct	 1	2:30	0	S
 Rule	Mont	1924	only	-	May	17	2:00	1:00	D
 Rule	Mont	1924	1926	-	Sep	lastSun	2:30	0	S
 Rule	Mont	1925	1926	-	May	Sun>=1	2:00	1:00	D
-Rule	Mont	1927	only	-	May	 1	0:00	1:00	D
-Rule	Mont	1927	1932	-	Sep	Sun>=25	0:00	0	S
-Rule	Mont	1928	1931	-	Apr	Sun>=25	0:00	1:00	D
-Rule	Mont	1932	only	-	May	 1	0:00	1:00	D
-Rule	Mont	1933	1940	-	Apr	Sun>=24	0:00	1:00	D
-Rule	Mont	1933	only	-	Oct	 1	0:00	0	S
-Rule	Mont	1934	1939	-	Sep	Sun>=24	0:00	0	S
+Rule	Mont	1927	1937	-	Apr	lastSat	24:00	1:00	D
+Rule	Mont	1927	1937	-	Sep	lastSat	24:00	0	S
+Rule	Mont	1938	1940	-	Apr	lastSun	0:00	1:00	D
+Rule	Mont	1938	1939	-	Sep	lastSun	0:00	0	S
+Rule	Mont	1946	1973	-	Apr	lastSun	2:00	1:00	D
 Rule	Mont	1945	1948	-	Sep	lastSun	2:00	0	S
-Rule	Mont	1946	1986	-	Apr	lastSun	2:00	1:00	D
 Rule	Mont	1949	1950	-	Oct	lastSun	2:00	0	S
 Rule	Mont	1951	1956	-	Sep	lastSun	2:00	0	S
-Rule	Mont	1957	max	-	Oct	lastSun	2:00	0	S
-Rule	Mont	1987	max	-	Apr	Sun>=1	2:00	1:00	D
+Rule	Mont	1957	1973	-	Oct	lastSun	2:00	0	S
+
+Rule	Toronto	1919	only	-	Mar	30	23:30	1:00	D
+Rule	Toronto	1919	only	-	Oct	26	0:00	0	S
+Rule	Toronto	1920	only	-	May	 2	2:00	1:00	D
+Rule	Toronto	1920	only	-	Sep	26	0:00	0	S
+Rule	Toronto	1921	only	-	May	15	2:00	1:00	D
+Rule	Toronto	1921	only	-	Sep	15	2:00	0	S
+Rule	Toronto	1922	1923	-	May	Sun>=8	2:00	1:00	D
+# Shanks says 1923-09-19; assume it's a typo and that "-16" was meant.
+Rule	Toronto	1922	1926	-	Sep	Sun>=15	2:00	0	S
+Rule	Toronto	1924	1927	-	May	Sun>=1	2:00	1:00	D
+Rule	Toronto	1927	1928	-	Sep	lastSun	2:00	0	S
+Rule	Toronto	1928	only	-	Apr	lastSun	2:00	1:00	D
+Rule	Toronto	1929	only	-	Apr	lastSun	0:00	1:00	D
+Rule	Toronto	1929	only	-	Sep	lastSun	0:00	0	S
+Rule	Toronto	1930	1937	-	Apr	lastSat	24:00	1:00	D
+Rule	Toronto	1930	1937	-	Sep	lastSat	24:00	0	S
+Rule	Toronto	1938	1940	-	Apr	lastSun	0:00	1:00	D
+Rule	Toronto	1938	1939	-	Sep	lastSun	0:00	0	S
+Rule	Toronto	1945	1946	-	Sep	lastSun	2:00	0	S
+Rule	Toronto	1946	only	-	Apr	lastSun	2:00	1:00	D
+Rule	Toronto	1947	1949	-	Apr	lastSun	0:00	1:00	D
+Rule	Toronto	1947	1948	-	Sep	lastSun	0:00	0	S
+Rule	Toronto	1949	only	-	Nov	lastSun	0:00	0	S
+Rule	Toronto	1950	1973	-	Apr	lastSun	2:00	1:00	D
+Rule	Toronto	1950	only	-	Nov	lastSun	2:00	0	S
+Rule	Toronto	1951	1956	-	Sep	lastSun	2:00	0	S
+# Shanks says Toronto ended DST a week early in 1971, namely on 1971-10-24,
+# but Mark Brader wrote (2003-05-31) that he checked the 1971-10-30 issue
+# of the Toronto Star, and it said that DST ended 1971-10-31 as usual.
+Rule	Toronto	1957	1973	-	Oct	lastSun	2:00	0	S
+
+# From Paul Eggert (2003-07-27):
+# Willett (1914-03) writes (p. 17) "In the Cities of Fort William, and
+# Port Arthur, Ontario, the principle of the Bill has been in
+# operation for the past three years, and in the City of Moose Jaw,
+# Saskatchewan, for one year."  Assume that the Thunder Bay region
+# observed DST starting 1910, and Moose Jaw starting 1912, as this
+# matches the Toronto Star report about Moose Jaw.  For lack of better
+# info, assume the Thunder Bay region used Willett's proposal, namely
+# third Sunday in April at 02:00 to third Sunday in September at
+# 03:00; also assume that they continued until Canada instituted
+# uniform DST in 1918.
+Rule	Thunder	1910	1917	-	Apr	Sun>=15	2:00s	1:00	D
+Rule	Thunder	1910	1917	-	Sep	Sun>=15	2:00s	0	S
+
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone America/Montreal	-4:54:16 -	LMT	1884
-			-5:00	Mont	E%sT
+			-5:00	Mont	E%sT	1918
+			-5:00	Canada	E%sT	1919
+			-5:00	Mont	E%sT	1942 Feb  9 2:00s
+			-5:00	Canada	E%sT	1946
+			-5:00	Mont	E%sT	1974
+			-5:00	Canada	E%sT
+Zone America/Toronto	-5:17:32 -	LMT	1895
+			-5:00	Canada	E%sT	1919
+			-5:00	Toronto	E%sT	1942 Feb  9 2:00s
+			-5:00	Canada	E%sT	1946
+			-5:00	Toronto	E%sT	1974
+			-5:00	Canada	E%sT
 Zone America/Thunder_Bay -5:57:00 -	LMT	1895
+			-5:00	Thunder	E%sT	1918
+			-5:00	Canada	E%sT	1940 Sep 29
+			-5:00	1:00	EDT	1942 Feb  9 2:00s
 			-5:00	Canada	E%sT	1970
 			-5:00	Mont	E%sT	1973
 			-5:00	-	EST	1974
 			-5:00	Canada	E%sT
 Zone America/Nipigon	-5:53:04 -	LMT	1895
+			-5:00	Canada	E%sT	1940 Sep 29
+			-5:00	1:00	EDT	1942 Feb  9 2:00s
 			-5:00	Canada	E%sT
 Zone America/Rainy_River -6:17:56 -	LMT	1895
+			-6:00	Canada	C%sT	1940 Sep 29
+			-6:00	1:00	CDT	1942 Feb  9 2:00s
 			-6:00	Canada	C%sT
 
 
@@ -964,7 +1047,8 @@ Rule	Winn	1918	only	-	Apr	14	2:00	1:00	D
 Rule	Winn	1918	only	-	Oct	31	2:00	0	S
 Rule	Winn	1937	only	-	May	16	2:00	1:00	D
 Rule	Winn	1937	only	-	Sep	26	2:00	0	S
-Rule	Winn	1942	only	-	Feb	 9	2:00	1:00	W
+Rule	Winn	1942	only	-	Feb	 9	2:00	1:00	W # War
+Rule	Winn	1945	only	-	Aug	14	23:00u	1:00	P # Peace
 Rule	Winn	1945	only	-	Sep	lastSun	2:00	0	S
 Rule	Winn	1946	only	-	May	12	2:00	1:00	D
 Rule	Winn	1946	only	-	Oct	13	2:00	0	S
@@ -992,6 +1076,20 @@ Zone America/Winnipeg	-6:28:36 -	LMT	1887 Jul 16
 
 # Saskatchewan
 
+# From Mark Brader (2003-07-26):
+# The first actual adoption of DST in Canada was at the municipal
+# level.  As the [Toronto] Star put it (1912-06-07), "While people
+# elsewhere have long been talking of legislation to save daylight,
+# the city of Moose Jaw [Saskatchewan] has acted on its own hook."
+# DST in Moose Jaw began on Saturday, 1912-06-01 (no time mentioned:
+# presumably late evening, as below), and would run until "the end of
+# the summer".  The discrepancy between municipal time and railroad
+# time was noted.
+
+# From Paul Eggert (2003-07-27):
+# Willett (1914-03) notes that DST "has been in operation ... in the
+# City of Moose Jaw, Saskatchewan, for one year."
+
 # From Paul Eggert (2000-10-02):
 # Shanks writes that since 1970 most of this region has been like Regina.
 # Some western towns (e.g. Swift Current) switched from MST/MDT to CST in 1972.
@@ -1034,12 +1132,14 @@ Rule	Regina	1937	1941	-	Apr	Sun>=8	0:00	1:00	D
 Rule	Regina	1937	only	-	Oct	Sun>=8	0:00	0	S
 Rule	Regina	1938	only	-	Oct	Sun>=1	0:00	0	S
 Rule	Regina	1939	1941	-	Oct	Sun>=8	0:00	0	S
-Rule	Regina	1942	only	-	Feb	 9	2:00	1:00	W
+Rule	Regina	1942	only	-	Feb	 9	2:00	1:00	W # War
+Rule	Regina	1945	only	-	Aug	14	23:00u	1:00	P # Peace
 Rule	Regina	1945	only	-	Sep	lastSun	2:00	0	S
 Rule	Regina	1946	only	-	Apr	Sun>=8	2:00	1:00	D
 Rule	Regina	1946	only	-	Oct	Sun>=8	2:00	0	S
-Rule	Regina	1947	1959	-	Apr	lastSun	2:00	1:00	D
-Rule	Regina	1947	1958	-	Sep	lastSun	2:00	0	S
+Rule	Regina	1947	1957	-	Apr	lastSun	2:00	1:00	D
+Rule	Regina	1947	1957	-	Sep	lastSun	2:00	0	S
+Rule	Regina	1959	only	-	Apr	lastSun	2:00	1:00	D
 Rule	Regina	1959	only	-	Oct	lastSun	2:00	0	S
 #
 Rule	Swift	1957	only	-	Apr	lastSun	2:00	1:00	D
@@ -1067,7 +1167,8 @@ Rule	Edm	1919	only	-	May	27	2:00	0	S
 Rule	Edm	1920	1923	-	Apr	lastSun	2:00	1:00	D
 Rule	Edm	1920	only	-	Oct	lastSun	2:00	0	S
 Rule	Edm	1921	1923	-	Sep	lastSun	2:00	0	S
-Rule	Edm	1942	only	-	Feb	 9	2:00	1:00	W
+Rule	Edm	1942	only	-	Feb	 9	2:00	1:00	W # War
+Rule	Edm	1945	only	-	Aug	14	23:00u	1:00	P # Peace
 Rule	Edm	1945	only	-	Sep	lastSun	2:00	0	S
 Rule	Edm	1947	only	-	Apr	lastSun	2:00	1:00	D
 Rule	Edm	1947	only	-	Sep	lastSun	2:00	0	S
@@ -1093,7 +1194,8 @@ Zone America/Edmonton	-7:33:52 -	LMT	1906 Sep
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 Rule	Vanc	1918	only	-	Apr	14	2:00	1:00	D
 Rule	Vanc	1918	only	-	Oct	31	2:00	0	S
-Rule	Vanc	1942	only	-	Feb	 9	2:00	1:00	W
+Rule	Vanc	1942	only	-	Feb	 9	2:00	1:00	W # War
+Rule	Vanc	1945	only	-	Aug	14	23:00u	1:00	P # Peace
 Rule	Vanc	1945	only	-	Sep	30	2:00	0	S
 Rule	Vanc	1946	1986	-	Apr	lastSun	2:00	1:00	D
 Rule	Vanc	1946	only	-	Oct	13	2:00	0	S
@@ -1219,7 +1321,8 @@ Rule	NT_YK	1918	only	-	Apr	14	2:00	1:00	D
 Rule	NT_YK	1918	only	-	Oct	27	2:00	0	S
 Rule	NT_YK	1919	only	-	May	25	2:00	1:00	D
 Rule	NT_YK	1919	only	-	Nov	 1	0:00	0	S
-Rule	NT_YK	1942	only	-	Feb	 9	2:00	1:00	W
+Rule	NT_YK	1942	only	-	Feb	 9	2:00	1:00	W # War
+Rule	NT_YK	1945	only	-	Aug	14	23:00u	1:00	P # Peace
 Rule	NT_YK	1945	only	-	Sep	30	2:00	0	S
 Rule	NT_YK	1965	only	-	Apr	lastSun	0:00	2:00	DD
 Rule	NT_YK	1965	only	-	Oct	lastSun	2:00	0	S
@@ -1412,7 +1515,7 @@ Rule	Mexico	1939	only	-	Feb	5	0:00	1:00	D
 Rule	Mexico	1939	only	-	Jun	25	0:00	0	S
 Rule	Mexico	1940	only	-	Dec	9	0:00	1:00	D
 Rule	Mexico	1941	only	-	Apr	1	0:00	0	S
-Rule	Mexico	1943	only	-	Dec	16	0:00	1:00	W
+Rule	Mexico	1943	only	-	Dec	16	0:00	1:00	W # War
 Rule	Mexico	1944	only	-	May	1	0:00	0	S
 Rule	Mexico	1950	only	-	Feb	12	0:00	1:00	D
 Rule	Mexico	1950	only	-	Jul	30	0:00	0	S
@@ -1682,7 +1785,8 @@ Zone America/Santo_Domingo -4:39:36 -	LMT	1890
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 Rule	Salv	1987	1988	-	May	Sun>=1	0:00	1:00	D
 Rule	Salv	1987	1988	-	Sep	lastSun	0:00	0	S
-# There are too many San Salvadors elsewhere, so we'll use `El Salvador'.
+# There are too many San Salvadors elsewhere, so use America/El_Salvador
+# instead of America/San_Salvador.
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone America/El_Salvador -5:56:48 -	LMT	1921		# San Salvador
 			-6:00	Salv	C%sT
@@ -1812,7 +1916,8 @@ Zone America/St_Lucia	-4:04:00 -	LMT	1890		# Castries
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone America/Miquelon	-3:44:40 -	LMT	1911 May 15	# St Pierre
 			-4:00	-	AST	1980 May
-			-3:00	Mont	PM%sT	# Pierre & Miquelon Time
+			-3:00	-	PMST	1987 # Pierre & Miquelon Time
+			-3:00	Canada	PM%sT
 
 # St Vincent and the Grenadines
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
diff --git a/JodaTime/src/java/org/joda/time/tz/src/southamerica b/JodaTime/src/java/org/joda/time/tz/src/southamerica
index a77bcc792..6d9b8ac6b 100644
--- a/JodaTime/src/java/org/joda/time/tz/src/southamerica
+++ b/JodaTime/src/java/org/joda/time/tz/src/southamerica
@@ -1,4 +1,4 @@
-# @(#)southamerica	7.46
+# @(#)southamerica	7.49
 
 # This data is by no means authoritative; if you think you know better,
 # go ahead and edit the file (and please send any changes to
@@ -443,12 +443,13 @@ Rule	Brazil	2001	max	-	Feb	Sun>=15	 0:00	0	-
 # Decree 4,399 (2002-10-01) repeals DST in AL, CE, MA, PB, PE, PI, RN, SE.
 # <a href="http://www.presidencia.gov.br/CCIVIL/decreto/2002/D4399.htm"></a>
 Rule	Brazil	2002	only	-	Nov	 3	 0:00	1:00	S
+# Decree 4,844 (2003-09-24; corrected 2003-09-26) repeals DST in BA, MT, TO.
+# <a href="http://www.presidencia.gov.br/CCIVIL/decreto/2003/D4844.htm"></a>
+Rule	Brazil	2003	max	-	Oct	Sun>=15	 0:00	1:00	S
+# The latest ruleset listed above says that the following states observe DST:
+# DF, ES, GO, MG, MS, PR, RJ, RS, SC, SP.
 #
-Rule	Brazil	2003	max	-	Oct	Sun>=8	 0:00	1:00	S
-# The latest decree listed above says that the following states observe DST:
-# BA, DF, ES, GO, MG, MS, MT, PR, RJ, RS, SC, SP, TO.
-#
-# For dates after mid-2003, the above rules with TO="max" are guesses
+# For dates after mid-2004, the above rules with TO="max" are guesses
 # and are quite possibly wrong, but are more likely than no DST at all.
 
 
@@ -462,6 +463,9 @@ Zone America/Noronha	-2:09:40 -	LMT	1914
 #
 # Amapa (AP), east Para (PA)
 # East Para includes Belem, Maraba, Serra Norte, and Sao Felix do Xingu.
+# The division between east and west Para is the river Xingu.
+# In the north a very small part from the river Javary (now Jari I guess,
+# the border with Amapa) to the Amazon, then to the Xingu.
 Zone America/Belem	-3:13:56 -	LMT	1914
 			-3:00	Brazil	BR%sT	1988 Sep 12
 			-3:00	-	BRT
@@ -489,7 +493,8 @@ Zone America/Recife	-2:19:36 -	LMT	1914
 Zone America/Araguaina	-3:12:48 -	LMT	1914
 			-3:00	Brazil	BR%sT	1990 Sep 17
 			-3:00	-	BRT	1995 Sep 14
-			-3:00	Brazil	BR%sT
+			-3:00	Brazil	BR%sT	2003 Sep 24
+			-3:00	-	BRT
 #
 # Alagoas (AL), Sergipe (SE)
 Zone America/Maceio	-2:22:52 -	LMT	1914
@@ -502,7 +507,14 @@ Zone America/Maceio	-2:22:52 -	LMT	1914
 			-3:00	Brazil	BR%sT	2002 Oct  1
 			-3:00	-	BRT
 #
-# Bahia (BA), Goias (GO), Distrito Federal (DF), Minas Gerais (MG),
+# Bahia (BA)
+# There are too many Salvadors elsewhere, so use America/Bahia instead
+# of America/Salvador.
+Zone America/Bahia	-2:34:04 -	LMT	1914
+			-3:00	Brazil	BR%sT	2003 Sep 24
+			-3:00	-	BRT
+#
+# Goias (GO), Distrito Federal (DF), Minas Gerais (MG),
 # Espirito Santo (ES), Rio de Janeiro (RJ), Sao Paulo (SP), Parana (PR),
 # Santa Catarina (SC), Rio Grande do Sul (RS)
 Zone America/Sao_Paulo	-3:06:28 -	LMT	1914
@@ -510,10 +522,15 @@ Zone America/Sao_Paulo	-3:06:28 -	LMT	1914
 			-3:00	1:00	BRST	1964
 			-3:00	Brazil	BR%sT
 #
-# Mato Grosso (MT), Mato Grosso do Sul (MS)
-Zone America/Cuiaba	-3:44:20 -	LMT	1914
+# Mato Grosso do Sul (MS)
+Zone America/Campo_Grande -3:38:28 -	LMT	1914
 			-4:00	Brazil	AM%sT
 #
+# Mato Grosso (MT)
+Zone America/Cuiaba	-3:44:20 -	LMT	1914
+			-4:00	Brazil	AM%sT	2003 Sep 24
+			-4:00	-	AMT
+#
 # west Para (PA), Rondonia (RO)
 # West Para includes Altamira, Oribidos, Prainha, Oriximina, and Santarem.
 Zone America/Porto_Velho -4:15:36 -	LMT	1914
@@ -528,6 +545,8 @@ Zone America/Boa_Vista	-4:02:40 -	LMT	1914
 			-4:00	-	AMT
 #
 # east Amazonas (AM): Boca do Acre, Jutai, Manaus, Floriano Peixoto
+# The great circle line from Tabatinga to Porto Acre divides
+# east from west Amazonas.
 Zone America/Manaus	-4:00:04 -	LMT	1914
 			-4:00	Brazil	AM%sT	1988 Sep 12
 			-4:00	-	AMT	1993 Sep 28
diff --git a/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeCommon.java b/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeCommon.java
index 9d0cbf672..0aa54bcc8 100644
--- a/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeCommon.java
+++ b/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeCommon.java
@@ -53,11 +53,8 @@
  */
 package org.joda.test.time;
 
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
 import java.util.Calendar;
 import java.util.Date;
-import java.util.GregorianCalendar;
 import java.util.TimeZone;
 
 import org.joda.time.Chronology;
diff --git a/JodaTime/src/test/org/joda/test/time/BulkTest.java b/JodaTime/src/test/org/joda/test/time/BulkTest.java
index f6b453190..425260987 100644
--- a/JodaTime/src/test/org/joda/test/time/BulkTest.java
+++ b/JodaTime/src/test/org/joda/test/time/BulkTest.java
@@ -53,21 +53,21 @@
  */
 package org.joda.test.time ;
 //
-import junit.framework.Test;
-import junit.framework.TestCase;
-import junit.framework.TestSuite;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
-import java.util.Arrays;
 import java.util.ArrayList;
-import java.util.List;
+import java.util.Arrays;
 import java.util.Calendar;
 import java.util.GregorianCalendar;
-import java.text.ParseException;
-import org.joda.time.* ;
-import org.joda.time.chrono.iso.* ;
+import java.util.List;
+
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+import org.joda.time.MutableDateTime;
+import org.joda.time.chrono.iso.ISOChronology;
 /**
  *  A {@link TestCase} that can define both simple and bulk test methods.<P>
  *
@@ -501,9 +501,9 @@ MutableDateTime getMDTFromString(String s) {
             retVal = new MutableDateTime( s,
                 ISOChronology.getInstanceUTC() );
         }
-        catch(ParseException pe)
+        catch(IllegalArgumentException pe)
         {
-            System.err.println("ParseException Detected");
+            System.err.println("IllegalArgumentException Detected");
             pe.printStackTrace();
         }
         return retVal;
diff --git a/JodaTime/src/test/org/joda/test/time/ClassLoadTest.java b/JodaTime/src/test/org/joda/test/time/ClassLoadTest.java
new file mode 100644
index 000000000..3ec99c699
--- /dev/null
+++ b/JodaTime/src/test/org/joda/test/time/ClassLoadTest.java
@@ -0,0 +1,92 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.test.time;
+
+import org.joda.time.AbstractDateTime;
+import org.joda.time.AbstractInstant;
+import org.joda.time.DateTime;
+import org.joda.time.DateTimeZone;
+import org.joda.time.ReadableDateTime;
+
+/**
+ * This class is a Junit unit test base class for
+ * Instant implementations.
+ *
+ * @author Stephen Colebourne
+ */
+public class ClassLoadTest {
+
+    // run using JVM -verbose:class
+    public static void main(String[] args) {
+        System.out.println("-----------------------------------------------");
+        System.out.println("-----------AbstractInstant---------------------");
+        Class cls = AbstractInstant.class;
+        System.out.println("-----------ReadableDateTime--------------------");
+        cls = ReadableDateTime.class;
+        System.out.println("-----------AbstractDateTime--------------------");
+        cls = AbstractDateTime.class;
+        System.out.println("-----------DateTime----------------------------");
+        cls = DateTime.class;
+        System.out.println("-----------DateTimeZone------------------------");
+        cls = DateTimeZone.class;
+        System.out.println("-----------new DateTime()----------------------");
+        DateTime dt = new DateTime();
+        System.out.println("-----------new DateTime(ReadableInstant)-------");
+        dt = new DateTime(dt);
+        System.out.println("-----------new DateTime(Long)------------------");
+        dt = new DateTime(new Long(0));
+        System.out.println("-----------------------------------------------");
+    }
+    
+}
diff --git a/JodaTime/src/test/org/joda/test/time/TestConstructors.java b/JodaTime/src/test/org/joda/test/time/TestConstructors.java
index b3452b801..3d06f459f 100644
--- a/JodaTime/src/test/org/joda/test/time/TestConstructors.java
+++ b/JodaTime/src/test/org/joda/test/time/TestConstructors.java
@@ -53,21 +53,17 @@
  */
 package org.joda.test.time;
 //
-import java.text.ParseException;
 import java.io.PrintStream;
-//
+
 import junit.framework.TestSuite;
-//
+
 import org.joda.time.DateTime;
-//import org.joda.time.DateOnly;
-//import org.joda.time.TimeOnly;
 import org.joda.time.ReadableInstant;
-import org.joda.time.DateTimeFieldProperty;
 //
 /**
  * This class is a Junit unit test for the
- * constructors of various ISODateTime, ISODateOnly, and
- * ISOTimeOnly objects.
+ * constructors of various DateTime, DateOnly, and
+ * TimeOnly objects.
  *
  * @author Guy Allard
  *
@@ -103,8 +99,8 @@ protected void tearDown() throws Exception {
         super.tearDown();
     }
     /**
-     * Test the <code>ISODateOnly</code> constructors.
-     * @see org.joda.time.iso.ISODateOnly
+     * Test the <code>DateOnly</code> constructors.
+     * @see org.joda.time.DateOnly
      */
     public void testDateOnlyConstructors() {
         dateOnly = true;
@@ -162,8 +158,8 @@ public void testDateOnlyConstructors() {
         tt.showResults();
     }
     /**
-     * Test the <code>ISOTimeOnly</code> constructors.
-     * @see org.joda.time.iso.ISOTimeOnly
+     * Test the <code>TimeOnly</code> constructors.
+     * @see org.joda.time.TimeOnly
      */
     public void testTimeOnlyConstructors() {
         dateOnly = false;
@@ -238,8 +234,8 @@ public void testTimeOnlyConstructors() {
         tt.showResults();
     }
     /**
-     * Test the <code>ISODateTime</code> constructors.
-     * @see org.joda.time.iso.ISODateTime
+     * Test the <code>DateTime</code> constructors.
+     * @see org.joda.time.DateTime
      */
     public void testDateTimeConstructors() {
         dateTimes = true;
@@ -691,7 +687,7 @@ public final void run() {
                     }
                     */
                 }
-                catch(ParseException pe)
+                catch(IllegalArgumentException pe)
                 {
                     ss.bumpFailedTests();
                     tt.bumpFailedTests();
diff --git a/JodaTime/src/test/org/joda/test/time/TestDateTimeComparator.java b/JodaTime/src/test/org/joda/test/time/TestDateTimeComparator.java
index edcbdf383..e26dd8f15 100644
--- a/JodaTime/src/test/org/joda/test/time/TestDateTimeComparator.java
+++ b/JodaTime/src/test/org/joda/test/time/TestDateTimeComparator.java
@@ -53,11 +53,21 @@
  */
 package org.joda.test.time;
 
-import java.util.*;
-import java.text.* ;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.Date;
+import java.util.List;
+
 import junit.framework.TestSuite;
-import org.joda.time.*;
-import org.joda.time.chrono.iso.*;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTime;
+import org.joda.time.DateTimeComparator;
+import org.joda.time.DateTimeZone;
+import org.joda.time.ReadableInstant;
+import org.joda.time.chrono.iso.ISOChronology;
 /**
  * This class is a Junit unit test for the
  * org.joda.time.DateTimeComparator class.
@@ -832,7 +842,7 @@ private DateTime getADate(String s) {
         {
             retDT = new DateTime( s, DateTimeZone.UTC );
         }
-        catch(ParseException pe)
+        catch(IllegalArgumentException pe)
         {
             pe.printStackTrace();
         }
@@ -849,7 +859,7 @@ private List loadAList(String[] someStrs) {
                 newList.add( new DateTime( someStrs[i], DateTimeZone.UTC ) );
             } // end of the for
         }
-        catch(ParseException pe)
+        catch(IllegalArgumentException pe)
         {
             pe.printStackTrace();
         }
diff --git a/JodaTime/src/test/org/joda/test/time/TestDateTimeFormat.java b/JodaTime/src/test/org/joda/test/time/TestDateTimeFormat.java
index df2f00804..9ef6d1266 100644
--- a/JodaTime/src/test/org/joda/test/time/TestDateTimeFormat.java
+++ b/JodaTime/src/test/org/joda/test/time/TestDateTimeFormat.java
@@ -68,255 +68,101 @@
  */
 public class TestDateTimeFormat extends BulkTest {
 
-	/**
-	 * This is the main class for this test suite.
-	 * @param args command line arguments.
-	 */
-	public static void main(String[] args) {
-		junit.textui.TestRunner.run(suite());
-	}
-	/**
-	 * TestSuite is a junit required method.
-	 */
-	public static TestSuite suite() {
-		return BulkTest.makeSuite(TestDateTimeFormat.class);
-	}
-	/**
-	 * TestDateTimeField constructor.
-	 * @param name
-	 */
-	public TestDateTimeFormat(String name) {
-		super(name);
-	}
-	// Class Name: org.joda.time.format.DateTimeFormat
-	/**
-	 * Junit <code>setUp()</code> method.
-	 */
-	public void setUp() /* throws Exception */ {
-		// super.setUp();
-	}
-	/**
-	 * Junit <code>tearDown()</code> method.
-	 */
-	protected void tearDown() /* throws Exception */ {
-		// super.tearDown();
-	}
-	/**
-	 * Test the <code>getInstance()</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#getInstance()
-	 */
-	protected void testGetInstance() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getInstance(java.lang.String)</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#getInstance(java.lang.String)
-	 */
-	public void testGetInstanceString() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getInstance(java.lang.String, java.util.TimeZone)</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#getInstance(java.lang.String, java.util.TimeZone)
-	 */
-	public void testGetInstanceSTZ() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getInstance(java.lang.String, java.util.TimeZone, java.util.Locale)</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#getInstance(java.lang.String, java.util.TimeZone, java.util.Locale)
-	 */
-	public void testGetInstanceSTZL() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getInstance(java.lang.String, org.joda.time.Chronology)</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#getInstance(java.lang.String, org.joda.time.Chronology)
-	 */
-	public void testGetInstanceSC() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getInstance(java.lang.String, org.joda.time.Chronology, java.util.TimeZone)</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#getInstance(java.lang.String, org.joda.time.Chronology, java.util.TimeZone)
-	 */
-	public void testGetInstanceSCT() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getInstance(java.lang.String, org.joda.time.Chronology, java.util.TimeZone, java.util.Locale)</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#getInstance(java.lang.String, org.joda.time.Chronology, java.util.TimeZone, java.util.Locale)
-	 */
-	public void testGetInstanceSCTL() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getDateInstance(java.lang.Object, org.joda.time.Chronology, java.util.TimeZone, java.util.Locale)</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#getDateInstance(java.lang.Object, org.joda.time.Chronology, java.util.TimeZone, java.util.Locale)
-	 */
-	public void testGetDateInstance() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getTimeInstance(java.lang.Object, org.joda.time.Chronology, java.util.TimeZone, java.util.Locale)</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#getTimeInstance(java.lang.Object, org.joda.time.Chronology, java.util.TimeZone, java.util.Locale)
-	 */
-	public void testGetTimeInstance() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getDateTimeInstance(java.lang.Object, java.lang.Object, org.joda.time.Chronology, java.util.TimeZone, java.util.Locale)</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#getDateTimeInstance(java.lang.Object, java.lang.Object, org.joda.time.Chronology, java.util.TimeZone, java.util.Locale)
-	 */
-	public void testGetDateTimeInstance() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getPattern()</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#getPattern()
-	 */
-	public void testGetPattern() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getChronology()</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#getChronology()
-	 */
-	public void testGetChronology() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getTimeZone()</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#getTimeZone()
-	 */
-	public void testGetTimeZone() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getLocale()</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#getLocale()
-	 */
-	public void testGetLocale() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getPrinter()</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#getPrinter()
-	 */
-	public void testGetPrinter() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getParser()</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#getParser()
-	 */
-	public void testGetParser() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>estimatePrintedLength()</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#estimatePrintedLength()
-	 */
-	public void testEstimatePrintedLength() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>printTo(java.lang.StringBuffer, long, long)</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#printTo(java.lang.StringBuffer, long, long)
-	 */
-	public void testPrintToSLL() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>printTo(java.io.Writer, long, long)</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#printTo(java.io.Writer, long, long)
-	 */
-	public void testPrintToWLL() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#printTo(java.lang.StringBuffer, org.joda.time.ReadableInstant)
-	 */
-	public void testPrintToSBRI() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>printTo(java.lang.StringBuffer, long)</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#printTo(java.lang.StringBuffer, long)
-	 */
-	public void testPrintToSBL() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>printTo(java.io.Writer, org.joda.time.ReadableInstant)</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#printTo(java.io.Writer, org.joda.time.ReadableInstant)
-	 */
-	public void testPrintToWRI() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>printTo(java.io.Writer, long)</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#printTo(java.io.Writer, long)
-	 */
-	public void testPrintToWL() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>print(org.joda.time.ReadableInstant)</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#print(org.joda.time.ReadableInstant)
-	 */
-	public void testPrintRI() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>print(long)</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#print(long)
-	 */
-	public void testPrintL() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>estimateParsedLength()</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#estimateParsedLength()
-	 */
-	public void testEstimateParsedLength() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#parseInto(org.joda.time.format.DateTimeParserBucket, java.lang.String, int)
-	 */
-	public void testParseIntoPBSI() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>parseInto(org.joda.time.ReadWritableInstant, java.lang.String)</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#parseInto(org.joda.time.ReadWritableInstant, java.lang.String)
-	 */
-	public void testParseIntoRWIS() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#parseInto(org.joda.time.ReadWritableInstant, java.lang.String, int)
-	 */
-	public void testParseIntoRWISI() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>parse(java.lang.String)</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#parse(java.lang.String)
-	 */
-	public void testParseS() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>parse(java.lang.String, int, long)</code> method.
-	 * @see org.joda.time.format.DateTimeFormat#parse(java.lang.String, int, long)
-	 */
-	public void testParseSL() {
-		fail("TBD");
-	}
+    /**
+     * This is the main class for this test suite.
+     * @param args command line arguments.
+     */
+    public static void main(String[] args) {
+        junit.textui.TestRunner.run(suite());
+    }
+    /**
+     * TestSuite is a junit required method.
+     */
+    public static TestSuite suite() {
+        return BulkTest.makeSuite(TestDateTimeFormat.class);
+    }
+    /**
+     * TestDateTimeField constructor.
+     * @param name
+     */
+    public TestDateTimeFormat(String name) {
+        super(name);
+    }
+    // Class Name: org.joda.time.format.DateTimeFormat
+    /**
+     * Junit <code>setUp()</code> method.
+     */
+    public void setUp() /* throws Exception */ {
+        // super.setUp();
+    }
+    /**
+     * Junit <code>tearDown()</code> method.
+     */
+    protected void tearDown() /* throws Exception */ {
+        // super.tearDown();
+    }
+    /**
+     * Test the <code>getInstanceUTC()</code> method.
+     * @see org.joda.time.format.DateTimeFormat#getInstanceUTC()
+     */
+    protected void testGetInstanceUTC() {
+        fail("TBD");
+    }
+    /**
+     * Test the <code>getInstance()</code> method.
+     * @see org.joda.time.format.DateTimeFormat#getInstance()
+     */
+    protected void testGetInstance() {
+        fail("TBD");
+    }
+    /**
+     * Test the <code>getInstance(org.joda.time.DateTimeZone)</code> method.
+     * @see org.joda.time.format.DateTimeFormat#getInstance(org.joda.time.DateTimeZone)
+     */
+    public void testGetInstanceTZ() {
+        fail("TBD");
+    }
+    /**
+     * Test the <code>getInstance(org.joda.time.DateTimeZone, java.util.Locale)</code> method.
+     * @see org.joda.time.format.DateTimeFormat#getInstance(org.joda.time.DateTimeZone, java.util.Locale)
+     */
+    public void testGetInstanceTZL() {
+        fail("TBD");
+    }
+    /**
+     * Test the <code>getInstance(org.joda.time.Chronology)</code> method.
+     * @see org.joda.time.format.DateTimeFormat#getInstance(org.joda.time.Chronology)
+     */
+    public void testGetInstanceC() {
+        fail("TBD");
+    }
+    /**
+     * Test the <code>getInstance(org.joda.time.Chronology, java.util.Locale)</code> method.
+     * @see org.joda.time.format.DateTimeFormat#getInstance(org.joda.time.Chronology, java.util.Locale)
+     */
+    public void testGetInstanceCL() {
+        fail("TBD");
+    }
+    /**
+     * Test the <code>forPattern(String)</code> method.
+     * @see org.joda.time.format.DateTimeFormat#forPattern(String)
+     */
+    public void testForPattern() {
+        fail("TBD");
+    }
+    /**
+     * Test the <code>forStyle(String)</code> method.
+     * @see org.joda.time.format.DateTimeFormat#forStyle(String)
+     */
+    public void testForStyle() {
+        fail("TBD");
+    }
+    /**
+     * Test the <code>getPatternForStyle()</code> method.
+     * @see org.joda.time.format.DateTimeFormat#getPatternForStyle(String)
+     */
+    public void testGetPatternForStyle() {
+        fail("TBD");
+    }
 
 }
diff --git a/JodaTime/src/test/org/joda/test/time/TestMDTAdd.java b/JodaTime/src/test/org/joda/test/time/TestMDTAdd.java
index 164b5a0b7..9a558428e 100644
--- a/JodaTime/src/test/org/joda/test/time/TestMDTAdd.java
+++ b/JodaTime/src/test/org/joda/test/time/TestMDTAdd.java
@@ -53,14 +53,20 @@
  */
 package org.joda.test.time;
 
-import java.util.*;
-import java.text.* ;
-import java.io.*;
+import java.io.PrintStream;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.SimpleTimeZone;
+import java.util.TimeZone;
 
 import junit.framework.TestSuite;
 
-import org.joda.time.*;
-import org.joda.time.chrono.iso.* ;
+import org.joda.time.Chronology;
+import org.joda.time.Instant;
+import org.joda.time.MutableDateTime;
+import org.joda.time.ReadableInstant;
+import org.joda.time.chrono.iso.ISOChronology;
 /**
  * This class is a Junit unit test for the
  * org.joda.time.MutableDateTime class.
@@ -188,7 +194,7 @@ protected void tearDown() /* throws Exception */ {
 
     /**
      * Test the <code>addMillis(long)</code> method.
-     * @see org.joda.time.MutableDateTime#addMillis(long)
+     * @see org.joda.time.MutableDateTime#add(long)
      */
     public void testAddMillis() {
         fail("TBD");
@@ -235,9 +241,9 @@ private  void prepTest(int item) {
         {
             mdt = new MutableDateTime( isoString, ISOChronology.getInstanceUTC() );
         }
-        catch(ParseException pe)
+        catch(IllegalArgumentException pe)
         {
-            ewtr.println("ParseException Detected: " + isoString);
+            ewtr.println("IllegalArgumentException Detected: " + isoString);
             ewtr.println( pe.getMessage() );
             ewtr.flush();
         }
diff --git a/JodaTime/src/test/org/joda/test/time/TestMDTAddWrapped.java b/JodaTime/src/test/org/joda/test/time/TestMDTAddWrapped.java
index 6ae50853e..dce56b5c8 100644
--- a/JodaTime/src/test/org/joda/test/time/TestMDTAddWrapped.java
+++ b/JodaTime/src/test/org/joda/test/time/TestMDTAddWrapped.java
@@ -53,14 +53,20 @@
  */
 package org.joda.test.time;
 
-import java.util.*;
-import java.text.* ;
-import java.io.*;
+import java.io.PrintStream;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.SimpleTimeZone;
+import java.util.TimeZone;
 
 import junit.framework.TestSuite;
 
-import org.joda.time.*;
-import org.joda.time.chrono.iso.* ;
+import org.joda.time.Chronology;
+import org.joda.time.Instant;
+import org.joda.time.MutableDateTime;
+import org.joda.time.ReadableInstant;
+import org.joda.time.chrono.iso.ISOChronology;
 /**
  * This class is a Junit unit test for the
  * org.joda.time.MutableDateTime class.
@@ -233,9 +239,9 @@ private  void prepTest(int item) {
         {
             mdt = new MutableDateTime( isoString, ISOChronology.getInstanceUTC() );
         }
-        catch(ParseException pe)
+        catch(IllegalArgumentException pe)
         {
-            ewtr.println("ParseException Detected: " + isoString);
+            ewtr.println("IllegalArgumentException Detected: " + isoString);
             ewtr.println( pe.getMessage() );
             ewtr.flush();
         }
diff --git a/JodaTime/src/test/org/joda/test/time/TestMDTGet.java b/JodaTime/src/test/org/joda/test/time/TestMDTGet.java
index 28d29ad36..abfb0925e 100644
--- a/JodaTime/src/test/org/joda/test/time/TestMDTGet.java
+++ b/JodaTime/src/test/org/joda/test/time/TestMDTGet.java
@@ -53,13 +53,18 @@
  */
 package org.joda.test.time;
 
-import java.util.*;
-import java.text.* ;
-import java.io.*;
+import java.io.PrintStream;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.SimpleTimeZone;
+import java.util.TimeZone;
 
 import junit.framework.TestSuite;
 
-import org.joda.time.*;
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeConstants;
+import org.joda.time.MutableDateTime;
 import org.joda.time.chrono.iso.ISOChronology;
 /**
  * This class is a Junit unit test for the
@@ -351,7 +356,7 @@ public void testGetDayOfYear() {
     }
     /**
      * Test the <code>getWeekOfYearWeek()</code> method.
-     * @see org.joda.time.MutableDateTime#getWeekOfYearWeek()
+     * @see org.joda.time.MutableDateTime#getWeekOfWeekyear()
      */
     public void testGetWeekOfWeekyear() {
         for (int ngc = 0; ngc < gcals.length; ++ngc) {
@@ -361,7 +366,7 @@ public void testGetWeekOfWeekyear() {
     }
     /**
      * Test the <code>getWeekOfYearYear()</code> method.
-     * @see org.joda.time.MutableDateTime#getWeekOfYearYear()
+     * @see org.joda.time.MutableDateTime#getWeekOfWeekyear()
      */
     public void testGetYearOfWeekyear() {
         for (int ngc = 0; ngc < gcals.length; ++ngc) {
@@ -547,7 +552,7 @@ public void testDayOfYear() {
     }
     /**
      * Test the <code>weekOfYearWeek()</code> method.
-     * @see org.joda.time.MutableDateTime#weekOfYearWeek()
+     * @see org.joda.time.MutableDateTime#weekOfWeekyear()
      */
     public void testWeekOfWeekyear() {
         for (int ngc = 0; ngc < gcals.length; ++ngc) {
@@ -564,9 +569,9 @@ public void testWeekOfWeekyear() {
     }
     /**
      * Test the <code>weekOfYearYear()</code> method.
-     * @see org.joda.time.MutableDateTime#weekOfYearYear()
+     * @see org.joda.time.MutableDateTime#weekyear()
      */
-    public void testYearOfWeekyear() {
+    public void testWeekyear() {
         for (int ngc = 0; ngc < gcals.length; ++ngc) {
             prepTest( ngc );
             assertEquals("DWOYY1:"+isoString, expected_woyy,
@@ -841,9 +846,9 @@ private  void prepTest(int item) {
         {
             mdt = new MutableDateTime( isoString, ISOChronology.getInstanceUTC() );
         }
-        catch(ParseException pe)
+        catch(IllegalArgumentException pe)
         {
-            ewtr.println("ParseException Detected: " + isoString);
+            ewtr.println("IllegalArgumentException Detected: " + isoString);
             ewtr.println( pe.getMessage() );
             ewtr.flush();
         }
diff --git a/JodaTime/src/test/org/joda/test/time/TestMDTSet.java b/JodaTime/src/test/org/joda/test/time/TestMDTSet.java
index 7373085c6..40a2eb909 100644
--- a/JodaTime/src/test/org/joda/test/time/TestMDTSet.java
+++ b/JodaTime/src/test/org/joda/test/time/TestMDTSet.java
@@ -53,13 +53,21 @@
  */
 package org.joda.test.time;
 
-import java.util.*;
-import java.text.* ;
-import java.io.*;
+import java.io.PrintStream;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.SimpleTimeZone;
+import java.util.TimeZone;
 
 import junit.framework.TestSuite;
 
-import org.joda.time.*;
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeConstants;
+import org.joda.time.Instant;
+import org.joda.time.MutableDateTime;
+import org.joda.time.ReadableInstant;
 import org.joda.time.chrono.iso.ISOChronology;
 /**
  * This class is a Junit unit test for the
@@ -1064,7 +1072,7 @@ public void testSetDayOfWeek() {
     }
     /**
      * Test the <code>setWeekOfYear(int, int)</code> method.
-     * @see org.joda.time.MutableDateTime#setWeekOfYear(int, int)
+     * @see org.joda.time.MutableDateTime#setWeekOfWeekyear(int)
      */
     public void testSetWeekOfYear() {
         ewtr.println("testSetWeekOfYear needs enhancement");
@@ -1152,9 +1160,9 @@ private  void prepTest(int item) {
         {
             mdt = new MutableDateTime( isoString, ISOChronology.getInstanceUTC() );
         }
-        catch(ParseException pe)
+        catch(IllegalArgumentException pe)
         {
-            ewtr.println("ParseException Detected: " + isoString);
+            ewtr.println("IllegalArgumentException Detected: " + isoString);
             ewtr.println( pe.getMessage() );
             ewtr.flush();
         }
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/Test.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/Test.java
index 8549b8be3..6a6475c36 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/Test.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/Test.java
@@ -227,6 +227,7 @@ private void testField(DateTimeField fieldA, DateTimeField fieldB, long millis,
     {
         int a, b;
         long x, y;
+        boolean m, n;
 
         // get test
         a = fieldA.get(millis);
@@ -303,6 +304,16 @@ private void testField(DateTimeField fieldA, DateTimeField fieldB, long millis,
             System.out.println("Test datetime 2: " + makeDatetime(millis2));
             throw e;
         }
+
+        // isLeap test
+        m = fieldA.isLeap(millis);
+        n = fieldB.isLeap(millis);
+        testBoolean(fieldA, fieldB, "isLeap", millis, m, n);
+
+        // getLeapAmount test
+        a = fieldA.getLeapAmount(millis);
+        b = fieldB.getLeapAmount(millis);
+        testValue(fieldA, fieldB, "getLeapAmount", millis, a, b);
     }
 
     private int getWrappedValue(int value, int minValue, int maxValue) {
@@ -347,6 +358,13 @@ private void testMillis(DateTimeField fieldA, DateTimeField fieldB,
         }
     }
 
+    private void testBoolean(DateTimeField fieldA, DateTimeField fieldB,
+                             String method, long millis, boolean boolA, boolean boolB) {
+        if (boolA != boolB) {
+            failBoolean(fieldA, fieldB, method, millis, boolA, boolB);
+        }
+    }
+
     private void failValue(DateTimeField fieldA, DateTimeField fieldB,
                            String method, long millis, long valueA, long valueB) {
         System.out.println("Failure on " + makeName(fieldA, fieldB) + "." + method);
@@ -409,6 +427,17 @@ private void failMillis(DateTimeField fieldA, DateTimeField fieldB,
         throw new RuntimeException();
     }
 
+    private void failBoolean(DateTimeField fieldA, DateTimeField fieldB,
+                             String method, long millis, boolean boolA, boolean boolB) {
+        System.out.println("Failure on " + makeName(fieldA, fieldB) + "." + method);
+        System.out.println(fieldA.getClass().getName() + "\n\tvs. "
+                           + fieldB.getClass().getName());
+        System.out.println("Datetime: " + makeDatetime(millis));
+        System.out.println("Millis from 1970: " + millis);
+        System.out.println(boolA + " != " + boolB);
+        throw new RuntimeException();
+    }
+
     private String makeName(DateTimeField fieldA, DateTimeField fieldB) {
         if (fieldA.getName().equals(fieldB.getName())) {
             return fieldA.getName();
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java
index f080914d5..5b0dfba03 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java
@@ -57,6 +57,7 @@
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeZone;
+import org.joda.time.DurationField;
 
 /**
  * A reference Gregorian/Julian chronology implementation, intended for testing
@@ -151,6 +152,10 @@ public long getDateOnlyMillis(long millis) {
         return millis - mod(millis, MILLIS_PER_DAY);
     }
 
+    public DurationField days() {
+        return dayOfWeek().getDurationField();
+    }
+
     public DateTimeField dayOfWeek() {
         return new TestGJDayOfWeekField(this);
     }
@@ -163,22 +168,42 @@ public DateTimeField dayOfYear() {
         return new TestGJDayOfYearField(this);
     }
 
+    public DurationField weeks() {
+        return weekOfWeekyear().getDurationField();
+    }
+
     public DateTimeField weekOfWeekyear() {
         return new TestGJWeekOfWeekyearField(this);
     }
 
+    public DurationField weekyears() {
+        return weekyear().getDurationField();
+    }
+
     public DateTimeField weekyear() {
         return new TestGJWeekyearField(this);
     }
 
+    public DurationField months() {
+        return monthOfYear().getDurationField();
+    }
+
     public DateTimeField monthOfYear() {
         return new TestGJMonthOfYearField(this);
     }
 
+    public DurationField years() {
+        return year().getDurationField();
+    }
+
     public DateTimeField year() {
         return new TestGJYearField(this);
     }
 
+    abstract long millisPerYear();
+
+    abstract long millisPerMonth();
+
     abstract boolean isLeapYear(int year);
 
     /**
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDateTimeField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDateTimeField.java
index 5fb807575..830b077c1 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDateTimeField.java
@@ -54,24 +54,30 @@
 
 package org.joda.test.time.chrono.gj;
 
-import org.joda.time.DateTimeField;
+import org.joda.time.chrono.ImpreciseDateTimeField;
+import org.joda.time.chrono.Utils;
 
 /**
  * 
  * @author Brian S O'Neill
  */
-abstract class TestGJDateTimeField extends DateTimeField {
+abstract class TestGJDateTimeField extends ImpreciseDateTimeField {
     protected final TestGJChronology iChronology;
 
-    public TestGJDateTimeField(String name, TestGJChronology chrono) {
-        super(name);
+    public TestGJDateTimeField(String name, String duratioName,
+                               long unitMillis, TestGJChronology chrono) {
+        super(name, duratioName, unitMillis);
         iChronology = chrono;
     }
 
-    // Redeclare to work around compiler bug.
-    public abstract long add(long millis, int value);
+    public boolean isLenient() {
+        return false;
+    }
 
-    public long add(long millis, long value) {
-        return addLong(millis, value);
+    public long add(long instant, int value) {
+        return add(instant, (long)value);
     }
+
+    public abstract long add(long instant, long value);
+
 }
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfMonthField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfMonthField.java
index 68ee05ea5..ad440d07e 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfMonthField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfMonthField.java
@@ -54,35 +54,33 @@
 
 package org.joda.test.time.chrono.gj;
 
+import org.joda.time.DurationField;
+
 /**
  * 
  * @author Brian S O'Neill
  */
 class TestGJDayOfMonthField extends TestGJDateTimeField {
     public TestGJDayOfMonthField(TestGJChronology chrono) {
-        super("dayOfMonth", chrono);
+        super("dayOfMonth", "days", chrono.MILLIS_PER_DAY, chrono);
     }
 
     public int get(long millis) {
         return iChronology.gjFromMillis(millis)[2];
     }
 
-    public long add(long millis, int value) {
-        return millis + value * iChronology.MILLIS_PER_DAY;
-    }
-
     public long set(long millis, int value) {
         int[] ymd = iChronology.gjFromMillis(millis);
         return iChronology.getTimeOnlyMillis(millis)
             + iChronology.millisFromGJ(ymd[0], ymd[1], value);
     }
 
-    public long getUnitMillis() {
-        return iChronology.MILLIS_PER_DAY;
+    public long add(long millis, long value) {
+        return millis + value * iChronology.MILLIS_PER_DAY;
     }
 
-    public long getRangeMillis() {
-        return (long)(365.2425 * iChronology.MILLIS_PER_DAY / 12);
+    public DurationField getRangeDurationField() {
+        return iChronology.months();
     }
 
     public int getMinimumValue() {
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfWeekField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfWeekField.java
index 45693c8a0..834661d78 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfWeekField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfWeekField.java
@@ -54,37 +54,35 @@
 
 package org.joda.test.time.chrono.gj;
 
+import org.joda.time.DurationField;
+
 /**
  * 
  * @author Brian S O'Neill
  */
 class TestGJDayOfWeekField extends TestGJDateTimeField {
     public TestGJDayOfWeekField(TestGJChronology chrono) {
-        super("dayOfWeek", chrono);
+        super("dayOfWeek", "days", chrono.MILLIS_PER_DAY, chrono);
     }
 
     public int get(long millis) {
-		int dayOfWeek = (int)iChronology.mod(iChronology.fixedFromMillis(millis), 7);
-		if (dayOfWeek == 0) {
-			dayOfWeek = 7;
-		}
-		return dayOfWeek;
-    }
-
-    public long add(long millis, int value) {
-        return millis + value * iChronology.MILLIS_PER_DAY;
+        int dayOfWeek = (int)iChronology.mod(iChronology.fixedFromMillis(millis), 7);
+        if (dayOfWeek == 0) {
+            dayOfWeek = 7;
+        }
+        return dayOfWeek;
     }
 
     public long set(long millis, int value) {
-        return add(millis, value - get(millis));
+        return add(millis, (long) value - get(millis));
     }
 
-    public long getUnitMillis() {
-        return iChronology.MILLIS_PER_DAY;
+    public long add(long millis, long value) {
+        return millis + value * iChronology.MILLIS_PER_DAY;
     }
 
-    public long getRangeMillis() {
-        return iChronology.MILLIS_PER_DAY * 7;
+    public DurationField getRangeDurationField() {
+        return iChronology.weeks();
     }
 
     public int getMinimumValue() {
@@ -96,6 +94,6 @@ public int getMaximumValue() {
     }
 
     public long roundFloor(long millis) {
-		return iChronology.getDateOnlyMillis(millis);
+        return iChronology.getDateOnlyMillis(millis);
     }
 }
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfYearField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfYearField.java
index d70a0b2df..4e39e1a73 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfYearField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfYearField.java
@@ -54,13 +54,15 @@
 
 package org.joda.test.time.chrono.gj;
 
+import org.joda.time.DurationField;
+
 /**
  * 
  * @author Brian S O'Neill
  */
 class TestGJDayOfYearField extends TestGJDateTimeField {
     public TestGJDayOfYearField(TestGJChronology chrono) {
-        super("dayOfYear", chrono);
+        super("dayOfYear", "days", chrono.MILLIS_PER_DAY, chrono);
     }
 
     public int get(long millis) {
@@ -69,20 +71,16 @@ public int get(long millis) {
                      - iChronology.fixedFromGJ(year, 1, 1)) + 1;
     }
 
-    public long add(long millis, int value) {
-        return millis + value * iChronology.MILLIS_PER_DAY;
-    }
-
     public long set(long millis, int value) {
-        return add(millis, value - get(millis));
+        return add(millis, (long) value - get(millis));
     }
 
-    public long getUnitMillis() {
-        return iChronology.MILLIS_PER_DAY;
+    public long add(long millis, long value) {
+        return millis + value * iChronology.MILLIS_PER_DAY;
     }
 
-    public long getRangeMillis() {
-        return (long)(365.2425 * iChronology.MILLIS_PER_DAY);
+    public DurationField getRangeDurationField() {
+        return iChronology.years();
     }
 
     public int getMinimumValue() {
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJMonthOfYearField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJMonthOfYearField.java
index 136b92b94..ea9c729c7 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJMonthOfYearField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJMonthOfYearField.java
@@ -54,20 +54,35 @@
 
 package org.joda.test.time.chrono.gj;
 
+import org.joda.time.DurationField;
+
 /**
  * 
  * @author Brian S O'Neill
  */
 class TestGJMonthOfYearField extends TestGJDateTimeField {
     public TestGJMonthOfYearField(TestGJChronology chrono) {
-        super("monthOfYear", chrono);
+        super("monthOfYear", "months", chrono.millisPerMonth(), chrono);
     }
 
     public int get(long millis) {
         return iChronology.gjFromMillis(millis)[1];
     }
 
-    public long add(long millis, int value) {
+    public long set(long millis, int value) {
+        long timeOnlyMillis = iChronology.getTimeOnlyMillis(millis);
+        int[] ymd = iChronology.gjFromMillis(millis);
+        // First set to start of month...
+        millis = iChronology.millisFromGJ(ymd[0], value, 1);
+        // ...and use dayOfMonth field to check range.
+        int maxDay = iChronology.dayOfMonth().getMaximumValue(millis);
+        if (ymd[2] > maxDay) {
+            ymd[2] = maxDay;
+        }
+        return timeOnlyMillis + iChronology.millisFromGJ(ymd[0], value, ymd[2]);
+    }
+
+    public long add(long millis, long value) {
         int newYear = iChronology.year().get(millis)
             + (int)iChronology.div(value, 12);
         int newMonth = get(millis) + (int)iChronology.mod(value, 12);
@@ -84,25 +99,21 @@ public long add(long millis, int value) {
         return millis;
     }
 
-    public long set(long millis, int value) {
-        long timeOnlyMillis = iChronology.getTimeOnlyMillis(millis);
+    public boolean isLeap(long millis) {
         int[] ymd = iChronology.gjFromMillis(millis);
-        // First set to start of month...
-        millis = iChronology.millisFromGJ(ymd[0], value, 1);
-        // ...and use dayOfMonth field to check range.
-        int maxDay = iChronology.dayOfMonth().getMaximumValue(millis);
-        if (ymd[2] > maxDay) {
-            ymd[2] = maxDay;
-        }
-        return timeOnlyMillis + iChronology.millisFromGJ(ymd[0], value, ymd[2]);
+        return ymd[1] == 2 && iChronology.isLeapYear(ymd[0]);
+    }
+
+    public int getLeapAmount(long millis) {
+        return isLeap(millis) ? 1 : 0;
     }
 
-    public long getUnitMillis() {
-        return (long)(365.2425 * iChronology.MILLIS_PER_DAY / 12);
+    public DurationField getLeapDurationField() {
+        return iChronology.days();
     }
 
-    public long getRangeMillis() {
-        return (long)(365.2425 * iChronology.MILLIS_PER_DAY);
+    public DurationField getRangeDurationField() {
+        return iChronology.years();
     }
 
     public int getMinimumValue() {
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekOfWeekyearField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekOfWeekyearField.java
index d604413b4..908b75639 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekOfWeekyearField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekOfWeekyearField.java
@@ -54,35 +54,34 @@
 
 package org.joda.test.time.chrono.gj;
 
+import org.joda.time.DurationField;
+
 /**
  * 
  * @author Brian S O'Neill
  */
 class TestGJWeekOfWeekyearField extends TestGJDateTimeField {
     public TestGJWeekOfWeekyearField(TestGJChronology chrono) {
-        super("weekOfWeekyear", chrono);
+        super("weekOfWeekyear", "weeks",
+              (long)(chrono.MILLIS_PER_DAY * 7), chrono);
     }
 
     public int get(long millis) {
         return iChronology.isoFromMillis(millis)[1];
     }
 
-    public long add(long millis, int value) {
-        return iChronology.dayOfYear().add(millis, value * 7);
-    }
-
     public long set(long millis, int value) {
         int[] wwd = iChronology.isoFromMillis(millis);
         return iChronology.getTimeOnlyMillis(millis)
             + iChronology.millisFromISO(wwd[0], value, wwd[2]);
     }
 
-    public long getUnitMillis() {
-        return (long)(iChronology.MILLIS_PER_DAY * 7);
+    public long add(long millis, long value) {
+        return iChronology.dayOfYear().add(millis, value * 7);
     }
 
-    public long getRangeMillis() {
-        return (long)(365.2425 * iChronology.MILLIS_PER_DAY);
+    public DurationField getRangeDurationField() {
+        return iChronology.weeks();
     }
 
     public int getMinimumValue() {
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekyearField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekyearField.java
index 0d9cd7f75..d2dab646b 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekyearField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekyearField.java
@@ -54,23 +54,21 @@
 
 package org.joda.test.time.chrono.gj;
 
+import org.joda.time.DurationField;
+
 /**
  * 
  * @author Brian S O'Neill
  */
 class TestGJWeekyearField extends TestGJDateTimeField {
     public TestGJWeekyearField(TestGJChronology chrono) {
-        super("weekyear", chrono);
+        super("weekyear", "weekyears", chrono.millisPerYear(), chrono);
     }
 
     public int get(long millis) {
         return iChronology.isoFromMillis(millis)[0];
     }
 
-    public long add(long millis, int value) {
-        return set(millis, get(millis) + value);
-    }
-
     public long set(long millis, int value) {
         int[] wwd = iChronology.isoFromMillis(millis);
         millis = iChronology.getTimeOnlyMillis(millis)
@@ -85,12 +83,12 @@ public long set(long millis, int value) {
         return millis;
     }
 
-    public long getUnitMillis() {
-        return (long)(365.2425 * iChronology.MILLIS_PER_DAY);
+    public long add(long millis, long value) {
+        return set(millis, (int)(get(millis) + value));
     }
 
-    public long getRangeMillis() {
-        return Long.MAX_VALUE;
+    public DurationField getRangeDurationField() {
+        return null;
     }
 
     public int getMinimumValue() {
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJYearField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJYearField.java
index eea648c7b..333b02497 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJYearField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJYearField.java
@@ -54,23 +54,21 @@
 
 package org.joda.test.time.chrono.gj;
 
+import org.joda.time.DurationField;
+
 /**
  * 
  * @author Brian S O'Neill
  */
 class TestGJYearField extends TestGJDateTimeField {
     public TestGJYearField(TestGJChronology chrono) {
-        super("year", chrono);
+        super("year", "years", chrono.millisPerYear(), chrono);
     }
 
     public int get(long millis) {
         return iChronology.gjYearFromMillis(millis);
     }
 
-    public long add(long millis, int value) {
-        return set(millis, get(millis) + value);
-    }
-
     public long set(long millis, int value) {
         int[] ymd = iChronology.gjFromMillis(millis);
         millis = iChronology.getTimeOnlyMillis(millis)
@@ -81,6 +79,10 @@ public long set(long millis, int value) {
         return millis;
     }
 
+    public long add(long millis, long value) {
+        return set(millis, (int)(get(millis) + value));
+    }
+
     public boolean isLeap(long millis) {
         return iChronology.isLeapYear(get(millis));
     }
@@ -89,12 +91,12 @@ public int getLeapAmount(long millis) {
         return isLeap(millis) ? 1 : 0;
     }
 
-    public long getUnitMillis() {
-        return (long)(365.2425 * iChronology.MILLIS_PER_DAY);
+    public DurationField getLeapDurationField() {
+        return iChronology.days();
     }
 
-    public long getRangeMillis() {
-        return Long.MAX_VALUE;
+    public DurationField getRangeDurationField() {
+        return null;
     }
 
     public int getMinimumValue() {
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGregorianChronology.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGregorianChronology.java
index 9b81a3a6f..c95faa343 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGregorianChronology.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGregorianChronology.java
@@ -78,6 +78,18 @@ public TestGregorianChronology(int epochYear, int epochMonth, int epochDay) {
         super(epochYear, epochMonth, epochDay);
     }
 
+    public String toString() {
+        return "TestGregorianChronology";
+    }
+
+    long millisPerYear() {
+        return (long)(365.2425 * MILLIS_PER_DAY);
+    }
+
+    long millisPerMonth() {
+        return (long)(365.2425 * MILLIS_PER_DAY / 12);
+    }
+
     boolean isLeapYear(int year) {
         if (mod(year, 4) == 0) {
             int t = (int)mod(year, 400);
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianChronology.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianChronology.java
index 4007ecdaf..41a1021c5 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianChronology.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianChronology.java
@@ -102,6 +102,18 @@ public DateTimeField year() {
         return new TestJulianYearField(this);
     }
 
+    public String toString() {
+        return "TestJulianChronology";
+    }
+
+    long millisPerYear() {
+        return (long)(365.25 * MILLIS_PER_DAY);
+    }
+
+    long millisPerMonth() {
+        return (long)(365.25 * MILLIS_PER_DAY / 12);
+    }
+
     boolean isLeapYear(int year) {
         if (year == 0) {
             throw new IllegalArgumentException("Illegal year: " + year);
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianDayOfMonthField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianDayOfMonthField.java
index 6b5e7f7e9..3de60550d 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianDayOfMonthField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianDayOfMonthField.java
@@ -64,6 +64,6 @@ public TestJulianDayOfMonthField(TestJulianChronology chrono) {
     }
 
     public long getRangeMillis() {
-        return (long)(365.25 * iChronology.MILLIS_PER_DAY / 12);
+        return iChronology.millisPerMonth();
     }
 }
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianMonthOfYearField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianMonthOfYearField.java
index 90ec05e06..5ce21a897 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianMonthOfYearField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianMonthOfYearField.java
@@ -67,8 +67,8 @@ public int get(long millis) {
         return iChronology.gjFromMillis(millis)[1];
     }
 
-    public long add(long millis, int value) {
-		int year = iChronology.year().get(millis);
+    public long add(long millis, long value) {
+        int year = iChronology.year().get(millis);
         int newYear = year + (int)iChronology.div(value, 12);
         if (year < 0) {
             if (newYear >= 0) {
@@ -81,11 +81,11 @@ public long add(long millis, int value) {
         }
         int newMonth = get(millis) + (int)iChronology.mod(value, 12);
         if (newMonth > 12) {
-			if (newYear == -1) {
-				newYear = 1;
-			} else {
-				newYear++;
-			}
+            if (newYear == -1) {
+                newYear = 1;
+            } else {
+                newYear++;
+            }
             newMonth -= 12;
         }
         int newDay = iChronology.dayOfMonth().get(millis);
@@ -96,12 +96,4 @@ public long add(long millis, int value) {
         }
         return millis;
     }
-
-    public long getUnitMillis() {
-        return (long)(365.25 * iChronology.MILLIS_PER_DAY / 12);
-    }
-
-    public long getRangeMillis() {
-        return (long)(365.25 * iChronology.MILLIS_PER_DAY);
-    }
 }
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianWeekyearField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianWeekyearField.java
index 2dad74aa0..6f3abcc8c 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianWeekyearField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianWeekyearField.java
@@ -54,6 +54,8 @@
 
 package org.joda.test.time.chrono.gj;
 
+import org.joda.time.chrono.Utils;
+
 /**
  * 
  * @author Brian S O'Neill
@@ -65,14 +67,14 @@ public TestJulianWeekyearField(TestJulianChronology chrono) {
 
     public long addWrapped(long millis, int value) {
         int weekyear = get(millis);
-        int wrapped = getWrappedValue
+        int wrapped = Utils.getWrappedValue
             (weekyear, value, getMinimumValue(), getMaximumValue());
-        return add(millis, wrapped - weekyear);
+        return add(millis, (long) wrapped - weekyear);
     }
 
-    public long add(long millis, int value) {
+    public long add(long millis, long value) {
         int weekyear = get(millis);
-        int newWeekyear = weekyear + value;
+        int newWeekyear = weekyear + Utils.safeToInt(value);
         if (weekyear < 0) {
             if (newWeekyear >= 0) {
                 newWeekyear++;
@@ -85,10 +87,6 @@ public long add(long millis, int value) {
         return set(millis, newWeekyear);
     }
 
-    public long getUnitMillis() {
-        return (long)(365.25 * iChronology.MILLIS_PER_DAY);
-    }
-
     public int getMinimumValue() {
         return -100000000;
     }
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianYearField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianYearField.java
index 0d6bf131d..9e4d3276e 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianYearField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianYearField.java
@@ -54,6 +54,8 @@
 
 package org.joda.test.time.chrono.gj;
 
+import org.joda.time.chrono.Utils;
+
 /**
  * 
  * @author Brian S O'Neill
@@ -65,14 +67,14 @@ public TestJulianYearField(TestJulianChronology chrono) {
 
     public long addWrapped(long millis, int value) {
         int year = get(millis);
-        int wrapped = getWrappedValue
+        int wrapped = Utils.getWrappedValue
             (year, value, getMinimumValue(), getMaximumValue());
-        return add(millis, wrapped - year);
+        return add(millis, (long) wrapped - year);
     }
 
-    public long add(long millis, int value) {
+    public long add(long millis, long value) {
         int year = get(millis);
-        int newYear = year + value;
+        int newYear = year + Utils.safeToInt(value);
         if (year < 0) {
             if (newYear >= 0) {
                 newYear++;
@@ -85,10 +87,6 @@ public long add(long millis, int value) {
         return set(millis, newYear);
     }
 
-    public long getUnitMillis() {
-        return (long)(365.25 * iChronology.MILLIS_PER_DAY);
-    }
-
     public int getMinimumValue() {
         return -100000000;
     }
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJYearDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearDateTimeField.java
index bbf3fd28c..aba6d1321 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJYearDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearDateTimeField.java
@@ -98,7 +98,7 @@ protected int getMinimumValue() {
         return -292269053;
     }
     protected int getMaximumValue() {
-        return 292272992;
+        return 292278993;
     }
     protected int getCalendarValue(long millis) {
         millis = millis + getZone().getOffset(millis);
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfEraDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfEraDateTimeField.java
index 93443896d..244cc2ff7 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfEraDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfEraDateTimeField.java
@@ -96,7 +96,7 @@ protected int getMinimumValue() {
         return 1;
     }
     protected int getMaximumValue() {
-        return 292272992;
+        return 292278993;
     }
     protected int getCalendarValue(long millis) {
         iDate.setTime(millis);

From 85ff24c65d87a5e0cf61ab2931b368822bcda2a2 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Fri, 19 Dec 2003 02:08:56 +0000
Subject: [PATCH 006/143] Move TODO to top level

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@11 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/ToDo.txt     | 64 +++++++++++++++++++++++++++++++++++++++++++
 JodaTime/src/ToDo.txt | 37 -------------------------
 2 files changed, 64 insertions(+), 37 deletions(-)
 create mode 100644 JodaTime/ToDo.txt
 delete mode 100644 JodaTime/src/ToDo.txt

diff --git a/JodaTime/ToDo.txt b/JodaTime/ToDo.txt
new file mode 100644
index 000000000..001398346
--- /dev/null
+++ b/JodaTime/ToDo.txt
@@ -0,0 +1,64 @@
+JodaTime ToDo list
+==================
+
+1.0
+---
+Duration:
+ Write formatters/parsers
+ Write tests
+ 
+Interval:
+ Write classes
+ Write formatters/parsers
+ Write tests
+ 
+Tests:
+ Write tests to cover functionality
+ Ensure all tests pass!
+
+Serializable:
+ Tests
+ 
+DateOnly/TimeOnly:
+ Enable DateTimeProperty
+
+Consistency:
+ Check API for design and naming consistency
+ eg. withXxx() vs toXxx() vs asXxx vs toCopyXxx()
+ 
+ Chronology: withUTC(), withDateTimeZone()
+ AbstractInstant: toCopy()
+ DateTimeProperty: addToCopy(), setCopy(), ...
+ DurationSupport: withChronology()
+ 
+
+Ideas longer term
+-----------------
+Factories for DateTime clases?
+ Is a locale dependent one needed at least?
+
+More chronologies:
+ Implement more chronologies, like ChineseChronology, HebrewChronology,
+ PersianChronology, etc. This may require more work in localization.
+
+Chronology:
+ Add daysFrom(year)
+ This would be a DateTimeField that, given a base year, returns the number of
+ elapsed days from 1st Jan that year. Apparantly useful for Excel, where a
+ standard format is days from 1900.
+
+ISOCalendar:
+ Calendar subclass that implements our interface. This might be difficult to
+ do since Calendar has so many final methods and a rigid specification.
+
+ISODate:
+ Date subclasses that implements our interface. This might not be a worthwhile
+ effort since almost all Date methods are deprecated.
+
+Recurrence:
+ Create a set of classes for supporting recurrences. This will need to support
+ complex specifications such as "2nd Wednesday in May" and "next Thursday".
+ A builder design might be helpful.
+
+Holidays:
+ These can simply be special instances of Recurrences.
diff --git a/JodaTime/src/ToDo.txt b/JodaTime/src/ToDo.txt
deleted file mode 100644
index be1c61b49..000000000
--- a/JodaTime/src/ToDo.txt
+++ /dev/null
@@ -1,37 +0,0 @@
-JodaTime ToDo list
-==================
-
-1.0
----
-Durations/TimePeriods:
- Integrate new design
- Write formatter
- Write tests
- 
-Tests:
- Write tests to cover functionality
- Ensure all tests pass!
-
-Serializable - need tests and serialVersionID field
-
-BuddhistChronology:
- Code missing fields
-
-Factories for DateTime clases? Well a locale dependent one is needed at least
-
-
-Ideas longer term
------------------
-Chronology:
- Add daysFrom(year)
-
-ISOCalendar:
- Calendar subclass that implements our interface
-
-ISODate:
- Date subclasses that implements our interface
-
-PartialDateTime:
- Add a partial date time class? It would allow you to have specify for example 7th Feb
- without specifying the year.
-

From 3dbd6a94aecfa8f6ccf5ef4f15147665b5ef5d5f Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Fri, 19 Dec 2003 02:58:34 +0000
Subject: [PATCH 007/143] Exception message more general.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@12 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/AbstractDuration.java | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/AbstractDuration.java b/JodaTime/src/java/org/joda/time/AbstractDuration.java
index 151ea1c2b..b82958b02 100644
--- a/JodaTime/src/java/org/joda/time/AbstractDuration.java
+++ b/JodaTime/src/java/org/joda/time/AbstractDuration.java
@@ -75,8 +75,7 @@
     private static void checkSupport(DurationField field, String name) {
         if (!field.isSupported()) {
             throw new UnsupportedOperationException
-                ("Duration does not support field \"" + name
-                 + "\". Supplied value must be zero.");
+                ("Duration does not support field \"" + name + '"');
         }
     }
 

From c817e44f4baed717eac1ed8930c371e8a6eefd81 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Fri, 19 Dec 2003 02:58:51 +0000
Subject: [PATCH 008/143] Moved out of DateTimeZone class.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@13 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/tz/UTCProvider.java    | 85 +++++++++++++++++++
 1 file changed, 85 insertions(+)
 create mode 100644 JodaTime/src/java/org/joda/time/tz/UTCProvider.java

diff --git a/JodaTime/src/java/org/joda/time/tz/UTCProvider.java b/JodaTime/src/java/org/joda/time/tz/UTCProvider.java
new file mode 100644
index 000000000..f4a8235b8
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/tz/UTCProvider.java
@@ -0,0 +1,85 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.tz;
+
+import java.util.Collections;
+import java.util.Set;
+import org.joda.time.DateTimeZone;
+
+/**
+ * Simple time zone provider that supports only UTC.
+ * <p>
+ * UTCProvider is thread-safe and immutable.
+ *
+ * @author Brian S O'Neill
+ */
+public final class UTCProvider implements Provider {
+    /**
+     * Returns {@link DateTimeZone#UTC UTC} for <code>"UTC"</code>, null
+     * otherwise.
+     */
+    public DateTimeZone getDateTimeZone(String id) {
+        if ("UTC".equalsIgnoreCase(id)) {
+            return DateTimeZone.UTC;
+        }
+        return null;
+    }
+
+    /**
+     * Returns a singleton collection containing only <code>"UTC"</code>.
+     */    
+    public Set getAvailableIDs() {
+        return Collections.singleton("UTC");
+    }
+}

From 869c49c93fb2f672f9ae3175764dbc42587e6149 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Fri, 19 Dec 2003 02:59:22 +0000
Subject: [PATCH 009/143] Moved out UTCProvider.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@14 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/DateTimeZone.java   | 18 +++---------------
 1 file changed, 3 insertions(+), 15 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/DateTimeZone.java b/JodaTime/src/java/org/joda/time/DateTimeZone.java
index a5f30cb9c..795668991 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeZone.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeZone.java
@@ -72,13 +72,14 @@
 import org.joda.time.tz.FixedDateTimeZone;
 import org.joda.time.tz.NameProvider;
 import org.joda.time.tz.Provider;
+import org.joda.time.tz.UTCProvider;
 import org.joda.time.tz.ZoneInfoProvider;
 
 /**
  * DateTimeZone represents a time zone.
  * <p>
  * A time zone is a system of rules to convert time from one geographic 
- * location to another. For example, Paris, France in one hour ahead of
+ * location to another. For example, Paris, France is one hour ahead of
  * London, England. Thus when it is 10:00 in London, it is 11:00 in Paris.
  * <p>
  * All time zone rules are expressed, for historical reasons, relative to
@@ -121,7 +122,7 @@
     
     static final long serialVersionUID = 5546345482340108586L;
 
-    /** The UTC time zone */
+    /** The time zone for Universal Coordinated Time */
     public static final DateTimeZone UTC = new FixedDateTimeZone("UTC", "UTC", 0, 0);
 
     private static Provider cProvider;
@@ -701,19 +702,6 @@ protected Object writeReplace() throws ObjectStreamException {
         return new Stub(iID);
     }
 
-    static class UTCProvider implements Provider {
-        public DateTimeZone getDateTimeZone(String id) {
-            if ("UTC".equals(id)) {
-                return UTC;
-            }
-            return null;
-        }
-
-        public Set getAvailableIDs() {
-            return Collections.singleton("UTC");
-        }
-    }
-
     /**
      * Used to serialize DateTimeZones by id.
      */

From 28ba3f232ddbd438bdb4aabbd84fccd7fd13bb35 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Fri, 19 Dec 2003 03:00:09 +0000
Subject: [PATCH 010/143] Moved into DurationFormatterBuilder.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@15 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../joda/time/format/DurationFieldAffix.java  | 70 -------------------
 1 file changed, 70 deletions(-)
 delete mode 100644 JodaTime/src/java/org/joda/time/format/DurationFieldAffix.java

diff --git a/JodaTime/src/java/org/joda/time/format/DurationFieldAffix.java b/JodaTime/src/java/org/joda/time/format/DurationFieldAffix.java
deleted file mode 100644
index 85ca78d21..000000000
--- a/JodaTime/src/java/org/joda/time/format/DurationFieldAffix.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-03 Stephen Colebourne.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.format;
-
-import java.io.IOException;
-import java.io.Writer;
-
-/**
- * Defines a formatted field's prefix or suffix text.
- *
- * @author Brian S O'Neill
- */
-public interface DurationFieldAffix {
-    int calculatePrintedLength(int value);
-
-    void printTo(StringBuffer buf, int value);
-
-    void printTo(Writer out, int value) throws IOException;
-}

From 8af63231705a04a12f9e9a6436b518b0d77e0809 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Fri, 19 Dec 2003 03:00:43 +0000
Subject: [PATCH 011/143] Minor error formatting fix.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@16 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/format/AbstractDateTimeFormatter.java    | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java b/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java
index cd8915eff..7f6e30977 100644
--- a/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java
+++ b/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java
@@ -88,7 +88,7 @@
     static String createErrorMessage(final String text, final int errorPos) {
         int sampleLen = errorPos + 20;
         String sampleText;
-        if (text.length() <= sampleLen) {
+        if (text.length() <= sampleLen + 3) {
             sampleText = text;
         } else {
             sampleText = text.substring(0, sampleLen).concat("...");

From 048f3a5cc26c89f60f93d547dbcd9413f0eae73c Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Fri, 19 Dec 2003 03:01:08 +0000
Subject: [PATCH 012/143] Comment changes.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@17 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/time/format/DateTimeFormat.java  | 20 +++++++++----------
 1 file changed, 10 insertions(+), 10 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java b/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java
index 25c79fe10..7d587f7be 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java
@@ -166,8 +166,8 @@
     private static Map cInstanceCache = new HashMap(7);
 
     /**
-     * Gets an instance of a formatter that works using the ISOChronology in UTC
-     * in the default locale.
+     * Gets a formatter provider that works using ISOChronology with UTC in the
+     * default locale.
      * 
      * @return a format provider
      */
@@ -176,8 +176,8 @@ public static DateTimeFormat getInstanceUTC() {
     }
 
     /**
-     * Gets an instance of a formatter that works using the ISOChronology in the
-     * default time zone and the default locale.
+     * Gets a formatter provider that works using ISOChronology with the default
+     * time zone and the default locale.
      * 
      * @return a format provider
      */
@@ -186,7 +186,7 @@ public static DateTimeFormat getInstance() {
     }
 
     /**
-     * Gets an instance of a formatter that works using the ISOChronology in the
+     * Gets a formatter provider that works using ISOChronology with the
      * specified time zone and the default locale.
      * 
      * @param zone  the time zone to use, null for default zone
@@ -197,7 +197,7 @@ public static DateTimeFormat getInstance(final DateTimeZone zone) {
     }
 
     /**
-     * Gets an instance of a formatter that works using the ISOChronology in the
+     * Gets a formatter provider that works using ISOChronology with the
      * specified time zone and locale.
      * 
      * @param zone  the time zone to use, null for default zone
@@ -209,8 +209,8 @@ public static DateTimeFormat getInstance(final DateTimeZone zone, final Locale l
     }
 
     /**
-     * Gets an instance of a formatter that works using the specified chronology
-     * in the default locale.
+     * Gets a formatter provider that works using the specified chronology and
+     * the default locale.
      * 
      * @param chrono  the chronology to use, null means ISOChronology in the default time zone
      * @return a format provider
@@ -220,8 +220,8 @@ public static DateTimeFormat getInstance(final Chronology chrono) {
     }
 
     /**
-     * Gets an instance of a formatter that works using the specified chronology
-     * and locale.
+     * Gets a formatter provider that works using the specified chronology and
+     * locale.
      * 
      * @param chrono  the chronology to use, null means ISOChronology in the default time zone
      * @param locale  the Locale to use, null for default locale

From b6272b13444f16bd60245a5ff8f339e8fee1c64d Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Fri, 19 Dec 2003 03:01:39 +0000
Subject: [PATCH 013/143] More comments.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@18 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../time/format/DateTimeFormatterBuilder.java | 59 ++++++++++++++++++-
 1 file changed, 57 insertions(+), 2 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
index 06d58a8da..ee16b3b0e 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
@@ -72,8 +72,8 @@
  * formatters.
  *
  * <p>
- * For example, a formatter that prints month and year, like "January 1970", can
- * be constructed as follows:
+ * For example, a formatter that prints month and year, like "January 1970",
+ * can be constructed as follows:
  * <p>
  * <pre>
  * DateTimeFormatter monthAndYear = new DateTimeFormatterBuilder()
@@ -251,6 +251,7 @@ public void clear() {
     /**
      * Appends another formatter.
      *
+     * @return this DateTimeFormatterBuilder
      * @throws IllegalArgumentException if formatter is null
      */
     public DateTimeFormatterBuilder append(final DateTimeFormatter formatter)
@@ -266,6 +267,7 @@ public DateTimeFormatterBuilder append(final DateTimeFormatter formatter)
      * Appends just a printer. With no matching parser, a parser cannot be
      * built from this DateTimeFormatterBuilder.
      *
+     * @return this DateTimeFormatterBuilder
      * @throws IllegalArgumentException if printer is null
      */
     public DateTimeFormatterBuilder append(final DateTimePrinter printer)
@@ -281,6 +283,7 @@ public DateTimeFormatterBuilder append(final DateTimePrinter printer)
      * Appends just a parser. With no matching printer, a printer cannot be
      * built from this builder.
      *
+     * @return this DateTimeFormatterBuilder
      * @throws IllegalArgumentException if parser is null
      */
     public DateTimeFormatterBuilder append(final DateTimeParser parser) {
@@ -293,6 +296,7 @@ public DateTimeFormatterBuilder append(final DateTimeParser parser) {
     /**
      * Appends a printer/parser pair.
      *
+     * @return this DateTimeFormatterBuilder
      * @throws IllegalArgumentException if printer or parser is null
      */
     public DateTimeFormatterBuilder append(final DateTimePrinter printer,
@@ -319,6 +323,7 @@ public DateTimeFormatterBuilder append(final DateTimePrinter printer,
      * null, this represents the empty parser. The presence of an empty parser
      * indicates that the entire array of parse formats is optional.
      *
+     * @return this DateTimeFormatterBuilder
      * @throws IllegalArgumentException if any parser element but the last is null
      */
     public DateTimeFormatterBuilder append(final DateTimePrinter printer,
@@ -350,6 +355,7 @@ public DateTimeFormatterBuilder append(final DateTimePrinter printer,
      * Appends just a parser element which is optional. With no matching
      * printer, a printer cannot be built from this DateTimeFormatterBuilder.
      *
+     * @return this DateTimeFormatterBuilder
      * @throws IllegalArgumentException if parser is null
      */
     public DateTimeFormatterBuilder appendOptional(final DateTimeParser parser) {
@@ -378,6 +384,8 @@ private DateTimeFormatterBuilder append0(
     /**
      * Instructs the printer to emit a specific character, and the parser to
      * expect it. The parser is case-insensitive.
+     *
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendLiteral(final char c) {
         return append0(new CharacterLiteral(iChrono, c));
@@ -387,6 +395,7 @@ public DateTimeFormatterBuilder appendLiteral(final char c) {
      * Instructs the printer to emit specific text, and the parser to expect
      * it. The parser is case-insensitive.
      *
+     * @return this DateTimeFormatterBuilder
      * @throws IllegalArgumentException if text is null
      */
     public DateTimeFormatterBuilder appendLiteral(final String text) {
@@ -404,6 +413,7 @@ public DateTimeFormatterBuilder appendLiteral(final String text) {
      * @param minDigits minumum number of digits to <i>print</i>
      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated
      * maximum number of digits to print
+     * @return this DateTimeFormatterBuilder
      * @throws IllegalArgumentException if field is null
      */
     public DateTimeFormatterBuilder appendNumeric(
@@ -432,6 +442,7 @@ public DateTimeFormatterBuilder appendNumeric(
      * @param minDigits minumum number of digits to <i>print</i>
      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated
      * maximum number of digits to print
+     * @return this DateTimeFormatterBuilder
      * @throws IllegalArgumentException if field is null
      */
     public DateTimeFormatterBuilder appendSignedNumeric(
@@ -457,6 +468,7 @@ public DateTimeFormatterBuilder appendSignedNumeric(
      * parser to expect text.
      *
      * @param field field should operate in UTC or be time zone agnostic
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendText(final DateTimeField field) {
         return append0(new TextField(iChrono, field, iLocale, false));
@@ -467,6 +479,7 @@ public DateTimeFormatterBuilder appendText(final DateTimeField field) {
      * parser to expect text.
      *
      * @param field field should operate in UTC or be time zone agnostic
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendShortText(final DateTimeField field) {
         return append0(new TextField(iChrono, field, iLocale, true));
@@ -482,6 +495,7 @@ public DateTimeFormatterBuilder appendShortText(final DateTimeField field) {
      * @param field field should operate in UTC or be time zone agnostic
      * @param minDigits minumum number of digits to print.
      * @param maxDigits maximum number of digits to print or parse.
+     * @return this DateTimeFormatterBuilder
      * @throws IllegalArgumentException if field's duration is not precise
      */
     public DateTimeFormatterBuilder appendFraction(
@@ -501,6 +515,7 @@ public DateTimeFormatterBuilder appendFraction(
     /**
      * @param minDigits minumum number of digits to print
      * @param maxDigits maximum number of digits to print or parse
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendFractionOfSecond(final int minDigits, final int maxDigits) {
         return appendFraction(iChronoUTC.secondOfDay(), minDigits, maxDigits);
@@ -509,6 +524,7 @@ public DateTimeFormatterBuilder appendFractionOfSecond(final int minDigits, fina
     /**
      * @param minDigits minumum number of digits to print
      * @param maxDigits maximum number of digits to print or parse
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendFractionOfMinute(final int minDigits, final int maxDigits) {
         return appendFraction(iChronoUTC.minuteOfDay(), minDigits, maxDigits);
@@ -517,6 +533,7 @@ public DateTimeFormatterBuilder appendFractionOfMinute(final int minDigits, fina
     /**
      * @param minDigits minumum number of digits to print
      * @param maxDigits maximum number of digits to print or parse
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendFractionOfHour(final int minDigits, final int maxDigits) {
         return appendFraction(iChronoUTC.hourOfDay(), minDigits, maxDigits);
@@ -525,6 +542,7 @@ public DateTimeFormatterBuilder appendFractionOfHour(final int minDigits, final
     /**
      * @param minDigits minumum number of digits to print
      * @param maxDigits maximum number of digits to print or parse
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendFractionOfDay(final int minDigits, final int maxDigits) {
         return appendFraction(iChronoUTC.dayOfYear(), minDigits, maxDigits);
@@ -534,6 +552,7 @@ public DateTimeFormatterBuilder appendFractionOfDay(final int minDigits, final i
      * Instructs the printer to emit a numeric millisOfSecond field.
      *
      * @param minDigits minumum number of digits to print
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendMillisOfSecond(final int minDigits) {
         return appendNumeric(iChronoUTC.millisOfSecond(), minDigits, 3);
@@ -543,6 +562,7 @@ public DateTimeFormatterBuilder appendMillisOfSecond(final int minDigits) {
      * Instructs the printer to emit a numeric millisOfDay field.
      *
      * @param minDigits minumum number of digits to print
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendMillisOfDay(final int minDigits) {
         return appendNumeric(iChronoUTC.millisOfDay(), minDigits, 8);
@@ -552,6 +572,7 @@ public DateTimeFormatterBuilder appendMillisOfDay(final int minDigits) {
      * Instructs the printer to emit a numeric secondOfMinute field.
      *
      * @param minDigits minumum number of digits to print
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendSecondOfMinute(final int minDigits) {
         return appendNumeric(iChronoUTC.secondOfMinute(), minDigits, 2);
@@ -561,6 +582,7 @@ public DateTimeFormatterBuilder appendSecondOfMinute(final int minDigits) {
      * Instructs the printer to emit a numeric secondOfDay field.
      *
      * @param minDigits minumum number of digits to print
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendSecondOfDay(final int minDigits) {
         return appendNumeric(iChronoUTC.secondOfDay(), minDigits, 5);
@@ -570,6 +592,7 @@ public DateTimeFormatterBuilder appendSecondOfDay(final int minDigits) {
      * Instructs the printer to emit a numeric minuteOfHour field.
      *
      * @param minDigits minumum number of digits to print
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendMinuteOfHour(final int minDigits) {
         return appendNumeric(iChronoUTC.minuteOfHour(), minDigits, 2);
@@ -579,6 +602,7 @@ public DateTimeFormatterBuilder appendMinuteOfHour(final int minDigits) {
      * Instructs the printer to emit a numeric minuteOfDay field.
      *
      * @param minDigits minumum number of digits to print
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendMinuteOfDay(final int minDigits) {
         return appendNumeric(iChronoUTC.minuteOfDay(), minDigits, 4);
@@ -588,6 +612,7 @@ public DateTimeFormatterBuilder appendMinuteOfDay(final int minDigits) {
      * Instructs the printer to emit a numeric hourOfDay field.
      *
      * @param minDigits minumum number of digits to print
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendHourOfDay(final int minDigits) {
         return appendNumeric(iChronoUTC.hourOfDay(), minDigits, 2);
@@ -597,6 +622,7 @@ public DateTimeFormatterBuilder appendHourOfDay(final int minDigits) {
      * Instructs the printer to emit a numeric clockhourOfDay field.
      *
      * @param minDigits minumum number of digits to print
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendClockhourOfDay(final int minDigits) {
         return appendNumeric(iChronoUTC.clockhourOfDay(), minDigits, 2);
@@ -606,6 +632,7 @@ public DateTimeFormatterBuilder appendClockhourOfDay(final int minDigits) {
      * Instructs the printer to emit a numeric hourOfHalfday field.
      *
      * @param minDigits minumum number of digits to print
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendHourOfHalfday(final int minDigits) {
         return appendNumeric(iChronoUTC.hourOfHalfday(), minDigits, 2);
@@ -615,6 +642,7 @@ public DateTimeFormatterBuilder appendHourOfHalfday(final int minDigits) {
      * Instructs the printer to emit a numeric clockhourOfHalfday field.
      *
      * @param minDigits minumum number of digits to print
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendClockhourOfHalfday(final int minDigits) {
         return appendNumeric(iChronoUTC.clockhourOfHalfday(), minDigits, 2);
@@ -624,6 +652,7 @@ public DateTimeFormatterBuilder appendClockhourOfHalfday(final int minDigits) {
      * Instructs the printer to emit a numeric dayOfWeek field.
      *
      * @param minDigits minumum number of digits to print
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendDayOfWeek(final int minDigits) {
         return appendNumeric(iChronoUTC.dayOfWeek(), minDigits, 1);
@@ -633,6 +662,7 @@ public DateTimeFormatterBuilder appendDayOfWeek(final int minDigits) {
      * Instructs the printer to emit a numeric dayOfMonth field.
      *
      * @param minDigits minumum number of digits to print
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendDayOfMonth(final int minDigits) {
         return appendNumeric(iChronoUTC.dayOfMonth(), minDigits, 2);
@@ -642,6 +672,7 @@ public DateTimeFormatterBuilder appendDayOfMonth(final int minDigits) {
      * Instructs the printer to emit a numeric dayOfYear field.
      *
      * @param minDigits minumum number of digits to print
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendDayOfYear(final int minDigits) {
         return appendNumeric(iChronoUTC.dayOfYear(), minDigits, 3);
@@ -651,6 +682,7 @@ public DateTimeFormatterBuilder appendDayOfYear(final int minDigits) {
      * Instructs the printer to emit a numeric weekOfWeekyear field.
      *
      * @param minDigits minumum number of digits to print
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendWeekOfWeekyear(final int minDigits) {
         return appendNumeric(iChronoUTC.weekOfWeekyear(), minDigits, 2);
@@ -662,6 +694,7 @@ public DateTimeFormatterBuilder appendWeekOfWeekyear(final int minDigits) {
      * @param minDigits minumum number of digits to <i>print</i>
      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated
      * maximum number of digits to print
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendWeekyear(final int minDigits, final int maxDigits) {
         return appendNumeric
@@ -672,6 +705,7 @@ public DateTimeFormatterBuilder appendWeekyear(final int minDigits, final int ma
      * Instructs the printer to emit a numeric monthOfYear field.
      *
      * @param minDigits minumum number of digits to print
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendMonthOfYear(final int minDigits) {
         return appendNumeric(iChronoUTC.monthOfYear(), minDigits, 2);
@@ -683,6 +717,7 @@ public DateTimeFormatterBuilder appendMonthOfYear(final int minDigits) {
      * @param minDigits minumum number of digits to <i>print</i>
      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated
      * maximum number of digits to print
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendYear(final int minDigits, final int maxDigits) {
         return appendSignedNumeric(iChronoUTC.year(), minDigits, maxDigits);
@@ -694,6 +729,7 @@ public DateTimeFormatterBuilder appendYear(final int minDigits, final int maxDig
      * @param minDigits minumum number of digits to <i>print</i>
      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated
      * maximum number of digits to print
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendYearOfEra(final int minDigits, final int maxDigits) {
         return appendNumeric(iChronoUTC.yearOfEra(), minDigits, maxDigits);
@@ -705,6 +741,7 @@ public DateTimeFormatterBuilder appendYearOfEra(final int minDigits, final int m
      * @param minDigits minumum number of digits to print
      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated
      * maximum number of digits to print
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendYearOfCentury(final int minDigits, final int maxDigits) {
         return appendNumeric(iChronoUTC.yearOfCentury(), minDigits, maxDigits);
@@ -716,6 +753,7 @@ public DateTimeFormatterBuilder appendYearOfCentury(final int minDigits, final i
      * @param minDigits minumum number of digits to print
      * @param maxDigits maximum number of digits to <i>parse</i>, or the estimated
      * maximum number of digits to print
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendCenturyOfEra(final int minDigits, final int maxDigits) {
         return appendSignedNumeric(iChronoUTC.centuryOfEra(), minDigits, maxDigits);
@@ -724,6 +762,8 @@ public DateTimeFormatterBuilder appendCenturyOfEra(final int minDigits, final in
     /**
      * Instructs the printer to emit a locale-specific AM/PM text, and the
      * parser to expect it. The parser is case-insensitive.
+     *
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendHalfdayOfDayText() {
         return appendText(iChronoUTC.halfdayOfDay());
@@ -732,6 +772,8 @@ public DateTimeFormatterBuilder appendHalfdayOfDayText() {
     /**
      * Instructs the printer to emit a locale-specific dayOfWeek text. The
      * parser will accept a long or short dayOfWeek text, case-insensitive.
+     *
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendDayOfWeekText() {
         return appendText(iChronoUTC.dayOfWeek());
@@ -741,6 +783,8 @@ public DateTimeFormatterBuilder appendDayOfWeekText() {
      * Instructs the printer to emit a short locale-specific dayOfWeek
      * text. The parser will accept a long or short dayOfWeek text,
      * case-insensitive.
+     *
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendDayOfWeekShortText() {
         return appendShortText(iChronoUTC.dayOfWeek());
@@ -750,6 +794,8 @@ public DateTimeFormatterBuilder appendDayOfWeekShortText() {
      * Instructs the printer to emit a short locale-specific monthOfYear
      * text. The parser will accept a long or short monthOfYear text,
      * case-insensitive.
+     *
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendMonthOfYearText() { 
         return appendText(iChronoUTC.monthOfYear());
@@ -758,6 +804,8 @@ public DateTimeFormatterBuilder appendMonthOfYearText() {
     /**
      * Instructs the printer to emit a locale-specific monthOfYear text. The
      * parser will accept a long or short monthOfYear text, case-insensitive.
+     *
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendMonthOfYearShortText() {
         return appendShortText(iChronoUTC.monthOfYear());
@@ -766,6 +814,8 @@ public DateTimeFormatterBuilder appendMonthOfYearShortText() {
     /**
      * Instructs the printer to emit a locale-specific era text (BC/AD), and
      * the parser to expect it. The parser is case-insensitive.
+     *
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendEraText() {
         return appendText(iChronoUTC.era());
@@ -775,6 +825,8 @@ public DateTimeFormatterBuilder appendEraText() {
      * Instructs the printer to emit a locale-specific time zone name. A
      * parser cannot be created from this builder if a time zone name is
      * appended.
+     *
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendTimeZoneName() {
         return append0(new TimeZonePrinter(iChrono, iLocale, false), null);
@@ -784,6 +836,8 @@ public DateTimeFormatterBuilder appendTimeZoneName() {
      * Instructs the printer to emit a short locale-specific time zone
      * name. A parser cannot be created from this builder if time zone
      * name is appended.
+     *
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendTimeZoneShortName() {
         return append0(new TimeZonePrinter(iChrono, iLocale, true), null);
@@ -801,6 +855,7 @@ public DateTimeFormatterBuilder appendTimeZoneShortName() {
      * @param minFields minimum number of fields to print, stopping when no
      * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction
      * @param maxFields maximum number of fields to print
+     * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendTimeZoneOffset(
             final String zeroOffsetText, final boolean showSeparators,

From 8e779f0382a203bd95bdc66502f1eb2e06ae5719 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Fri, 19 Dec 2003 03:02:09 +0000
Subject: [PATCH 014/143] Finished parsing support.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@19 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../time/format/DurationFormatterBuilder.java | 555 +++++++++++++++---
 1 file changed, 480 insertions(+), 75 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java b/JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java
index f87647b3f..f7c8d9727 100644
--- a/JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java
+++ b/JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java
@@ -61,10 +61,32 @@
 import org.joda.time.DurationField;
 import org.joda.time.DurationType;
 import org.joda.time.ReadableDuration;
+import org.joda.time.ReadWritableDuration;
 
 /**
- * 
+ * DurationFormatterBuilder is used for constructing {@link DurationFormatter}s.
+ * DurationFormatters are built by appending specific fields and separators.
  *
+ * <p>
+ * For example, a formatter that prints years and months, like "15 years and 8 months",
+ * can be constructed as follows:
+ * <p>
+ * <pre>
+ * DurationFormatter yearsAndMonths = new DurationFormatterBuilder()
+ *     .printZeroAlways()
+ *     .appendYears()
+ *     .appendSuffix(" year", " years")
+ *     .appendSeparator(" and ")
+ *     .printZeroNever()
+ *     .appendMonths()
+ *     .appendSuffix(" month", " months")
+ *     .toFormatter();
+ * </pre>
+ * <p>
+ * DurationFormatterBuilder itself is mutable and not thread-safe, but the
+ * formatters that it builds are thread-safe and immutable.
+ *
+ * @see DurationFormat
  * @author Brian S O'Neill
  */
 public class DurationFormatterBuilder {
@@ -72,8 +94,12 @@
     private static final int PRINT_ZERO_MAYBE = 1;
     private static final int PRINT_ZERO_ALWAYS = 2;
 
+    private String iAlternate;
+
     private int iMinPrintedDigits = 1;
     private int iPrintZeroSetting;
+    private int iMaxParsedDigits = 10;
+    private boolean iRejectSignedValues;
 
     private DurationFieldAffix iPrefix;
 
@@ -90,71 +116,55 @@ public DurationFormatterBuilder() {
      * printer.
      */
     public DurationPrinter toPrinter() {
-        return toPrinter(iFormatters);
+        return toFormatter();
     }
 
     /**
-     * Converts to a DurationPrinter that prints using all the appended
+     * Converts to a DurationParser that parses using all the appended
      * elements. Subsequent changes to this builder do not affect the returned
-     * printer.
-     *
-     * @param alternate alternate text to print when printer emits no fields
+     * parser.
      */
-    public DurationPrinter toPrinter(String alternate) {
-        DurationPrinter printer = toPrinter();
-        if (alternate != null) {
-            return new AlternateSelector(printer, new Literal(alternate));
-        }
-        return printer;
+    public DurationParser toParser() {
+        return toFormatter();
     }
 
     /**
-     * Converts to a DurationPrinter that prints using all the appended
+     * Converts to a DurationFormatter that formats using all the appended
      * elements. Subsequent changes to this builder do not affect the returned
-     * printer.
-     *
-     * @param alternate alternate printer to use when printer emits no fields
+     * formatter.
      */
-    public DurationPrinter toPrinter(DurationPrinter alternate) {
-        DurationPrinter printer = toPrinter();
-        if (alternate != null) {
-            return new AlternateSelector(printer, alternate);
+    public DurationFormatter toFormatter() {
+        DurationFormatter formatter = toFormatter(iFormatters);
+        if (iAlternate != null) {
+            formatter = new AlternateSelector(formatter, iAlternate);
         }
-        return printer;
+        return formatter;
     }
 
-    private static DurationPrinter toPrinter(List formatters) {
+    private static DurationFormatter toFormatter(List formatters) {
         int size = formatters.size();
         if (size >= 2 && formatters.get(1) instanceof Separator) {
-            DurationPrinter before = (DurationPrinter) formatters.get(0);
+            DurationFormatter before = (DurationFormatter) formatters.get(0);
             if (size == 2) {
-                // Separator at the end would never print anything.
+                // Separator at the end would never format anything.
                 return before;
             }
             return ((Separator) formatters.get(1)).finish
-                (before, toPrinter(formatters.subList(2, size)));
+                (before, toFormatter(formatters.subList(2, size)));
         }
         return createComposite(formatters);
     }
 
-    /**
-     * Depending on what rules are applied, a parser may not be buildable due
-     * to ambiguities that may arise during parsing.
-     */
-    /*
-    public boolean canBuildParser() {
-        // TODO
-        return true;
-    }
-    */
-
     /**
      * Clears out all the appended elements, allowing this builder to be
      * reused.
      */
     public void clear() {
+        iAlternate = null;
         iMinPrintedDigits = 1;
         iPrintZeroSetting = PRINT_ZERO_NEVER;
+        iMaxParsedDigits = 10;
+        iRejectSignedValues = false;
         iPrefix = null;
         iFormatters.clear();
     }
@@ -162,6 +172,8 @@ public void clear() {
     /**
      * Appends just a printer. With no matching parser, a parser cannot be
      * built from this DurationFormatterBuilder.
+     *
+     * @return this DurationFormatterBuilder
      */
     public DurationFormatterBuilder append(DurationPrinter printer)
         throws IllegalArgumentException
@@ -178,6 +190,7 @@ public DurationFormatterBuilder append(DurationPrinter printer)
      * Instructs the printer to emit specific text, and the parser to expect
      * it. The parser is case-insensitive.
      *
+     * @return this DurationFormatterBuilder
      * @throws IllegalArgumentException if text is null
      */
     public DurationFormatterBuilder appendLiteral(String text) {
@@ -193,6 +206,8 @@ public DurationFormatterBuilder appendLiteral(String text) {
      * Set the minimum digits printed for the next and following appended
      * fields. By default, the minimum digits printed is one. If the field value
      * is zero, it is not printed unless a printZero rule is applied.
+     *
+     * @return this DurationFormatterBuilder
      */
     public DurationFormatterBuilder minimumPrintedDigits(int minDigits) {
         iMinPrintedDigits = minDigits;
@@ -202,23 +217,29 @@ public DurationFormatterBuilder minimumPrintedDigits(int minDigits) {
     /**
      * Set the maximum digits parsed for the next and following appended
      * fields. By default, the maximum digits parsed is ten.
+     *
+     * @return this DurationFormatterBuilder
      */
     public DurationFormatterBuilder maximumParsedDigits(int maxDigits) {
-        // TODO
+        iMaxParsedDigits = maxDigits;
         return this;
     }
 
     /**
      * Reject signed values when parsing the next and following appended fields.
+     *
+     * @return this DurationFormatterBuilder
      */
-    public DurationFormatterBuilder rejectSignedValues() {
-        // TODO
+    public DurationFormatterBuilder rejectSignedValues(boolean v) {
+        iRejectSignedValues = v;
         return this;
     }
 
     /**
      * Never print zero values for the next and following appended fields. This
      * is the default setting.
+     *
+     * @return this DurationFormatterBuilder
      */
     public DurationFormatterBuilder printZeroNever() {
         iPrintZeroSetting = PRINT_ZERO_NEVER;
@@ -228,6 +249,8 @@ public DurationFormatterBuilder printZeroNever() {
     /**
      * Print zero values for the next and following appened fields only if the
      * duration supports it.
+     *
+     * @return this DurationFormatterBuilder
      */
     public DurationFormatterBuilder printZeroMaybe() {
         iPrintZeroSetting = PRINT_ZERO_MAYBE;
@@ -236,7 +259,10 @@ public DurationFormatterBuilder printZeroMaybe() {
 
     /**
      * Always print zero values for the next and following appended fields,
-     * even if the duration doesn't support it.
+     * even if the duration doesn't support it. The parser requires values for
+     * fields that always print zero.
+     *
+     * @return this DurationFormatterBuilder
      */
     public DurationFormatterBuilder printZeroAlways() {
         iPrintZeroSetting = PRINT_ZERO_ALWAYS;
@@ -248,6 +274,7 @@ public DurationFormatterBuilder printZeroAlways() {
      * the field is not printed, neither is the prefix.
      *
      * @param text text to print before field only if field is printed
+     * @return this DurationFormatterBuilder
      * @see #appendSuffix
      */
     public DurationFormatterBuilder appendPrefix(String text) {
@@ -266,6 +293,7 @@ public DurationFormatterBuilder appendPrefix(String text) {
      *
      * @param singularText text to print if field value is one
      * @param pluralText text to print if field value is not one
+     * @return this DurationFormatterBuilder
      * @see #appendSuffix
      */
     public DurationFormatterBuilder appendPrefix(String singularText,
@@ -281,9 +309,10 @@ public DurationFormatterBuilder appendPrefix(String singularText,
      * the field is not printed, neither is the prefix.
      *
      * @param prefix custom prefix
+     * @return this DurationFormatterBuilder
      * @see #appendSuffix
      */
-    public DurationFormatterBuilder appendPrefix(DurationFieldAffix prefix) {
+    private DurationFormatterBuilder appendPrefix(DurationFieldAffix prefix) {
         if (prefix == null) {
             throw new IllegalArgumentException();
         }
@@ -296,6 +325,8 @@ public DurationFormatterBuilder appendPrefix(DurationFieldAffix prefix) {
 
     /**
      * Instruct the printer to emit a numeric years field, if supported.
+     *
+     * @return this DurationFormatterBuilder
      */
     public DurationFormatterBuilder appendYears() {
         appendField(1);
@@ -304,6 +335,8 @@ public DurationFormatterBuilder appendYears() {
 
     /**
      * Instruct the printer to emit a numeric years field, if supported.
+     *
+     * @return this DurationFormatterBuilder
      */
     public DurationFormatterBuilder appendMonths() {
         appendField(2);
@@ -312,6 +345,8 @@ public DurationFormatterBuilder appendMonths() {
 
     /**
      * Instruct the printer to emit a numeric weeks field, if supported.
+     *
+     * @return this DurationFormatterBuilder
      */
     public DurationFormatterBuilder appendWeeks() {
         appendField(3);
@@ -320,6 +355,8 @@ public DurationFormatterBuilder appendWeeks() {
 
     /**
      * Instruct the printer to emit a numeric days field, if supported.
+     *
+     * @return this DurationFormatterBuilder
      */
     public DurationFormatterBuilder appendDays() {
         appendField(4);
@@ -328,6 +365,8 @@ public DurationFormatterBuilder appendDays() {
 
     /**
      * Instruct the printer to emit a numeric hours field, if supported.
+     *
+     * @return this DurationFormatterBuilder
      */
     public DurationFormatterBuilder appendHours() {
         appendField(5);
@@ -336,6 +375,8 @@ public DurationFormatterBuilder appendHours() {
 
     /**
      * Instruct the printer to emit a numeric minutes field, if supported.
+     *
+     * @return this DurationFormatterBuilder
      */
     public DurationFormatterBuilder appendMinutes() {
         appendField(6);
@@ -344,6 +385,8 @@ public DurationFormatterBuilder appendMinutes() {
 
     /**
      * Instruct the printer to emit a numeric seconds field, if supported.
+     *
+     * @return this DurationFormatterBuilder
      */
     public DurationFormatterBuilder appendSeconds() {
         appendField(7);
@@ -352,6 +395,8 @@ public DurationFormatterBuilder appendSeconds() {
 
     /**
      * Instruct the printer to emit a numeric millis field, if supported.
+     *
+     * @return this DurationFormatterBuilder
      */
     public DurationFormatterBuilder appendMillis() {
         appendField(8);
@@ -360,6 +405,7 @@ public DurationFormatterBuilder appendMillis() {
 
     private void appendField(int type) {
         iFormatters.add(new FieldFormatter(iMinPrintedDigits, iPrintZeroSetting,
+                                           iMaxParsedDigits, iRejectSignedValues,
                                            type, iPrefix, null));
         iPrefix = null;
     }
@@ -369,6 +415,7 @@ private void appendField(int type) {
      * the field is not printed, neither is the suffix.
      *
      * @param text text to print after field only if field is printed
+     * @return this DurationFormatterBuilder
      * @throws IllegalStateException if no field exists to append to
      * @see #appendPrefix
      */
@@ -388,6 +435,7 @@ public DurationFormatterBuilder appendSuffix(String text) {
      *
      * @param singularText text to print if field value is one
      * @param pluralText text to print if field value is not one
+     * @return this DurationFormatterBuilder
      * @throws IllegalStateException if no field exists to append to
      * @see #appendPrefix
      */
@@ -404,10 +452,11 @@ public DurationFormatterBuilder appendSuffix(String singularText,
      * the field is not printed, neither is the suffix.
      *
      * @param suffix custom suffix
+     * @return this DurationFormatterBuilder
      * @throws IllegalStateException if no field exists to append to
      * @see #appendPrefix
      */
-    public DurationFormatterBuilder appendSuffix(DurationFieldAffix suffix) {
+    private DurationFormatterBuilder appendSuffix(DurationFieldAffix suffix) {
         Object f = null;
         if (iFormatters.size() > 0) {
             f = iFormatters.get(iFormatters.size() - 1);
@@ -427,6 +476,8 @@ public DurationFormatterBuilder appendSuffix(DurationFieldAffix suffix) {
      * <p>
      * Note: appending a separator discontinues any further work on the latest
      * appended field.
+     *
+     * @return this DurationFormatterBuilder
      */
     public DurationFormatterBuilder appendSeparator(String text) {
         return appendSeparator(text, text);
@@ -444,6 +495,7 @@ public DurationFormatterBuilder appendSeparator(String text) {
      *
      * @param finalText alternate used if this is the final separator
      * printed
+     * @return this DurationFormatterBuilder
      */
     public DurationFormatterBuilder appendSeparator(String text,
                                                     String finalText) {
@@ -475,7 +527,7 @@ public DurationFormatterBuilder appendSeparator(String text,
             // Merge two adjacent separators together.
             iFormatters.set(i, lastSeparator.merge(text, finalText));
         } else {
-            DurationPrinter composite = createComposite(formatters);
+            DurationFormatter composite = createComposite(formatters);
             formatters.clear();
             formatters.add(composite);
             
@@ -486,6 +538,21 @@ public DurationFormatterBuilder appendSeparator(String text,
         return this;
     }
 
+    /**
+     * Supply alternate text to print, when no fields are emitted. During
+     * parsing, the alternate text is compared against first. If the alternate
+     * text matches (ignoring case), the parser finishes without attempting to
+     * parse any specific fields.
+     *
+     * @return this DurationFormatterBuilder
+     */
+    // TODO: Drop support for alternate. Instead, show least significant field
+    // that is supported.
+    public DurationFormatterBuilder setAlternate(String text) {
+        iAlternate = text;
+        return this;
+    }
+
     private void clearPrefix() throws IllegalStateException {
         if (iPrefix != null) {
             throw new IllegalStateException("Prefix not followed by field");
@@ -493,14 +560,35 @@ private void clearPrefix() throws IllegalStateException {
         iPrefix = null;
     }
 
-    private static DurationPrinter createComposite(List formatters) {
+    private static DurationFormatter createComposite(List formatters) {
         if (formatters.size() == 1) {
-            return (DurationPrinter)formatters.get(0);
+            return (DurationFormatter)formatters.get(0);
         } else {
             return new Composite(formatters);
         }
     }
 
+    /**
+     * Defines a formatted field's prefix or suffix text.
+     */
+    private static interface DurationFieldAffix {
+        int calculatePrintedLength(int value);
+        
+        void printTo(StringBuffer buf, int value);
+        
+        void printTo(Writer out, int value) throws IOException;
+        
+        /**
+         * @return new position after parsing affix, or ~position of failure
+         */
+        int parse(String durationStr, int position);
+
+        /**
+         * @return position where affix starts, or original ~position if not found
+         */
+        int scan(String durationStr, int position);
+    }
+
     private static final class SingularAffix implements DurationFieldAffix {
         private final String iText;
 
@@ -519,6 +607,27 @@ public void printTo(StringBuffer buf, int value) {
         public void printTo(Writer out, int value) throws IOException {
             out.write(iText);
         }
+
+        public int parse(String durationStr, int position) {
+            String text = iText;
+            int textLength = text.length();
+            if (durationStr.regionMatches(true, position, text, 0, textLength)) {
+                return position + textLength;
+            }
+            return ~position;
+        }
+
+        public int scan(String durationStr, final int position) {
+            String text = iText;
+            int textLength = text.length();
+            int sourceLength = durationStr.length();
+            for (int pos = position; pos < sourceLength; pos++) {
+                if (durationStr.regionMatches(true, pos, text, 0, textLength)) {
+                    return pos;
+                }
+            }
+            return ~position;
+        }
     }
 
     private static final class PluralAffix implements DurationFieldAffix {
@@ -541,6 +650,55 @@ public void printTo(StringBuffer buf, int value) {
         public void printTo(Writer out, int value) throws IOException {
             out.write(value == 1 ? iSingularText : iPluralText);
         }
+
+        public int parse(String durationStr, int position) {
+            String text1 = iPluralText;
+            String text2 = iSingularText; 
+
+            if (text1.length() < text2.length()) {
+                // Swap in order to match longer one first.
+                String temp = text1;
+                text1 = text2;
+                text2 = temp;
+            }
+
+            if (durationStr.regionMatches
+                (true, position, text1, 0, text1.length())) {
+                return position + text1.length();
+            }
+            if (durationStr.regionMatches
+                (true, position, text2, 0, text2.length())) {
+                return position + text2.length();
+            }
+
+            return ~position;
+        }
+
+        public int scan(String durationStr, final int position) {
+            String text1 = iPluralText;
+            String text2 = iSingularText; 
+
+            if (text1.length() < text2.length()) {
+                // Swap in order to match longer one first.
+                String temp = text1;
+                text1 = text2;
+                text2 = temp;
+            }
+
+            int textLength1 = text1.length();
+            int textLength2 = text2.length();
+
+            int sourceLength = durationStr.length();
+            for (int pos = position; pos < sourceLength; pos++) {
+                if (durationStr.regionMatches(true, pos, text1, 0, textLength1)) {
+                    return pos;
+                }
+                if (durationStr.regionMatches(true, pos, text2, 0, textLength2)) {
+                    return pos;
+                }
+            }
+            return ~position;
+        }
     }
 
     private static final class CompositeAffix implements DurationFieldAffix {
@@ -566,13 +724,31 @@ public void printTo(Writer out, int value) throws IOException {
             iLeft.printTo(out, value);
             iRight.printTo(out, value);
         }
+
+        public int parse(String durationStr, int position) {
+            position = iLeft.parse(durationStr, position);
+            if (position >= 0) {
+                position = iRight.parse(durationStr, position);
+            }
+            return position;
+        }
+
+        public int scan(String durationStr, final int position) {
+            int pos = iLeft.scan(durationStr, position);
+            if (pos >= 0) {
+                return iRight.scan(durationStr, pos);
+            }
+            return ~position;
+        }
     }
 
     private static final class FieldFormatter extends AbstractDurationFormatter
-        implements DurationPrinter
+        implements DurationFormatter
     {
         private final int iMinPrintedDigits;
         private final int iPrintZeroSetting;
+        private final int iMaxParsedDigits;
+        private final boolean iRejectSignedValues;
 
         private final int iFieldType;
 
@@ -580,9 +756,12 @@ public void printTo(Writer out, int value) throws IOException {
         private final DurationFieldAffix iSuffix;
 
         FieldFormatter(int minPrintedDigits, int printZeroSetting,
+                       int maxParsedDigits, boolean rejectSignedValues,
                        int fieldType, DurationFieldAffix prefix, DurationFieldAffix suffix) {
             iMinPrintedDigits = minPrintedDigits;
             iPrintZeroSetting = printZeroSetting;
+            iMaxParsedDigits = maxParsedDigits;
+            iRejectSignedValues = rejectSignedValues;
             iFieldType = fieldType;
             iPrefix = prefix;
             iSuffix = suffix;
@@ -591,6 +770,8 @@ public void printTo(Writer out, int value) throws IOException {
         FieldFormatter(FieldFormatter field, DurationFieldAffix suffix) {
             iMinPrintedDigits = field.iMinPrintedDigits;
             iPrintZeroSetting = field.iPrintZeroSetting;
+            iMaxParsedDigits = field.iMaxParsedDigits;
+            iRejectSignedValues = field.iRejectSignedValues;
             iFieldType = field.iFieldType;
             iPrefix = field.iPrefix;
             if (field.iSuffix != null) {
@@ -680,6 +861,123 @@ public void printTo(Writer out, ReadableDuration duration) throws IOException {
             }
         }
 
+        public int parseInto(ReadWritableDuration duration,
+                             String text, int position) {
+
+            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);
+
+            // Shortcut test.
+            if (position >= text.length()) {
+                return mustParse ? ~position : position;
+            }
+
+            if (iPrefix != null) {
+                position = iPrefix.parse(text, position);
+                if (position >= 0) {
+                    // If prefix is found, then the parse must finish.
+                    mustParse = true;
+                } else {
+                    // Prefix not found, so bail.
+                    if (!mustParse) {
+                        // It's okay because parsing of this field is not
+                        // required. Don't return an error. Fields down the
+                        // chain can continue on, trying to parse.
+                        return ~position;
+                    }
+                    return position;
+                }
+            }
+
+            int suffixPos = -1;
+            if (iSuffix != null && !mustParse) {
+                // Pre-scan the suffix, to help determine if this field must be
+                // parsed.
+                suffixPos = iSuffix.scan(text, position);
+                if (suffixPos >= 0) {
+                    // If suffix is found, then parse must finish.
+                    mustParse = true;
+                } else {
+                    // Suffix not found, so bail.
+                    if (!mustParse) {
+                        // It's okay because parsing of this field is not
+                        // required. Don't return an error. Fields down the
+                        // chain can continue on, trying to parse.
+                        return ~suffixPos;
+                    }
+                    return suffixPos;
+                }
+            }
+
+            if (!mustParse && !isSupported(duration.getDurationType())) {
+                // If parsing is not required and the field is not supported,
+                // exit gracefully so that another parser can continue on.
+                return position;
+            }
+
+            int limit;
+            if (suffixPos > 0) {
+                limit = Math.min(iMaxParsedDigits, suffixPos - position);
+            } else {
+                limit = Math.min(iMaxParsedDigits, text.length() - position);
+            }
+
+            boolean negative = false;
+            int length = 0;
+            while (length < limit) {
+                char c = text.charAt(position + length);
+                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {
+                    negative = c == '-';
+                    if (negative) {
+                        length++;
+                    } else {
+                        // Skip the '+' for parseInt to succeed.
+                        position++;
+                    }
+                    // Expand the limit to disregard the sign character.
+                    limit = Math.min(limit + 1, text.length() - position);
+                    continue;
+                }
+                if (c < '0' || c > '9') {
+                    break;
+                }
+                length++;
+            }
+
+            if (length == 0) {
+                return ~position;
+            }
+
+            int value;
+            if (length == 3 && negative) {
+                value = -FormatUtils.parseTwoDigits(text, position + 1);
+            } else if (length == 2) {
+                if (negative) {
+                    value = text.charAt(position + 1) - '0';
+                    value = -value;
+                } else {
+                    value = FormatUtils.parseTwoDigits(text, position);
+                }
+            } else if (length == 1 && !negative) {
+                value = text.charAt(position) - '0';
+            } else {
+                String sub = text.substring(position, position + length);
+                try {
+                    value = Integer.parseInt(sub);
+                } catch (NumberFormatException e) {
+                    return ~position;
+                }
+            }
+
+            setFieldValue(duration, value);
+            position += length;
+
+            if (position >= 0 && iSuffix != null) {
+                position = iSuffix.parse(text, position);
+            }
+
+            return position;
+        }
+
         /**
          * @return negative value if nothing to print, otherwise lower 32 bits
          * is signed int value.
@@ -753,10 +1051,64 @@ long getFieldValue(ReadableDuration duration) {
 
             return value & 0xffffffffL;
         }
+
+        boolean isSupported(DurationType type) {
+            switch (iFieldType) {
+            default:
+                return false;
+            case 1:
+                return type.years().isSupported();
+            case 2:
+                return type.months().isSupported();
+            case 3:
+                return type.weeks().isSupported();
+            case 4:
+                return type.days().isSupported();
+            case 5:
+                return type.hours().isSupported();
+            case 6:
+                return type.minutes().isSupported();
+            case 7:
+                return type.seconds().isSupported();
+            case 8:
+                return type.millis().isSupported();
+            }
+        }
+
+        void setFieldValue(ReadWritableDuration duration, int value) {
+            switch (iFieldType) {
+            default:
+                break;
+            case 1:
+                duration.setYears(value);
+                break;
+            case 2:
+                duration.setMonths(value);
+                break;
+            case 3:
+                duration.setWeeks(value);
+                break;
+            case 4:
+                duration.setDays(value);
+                break;
+            case 5:
+                duration.setHours(value);
+                break;
+            case 6:
+                duration.setMinutes(value);
+                break;
+            case 7:
+                duration.setSeconds(value);
+                break;
+            case 8:
+                duration.setMillis(value);
+                break;
+            }
+        }
     }
 
     private static final class Literal extends AbstractDurationFormatter
-        implements DurationPrinter
+        implements DurationFormatter
     {
         private final String iText;
 
@@ -779,23 +1131,31 @@ public void printTo(StringBuffer buf, ReadableDuration duration) {
         public void printTo(Writer out, ReadableDuration duration) throws IOException {
             out.write(iText);
         }
+
+        public int parseInto(ReadWritableDuration duration,
+                             String durationStr, int position) {
+            if (durationStr.regionMatches(true, position, iText, 0, iText.length())) {
+                return position + iText.length();
+            }
+            return ~position;
+        }
     }
 
     private static final class Separator extends AbstractDurationFormatter
-        implements DurationPrinter
+        implements DurationFormatter
     {
         private final String iText;
         private final String iFinalText;
 
-        private final DurationPrinter iBefore;
-        private final DurationPrinter iAfter;
+        private final DurationFormatter iBefore;
+        private final DurationFormatter iAfter;
 
         Separator(String text, String finalText) {
             this(text, finalText, null, null);
         }
 
         Separator(String text, String finalText,
-                  DurationPrinter before, DurationPrinter after) {
+                  DurationFormatter before, DurationFormatter after) {
             iText = text;
             iFinalText = finalText;
             iBefore = before;
@@ -856,23 +1216,47 @@ public void printTo(Writer out, ReadableDuration duration) throws IOException {
             after.printTo(out, duration);
         }
 
+        public int parseInto(ReadWritableDuration duration,
+                             String durationStr, int position) {
+            final int oldPos = position;
+
+            position = iBefore.parseInto(duration, durationStr, position);
+
+            if (position < 0) {
+                return position;
+            }
+
+            if (position > oldPos) {
+                // Since position advanced, this separator is
+                // allowed. Optionally parse it.
+                if (durationStr.regionMatches(true, position, iText, 0, iText.length())) {
+                    position += iText.length();
+                } else if (iText != iFinalText && durationStr.regionMatches
+                           (true, position, iFinalText, 0, iFinalText.length())) {
+                    position += iFinalText.length();
+                }
+            }
+
+            return iAfter.parseInto(duration, durationStr, position);
+        }
+
         Separator merge(String text, String finalText) {
             return new Separator(iText + text, iFinalText + finalText, iBefore, iAfter);
         }
 
-        Separator finish(DurationPrinter before, DurationPrinter after) {
+        Separator finish(DurationFormatter before, DurationFormatter after) {
             return new Separator(iText, iFinalText, before, after);
         }
     }
 
     private static final class Composite extends AbstractDurationFormatter
-        implements DurationPrinter
+        implements DurationFormatter
     {
-        private final DurationPrinter[] iFormatters;
+        private final DurationFormatter[] iFormatters;
 
         Composite(List formatters) {
-            iFormatters = (DurationPrinter[])formatters.toArray
-                (new DurationPrinter[formatters.size()]);
+            iFormatters = (DurationFormatter[])formatters.toArray
+                (new DurationFormatter[formatters.size()]);
         }
 
         public int countFieldsToPrint(ReadableDuration duration, int stopAt) {
@@ -908,49 +1292,70 @@ public void printTo(Writer out, ReadableDuration duration) throws IOException {
                 printers[i].printTo(out, duration);
             }
         }
+
+        public int parseInto(ReadWritableDuration duration,
+                             String durationStr, int position) {
+            DurationParser[] parsers = iFormatters;
+
+            if (parsers == null) {
+                throw new UnsupportedOperationException();
+            }
+
+            int len = parsers.length;
+            for (int i=0; i<len && position >= 0; i++) {
+                position = parsers[i].parseInto(duration, durationStr, position);
+            }
+            return position;
+        }
     }
 
     private static final class AlternateSelector extends AbstractDurationFormatter
-        implements DurationPrinter
+        implements DurationFormatter
     {
-        private final DurationPrinter iPrimary;
-        private final DurationPrinter iAlternate;
+        private final DurationFormatter iFormatter;
+        private final String iAlternate;
 
-        AlternateSelector(DurationPrinter primary, DurationPrinter alternate) {
-            iPrimary = primary;
+        AlternateSelector(DurationFormatter formatter, String alternate) {
+            iFormatter = formatter;
             iAlternate = alternate;
         }
 
         public int countFieldsToPrint(ReadableDuration duration, int stopAt) {
-            int count = iPrimary.countFieldsToPrint(duration, stopAt);
-            if (count <= 0) {
-                count = iAlternate.countFieldsToPrint(duration, stopAt);
-            }
-            return count;
+            return iFormatter.countFieldsToPrint(duration, stopAt);
         }
 
         public int calculatePrintedLength(ReadableDuration duration) {
-            if (iPrimary.countFieldsToPrint(duration, 1) > 0) {
-                return iPrimary.calculatePrintedLength(duration);
+            if (iFormatter.countFieldsToPrint(duration, 1) > 0) {
+                return iFormatter.calculatePrintedLength(duration);
             } else {
-                return iAlternate.calculatePrintedLength(duration);
+                return iAlternate.length();
             }
         }
 
         public void printTo(StringBuffer buf, ReadableDuration duration) {
-            if (iPrimary.countFieldsToPrint(duration, 1) > 0) {
-                iPrimary.printTo(buf, duration);
+            if (iFormatter.countFieldsToPrint(duration, 1) > 0) {
+                iFormatter.printTo(buf, duration);
             } else {
-                iAlternate.printTo(buf, duration);
+                buf.append(iAlternate);
             }
         }
 
         public void printTo(Writer out, ReadableDuration duration) throws IOException {
-            if (iPrimary.countFieldsToPrint(duration, 1) > 0) {
-                iPrimary.printTo(out, duration);
+            if (iFormatter.countFieldsToPrint(duration, 1) > 0) {
+                iFormatter.printTo(out, duration);
             } else {
-                iAlternate.printTo(out, duration);
+                out.write(iAlternate);
+            }
+        }
+
+        public int parseInto(ReadWritableDuration duration,
+                             String durationStr, int position) {
+            String alt = iAlternate;
+            int altLength = alt.length();
+            if (durationStr.regionMatches(true, position, alt, 0, altLength)) {
+                return position + altLength;
             }
+            return iFormatter.parseInto(duration, durationStr, position);
         }
     }
 

From 9309cdcc206c9ac737d7a82481fb8dedc612cfa0 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Fri, 19 Dec 2003 03:02:20 +0000
Subject: [PATCH 015/143] Added

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@20 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/time/format/DurationFormat.java  | 130 ++++++++++++++++++
 1 file changed, 130 insertions(+)
 create mode 100644 JodaTime/src/java/org/joda/time/format/DurationFormat.java

diff --git a/JodaTime/src/java/org/joda/time/format/DurationFormat.java b/JodaTime/src/java/org/joda/time/format/DurationFormat.java
new file mode 100644
index 000000000..328547a13
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/format/DurationFormat.java
@@ -0,0 +1,130 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.format;
+
+import java.util.Locale;
+
+/**
+ * DurationFormat provides basic printing and parsing capabilities for
+ * durations. Eventually, this class will also support localization.
+ * <p>
+ * DurationFormat is thread-safe and immutable, and the formatters it returns
+ * are as well.
+ *
+ * @author Brian S O'Neill
+ * @since 1.0
+ * @see ISODurationFormat
+ * @see DurationFormatterBuilder
+ */
+public class DurationFormat {
+
+    private static final DurationFormat INSTANCE = new DurationFormat();
+
+    /**
+     * Gets a formatter provider that works using the default locale.
+     * 
+     * @return a format provider
+     */
+    public static DurationFormat getInstance() {
+        return INSTANCE;
+    }
+
+    /**
+     * Gets a formatter provider that works using the given locale.
+     * 
+     * @param locale  the Locale to use, null for default locale
+     * @return a format provider
+     */
+    public static DurationFormat getInstance(Locale locale) {
+        return INSTANCE;
+    }
+
+    private final DurationFormatter iDefault;
+
+    private DurationFormat() {
+        iDefault = new DurationFormatterBuilder()
+            .appendYears()
+            .appendSuffix(" year", " years")
+            .appendSeparator(", ", " and ")
+            .appendMonths()
+            .appendSuffix(" month", " months")
+            .appendSeparator(", ", " and ")
+            .appendWeeks()
+            .appendSuffix(" week", " weeks")
+            .appendSeparator(", ", " and ")
+            .appendDays()
+            .appendSuffix(" day", " days")
+            .appendSeparator(", ", " and ")
+            .appendHours()
+            .appendSuffix(" hour", " hours")
+            .appendSeparator(", ", " and ")
+            .appendMinutes()
+            .appendSuffix(" minute", " minutes")
+            .appendSeparator(", ", " and ")
+            .appendSeconds()
+            .appendSuffix(" second", " seconds")
+            .appendSeparator(", ", " and ")
+            .appendMillis()
+            .appendSuffix(" millisecond", " milliseconds")
+            .setAlternate("0 milliseconds")
+            .toFormatter();
+    }
+
+    /**
+     * Returns the default DurationFormatter.
+     */
+    public DurationFormatter getDefault() {
+        return iDefault;
+    }
+}

From 3099a72cc3adc0778109788f84eca910dd781162 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Fri, 19 Dec 2003 04:52:30 +0000
Subject: [PATCH 016/143] UTCProvider moved out of DateTimeZone.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@21 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/build.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/JodaTime/build.xml b/JodaTime/build.xml
index 6ca55dd4c..fd3c0a4ed 100644
--- a/JodaTime/build.xml
+++ b/JodaTime/build.xml
@@ -151,7 +151,7 @@
       <classpath path="${build.classes}" />
       <!-- Override default provider since data directory doesn't exist yet -->
       <sysproperty key="org.joda.time.DateTimeZone.Provider"
-                   value="org.joda.time.DateTimeZone$UTCProvider" />
+                   value="org.joda.time.tz.UTCProvider" />
       <!-- Specify destination directory for compiled data files -->
       <arg line="-d ../../../../../../../${build.classes}/org/joda/time/tz/data" />
       <!-- Specify all the data files to compile -->

From d3ddf13c4a3fe1dfa9849d0d04eeb9f86a4bad8f Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Fri, 19 Dec 2003 04:53:49 +0000
Subject: [PATCH 017/143] Alternate printing now selects a supported field.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@22 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../time/format/DurationFormatterBuilder.java | 273 ++++++++++++++----
 1 file changed, 212 insertions(+), 61 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java b/JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java
index f7c8d9727..739859e42 100644
--- a/JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java
+++ b/JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java
@@ -77,7 +77,7 @@
  *     .appendYears()
  *     .appendSuffix(" year", " years")
  *     .appendSeparator(" and ")
- *     .printZeroNever()
+ *     .printZeroRarely()
  *     .appendMonths()
  *     .appendSuffix(" month", " months")
  *     .toFormatter();
@@ -90,24 +90,28 @@
  * @author Brian S O'Neill
  */
 public class DurationFormatterBuilder {
-    private static final int PRINT_ZERO_NEVER = 0;
-    private static final int PRINT_ZERO_MAYBE = 1;
-    private static final int PRINT_ZERO_ALWAYS = 2;
+    private static final int PRINT_ZERO_RARELY = 1;
+    private static final int PRINT_ZERO_IF_SUPPORTED = 2;
+    private static final int PRINT_ZERO_ALWAYS = 3;
 
-    private String iAlternate;
+    private boolean iFavorFirstFieldForZero;
 
-    private int iMinPrintedDigits = 1;
+    private int iMinPrintedDigits;
     private int iPrintZeroSetting;
-    private int iMaxParsedDigits = 10;
+    private int iMaxParsedDigits;
     private boolean iRejectSignedValues;
 
     private DurationFieldAffix iPrefix;
 
-    // List of separate DurationFormatters.
+    // List of DurationFormatters used to build a final formatter.
     private List iFormatters;
 
+    // List of DurationFormatters used to build an alternate formatter. The
+    // alternate is chosen if no other fields are printed.
+    private List iAlternateFormatters;
+
     public DurationFormatterBuilder() {
-       iFormatters = new ArrayList();
+        clear();
     }
 
     /**
@@ -135,8 +139,17 @@ public DurationParser toParser() {
      */
     public DurationFormatter toFormatter() {
         DurationFormatter formatter = toFormatter(iFormatters);
-        if (iAlternate != null) {
-            formatter = new AlternateSelector(formatter, iAlternate);
+        List altFormatters = iAlternateFormatters;
+        if (altFormatters.size() > 0) {
+            // Alternate is needed only if field formatters were
+            // appended. Literals may have been appended as well.
+            for (int i=altFormatters.size(); --i>=0; ) {
+                if (altFormatters.get(i) instanceof FieldFormatter) {
+                    formatter = new AlternateSelector
+                        (formatter, altFormatters, iFavorFirstFieldForZero);
+                    break;
+                }
+            }
         }
         return formatter;
     }
@@ -160,13 +173,22 @@ private static DurationFormatter toFormatter(List formatters) {
      * reused.
      */
     public void clear() {
-        iAlternate = null;
+        iFavorFirstFieldForZero = false;
         iMinPrintedDigits = 1;
-        iPrintZeroSetting = PRINT_ZERO_NEVER;
+        iPrintZeroSetting = PRINT_ZERO_RARELY;
         iMaxParsedDigits = 10;
         iRejectSignedValues = false;
         iPrefix = null;
-        iFormatters.clear();
+        if (iFormatters == null) {
+            iFormatters = new ArrayList();
+        } else {
+            iFormatters.clear();
+        }
+        if (iAlternateFormatters == null) {
+            iAlternateFormatters = new ArrayList();
+        } else {
+            iAlternateFormatters.clear();
+        }
     }
 
     /**
@@ -198,7 +220,9 @@ public DurationFormatterBuilder appendLiteral(String text) {
             throw new IllegalArgumentException("Literal must not be null");
         }
         clearPrefix();
-        iFormatters.add(new Literal(text));
+        Literal literal = new Literal(text);
+        iFormatters.add(literal);
+        iAlternateFormatters.add(literal);
         return this;
     }
 
@@ -236,13 +260,18 @@ public DurationFormatterBuilder rejectSignedValues(boolean v) {
     }
 
     /**
-     * Never print zero values for the next and following appended fields. This
-     * is the default setting.
+     * Never print zero values for the next and following appended fields,
+     * unless no fields would be printed. If no fields are printed, the printer
+     * forces at most one "printZeroRarely" field to print a zero.
+     * <p>
+     * This field setting is the default.
      *
      * @return this DurationFormatterBuilder
+     * @see #favorLastFieldForZero()
+     * @see #favorFirstFieldForZero()
      */
-    public DurationFormatterBuilder printZeroNever() {
-        iPrintZeroSetting = PRINT_ZERO_NEVER;
+    public DurationFormatterBuilder printZeroRarely() {
+        iPrintZeroSetting = PRINT_ZERO_RARELY;
         return this;
     }
 
@@ -252,8 +281,8 @@ public DurationFormatterBuilder printZeroNever() {
      *
      * @return this DurationFormatterBuilder
      */
-    public DurationFormatterBuilder printZeroMaybe() {
-        iPrintZeroSetting = PRINT_ZERO_MAYBE;
+    public DurationFormatterBuilder printZeroIfSupported() {
+        iPrintZeroSetting = PRINT_ZERO_IF_SUPPORTED;
         return this;
     }
 
@@ -404,9 +433,14 @@ public DurationFormatterBuilder appendMillis() {
     }
 
     private void appendField(int type) {
-        iFormatters.add(new FieldFormatter(iMinPrintedDigits, iPrintZeroSetting,
-                                           iMaxParsedDigits, iRejectSignedValues,
-                                           type, iPrefix, null));
+        FieldFormatter field = new FieldFormatter
+            (iMinPrintedDigits, iPrintZeroSetting,
+             iMaxParsedDigits, iRejectSignedValues,
+             type, iPrefix, null);
+        iFormatters.add(field);
+        if (iPrintZeroSetting == PRINT_ZERO_RARELY) {
+            iAlternateFormatters.add(field);
+        }
         iPrefix = null;
     }
 
@@ -457,16 +491,26 @@ public DurationFormatterBuilder appendSuffix(String singularText,
      * @see #appendPrefix
      */
     private DurationFormatterBuilder appendSuffix(DurationFieldAffix suffix) {
-        Object f = null;
+        final Object originalField;
         if (iFormatters.size() > 0) {
-            f = iFormatters.get(iFormatters.size() - 1);
+            originalField = iFormatters.get(iFormatters.size() - 1);
+        } else {
+            originalField = null;
         }
-        if (!(f instanceof FieldFormatter)) {
+
+        if (originalField == null || !(originalField instanceof FieldFormatter)) {
             throw new IllegalStateException("No field to apply suffix to");
         }
+
         clearPrefix();
-        f = new FieldFormatter((FieldFormatter) f, suffix);
-        iFormatters.set(iFormatters.size() - 1, f);
+        Object newField = new FieldFormatter((FieldFormatter) originalField, suffix);
+        iFormatters.set(iFormatters.size() - 1, newField);
+
+        int index = iAlternateFormatters.lastIndexOf(originalField);
+        if (index >= 0) {
+            iAlternateFormatters.set(index, newField);
+        }
+
         return this;
     }
 
@@ -539,17 +583,38 @@ public DurationFormatterBuilder appendSeparator(String text,
     }
 
     /**
-     * Supply alternate text to print, when no fields are emitted. During
-     * parsing, the alternate text is compared against first. If the alternate
-     * text matches (ignoring case), the parser finishes without attempting to
-     * parse any specific fields.
+     * If the printer doesn't print any field values, it forces a
+     * "printZeroRarely" field to print. This setting controls which field is
+     * selected.
+     * <p>
+     * It starts from the last appended field, and moves towards the first,
+     * stopping until it finds a field that is supported by the duration being
+     * printed. If no supported fields are found, then no fields are printed.
+     * <p>
+     * This setting is the default.
+     *
+     * @return this DurationFormatterBuilder
+     * @see #printZeroRarely()
+     */
+    public DurationFormatterBuilder favorLastFieldForZero() {
+        iFavorFirstFieldForZero = false;
+        return this;
+    }
+
+    /**
+     * If the printer doesn't print any field values, it forces a
+     * "printZeroRarely" field to print. This setting controls which field is
+     * selected.
+     * <p>
+     * It starts from the first appended field, and moves towards the last,
+     * stopping until it finds a field that is supported by the duration being
+     * printed. If no supported fields are found, then no fields are printed.
      *
      * @return this DurationFormatterBuilder
+     * @see #printZeroRarely()
      */
-    // TODO: Drop support for alternate. Instead, show least significant field
-    // that is supported.
-    public DurationFormatterBuilder setAlternate(String text) {
-        iAlternate = text;
+    public DurationFormatterBuilder favorFirstFieldForZero() {
+        iFavorFirstFieldForZero = true;
         return this;
     }
 
@@ -780,6 +845,16 @@ public int scan(String durationStr, final int position) {
             iSuffix = suffix;
         }
 
+        FieldFormatter(FieldFormatter field, int printZeroSetting) {
+            iMinPrintedDigits = field.iMinPrintedDigits;
+            iPrintZeroSetting = printZeroSetting;
+            iMaxParsedDigits = field.iMaxParsedDigits;
+            iRejectSignedValues = field.iRejectSignedValues;
+            iFieldType = field.iFieldType;
+            iPrefix = field.iPrefix;
+            iSuffix = field.iSuffix;
+        }
+
         public int countFieldsToPrint(ReadableDuration duration) {
             if (iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue(duration) >= 0) {
                 return 1;
@@ -1045,7 +1120,7 @@ long getFieldValue(ReadableDuration duration) {
                 break;
             }
 
-            if (value == 0 && iPrintZeroSetting == PRINT_ZERO_NEVER) {
+            if (value == 0 && iPrintZeroSetting == PRINT_ZERO_RARELY) {
                 return -1;
             }
 
@@ -1105,6 +1180,10 @@ void setFieldValue(ReadWritableDuration duration, int value) {
                 break;
             }
         }
+
+        int getPrintZeroSetting() {
+            return iPrintZeroSetting;
+        }
     }
 
     private static final class Literal extends AbstractDurationFormatter
@@ -1312,50 +1391,122 @@ public int parseInto(ReadWritableDuration duration,
     private static final class AlternateSelector extends AbstractDurationFormatter
         implements DurationFormatter
     {
-        private final DurationFormatter iFormatter;
-        private final String iAlternate;
+        private final DurationFormatter iPrimaryFormatter;
+        private final DurationPrinter[] iAlternatePrinters;
+        private final boolean iFavorFirstFieldForZero;
 
-        AlternateSelector(DurationFormatter formatter, String alternate) {
-            iFormatter = formatter;
-            iAlternate = alternate;
+        AlternateSelector(DurationFormatter primaryFormatter,
+                          List alternatePrinters,
+                          boolean favorFirstFieldForZero) {
+            iPrimaryFormatter = primaryFormatter;
+            iAlternatePrinters = (DurationPrinter[])alternatePrinters.toArray
+                (new DurationPrinter[alternatePrinters.size()]);
+            iFavorFirstFieldForZero = favorFirstFieldForZero;
         }
 
         public int countFieldsToPrint(ReadableDuration duration, int stopAt) {
-            return iFormatter.countFieldsToPrint(duration, stopAt);
+            int count = iPrimaryFormatter.countFieldsToPrint(duration, stopAt);
+            if (count < 1 && stopAt >= 1) {
+                if (chooseFieldToPrint(duration) != null) {
+                    return 1;
+                }
+            }
+            return count;
         }
 
         public int calculatePrintedLength(ReadableDuration duration) {
-            if (iFormatter.countFieldsToPrint(duration, 1) > 0) {
-                return iFormatter.calculatePrintedLength(duration);
-            } else {
-                return iAlternate.length();
+            if (iPrimaryFormatter.countFieldsToPrint(duration, 1) > 0) {
+                return iPrimaryFormatter.calculatePrintedLength(duration);
             }
+
+            Object chosenOne = chooseFieldToPrint(duration);
+
+            int sum = 0;
+            DurationPrinter[] printers = iAlternatePrinters;
+            for (int i=printers.length; --i>=0; ) {
+                DurationPrinter dp = printers[i];
+                if (dp == chosenOne || !(dp instanceof FieldFormatter)) {
+                    sum += dp.calculatePrintedLength(duration);
+                }
+            }
+            return sum;
         }
 
         public void printTo(StringBuffer buf, ReadableDuration duration) {
-            if (iFormatter.countFieldsToPrint(duration, 1) > 0) {
-                iFormatter.printTo(buf, duration);
-            } else {
-                buf.append(iAlternate);
+            if (iPrimaryFormatter.countFieldsToPrint(duration, 1) > 0) {
+                iPrimaryFormatter.printTo(buf, duration);
+                return;
+            }
+
+            Object chosenOne = chooseFieldToPrint(duration);
+            
+            DurationPrinter[] printers = iAlternatePrinters;
+            int len = printers.length;
+            for (int i=0; i<len; i++) {
+                DurationPrinter dp = printers[i];
+                if (dp == chosenOne || !(dp instanceof FieldFormatter)) {
+                    dp.printTo(buf, duration);
+                }
             }
         }
 
         public void printTo(Writer out, ReadableDuration duration) throws IOException {
-            if (iFormatter.countFieldsToPrint(duration, 1) > 0) {
-                iFormatter.printTo(out, duration);
-            } else {
-                out.write(iAlternate);
+            if (iPrimaryFormatter.countFieldsToPrint(duration, 1) > 0) {
+                iPrimaryFormatter.printTo(out, duration);
+                return;
+            }
+            
+            Object chosenOne = chooseFieldToPrint(duration);
+
+            DurationPrinter[] printers = iAlternatePrinters;
+            int len = printers.length;
+            for (int i=0; i<len; i++) {
+                DurationPrinter dp = printers[i];
+                if (dp == chosenOne || !(dp instanceof FieldFormatter)) {
+                    dp.printTo(out, duration);
+                }
             }
         }
 
         public int parseInto(ReadWritableDuration duration,
                              String durationStr, int position) {
-            String alt = iAlternate;
-            int altLength = alt.length();
-            if (durationStr.regionMatches(true, position, alt, 0, altLength)) {
-                return position + altLength;
+            return iPrimaryFormatter.parseInto(duration, durationStr, position);
+        }
+
+        private FieldFormatter chooseFieldToPrint(ReadableDuration duration) {
+            DurationType type = duration.getDurationType();
+            DurationPrinter[] printers = iAlternatePrinters;
+            if (iFavorFirstFieldForZero) {
+                int len = printers.length;
+                for (int i=0; i<len; i++) {
+                    DurationPrinter dp = printers[i];
+                    if (dp instanceof FieldFormatter) {
+                        FieldFormatter ff = (FieldFormatter) dp;
+                        if (ff.isSupported(type)) {
+                            if (ff.getPrintZeroSetting() == PRINT_ZERO_RARELY) {
+                                ff = new FieldFormatter(ff, PRINT_ZERO_IF_SUPPORTED);
+                                printers[i] = ff;
+                            }
+                            return ff;
+                        }
+                    }
+                }
+            } else {
+                for (int i=printers.length; --i>=0; ) {
+                    DurationPrinter dp = printers[i];
+                    if (dp instanceof FieldFormatter) {
+                        FieldFormatter ff = (FieldFormatter) dp;
+                        if (ff.isSupported(type)) {
+                            if (ff.getPrintZeroSetting() == PRINT_ZERO_RARELY) {
+                                ff = new FieldFormatter(ff, PRINT_ZERO_IF_SUPPORTED);
+                                printers[i] = ff;
+                            }
+                            return ff;
+                        }
+                    }
+                }
             }
-            return iFormatter.parseInto(duration, durationStr, position);
+            return null;
         }
     }
 

From f75ec7b8ee2e4c849a8019e8b9d550a906b50bd6 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Fri, 19 Dec 2003 04:54:16 +0000
Subject: [PATCH 018/143] Call to dropped method removed.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@23 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/format/DurationFormat.java | 1 -
 1 file changed, 1 deletion(-)

diff --git a/JodaTime/src/java/org/joda/time/format/DurationFormat.java b/JodaTime/src/java/org/joda/time/format/DurationFormat.java
index 328547a13..fb0bae386 100644
--- a/JodaTime/src/java/org/joda/time/format/DurationFormat.java
+++ b/JodaTime/src/java/org/joda/time/format/DurationFormat.java
@@ -117,7 +117,6 @@ private DurationFormat() {
             .appendSeparator(", ", " and ")
             .appendMillis()
             .appendSuffix(" millisecond", " milliseconds")
-            .setAlternate("0 milliseconds")
             .toFormatter();
     }
 

From e1301ddf17a172569fb605e0ef4ac24ea113dacc Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Fri, 19 Dec 2003 22:06:56 +0000
Subject: [PATCH 019/143] Fix maven build to new UTCProvider

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@24 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/maven.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/JodaTime/maven.xml b/JodaTime/maven.xml
index 4e7c98d1d..01a1741bd 100644
--- a/JodaTime/maven.xml
+++ b/JodaTime/maven.xml
@@ -11,7 +11,7 @@
       <classpath path="${maven.build.dest}" />
       <!-- Override default provider since data directory doesn't exist yet -->
       <sysproperty key="org.joda.time.DateTimeZone.Provider"
-                   value="org.joda.time.DateTimeZone$UTCProvider" />
+                   value="org.joda.time.tz.UTCProvider" />
       <!-- Specify destination directory for compiled data files -->
       <arg line="-d ${maven.build.dest}/org/joda/time/tz/data" />
       <!-- Specify all the data files to compile -->

From 23bf6bcc0a71763b01ff3711468b16344b2b795d Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 20 Dec 2003 00:00:16 +0000
Subject: [PATCH 020/143] Initial website

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@25 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/xdocs/index.xml      | 101 ++++++++++++++++++++++++++++++++++
 JodaTime/xdocs/navigation.xml |  26 +++++++++
 JodaTime/xdocs/tasks.xml      |  38 +++++++++++++
 3 files changed, 165 insertions(+)
 create mode 100644 JodaTime/xdocs/index.xml
 create mode 100644 JodaTime/xdocs/navigation.xml
 create mode 100644 JodaTime/xdocs/tasks.xml

diff --git a/JodaTime/xdocs/index.xml b/JodaTime/xdocs/index.xml
new file mode 100644
index 000000000..065c9ec71
--- /dev/null
+++ b/JodaTime/xdocs/index.xml
@@ -0,0 +1,101 @@
+<?xml version="1.0"?>
+
+<document>
+
+ <properties>
+  <title>Joda Time</title>
+  <author email="scolebourne@users.sourceforge.net">Stephen Colebourne</author>
+ </properties>
+
+ <body>
+
+<section name="Joda Time">
+
+<p>
+<b>Joda Dates is a Java open-source project to rewrite the Java Date and Calendar classes.</b>
+</p>
+
+<p>
+Date and Time handling is fundamental to many applications.
+However, the classes supplied in Java have always been weak.
+Date should have been immutable, like String.
+Instead, it has many deprecated methods.
+Calendar makes accessing 'normal' dates difficult, due to the lack of simple methods.
+Calendar also has some strange performance characteristics. 
+</p>
+
+<p>
+The Joda Dates project seeks to provide an implementation of dates and times for the Java community.
+The 'default' calendar system implemented will be the ISO8601 standard.
+This specifies a framework for date and time management independent of locale.
+Thus, in the standard, the first day of the week is Monday, and this has the index 1.
+This avoids any ambiguity accross national boundaries.
+</p>
+
+<p>
+Additional calendar systems supported are Gregorian, Julian, GregorianJulian (GJ) and Buddhist.
+The design is flexible and pluggable, so adding additional calendar systems should be easy. 
+</p>
+
+<p>
+Using a Joda date you can write:
+</p>
+<pre>
+  DateTime dt = new DateTime();
+  int year = dt.getYear();
+  String monthText = dt.monthOfYear().getAsText();
+</pre>
+<p>
+And this is only a flavour of what is available, see the <a href="apidocs/index.html">API</a> for more detail.
+</p>
+
+<p>
+Current interfaces and implementations include:
+</p>
+<ul>
+<li>Instant</li>
+<li>DateTime</li>
+<li>DateOnly</li>
+<li>TimeOnly</li>
+<li>Duration</li>
+<li>DateTimeZone</li>
+<li>...plus formatting and parsing</li>
+</ul>
+
+<p>
+Joda Time is licenced under the <a href="license.html">Joda licence</a>,
+which is an Apache/BSD cloned licence.
+</p>
+
+</section>
+
+<section name="Documentation">
+<p>
+The <a href="apidocs/index.html">JavaDoc API documents</a> are available online.
+</p>
+<p>
+The <a href="http://cvs.sourceforge.net/viewcvs.py/joda-time">CVS repository</a> can be browsed.
+</p>
+</section>
+
+<section name="Releases">
+<p>
+<a href="http://sourceforge.net/project/showfiles.php?group_id=97367&amp;package_id=104212">Release 0.9</a>
+is the current latest release. It is reasonably stable, although some APIs will change for 1.0.
+</p>
+</section>
+
+<section name="Contact">
+<p>
+If you have any questions, or want to volunteer to help, just email
+<a href="mailto:scolebourne@users.sourceforge.net">scolebourne@users.sourceforge.net</a>
+</p>
+</section>
+</body>
+</document>
+
+
+
+
+
+
diff --git a/JodaTime/xdocs/navigation.xml b/JodaTime/xdocs/navigation.xml
new file mode 100644
index 000000000..3215a75ed
--- /dev/null
+++ b/JodaTime/xdocs/navigation.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+
+<project name="Joda Time">
+
+  <title>Joda Time</title>
+  <organizationLogo href="">Joda.org</organizationLogo>
+
+  <body>
+    <menu name="Joda Time">
+      <item name="Overview" href="/index.html"/>
+      <item name="Sourceforge" href="http://sourceforge.net/projects/joda-time/"/>
+      <item name="Javadoc" href="/apidocs/index.html"/>
+      <item name="CVS" href="http://cvs.sourceforge.net/viewcvs.py/joda-time/"/>
+      <item name="Test results" href="/junit-report.html"/>
+      <item name="Mailing lists" href="/mail-lists.html"/>
+      <item name="TODO" href="/tasks.html"/>
+      <item name="License" href="/license.html"/>
+    </menu>
+    <menu name="Joda">
+      <item name="Joda home" href="http://joda.sourceforge.net"/>
+      <item name="Beans" href="http://joda.sourceforge.net/beans.html"/>
+      <item name="Primitives" href="http://joda-primitives.sourceforge.net/index.html"/>
+    </menu>
+    
+  </body>
+</project>
diff --git a/JodaTime/xdocs/tasks.xml b/JodaTime/xdocs/tasks.xml
new file mode 100644
index 000000000..4590820d7
--- /dev/null
+++ b/JodaTime/xdocs/tasks.xml
@@ -0,0 +1,38 @@
+<?xml version="1.0"?>
+
+<document>
+
+ <properties>
+  <title>Joda Time - tasks outstanding</title>
+  <author email="scolebourne@users.sourceforge.net">Stephen Colebourne</author>
+ </properties>
+
+ <body>
+
+<section name="Tasks outstanding">
+
+<p>
+The following tasks still need doing:
+</p>
+
+<ul>
+<li>DateOnly/TimeOnly properties</li>
+<li>API consistency</li>
+<li>Interval</li>
+<li>Testing</li>
+<li>Release!</li>
+</ul>
+
+<p>
+Would you like to <a href="mailto:scolebourne@users.sourceforge.net">volunteer</a>?
+</p>
+</section>
+
+</body>
+</document>
+
+
+
+
+
+

From aed8060b561d1d8921acaf7af33ce72e5ec53a44 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 20 Dec 2003 00:00:49 +0000
Subject: [PATCH 021/143] Fix build script

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@26 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/build.xml | 132 ++++++++++++++++++++++++++++++---------------
 1 file changed, 89 insertions(+), 43 deletions(-)

diff --git a/JodaTime/build.xml b/JodaTime/build.xml
index fd3c0a4ed..b4c747f65 100644
--- a/JodaTime/build.xml
+++ b/JodaTime/build.xml
@@ -25,24 +25,32 @@
   <!-- The current version number of this component -->
   <property name="component.version"       value="0.95"/>
 
-  <!-- The base directory for component configuration files -->
-  <property name="conf.home"               value="src/conf"/>
-
-  <!-- The base directory for component sources -->
-  <property name="source.home"             value="src/java"/>
-
-  <!-- The base directory for unit test sources -->
-  <property name="test.home"               value="src/test"/>
+  <!-- The current version number of this component -->
+  <property name="component.fullname"      value="${component.name}-${component.version}"/>
+  
+  <!-- The directory of source files -->
+  <property name="xdocs"                   value="xdocs"/>
+  
+  <!-- The directory of source files -->
+  <property name="source"                  value="src"/>
+  <property name="source.home"             value="${source}/java"/>
+  <property name="source.tz"               value="${source.home}/org/joda/time/tz/src"/>
+  <property name="conf.home"               value="${source}/conf"/>
+  <property name="test.home"               value="${source}/test"/>
 
   <!-- The base directory for example sources -->
   <property name="example.home"            value="src/example"/>
 
   <!-- The base directory for compilation targets -->
-  <property name="build.home"              value="build"/>
-  <property name="build.conf"              value="${build.home}/conf"/>
-  <property name="build.classes"           value="${build.home}/classes"/>
-  <property name="build.tests"             value="${build.home}/tests"/>
-  <property name="build.dist"              value="${build.home}/dist"/>
+  <property name="build"                   value="build"/>
+  <property name="build.conf"              value="${build}/conf"/>
+  <property name="build.classes"           value="${build}/classes"/>
+  <property name="build.tz"                value="${build.classes}/org/joda/time/tz/data"/>
+  <property name="build.tests"             value="${build}/tests"/>
+  <property name="build.docs"              value="${build}/docs"/>
+  <property name="build.dist"              value="${build}/dist"/>
+  <property name="build.fullname"          value="${build}/${component.fullname}"/>
+  <property name="build.dist.fullname"     value="${build.dist}/${component.fullname}"/>
 
 
 <!-- ========== Compiler Defaults ========================================= -->
@@ -67,7 +75,7 @@
   <!-- Construct unit test classpath -->
   <path id="test.classpath">
     <pathelement location="${build.classes}"/>
-    <pathelement location="${build.home}/tests"/>
+    <pathelement location="${build.tests}"/>
     <pathelement location="${junit.jar}"/>
   </path>
 
@@ -84,7 +92,7 @@
 
   <target name="clean"
           description="Clean build and distribution directories">
-    <delete dir="${build.home}"/>
+    <delete dir="${build}"/>
   </target>
 
 <!-- ====================================================================== -->
@@ -101,10 +109,9 @@
 
   <target name="prepare" depends="init"
           description="Prepare build directory">
-    <mkdir dir="${build.home}"/>
+    <mkdir dir="${build}"/>
     <mkdir dir="${build.classes}"/>
     <mkdir dir="${build.conf}"/>
-    <mkdir dir="${build.tests}"/>
   </target>
 
 <!-- ====================================================================== -->
@@ -119,8 +126,13 @@
 
 <!-- ====================================================================== -->
 
-  <target name="compile" depends="static,compile.main,compile.zoneinfo"
-          description="Compile shareable components"/>
+  <target name="compile" depends="compile.main"
+          description="Compile shareable components">
+    <uptodate property="tz.build.notneeded" targetfile="${build.tz}/ZoneInfoMap" >
+      <srcfiles dir= "${source.tz}" includes="**/*.*"/>
+    </uptodate>
+    <antcall target="compile.zoneinfo" />
+  </target>
           
           
   <target name="compile.main" depends="static"
@@ -141,19 +153,20 @@
 
   <target name="compile.zoneinfo"
           depends="compile.main"
-          description="Compile timezone data files" >
+          description="Compile timezone data files"
+          unless="tz.build.notneeded">
     <!-- Invoke the newly built ZoneInfoCompiler to compile the zoneinfo data files -->
-    <mkdir dir="${build.classes}/org/joda/time/tz/data" />
+    <mkdir dir="${build.tz}" />
     <java classname="org.joda.time.tz.ZoneInfoCompiler"
           fork="true"
-          dir="${source.home}/org/joda/time/tz/src"
+          dir="${source.tz}"
           failonerror="true">
       <classpath path="${build.classes}" />
       <!-- Override default provider since data directory doesn't exist yet -->
       <sysproperty key="org.joda.time.DateTimeZone.Provider"
                    value="org.joda.time.tz.UTCProvider" />
       <!-- Specify destination directory for compiled data files -->
-      <arg line="-d ../../../../../../../${build.classes}/org/joda/time/tz/data" />
+      <arg line="-d ../../../../../../../${build.tz}" />
       <!-- Specify all the data files to compile -->
       <arg value="africa" />
       <arg value="antarctica" />
@@ -176,6 +189,7 @@
 
   <target name="compile.tests" depends="compile"
           description="Compile unit test cases">
+    <mkdir dir="${build.tests}"/>
     <javac  srcdir="${test.home}"
            destdir="${build.tests}"
              debug="${compile.debug}"
@@ -197,47 +211,79 @@
 
   <target name="javadoc" depends="compile"
           description="Create component Javadoc documentation">
-    <mkdir      dir="${dist.home}"/>
-    <mkdir      dir="${dist.home}/docs"/>
-    <mkdir      dir="${dist.home}/docs/api"/>
+    <mkdir      dir="${build.docs}"/>
     <javadoc sourcepath="${source.home}"
-                destdir="${dist.home}/docs/api"
+                destdir="${build.docs}"
            packagenames="org.joda.time.*"
                  author="true"
-                private="true"
+                private="false"
+                package="false"
                 version="true"
                doctitle="&lt;h1&gt;${component.title}&lt;/h1&gt;"
             windowtitle="${component.title} (Version ${component.version})"
-                 bottom="Copyright (c) 2003 - Joda.org">
+                 bottom="Copyright (c) 2001-2003 - Joda.org">
       <classpath refid="compile.classpath"/>
     </javadoc>
   </target>
 
-<!-- ====================================================================== -->
-
-  <target name="dist" depends="compile,javadoc"
-          description="Create binary distribution">
-    <mkdir      dir="${dist.home}"/>
-    <copy      file="LICENSE.txt"
-              todir="${dist.home}"/>
-    <copy      file="RELEASE-NOTES.txt"
-              todir="${dist.home}"/>
-    <antcall target="jar"/>
-  </target>
-
 <!-- ====================================================================== -->
 
   <target name="jar" depends="compile"
           description="Create jar">
-    <mkdir      dir="${dist.home}"/>
     <mkdir      dir="${build.classes}/META-INF"/>
     <copy      file="LICENSE.txt"
              tofile="${build.classes}/META-INF/LICENSE.txt"/>
-    <jar    jarfile="${dist.home}/${component.name}-${component.version}.jar"
+    <jar    jarfile="${build.fullname}.jar"
             basedir="${build.classes}"
            manifest="${build.conf}/MANIFEST.MF"/>
   </target>
 
+<!-- ====================================================================== -->
+
+  <target name="dist" depends="compile,jar,javadoc"
+          description="Create binary distribution">
+    <delete     dir="${build.dist.fullname}"/>
+    <mkdir      dir="${build.dist.fullname}"/>
+    
+	<!-- binary -->
+    <copy      file="LICENSE.txt" todir="${build.dist.fullname}"/>
+    <copy      file="RELEASE-NOTES.txt" todir="${build.dist.fullname}"/>
+    <copy      file="${build.fullname}.jar"
+              todir="${build.dist.fullname}"/>
+    <copy     todir="${build.dist.fullname}">
+      <fileset  dir="${build}" includes="docs/**/*.*"/>
+    </copy>
+    
+	<tar   destfile="${build.fullname}.tar" basedir="${build.dist}"/>
+	<gzip   zipfile="${build.fullname}.tar.gz" src="${build.fullname}.tar"/>
+	<delete    file="${build.fullname}.tar"/>
+	<fixcrlf srcdir="${build.dist}" eol="crlf" includes="**/*.txt"/>
+	<zip   destfile="${build.fullname}.zip" basedir="${build.dist}"/>
+	
+	<!-- source -->
+	<delete     dir="${build.dist.fullname}/docs"/>
+    <copy     todir="${build.dist.fullname}">
+      <fileset  dir="." includes="${source}/**/*" excludes="CVS/**/*"/>
+    </copy>
+    <copy     todir="${build.dist.fullname}">
+      <fileset  dir="." includes="${xdocs}/**/*" excludes="CVS/**/*"/>
+    </copy>
+	<delete     dir="${build.dist.fullname}/src/tzdata"/>
+    <copy      file="build.xml" todir="${build.dist.fullname}"/>
+    <copy      file="build.properties.sample" todir="${build.dist.fullname}"/>
+    <copy      file="maven.xml" todir="${build.dist.fullname}"/>
+    <copy      file="project.xml" todir="${build.dist.fullname}"/>
+    <copy      file="project.properties" todir="${build.dist.fullname}"/>
+    <copy      file="checkstyle.xml" todir="${build.dist.fullname}"/>
+    <copy      file="ToDo.txt" todir="${build.dist.fullname}"/>
+	
+	<tar   destfile="${build.fullname}-src.tar" basedir="${build.dist}"/>
+	<gzip   zipfile="${build.fullname}-src.tar.gz" src="${build.fullname}-src.tar"/>
+	<delete    file="${build.fullname}-src.tar"/>
+	<fixcrlf srcdir="${build.dist}" eol="crlf" includes="**/*.txt"/>
+	<zip   destfile="${build.fullname}-src.zip" basedir="${build.dist}"/>
+  </target>
+
 <!-- ====================================================================== -->
 
   <target name="test"  depends="compile.tests, test.time"

From 8f53ce908dc55357f196ed92a1ab673c5416eb81 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 20 Dec 2003 00:01:07 +0000
Subject: [PATCH 022/143] Basic release notes

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@27 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/RELEASE-NOTES.txt | 11 +++++++++++
 1 file changed, 11 insertions(+)
 create mode 100644 JodaTime/RELEASE-NOTES.txt

diff --git a/JodaTime/RELEASE-NOTES.txt b/JodaTime/RELEASE-NOTES.txt
new file mode 100644
index 000000000..7c91060d4
--- /dev/null
+++ b/JodaTime/RELEASE-NOTES.txt
@@ -0,0 +1,11 @@
+Joda-Time version 0.95
+----------------------
+
+This version of Joda-Time is the first released from the new home of joda-time.sourceforge.net.
+The API has had many details tidied up, and performance tweaked.
+It also has a Duration class again, complete with parser and formatter.
+
+The code is accurate as far as we know, however the tests could still do with work.
+So, if you would like to help out in any way, let us know.
+
+scolebourne@users.sourceforge.net
\ No newline at end of file

From 4b616bb626baf22ebc64582ac344b76ab040d1b0 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 20 Dec 2003 00:12:11 +0000
Subject: [PATCH 023/143] Update to reference more people

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@28 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/project.xml | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/JodaTime/project.xml b/JodaTime/project.xml
index 9e0f262b3..97165e71a 100644
--- a/JodaTime/project.xml
+++ b/JodaTime/project.xml
@@ -56,10 +56,16 @@
       <id>broneill</id>
       <email>broneill@users.sourceforge.net</email>
       <organization></organization>
+      <roles>
+        <role>Senior Developer</role>
+      </roles>
     </developer>
   </developers>
   
   <contributors>
+    <contributor>
+      <name>Guy Allard</name>
+    </contributor>
   </contributors>
 
   <dependencies>

From b6f8660bff6c31a4d3896848b70371fa32fd7bbf Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 20 Dec 2003 08:49:46 +0000
Subject: [PATCH 024/143] Can specify source directory too.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@29 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/time/tz/ZoneInfoCompiler.java    | 67 +++++++++++++------
 1 file changed, 46 insertions(+), 21 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java b/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java
index 9442edee2..5f866a602 100644
--- a/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java
+++ b/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java
@@ -102,7 +102,14 @@
     static final DateTimeOfYear START_OF_YEAR = new DateTimeOfYear();
 
     /**
-     * Usage: java ZoneInfoCompiler [-d outputDirectory] sourceFile ...
+     * Launches the ZoneInfoCompiler tool.
+     *
+     * <pre>
+     * Usage: java org.joda.time.tz.ZoneInfoCompiler &lt;options&gt; &lt;source files&gt;");
+     * where possible options include:");
+     *   -src &lt;directory&gt;    Specify where to read source files");
+     *   -dst &lt;directory&gt;    Specify where to write generated files");
+     * </pre>
      */
     public static void main(String[] args) throws Exception {
         if (args.length == 0) {
@@ -110,18 +117,36 @@ public static void main(String[] args) throws Exception {
             return;
         }
 
-        String[] sources = args;
-        String outputDir = null;
+        File inputDir = null;
+        File outputDir = null;
 
-        if ("-d".equals(args[0])) {
-            if (args.length < 3) {
+        int i;
+        for (i=0; i<args.length; i++) {
+            try {
+                if ("-src".equals(args[i])) {
+                    inputDir = new File(args[++i]);
+                } else if ("-dst".equals(args[i])) {
+                    outputDir = new File(args[++i]);
+                } else if ("-?".equals(args[i])) {
+                    printUsage();
+                    return;
+                } else {
+                    break;
+                }
+            } catch (IndexOutOfBoundsException e) {
                 printUsage();
                 return;
             }
-            outputDir = args[1];
-            String[] newSources = new String[args.length - 2];
-            System.arraycopy(args, 2, newSources, 0, newSources.length);
-            sources = newSources;
+        }
+
+        if (i >= args.length) {
+            printUsage();
+            return;
+        }
+
+        File[] sources = new File[args.length - i];
+        for (int j=0; i<args.length; i++,j++) {
+            sources[j] = inputDir == null ? new File(args[i]) : new File(inputDir, args[i]);
         }
 
         ZoneInfoCompiler zic = new ZoneInfoCompiler();
@@ -129,8 +154,10 @@ public static void main(String[] args) throws Exception {
     }
 
     private static void printUsage() {
-        System.out.println
-            ("Usage: java ZoneInfoCompiler [-d outputDirectory] sourceFile ...");
+        System.out.println("Usage: java org.joda.time.tz.ZoneInfoCompiler <options> <source files>");
+        System.out.println("where possible options include:");
+        System.out.println("  -src <directory>    Specify where to read source files");
+        System.out.println("  -dst <directory>    Specify where to write generated files");
     }
 
     /**
@@ -367,9 +394,9 @@ public ZoneInfoCompiler() {
      * Returns a map of ids to DateTimeZones.
      *
      * @param outputDir optional directory to write compiled data files to
-     * @param sources optional list of source file paths to parse
+     * @param sources optional list of source files to parse
      */
-    public Map compile(String outputDir, String[] sources) throws IOException {
+    public Map compile(File outputDir, File[] sources) throws IOException {
         if (sources != null) {
             for (int i=0; i<sources.length; i++) {
                 BufferedReader in = new BufferedReader(new FileReader(sources[i]));
@@ -378,13 +405,11 @@ public Map compile(String outputDir, String[] sources) throws IOException {
             }
         }
 
-        File dir = null;
         if (outputDir != null) {
-            dir = new File(outputDir);
-            if (!dir.exists()) {
+            if (!outputDir.exists()) {
                 throw new IOException("Destination directory doesn't exist: " + outputDir);
             }
-            if (!dir.isDirectory()) {
+            if (!outputDir.isDirectory()) {
                 throw new IOException("Destination is not a directory: " + outputDir);
             }
         }
@@ -399,9 +424,9 @@ public Map compile(String outputDir, String[] sources) throws IOException {
             DateTimeZone tz = original;
             if (test(tz.getID(), tz)) {
                 map.put(tz.getID(), tz);
-                if (dir != null) {
+                if (outputDir != null) {
                     System.out.println("Writing " + tz.getID());
-                    File file = new File(dir, tz.getID());
+                    File file = new File(outputDir, tz.getID());
                     if (!file.getParentFile().exists()) {
                         file.getParentFile().mkdirs();
                     }
@@ -438,9 +463,9 @@ public Map compile(String outputDir, String[] sources) throws IOException {
             }
         }
 
-        if (dir != null) {
+        if (outputDir != null) {
             System.out.println("Writing ZoneInfoMap");
-            File file = new File(dir, "ZoneInfoMap");
+            File file = new File(outputDir, "ZoneInfoMap");
             if (!file.getParentFile().exists()) {
                 file.getParentFile().mkdirs();
             }

From f1a476f463c62b736e4a641aba4c59d9629814d1 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 20 Dec 2003 08:52:00 +0000
Subject: [PATCH 025/143] Don't copy unnecessary files to build directory;
 ZoneInfoCompiler args simplified.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@30 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/build.xml | 8 ++------
 1 file changed, 2 insertions(+), 6 deletions(-)

diff --git a/JodaTime/build.xml b/JodaTime/build.xml
index b4c747f65..3442545e6 100644
--- a/JodaTime/build.xml
+++ b/JodaTime/build.xml
@@ -144,9 +144,6 @@
           optimize="${compile.optimize}">
       <classpath refid="compile.classpath"/>
     </javac>
-    <copy    todir="${build.classes}" filtering="on">
-      <fileset dir="${source.home}" excludes="**/*.java"/>
-    </copy>
   </target>
 
 <!-- ====================================================================== -->
@@ -159,14 +156,13 @@
     <mkdir dir="${build.tz}" />
     <java classname="org.joda.time.tz.ZoneInfoCompiler"
           fork="true"
-          dir="${source.tz}"
           failonerror="true">
       <classpath path="${build.classes}" />
       <!-- Override default provider since data directory doesn't exist yet -->
       <sysproperty key="org.joda.time.DateTimeZone.Provider"
                    value="org.joda.time.tz.UTCProvider" />
-      <!-- Specify destination directory for compiled data files -->
-      <arg line="-d ../../../../../../../${build.tz}" />
+      <!-- Specify source and destination directories -->
+      <arg line="-src ${source.tz} -dst ${build.tz}" />
       <!-- Specify all the data files to compile -->
       <arg value="africa" />
       <arg value="antarctica" />

From acc5016243117465b83621ea5ff31ae76163d3b8 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 20 Dec 2003 14:11:23 +0000
Subject: [PATCH 026/143] Remove usused tests

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@31 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../joda/test/time/TestDateTimeFormat.java    | 168 -------
 .../time/TestDateTimeFormatterBuilder.java    | 448 ------------------
 .../test/time/TestDateTimeParserBucket.java   | 154 ------
 .../org/joda/test/time/TestTimePeriod.java    | 273 -----------
 .../joda/test/time/TestTimePeriodFormat.java  | 120 -----
 5 files changed, 1163 deletions(-)
 delete mode 100644 JodaTime/src/test/org/joda/test/time/TestDateTimeFormat.java
 delete mode 100644 JodaTime/src/test/org/joda/test/time/TestDateTimeFormatterBuilder.java
 delete mode 100644 JodaTime/src/test/org/joda/test/time/TestDateTimeParserBucket.java
 delete mode 100644 JodaTime/src/test/org/joda/test/time/TestTimePeriod.java
 delete mode 100644 JodaTime/src/test/org/joda/test/time/TestTimePeriodFormat.java

diff --git a/JodaTime/src/test/org/joda/test/time/TestDateTimeFormat.java b/JodaTime/src/test/org/joda/test/time/TestDateTimeFormat.java
deleted file mode 100644
index 9ef6d1266..000000000
--- a/JodaTime/src/test/org/joda/test/time/TestDateTimeFormat.java
+++ /dev/null
@@ -1,168 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-03 Stephen Colebourne.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.test.time;
-
-//import java.util.*;
-//import java.text.* ;
-import junit.framework.TestSuite;
-//import org.joda.time.*;
-//import org.joda.time.gj.*;
-//import org.joda.time.iso.*;
-/**
- * This class is a Junit unit test for the
- * GJDateTimeFormat date time class.
- *
- * @author Stephen Colebourne
- * @author Guy Allard
- */
-public class TestDateTimeFormat extends BulkTest {
-
-    /**
-     * This is the main class for this test suite.
-     * @param args command line arguments.
-     */
-    public static void main(String[] args) {
-        junit.textui.TestRunner.run(suite());
-    }
-    /**
-     * TestSuite is a junit required method.
-     */
-    public static TestSuite suite() {
-        return BulkTest.makeSuite(TestDateTimeFormat.class);
-    }
-    /**
-     * TestDateTimeField constructor.
-     * @param name
-     */
-    public TestDateTimeFormat(String name) {
-        super(name);
-    }
-    // Class Name: org.joda.time.format.DateTimeFormat
-    /**
-     * Junit <code>setUp()</code> method.
-     */
-    public void setUp() /* throws Exception */ {
-        // super.setUp();
-    }
-    /**
-     * Junit <code>tearDown()</code> method.
-     */
-    protected void tearDown() /* throws Exception */ {
-        // super.tearDown();
-    }
-    /**
-     * Test the <code>getInstanceUTC()</code> method.
-     * @see org.joda.time.format.DateTimeFormat#getInstanceUTC()
-     */
-    protected void testGetInstanceUTC() {
-        fail("TBD");
-    }
-    /**
-     * Test the <code>getInstance()</code> method.
-     * @see org.joda.time.format.DateTimeFormat#getInstance()
-     */
-    protected void testGetInstance() {
-        fail("TBD");
-    }
-    /**
-     * Test the <code>getInstance(org.joda.time.DateTimeZone)</code> method.
-     * @see org.joda.time.format.DateTimeFormat#getInstance(org.joda.time.DateTimeZone)
-     */
-    public void testGetInstanceTZ() {
-        fail("TBD");
-    }
-    /**
-     * Test the <code>getInstance(org.joda.time.DateTimeZone, java.util.Locale)</code> method.
-     * @see org.joda.time.format.DateTimeFormat#getInstance(org.joda.time.DateTimeZone, java.util.Locale)
-     */
-    public void testGetInstanceTZL() {
-        fail("TBD");
-    }
-    /**
-     * Test the <code>getInstance(org.joda.time.Chronology)</code> method.
-     * @see org.joda.time.format.DateTimeFormat#getInstance(org.joda.time.Chronology)
-     */
-    public void testGetInstanceC() {
-        fail("TBD");
-    }
-    /**
-     * Test the <code>getInstance(org.joda.time.Chronology, java.util.Locale)</code> method.
-     * @see org.joda.time.format.DateTimeFormat#getInstance(org.joda.time.Chronology, java.util.Locale)
-     */
-    public void testGetInstanceCL() {
-        fail("TBD");
-    }
-    /**
-     * Test the <code>forPattern(String)</code> method.
-     * @see org.joda.time.format.DateTimeFormat#forPattern(String)
-     */
-    public void testForPattern() {
-        fail("TBD");
-    }
-    /**
-     * Test the <code>forStyle(String)</code> method.
-     * @see org.joda.time.format.DateTimeFormat#forStyle(String)
-     */
-    public void testForStyle() {
-        fail("TBD");
-    }
-    /**
-     * Test the <code>getPatternForStyle()</code> method.
-     * @see org.joda.time.format.DateTimeFormat#getPatternForStyle(String)
-     */
-    public void testGetPatternForStyle() {
-        fail("TBD");
-    }
-
-}
diff --git a/JodaTime/src/test/org/joda/test/time/TestDateTimeFormatterBuilder.java b/JodaTime/src/test/org/joda/test/time/TestDateTimeFormatterBuilder.java
deleted file mode 100644
index 3b2788dce..000000000
--- a/JodaTime/src/test/org/joda/test/time/TestDateTimeFormatterBuilder.java
+++ /dev/null
@@ -1,448 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-03 Stephen Colebourne.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.test.time;
-
-//import java.util.*;
-//import java.text.* ;
-import junit.framework.TestSuite;
-//import org.joda.time.*;
-//import org.joda.time.gj.*;
-//import org.joda.time.iso.*;
-/**
- * This class is a Junit unit test for the
- * GJDateTimeFormatterBuilder date time class.
- *
- * @author Stephen Colebourne
- * @author Guy Allard
- */
-public class TestDateTimeFormatterBuilder extends BulkTest {
-
-	/**
-	 * This is the main class for this test suite.
-	 * @param args command line arguments.
-	 */
-	public static void main(String[] args) {
-		junit.textui.TestRunner.run(suite());
-	}
-	/**
-	 * TestSuite is a junit required method.
-	 */
-	public static TestSuite suite() {
-		return BulkTest.makeSuite(TestDateTimeFormatterBuilder.class);
-	}
-	/**
-	 * TestDateTimeField constructor.
-	 * @param name
-	 */
-	public TestDateTimeFormatterBuilder(String name) {
-		super(name);
-	}
-	// Class Name: org.joda.time.format.DateTimeFormatterBuilder
-	/**
-	 * Junit <code>setUp()</code> method.
-	 */
-	protected void setUp() /* throws Exception */ {
-		// super.setUp();
-	}
-	/**
-	 * Junit <code>tearDown()</code> method.
-	 */
-	protected void tearDown() /* throws Exception */ {
-		// super.tearDown();
-	}
-	/**
-	 * Test the <code>toPrinter()</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#toPrinter()
-	 */
-	public void testToPrinter() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>toParser()</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#toParser()
-	 */
-	public void testToParser() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>toFormatter()</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#toFormatter()
-	 */
-	public void testToFormatter() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>canBuildPrinter()</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#canBuildPrinter()
-	 */
-	public void testCanBuildPrinter() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>canBuildParser()</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#canBuildParser()
-	 */
-	public void testCanBuildParser() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>canBuilderFormatter()</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#canBuilderFormatter()
-	 */
-	public void testCanBuilderFormatter() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>clear()</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#clear()
-	 */
-	public void testClear() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>append(org.joda.time.format.DateTimeFormatter)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#append(org.joda.time.format.DateTimeFormatter)
-	 */
-	public void testAppendDTF() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>append(org.joda.time.format.DateTimePrinterElement, org.joda.time.format.DateTimeParserElement)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#append(org.joda.time.format.DateTimePrinterElement, org.joda.time.format.DateTimeParserElement)
-	 */
-	public void testAppendDTPE() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendLiteral(char)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendLiteral(char)
-	 */
-	public void testAppendLiteralC() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendLiteral(java.lang.String)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendLiteral(java.lang.String)
-	 */
-	public void testAppendLiteralS() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendNumeric(org.joda.time.DateTimeField, int, int, int)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendNumeric(org.joda.time.DateTimeField, int, int, int)
-	 */
-	public void testAppendNumeric() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendSignedNumeric(org.joda.time.DateTimeField, int, int, int)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendSignedNumeric(org.joda.time.DateTimeField, int, int, int)
-	 */
-	public void testAppendSignedNumeric() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendFraction(int, int, int, int)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendFraction(int, int, int, int)
-	 */
-	public void testAppendFraction() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendFractionOfSecond(int, int)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendFractionOfSecond(int, int)
-	 */
-	public void testAppendFractionOfSecond() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendFractionOfMinute(int, int)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendFractionOfMinute(int, int)
-	 */
-	public void testAppendFractionOfMinute() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendFractionOfHour(int, int)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendFractionOfHour(int, int)
-	 */
-	public void testAppendFractionOfHour() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendFractionOfDay(int, int)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendFractionOfDay(int, int)
-	 */
-	public void testAppendFractionOfDay() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendMillisOfSecond(int)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendMillisOfSecond(int)
-	 */
-	public void testAppendMillisOfSecond() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendMillisOfDay(int)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendMillisOfDay(int)
-	 */
-	public void testAppendMillisOfDay() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendSecondOfMinute(int)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendSecondOfMinute(int)
-	 */
-	public void testAppendSecondOfMinute() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendSecondOfDay(int)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendSecondOfDay(int)
-	 */
-	public void testAppendSecondOfDay() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendMinuteOfHour(int)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendMinuteOfHour(int)
-	 */
-	public void testAppendMinuteOfHour() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendMinuteOfDay(int)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendMinuteOfDay(int)
-	 */
-	public void testAppendMinuteOfDay() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendHourOfDay(int)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendHourOfDay(int)
-	 */
-	public void testAppendHourOfDay() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendClockhourOfDay(int)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendClockhourOfDay(int)
-	 */
-	public void testAppendClockhourOfDay() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendHourOfHalfday(int)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendHourOfHalfday(int)
-	 */
-	public void testAppendHourOfHalfday() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendClockhourOfHalfday(int)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendClockhourOfHalfday(int)
-	 */
-	public void testAppendClockhourOfHalfday() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendDayOfWeek(int)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendDayOfWeek(int)
-	 */
-	public void testAppendDayOfWeek() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendDayOfMonth(int)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendDayOfMonth(int)
-	 */
-	public void testAppendDayOfMonth() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendDayOfYear(int)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendDayOfYear(int)
-	 */
-	public void testAppendDayOfYear() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendWeekOfYearWeek(int)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendWeekOfYearWeek(int)
-	 */
-	public void testAppendWeekOfYearWeek() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendWeekOfYearYear(int, int)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendWeekOfYearYear(int, int)
-	 */
-	public void testAppendWeekOfYearYear() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendMonthOfYear(int)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendMonthOfYear(int)
-	 */
-	public void testAppendMonthOfYear() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendYear(int, int)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendYear(int, int)
-	 */
-	public void testAppendYear() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendYearOfEra(int, int)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendYearOfEra(int, int)
-	 */
-	public void testAppendYearOfEra() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendYearOfCentury()</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendYearOfCentury()
-	 */
-	public void testAppendYearOfCentury() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendCentury(int)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendCentury(int)
-	 */
-	public void testAppendCentury() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendCenturyOfEra(int)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendCenturyOfEra(int)
-	 */
-	public void testAppendCenturyOfEra() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendAmPmSymbol()</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendAmPmSymbol()
-	 */
-	public void testAppendAmPmSymbol() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendDayOfWeekSymbol()</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendDayOfWeekSymbol()
-	 */
-	public void testAppendDayOfWeekSymbol() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendDayOfWeekShortSymbol()</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendDayOfWeekShortSymbol()
-	 */
-	public void testAppendDayOfWeekShortSymbol() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendMonthOfYearSymbol()</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendMonthOfYearSymbol()
-	 */
-	public void testAppendMonthOfYearSymbol() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendMonthOfYearShortSymbol()</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendMonthOfYearShortSymbol()
-	 */
-	public void testAppendMonthOfYearShortSymbol() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendEraSymbol()</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendEraSymbol()
-	 */
-	public void testAppendEraSymbol() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendTimeZoneSymbol()</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendTimeZoneSymbol()
-	 */
-	public void testAppendTimeZoneSymbol() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendTimeZoneShortSymbol()</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendTimeZoneShortSymbol()
-	 */
-	public void testAppendTimeZoneShortSymbol() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendTimeZoneOffset(java.lang.String, java.lang.String, boolean)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendTimeZoneOffset(java.lang.String, java.lang.String, boolean)
-	 */
-	public void testAppendTimeZoneOffset() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>appendPattern(java.lang.String)</code> method.
-	 * @see org.joda.time.format.DateTimeFormatterBuilder#appendPattern(java.lang.String)
-	 */
-	public void testAppendPattern() {
-		fail("TBD");
-	}
-
-}
diff --git a/JodaTime/src/test/org/joda/test/time/TestDateTimeParserBucket.java b/JodaTime/src/test/org/joda/test/time/TestDateTimeParserBucket.java
deleted file mode 100644
index 6159b4f2f..000000000
--- a/JodaTime/src/test/org/joda/test/time/TestDateTimeParserBucket.java
+++ /dev/null
@@ -1,154 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-03 Stephen Colebourne.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.test.time;
-
-//import java.util.*;
-//import java.text.* ;
-import junit.framework.TestSuite;
-//import org.joda.time.*;
-//import org.joda.time.gj.*;
-//import org.joda.time.iso.*;
-/**
- * This class is a Junit unit test for the
- * GJDateTimeParserBucket date time class.
- *
- * @author Stephen Colebourne
- * @author Guy Allard
- */
-public class TestDateTimeParserBucket extends BulkTest {
-
-	/**
-	 * This is the main class for this test suite.
-	 * @param args command line arguments.
-	 */
-	public static void main(String[] args) {
-		junit.textui.TestRunner.run(suite());
-	}
-	/**
-	 * TestSuite is a junit required method.
-	 */
-	public static TestSuite suite() {
-		return BulkTest.makeSuite(TestDateTimeParserBucket.class);
-	}
-	/**
-	 * TestDateTimeField constructor.
-	 * @param name
-	 */
-	public TestDateTimeParserBucket(String name) {
-		super(name);
-	}
-	// Class Name: org.joda.time.format.DateTimeParserBucket
-	/**
-	 * Junit <code>setUp()</code> method.
-	 */
-	protected void setUp() /* throws Exception */ {
-		// super.setUp();
-	}
-	/**
-	 * Junit <code>tearDown()</code> method.
-	 */
-	protected void tearDown() /* throws Exception */ {
-		// super.tearDown();
-	}
-	/**
-	 * Test the <code>setMillis(long)</code> method.
-	 * @see org.joda.time.format.DateTimeParserBucket#setMillis(long)
-	 */
-	public void testSetMillis() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>saveField(org.joda.time.DateTimeField, int, int)</code> method.
-	 * @see org.joda.time.format.DateTimeParserBucket#saveField(org.joda.time.DateTimeField, int, int)
-	 */
-	public void testSaveField() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>setTimeZone(java.util.TimeZone)</code> method.
-	 * @see org.joda.time.format.DateTimeParserBucket#setTimeZone(java.util.TimeZone)
-	 */
-	public void testSetTimeZone() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>setTimeZoneOffset(int)</code> method.
-	 * @see org.joda.time.format.DateTimeParserBucket#setTimeZoneOffset(int)
-	 */
-	public void testSetTimeZoneOffset() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getTimeZone()</code> method.
-	 * @see org.joda.time.format.DateTimeParserBucket#getTimeZone()
-	 */
-	public void testGetTimeZone() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getTimeZoneOffset()</code> method.
-	 * @see org.joda.time.format.DateTimeParserBucket#getTimeZoneOffset()
-	 */
-	public void testGetTimeZoneOffset() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>computeMillis()</code> method.
-	 * @see org.joda.time.format.DateTimeParserBucket#computeMillis()
-	 */
-	public void testComputeMillis() {
-		fail("TBD");
-	}
-
-}
diff --git a/JodaTime/src/test/org/joda/test/time/TestTimePeriod.java b/JodaTime/src/test/org/joda/test/time/TestTimePeriod.java
deleted file mode 100644
index 9a48a5147..000000000
--- a/JodaTime/src/test/org/joda/test/time/TestTimePeriod.java
+++ /dev/null
@@ -1,273 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-03 Stephen Colebourne.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.test.time;
-
-//import java.util.*;
-//import java.text.* ;
-import junit.framework.TestSuite;
-//import org.joda.time.*;
-//import org.joda.time.gj.*;
-//import org.joda.time.iso.*;
-/**
- * This class is a Junit unit test for the
- * GJTimePeriod date time class.
- *
- * @author Stephen Colebourne
- * @author Guy Allard
- */
-public class TestTimePeriod extends BulkTest {
-
-	/**
-	 * This is the main class for this test suite.
-	 * @param args command line arguments.
-	 */
-	public static void main(String[] args) {
-		junit.textui.TestRunner.run(suite());
-	}
-	/**
-	 * TestSuite is a junit required method.
-	 */
-	public static TestSuite suite() {
-		return BulkTest.makeSuite(TestTimePeriod.class);
-	}
-	/**
-	 * TestDateTimeField constructor.
-	 * @param name
-	 */
-	public TestTimePeriod(String name) {
-		super(name);
-	}
-	// Class Name: org.joda.time.TimePeriod
-	/**
-	 * Junit <code>setUp()</code> method.
-	 */
-	protected void setUp() /* throws Exception */ {
-		// super.setUp();
-	}
-	/**
-	 * Junit <code>tearDown()</code> method.
-	 */
-	protected void tearDown() /* throws Exception */ {
-		// super.tearDown();
-	}
-	/**
-	 * Test the <code>clone()</code> method.
-	 * @see org.joda.time.TimePeriod#clone()
-	 */
-	public void testClone() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>format(java.text.Format)</code> method.
-	 * @see org.joda.time.TimePeriod#format(java.text.Format)
-	 */
-	public void testFormat() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getMillis()</code> method.
-	 * @see org.joda.time.TimePeriod#getMillis()
-	 */
-	public void testGetMillis() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getStartInstant()</code> method.
-	 * @see org.joda.time.TimePeriod#getStartInstant()
-	 */
-	public void testGetStartInstant() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getEndInstant()</code> method.
-	 * @see org.joda.time.TimePeriod#getEndInstant()
-	 */
-	public void testGetEndInstant() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>toTimePeriod()</code> method.
-	 * @see org.joda.time.TimePeriod#toTimePeriod()
-	 */
-	public void testToTimePeriod() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getTotalSeconds()</code> method.
-	 * @see org.joda.time.TimePeriod#getTotalSeconds()
-	 */
-	public void testGetTotalSeconds() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getTotalMinutes()</code> method.
-	 * @see org.joda.time.TimePeriod#getTotalMinutes()
-	 */
-	public void testGetTotalMinutes() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getTotalHours()</code> method.
-	 * @see org.joda.time.TimePeriod#getTotalHours()
-	 */
-	public void testGetTotalHours() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getTotalDays()</code> method.
-	 * @see org.joda.time.TimePeriod#getTotalDays()
-	 */
-	public void testGetTotalDays() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getTotalMonths()</code> method.
-	 * @see org.joda.time.TimePeriod#getTotalMonths()
-	 */
-	public void testGetTotalMonths() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getTotalWeeks()</code> method.
-	 * @see org.joda.time.TimePeriod#getTotalWeeks()
-	 */
-	public void testGetTotalWeeks() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getSeconds()</code> method.
-	 * @see org.joda.time.TimePeriod#getSeconds()
-	 */
-	public void testGetSeconds() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getMinutes()</code> method.
-	 * @see org.joda.time.TimePeriod#getMinutes()
-	 */
-	public void testGetMinutes() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getHours()</code> method.
-	 * @see org.joda.time.TimePeriod#getHours()
-	 */
-	public void testGetHours() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getDays()</code> method.
-	 * @see org.joda.time.TimePeriod#getDays()
-	 */
-	public void testGetDays() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getMonths()</code> method.
-	 * @see org.joda.time.TimePeriod#getMonths()
-	 */
-	public void testGetMonths() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>getYears()</code> method.
-	 * @see org.joda.time.TimePeriod#getYears()
-	 */
-	public void testGetYears() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>equals(java.lang.Object)</code> method.
-	 * @see org.joda.time.TimePeriod#equals(java.lang.Object)
-	 */
-	public void testEquals() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>hashCode()</code> method.
-	 * @see org.joda.time.TimePeriod#hashCode()
-	 */
-	public void testHashCode() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>compareTo(java.lang.Object)</code> method.
-	 * @see org.joda.time.TimePeriod#compareTo(java.lang.Object)
-	 */
-	public void testCompareTo() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>isLongerThan(java.lang.Object)</code> method.
-	 * @see org.joda.time.TimePeriod#isLongerThan(java.lang.Object)
-	 */
-	public void testIsLongerThan() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>isShorterThan(java.lang.Object)</code> method.
-	 * @see org.joda.time.TimePeriod#isShorterThan(java.lang.Object)
-	 */
-	public void testIsShorterThan() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>toString()</code> method.
-	 * @see org.joda.time.TimePeriod#toString()
-	 */
-	public void testToString() {
-		fail("TBD");
-	}
-
-}
diff --git a/JodaTime/src/test/org/joda/test/time/TestTimePeriodFormat.java b/JodaTime/src/test/org/joda/test/time/TestTimePeriodFormat.java
deleted file mode 100644
index 0cc57ad09..000000000
--- a/JodaTime/src/test/org/joda/test/time/TestTimePeriodFormat.java
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-03 Stephen Colebourne.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.test.time;
-
-//import java.util.*;
-//import java.text.* ;
-import junit.framework.TestSuite;
-//import org.joda.time.*;
-//import org.joda.time.gj.*;
-//import org.joda.time.iso.*;
-/**
- * This class is a Junit unit test for the
- * GJTimePeriodFormat date time class.
- *
- * @author Stephen Colebourne
- * @author Guy Allard
- */
-public class TestTimePeriodFormat extends BulkTest {
-
-	/**
-	 * This is the main class for this test suite.
-	 * @param args command line arguments.
-	 */
-	public static void main(String[] args) {
-		junit.textui.TestRunner.run(suite());
-	}
-	/**
-	 * TestSuite is a junit required method.
-	 */
-	public static TestSuite suite() {
-		return BulkTest.makeSuite(TestTimePeriodFormat.class);
-	}
-	/**
-	 * TestDateTimeField constructor.
-	 * @param name
-	 */
-	public TestTimePeriodFormat(String name) {
-		super(name);
-	}
-
-	// Class Name: org.joda.time.TimePeriodFormat
-	/**
-	 * Junit <code>setUp()</code> method.
-	 */
-	protected void setUp() /* throws Exception */ {
-		// super.setUp();
-	}
-	/**
-	 * Junit <code>tearDown()</code> method.
-	 */
-	protected void tearDown() /* throws Exception */ {
-		// super.tearDown();
-	}
-	/**
-	 * Test the <code>format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)</code> method.
-	 * @see org.joda.time.TimePeriodFormat#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)
-	 */
-	public void testFormat() {
-		fail("TBD");
-	}
-	/**
-	 * Test the <code>parseObject(java.lang.String, java.text.ParsePosition)</code> method.
-	 * @see org.joda.time.TimePeriodFormat#parseObject(java.lang.String, java.text.ParsePosition)
-	 */
-	public void testParseObject() {
-		fail("TBD");
-	}
-
-}

From a97704fe47f605d6781ed0e2d8addf5da6c082af Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 20 Dec 2003 16:52:28 +0000
Subject: [PATCH 027/143] First website for joda-time

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@32 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/project.properties   |   5 +-
 JodaTime/project.xml          |  25 ++++----
 JodaTime/xdocs/index.xml      |  31 +++++----
 JodaTime/xdocs/joda.png       | Bin 0 -> 2919 bytes
 JodaTime/xdocs/jodatime.png   | Bin 0 -> 2850 bytes
 JodaTime/xdocs/navigation.xml |   9 ++-
 JodaTime/xdocs/userguide.xml  | 116 ++++++++++++++++++++++++++++++++++
 7 files changed, 156 insertions(+), 30 deletions(-)
 create mode 100644 JodaTime/xdocs/joda.png
 create mode 100644 JodaTime/xdocs/jodatime.png
 create mode 100644 JodaTime/xdocs/userguide.xml

diff --git a/JodaTime/project.properties b/JodaTime/project.properties
index 3b0009a8d..0387184dc 100644
--- a/JodaTime/project.properties
+++ b/JodaTime/project.properties
@@ -1,6 +1,7 @@
 #show data on the breadcrumbs line
-maven.xdoc.date = left
-maven.xdoc.version = ${pom.currentVersion}
+maven.xdoc.date = navigation-bottom
+maven.xdoc.date.format = yyyy-MM-dd
+# maven.xdoc.version = ${pom.currentVersion}
 
 maven.checkstyle.properties=checkstyle.xml
 maven.junit.fork=true
diff --git a/JodaTime/project.xml b/JodaTime/project.xml
index 97165e71a..14fa1ca68 100644
--- a/JodaTime/project.xml
+++ b/JodaTime/project.xml
@@ -5,15 +5,15 @@
   <id>joda-time</id>
   <name>Joda time</name>
   <groupId>joda-time</groupId>
-  <currentVersion>0.91</currentVersion>
+  <currentVersion>0.95</currentVersion>
   <organization>
     <name>Joda.org</name>
     <url>http://www.joda.org</url>
-    <logo>http://sourceforge.net/sflogo.php?group_id=97367&amp;type=2</logo>
+    <logo>/joda.png</logo>
   </organization>
-  <inceptionYear>2003</inceptionYear>
+  <inceptionYear>2002</inceptionYear>
   <package>org.joda.time.*</package>
-  <logo>http://sourceforge.net/sflogo.php?group_id=97367&amp;type=2</logo>
+  <logo>/jodatime.png</logo>
 
   <description>
     Date and time library to replace JDK date handling.
@@ -32,14 +32,14 @@
     <url>http://cvs.sourceforge.net/viewcvs.py/joda-time/</url>
   </repository>
   
-  <!--mailingLists>
+  <mailingLists>
     <mailingList>
-      <name>Interest list</name>
-      <subscribe></subscribe>
-      <unsubscribe></unsubscribe>
-      <archive></archive>
+      <name>Joda Interest list</name>
+      <subscribe>http://sourceforge.net/mail/?group_id=47291</subscribe>
+      <unsubscribe>http://sourceforge.net/mail/?group_id=47291</unsubscribe>
+      <archive>http://sourceforge.net/mailarchive/forum.php?forum_id=8530</archive>
     </mailingList>
-  </mailingLists-->
+  </mailingLists>
 
   <developers>
     <developer>
@@ -83,6 +83,9 @@
       <includes>
         <include>org/joda/time/**/Test*.java</include>
       </includes>
+      <excludes>
+        <exclude>org/joda/time/**/TestSuite*.java</exclude>
+      </excludes>
     </unitTest>
   </build>
 
@@ -91,7 +94,7 @@
      <report>maven-changes-plugin</report>
      <report>maven-checkstyle-plugin</report>
      <!-- <report>maven-clover-plugin</report> -->
-     <report>maven-jcoverage-plugin</report>
+     <!-- report>maven-jcoverage-plugin</report -->
      <report>maven-developer-activity-plugin</report>
      <report>maven-file-activity-plugin</report>
      <report>maven-javadoc-plugin</report>
diff --git a/JodaTime/xdocs/index.xml b/JodaTime/xdocs/index.xml
index 065c9ec71..186dd659b 100644
--- a/JodaTime/xdocs/index.xml
+++ b/JodaTime/xdocs/index.xml
@@ -1,4 +1,4 @@
-<?xml version="1.0"?>
+<?xml version="1.0" encoding="ISO-8859-1"?>
 
 <document>
 
@@ -12,7 +12,7 @@
 <section name="Joda Time">
 
 <p>
-<b>Joda Dates is a Java open-source project to rewrite the Java Date and Calendar classes.</b>
+<b>Joda-Time is an open-source project to provide a quality Java date and time API.</b>
 </p>
 
 <p>
@@ -27,7 +27,7 @@ Calendar also has some strange performance characteristics.
 <p>
 The Joda Dates project seeks to provide an implementation of dates and times for the Java community.
 The 'default' calendar system implemented will be the ISO8601 standard.
-This specifies a framework for date and time management independent of locale.
+This specifies a framework for date and time independent of locale.
 Thus, in the standard, the first day of the week is Monday, and this has the index 1.
 This avoids any ambiguity accross national boundaries.
 </p>
@@ -40,13 +40,16 @@ The design is flexible and pluggable, so adding additional calendar systems shou
 <p>
 Using a Joda date you can write:
 </p>
-<pre>
-  DateTime dt = new DateTime();
-  int year = dt.getYear();
-  String monthText = dt.monthOfYear().getAsText();
-</pre>
+<source>
+DateTime dt = new DateTime();
+int year = dt.getYear();
+String monthText = dt.monthOfYear().getAsText(Locale.ENGLISH);
+String monthInFrench = dt.monthOfYear().getAsText(Locale.FRENCH);
+String dateAsISO8601Format = dt.toString();
+</source>
 <p>
-And this is only a flavour of what is available, see the <a href="apidocs/index.html">API</a> for more detail.
+And this is only a flavour of what is available, see the <a href="api-0.9/index.html">API</a>
+or <a href="userguide.html">users guide</a> for more detail.
 </p>
 
 <p>
@@ -71,7 +74,9 @@ which is an Apache/BSD cloned licence.
 
 <section name="Documentation">
 <p>
-The <a href="apidocs/index.html">JavaDoc API documents</a> are available online.
+The JavaDoc API documents are available online for the
+<a href="api-0.9/index.html">current release</a> and the
+<a href="apidocs/index.html">latest CVS</a>.
 </p>
 <p>
 The <a href="http://cvs.sourceforge.net/viewcvs.py/joda-time">CVS repository</a> can be browsed.
@@ -93,9 +98,3 @@ If you have any questions, or want to volunteer to help, just email
 </section>
 </body>
 </document>
-
-
-
-
-
-
diff --git a/JodaTime/xdocs/joda.png b/JodaTime/xdocs/joda.png
new file mode 100644
index 0000000000000000000000000000000000000000..435df26a39732551d2f7ed9b1fdf288be1c83875
GIT binary patch
literal 2919
zcmY*bc{EgSAHT9>C)v0BESbp~S(CBGl$e?^_B~6ojwNKGWSNNUMkJ&mhRl>=EM>`7
zw&BN^Y$4f83=+Nf?T`1I_n!0I=bn4c{XEZozMtibLs(nzaEfyR0KfycG`j}QVc>wU
z9|P|ue%BJgi6g|);lD4L{tg?3&VRv&<Kgft=Eterg8UphIyI<i0N`SSn;D~`iq;(h
zt&rmqaY478CQY0sFSAysyvuRKb8CC3E1D8gl&uN|0<L~w7;mSh;`{CMyf15?_PMm@
zev$O4Gq6zXT!PpL?{n*rgh-9p#P4OVI2kQDc_X{@BUsVG*O+LrAHje6<CZt6%X)2L
z8)0{r^ai5`pu#vanIuU3j*Z0kI&&+U-#^a-UhyNf9aEqZDxEnGg+2Q&a-H=qPb?q}
zx0mHik$r6(9SfaRXPTqQ!+x<OVM*8>gY)N|RP*g@ZEu__R6M^2V~;&6|M-)S2L9Mx
zz?feiZs@?}teW3@okU-cq+H-<H=w=$W87J0{J(XS&kU%hZES30E80xI4fVocvbsE>
zxqT}uD<l%Bv(t=?x`-(@#Qyq-*W{BnnEkn5QBiT6SF&JJjOtlm1dD5Z{W>Bb;A4Px
zSfg{rHHWKL>%*1?($dnpM18a$(<dhfiq8|qS6f`wjQJH56mIWsU^g0<AnEk=)|efC
zCnt&Y`J3alDr#!Metw856dVqxM6T<{?y0BG-!+>3@KB;VU21iGy({#0mxx;pk?8U!
z$OVa{c6PF4bXOCJwr6rb4q6D`9T~Z%n$HE$XteqHdDP+d_BK7ZO+}E?ckl&?gz@u(
zNb({Va5$U`CGtm<fqvjrQ^fxMz5tE|&<^@MF*cUiqZ2$`Q&ZC!`nBCl6pcpzOQ%y_
zzAr^olF4C*zjnwxP7MJLrlzJc{6<#QV~%cae1Nm64!G@^R&0u}h=`r5Yx>u{PdYQ5
zU0uV+GcQ%_?CjXU4$lE8W@T=7_PrZ;{^XJlb~j6q==(a;QC{KUf@iUY;Kv670s@GW
z>GRjBat4>E`#B`(jHRJcQ$G#Sq!TQed3mP=aF9^&<iCaJ3ah`RP;Pf5@%$9aD=eIx
znCL;|ee&UAImVlupxfKq+nsT0_u#O&xcJA9AC+Jkab~jh_Gx>5`ahuud!dZJTqXb4
zF)=aX0J_c<`)hl-zP`S;w)UZfPMNpvZN}PIwVkhz4=_7YaasJ~hxJHiqdRw69f{g_
zt6Q7X*rnoI5DL_p5=m@po7vp`x&NEbaL+v?1W`9$je4Qt)BqUC3!D{y$d=$?*b$&j
zuWLK{b+FmS43rGc)O%S32XB7=9^&OSPx9^u++$;#D=HQl>-23`d3cP0^gWsB+nX)r
z78x6#8_Ca}bp~k1?Tp#^ak3Z}>4vt?g@|$|ef{bq**zTowae>ZZDWd(N##gvPfzD<
zo5@(&oTAtv5br$efv3&QvF`3N0=U?{xnz(_z@vhKC=k<KJ*9`4nc3-0ka^w^Hqy`U
z+Zv5LgWa9#>0$R|J9f9JNx$=RE0%(;E*_jr6;Ug*?DMRTT$?Z!Tl*1ZU96udtf8m3
zPql$n94G_w^75mjqeIC}(LYZYmK(`TkbU`VVOm-d-)D_SS2+%9#{66E95#)wvc`|Q
z-VR)!d~F#6^z`&Vl$1>M84QLa5e<lniG}J)0tggpdlYGNl?hdaIwQz=(H_*7gM$O*
z)+SgO*Vq0+@GSk}jnOKkU9Gc2S|HykLrF<VmUtm0bo1}6{{DP5Lei)HetL7XCaJBi
zPEC}1<oxqz&rr6uS7BJg5^I8Km|$vGZf-6r+eoIeveJGct@|SnHyg7z+S;1e%Yr~4
zlo$5)!U<G8P0jg8%J8BJ6bhH&AL?Z>?(FU^=NR%hCvJOYERjp(ocO~oPlsn7(iz>J
z^-%`Wz#~ifoEmnM(vYqPLI6K+GKdwZEg@vj6yH7HyNFrwg$RP4Q<*le+k*S#Q~r(w
zNF!;>%QsdEm2xjFGnnG-m7n_?NN4mfaweMOToFwg?v>3<nIi*3las&pmr8bbcad69
zC^XX&WCJshKA)yGz`>i`Vc+%kt?o(>4_iXe8;J@9!ICG?qz;dg!Q?&=;-nCFhbXN*
zz(9bf@bTlYu&|12H-ds{`xhObN*MEx<_~2bYZ>!@{p;`!3iRH~dCH}0A-a+|jVK<>
zSx!e{Lt~>@?+XM3G{0AlL~BC%HCgElo!e*mCjzt;ng*A`^ozIAb>lb5Gz7kXu?+d-
zn5hGAvRrmALQjyh^ktG!*1}Ay)rB&U0aBu(AaYF0lPwKEU6lJ9!CBSfo~m1Gkw7(p
zkX+B*(a{0%wY+jgD77m<+v#-nKPnqDZ8jw;@GKv)SSHl(oVXw)41-CRz7Vs}lll91
z>_u6FQ(wM(xvqgnonZwiQ?=CPZ$u;#>E-1GyqgQj%F2SweU&()r6rVmLE6T~hHq@)
z=YA7~BGRyM!dr-wRi8?D{(RJ5Ys-v?zIjf(V@@4-Mj*&#@N*_cM@ReBRiR$Mj`o-<
zP6I<!YB{=EQBjd;Hc`aYo^+i9sBs{(ty9k5+TiBqMl1{r41nTJo!b&l_4fDY1oBi}
zE?qgA>qsVRs<h3(baf}D|6VgQ8TTSE7>tk4>6J2cb)8#VdQWzCwuqYR+RBPaQG2_|
zMQ6`T9iCu1`IcaXfg<ar4A@cB>c1)gJ6l5B(f(4VoP{u&ky+F4S&yJIRVZs|X|Wh1
zgu&REUfq%13T`{h%gakzF_#^tY_`%zMn;B)9^vu0JPU|mLqkJZz}n>No2;y?Dax6a
z({X<eLBW(5L}Nfd573qvLps<Yktg*}naK`|xW&$e>+`Ugy0}Og^QXYQT~22&gDzaT
zwKMM47Wc>S(lf)OJug(R4;dttgoMOkksf&V2@Iapu1V0*z&Mgy?He3?LkkEu27d#0
zQW2q)<N*fGW9`7nmmbU!i+8(b-ZM65U^8<sBUaJby=IDW+rt*yC*$j9!Kgr2=gP)y
z^(ywniP<-WLm%AAAxTL|B_<|T=Jqc>Fq0MJROdFm>Fn$ryT7%#pJUF|h&^EF@i501
z6%~Ol*y(Ifvy?9zUv-OFR`|ev>~4JDpm22!b-AXpvH<I$rlL|@Q1G;kStj<+;jWTh
z?ezd9oY~0e==C@BWvjaJ1DbEiaF_^hG8uIGj$}SxZ|~t;P+?&9mTNN2;(eb~5sBsx
z>YN+5z*u!L0@u>e*N>Tf$Mk_?U@qiAYHHOut_yNGYhhwy;&E^*PLj7n9dE^0%y(n#
z?5NZz3*%R-mcd*J3=9PGc`n4h3Kc|eAXZkUG;yiBYv3p8bS-h7zN05#(fj)P!1jUG
z&kSI(SQQnO^73*H4vueZ%b3QE>6X<<3dg;kzCM#=K6sWRk<p&WmC|^F`aF={z`=5F
zc=)Pdpr)p#5U05e|Jz%e()u|InEgVno8R;j2A3$<gN92L;?mMj@OUsBpddIDTDnO#
zlKDRSKB2VqAHdSeN*Mwv2<vA{Fm7>$85n$A#E{8kkhH;5O}Y8`#{tj!y`_>kRaI4=
zaJ&;ulwVo6f7~rjik)SIO0}zVbwMEFKPw1wf+a2Gk<YYz<+%RBwz{C$mlDb?7_KiR
zbbS${CsZ7$?GzEA1-Ogmfjh}sSZlSJT|970yMO;aD2i=Y4|P#j?2c`s$qAfU+C{mh
zke^Y_FJ7F<;X3;RwsZH7&LjEgrGa9w^m-B9q0KK}hP38?u`fE5Fq1t&nL6s=gZ<v7
z+Q`Yt38%7lyxiN{D=RCrbB$gkzL_q2vLN=iyF8-&e|s4RJf;x@X*Ewdz$O`hn_HXJ
Inz-Nl59h<Bq5uE@

literal 0
HcmV?d00001

diff --git a/JodaTime/xdocs/jodatime.png b/JodaTime/xdocs/jodatime.png
new file mode 100644
index 0000000000000000000000000000000000000000..4d5d609868c392a2871e8f15100f4ba54b7e92b6
GIT binary patch
literal 2850
zcmai$c{Ei28^^DVeMuoZ6GADZX}&_k*dh$3F_xskSY|?&2rZUx$d)V_YZwwqizRC)
z2GJN|EJNZuA|~rlWc%Ik@9*C^zkAN}JolV?&b^<{b6?N<{YkJzT@vD#<_7>k$imzN
z4b}uO)OZhp*_0ba2Mb?-xl=G$IsO|qCpt&K8=hMh)}}l|f?^`V0uC{)PXU1cgM|qa
z6PCZ^>|`Z+O$Kq!FXzjbL*gefr_U%sAI3z9NSJh{nAG}<48sy*e3UO|3V2MqTe)b!
zx@eLqE>JTI7jmbht&$qi)(&$1^ph9n<6?x9brZK*lh}8(v#?eFcpsF~V#9a(gQvo2
z;r;7Rk;!F*>FBG64kq}*rp4s_CMEt~_&Uhs>xK}0e0TxF^irc@$q$%_h=|_a-lA)^
zw(axmNCPh?Cnp;l8cl0P=H}NX`q&unzTwJ!uG%E1MLKPsy}c{0j%{H4+6nvhQ|dsy
zsj10Kc`jM%+?D~)R@cXm9}R|^uSfN<x^P<UAs#U4OQBg~zHmvY{_G<O3DtYYr)8{F
zh7=aRYPNg&?YF%l(q9Y@V>Z~omL{yNtpPwjwcf3RTSe5rI505KGV3%4psb>@U!S8J
zl}9{>W|>uBoKGLysCoVRFp<e*UU6~xj5qQV<EOlIs)4$h9Nm&jE`?(&>#D1(!G%44
z-t7wyZk#MFE&bj{;^F2NR;{nC&CJSb4QF%zyM1&89zoIitl?{KZyy=ihOMLo>Vp>o
zaeutp)791Wo6SimG-^Aen~D6J;?Bjxb9lb({+@KADygsgk(@vQnEp0%b)6a*7@#Cc
z6e8{s;d!3g<7L));H#-#>YAEuA*`$qxK%dW(%PEZ-`}-%lZeZsV(slim|ZEYtq35>
zTsilgcR$%QY0P*2XhVcyv4*FYm-gPu)cd~PUVZ@qQT|v6GC)UGgCrv>s~@sBytqhg
zhB~}*Nk~cAWV4yzBjIiuO%o3P)gH~MR@vW=>Vf50adC0Exw#<_2ncdo=Ml5PRxR`L
zv+(e6m5fi%X4!1E+wSx<F8+bv#JdEF`&-ABh)v?GSR`d{=eIXC_r$RzH=cX<?p;Bn
zb#-+U6BA3(CrN$Z19bG|ZB9Lr*AIIvHG<a`7Z*=cUSKjgn?KL9J++<u{g<bwi)wtM
zsis<WNL0orSmgfQ7--y$RJUvwjn}VVUz%kw7-v1YpfQF}5nf1Wa7#^%X!^nSyaL8b
z0CFf@dC+-gEzHx?Q{zM-i4<SEjffuC%cPfDWH_GAGFLWY9qwM++6s#{Z1<`$RXpOJ
zXhN3IbS>iD`MnZ<4*~=<y5R5Jxg#MiexWZEKSE6qRRw#qK`YSv-IXHqd-?0cTMr&a
zE*gziON^O~6_8LIe<XjAF*WrHT@ku6Ma5uB1_xl)c9^g*osE~*nz7H&?;{WP_xE<x
z;`8%mN$CeOO-P8>iY->>k%I0m^D1mx#O5gt4dG2AsK{hX_?0Sb;l(@0(oz)+g!3vf
zrwj}Xeqc^L@$>UrT3Y&1%Vcj;sZ`+%DGooi#KeaWqx#Fs%a@n^YsP)+oHrx(rrzHv
zE~L2IW3gXgRimuIb?3JG??2#*2n??pAt51<3gOYYHD<SWe?Ca3<?Y+`RId^OgIMR~
z>4|i9cPCqZIw*tJc+<@I6cBeMw{NdZ`N8uDxo~L^wAO*faJJXjUDim|fauYq>kC7w
zV*>A84T9&ah9}*$m23s{BllaXs)QKLp-cRNf)Dy)Y4Z{i5(;{uzBpVIxm?}h)#tpw
zR>1G8Wbmbf_$@3g2?6a|$=%E|*P3d{<QOTbjyDe;JZNapsTogZHhjPh_`txqvMEHw
zLTYDxV7WujZ6;1+<>cf%e!RLPXVTNtW5{Ru3_VNh?Twk>Mv4SAwiFk0062Kw%#hyg
zWkaQl7Ym>dHLtg}^AZRI@c(fF?UC`!(K@8);?hKY56arwGs|&mYAP))EhHoah|0=3
z21J>aAZ?VClyW#!t+H_vvK?BLbjILd;LOKZ5WY*P@`O5P!H(?LQ9l+J8TB^{3$7@p
zjS-9w%3+rv@m4ujalW@^0bn-hLbY9ZoMKDlfxI+H<62WVTg9EsI+Hsd8t@_oTS;HI
z1*X2fr0`oxMI73af;|avZ08aF*ntt&=Jdo4oSn_}ZG<{dMgV0ff|`3?I)yvS+oLO4
z>S9FgppUP=KlgRb69%a>WL+g4d{CoHd~vp}kgA}tuu;dW>eco2nD2*^C_&lDSNtwt
zzKnXRUoq%IE-5M0504?2RLbh^o;b=!q<{IM9lnm=$RMl1ZWtLE0l??0v1TRFDBc2;
zH>sn&y}c=fHI24Jq5404vaqyFdh}?jAy8?U+nOr|YD<rbDx-XhHBsDNo#6y<zkZJ2
z7<sw99fztrE1h!c2|rMTu0TZY|6Ex)4E$JH+S^zVRelf`XQZUBpAY2?OUxvZx;s0e
z<F2iDx0k=_`KYR@asuY*__vN?rW^o~NK8*ppT3eu4gI}*tyxwcad&KRkOKtfWlM|f
zHSR$x6Uo2)CpTH6OZiA7(%=Grq!=F`pRG)8nK(aJi|-fM*MR{;JF(Pm8L(p=;HnZ*
zQ@gd2%NC-eqd}0o@pznM=;oq*Z3?-{<<t{Yj`p*6?~VZhbDwiEGc(7=9EIbD==8ea
zc~nC}iu8H@EH`C~xcK-Er^w~W#tXr7J$UWhvIz#GztG?&$v86d;Gh~`Gt+Njhq-Y>
zUB4ahh@TB=WOk?C4j<bWJ?+}E^=Fd>vmPBD)(>07t<QdfAj|2Cpy<n_nB`c#17-B*
z&!00w1;mW}{L`eqiHQjg0Gy;3<>k1yjy|@aFMb&sI@0*&&6~Qqy88P1wzkN<Kb!oq
zMrvXs!^4IMqzEY3tL5G`<1%1dTJJSe+zCWtFOBA)CWfutWYpbQ_23o_-~-(+iBj!N
zlYfS;7+Sb&X-OxZSJqM&Agy+gr%7k^*FVMzfb{3(<;BOvf$s6-^0T(KgSs1|(^-Z?
zFh;a&XHcA|DoSVf2h4x6AwB)5%8)M{6tkXJ%Q3vXyggJZomltqC7nppye^z%2Pw9F
zxI8<}+UxRxX*j+C>=B@pNXD&g--VqqQA|TU-$6<IT+REPmzc;ui_hBm%)7R>Hjq<T
zn3@mDxUz+?LOzJ$#XG->t~ScGIvCH-&7sBYot!GLl|tN{ac&$O96^nD2g#<Oyx_Gj
z$o7Nh0ApigaOQXCs4`*2YwPRaCM+#2`)D+8`97oK)t)q^<HwJu%3oYuUgieOmD4vi
zHezB9HE41I(|eiFhnzgZ5C{YYhksnWprPT<s3nY#kArIR;JnSvo0@+h>&Bg(op?MR
z0J6V1$R5q6{I$_uj2Bj4KX=xT0ekBxXnfoog%UQk1Kq8vs>-?Q7yx=z*CV;Sr%zi6
zLn_U$$-I(#CG@Y8le_EREelZb%mx$19GyUN2L&=nr_%=pR@a!9k|_TyEy;<Bo^$&M
ziC=+B3W5R^a9hzL=+DN2FMJ2&ewAQi0{LSIl5*9-VRUpfo*9P0VBFmmlPE+2A)3q7
z*7k8tbZGX}Jgtxe@P*6V>kBZC^57{@Q?I}z?uQnQvh4Vz<>XQnYwPPft_*zp_RYUY
zS5J?{Vj0}u<po3%OpY8m@-M+Ef?HC4`de35cMW8I$6os1!8H-w7I<}6;7zqmuJI&B
R4?N!j7N#hZS4Oy){{UxZaMAz(

literal 0
HcmV?d00001

diff --git a/JodaTime/xdocs/navigation.xml b/JodaTime/xdocs/navigation.xml
index 3215a75ed..ce19cf8dd 100644
--- a/JodaTime/xdocs/navigation.xml
+++ b/JodaTime/xdocs/navigation.xml
@@ -8,8 +8,10 @@
   <body>
     <menu name="Joda Time">
       <item name="Overview" href="/index.html"/>
+      <item name="Users guide" href="/userguide.html"/>
       <item name="Sourceforge" href="http://sourceforge.net/projects/joda-time/"/>
-      <item name="Javadoc" href="/apidocs/index.html"/>
+      <item name="Javadoc (0.9)" href="/api-0.9/index.html"/>
+      <item name="Javadoc (CVS)" href="/apidocs/index.html"/>
       <item name="CVS" href="http://cvs.sourceforge.net/viewcvs.py/joda-time/"/>
       <item name="Test results" href="/junit-report.html"/>
       <item name="Mailing lists" href="/mail-lists.html"/>
@@ -22,5 +24,10 @@
       <item name="Primitives" href="http://joda-primitives.sourceforge.net/index.html"/>
     </menu>
     
+    <footer>
+      <a href="http://sourceforge.net">
+        <img src="http://sourceforge.net/sflogo.php?group_id=97367&amp;type=2" width="125" height="37" border="0" alt="SourceForge.net Logo" />
+      </a>
+    </footer>
   </body>
 </project>
diff --git a/JodaTime/xdocs/userguide.xml b/JodaTime/xdocs/userguide.xml
new file mode 100644
index 000000000..d34a187ad
--- /dev/null
+++ b/JodaTime/xdocs/userguide.xml
@@ -0,0 +1,116 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+
+<document>
+
+ <properties>
+  <title>Users Guide</title>
+  <author email="scolebourne@users.sourceforge.net">Stephen Colebourne</author>
+ </properties>
+
+ <body>
+
+<section name="Introduction">
+
+<p>
+Joda-Time provides a large API for managing date and time in Java.
+Most of these classes are internal to the design, and provided for flexibility and extension.
+This document outlines what you really need to know to use the API.
+</p>
+
+</section>
+
+<section name="Chronology">
+
+<p>
+The Joda-Time design is based around the <a href="apidocs\org\joda\time\Chronology.html">Chronology</a>.
+This is the calculation engine that defines the complex rules for a calendar system.
+It uses a number of <a href="apidocs\org\joda\time\DateTimeField.html">fields</a>
+to split the time, stored in milliseconds, into a recognisable fields like 'day of week'.
+</p>
+<p>
+The current chronologies supplied are:
+</p>
+<ul>
+<li>ISOChronology - Implements the ISO8601 standard, which is compatable with Gregorian in modern times.</li>
+<li>GJChronology - The Gregorian/Julian calendar system, for historical use.</li>
+<li>BuddhistChronology - Offset from Gregorian/Julian by 543 years.</li>
+</ul>
+<p>
+It is hoped that other chronologies will be added over time.
+</p>
+<p>
+Although the Chronology is key to the design, it is not key to using the API!
+For most usages, the Chronology can be ignored as it will default to the ISOChronology.
+This is suitable for most uses.
+You would change it if you need accurate dates before October 15, 1582 when the Julian calendar was used,
+or if you need a specific chronology like BuddhistChronology.
+</p>
+
+</section>
+
+<section name="Interfaces">
+
+<p>
+Joda-Time defines a number of new interfaces.
+The most important is <a href="apidocs\org\joda\time\ReadableInstant.html">ReadableInstant</a>.
+This defines an instant in time that can be read.
+Other interfaces are defined for datetimes and durations.
+</p>
+<p>
+These interfaces allow multiple implementations of the basic date and time functionality to interoperate.
+Where possible, your application should define dates in terms of these interfaces.
+The design principle is the same as the Java Collections Framework (List/Map/Set).
+</p>
+
+</section>
+
+<section name="DateTime">
+
+<p>
+The main date instance used is <a href="apidocs\org\joda\time\DateTime.html">DateTime</a>.
+This holds the millisecond time of the date and the chronology used to calculate the fields.
+DateTime is immutable, and once created the values do not change.
+Thus, this class can safely be passed around and used in multiple threads without serialization.
+</p>
+<p>
+A companion class to DateTime is <a href="apidocs\org\joda\time\MutableDateTime.html">MutableDateTime</a>.
+This class is mutable, and has a full set of set and add methods.
+When calculating a date, or making changes, this is the best class to use.
+</p>
+<p>
+These two classes, as with others, can be constructed in many ways.
+One constructor takes an Object as input, and by default this accepts a String, Date (JDK) and Calendar (JDK).
+Interoperability is also made simple via the <code>toDate()</code>, <code>toCalendar(Locale)</code> and <code>toGregorianCalendar()</code> methods.
+</p>
+
+</section>
+
+<section name="Properties">
+
+<p>
+The main API of DateTime has been kept small, limited to just get methods for each field.
+There is much more power available however through the use of <i>properties</i>.
+In addition to the <code>getDayOfYear()</code> method you will find <code>dayOfYear()</code>.
+This returns a <a href="apidocs\org\joda\time\DateTimeFieldProperty.html">property</a> with considerable functionality.
+</p>
+<p>
+The property has methods to:
+</p>
+<ul>
+<li>get the value of the field</li>
+<li>get the value of the field as text</li>
+<li>get the value of the field as text in another language</li>
+<li>get metadata about the field, such as min/max size and leap status</li>
+<li>obtain duration fields</li>
+<li>set the value of the field returning a new DateTime</li>
+<li>add a value to the field returning a new DateTime</li>
+<li>round the datetime returning a new DateTime</li>
+</ul>
+<p>
+Knowing the methods on the property is the secret to making the most of the API.
+</p>
+
+</section>
+
+</body>
+</document>

From 09fc5a06cea8944df41f765fc3e5533591c168e2 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 20 Dec 2003 17:16:23 +0000
Subject: [PATCH 028/143] Full contribbuter list

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@33 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/project.xml | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/JodaTime/project.xml b/JodaTime/project.xml
index 14fa1ca68..677bef41a 100644
--- a/JodaTime/project.xml
+++ b/JodaTime/project.xml
@@ -66,6 +66,15 @@
     <contributor>
       <name>Guy Allard</name>
     </contributor>
+    <contributor>
+      <name>Sean Geoghegan </name>
+    </contributor>
+    <contributor>
+      <name>Ashish Katyal </name>
+    </contributor>
+    <contributor>
+      <name>Kandarp Shah </name>
+    </contributor>
   </contributors>
 
   <dependencies>

From 8f9d4d4d73158f3363a309191209be47f020f6bd Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 20 Dec 2003 18:43:17 +0000
Subject: [PATCH 029/143] Move images to keep sourceforge happy

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@34 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/project.xml                     |   4 ++--
 JodaTime/xdocs/{ => images}/joda.png     | Bin
 JodaTime/xdocs/{ => images}/jodatime.png | Bin
 3 files changed, 2 insertions(+), 2 deletions(-)
 rename JodaTime/xdocs/{ => images}/joda.png (100%)
 rename JodaTime/xdocs/{ => images}/jodatime.png (100%)

diff --git a/JodaTime/project.xml b/JodaTime/project.xml
index 677bef41a..e6a411fc3 100644
--- a/JodaTime/project.xml
+++ b/JodaTime/project.xml
@@ -9,11 +9,11 @@
   <organization>
     <name>Joda.org</name>
     <url>http://www.joda.org</url>
-    <logo>/joda.png</logo>
+    <logo>/images/joda.png</logo>
   </organization>
   <inceptionYear>2002</inceptionYear>
   <package>org.joda.time.*</package>
-  <logo>/jodatime.png</logo>
+  <logo>/images/jodatime.png</logo>
 
   <description>
     Date and time library to replace JDK date handling.
diff --git a/JodaTime/xdocs/joda.png b/JodaTime/xdocs/images/joda.png
similarity index 100%
rename from JodaTime/xdocs/joda.png
rename to JodaTime/xdocs/images/joda.png
diff --git a/JodaTime/xdocs/jodatime.png b/JodaTime/xdocs/images/jodatime.png
similarity index 100%
rename from JodaTime/xdocs/jodatime.png
rename to JodaTime/xdocs/images/jodatime.png

From 45516c85c233683fc2489b9b9eba9a910b1e2c2d Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 20 Dec 2003 18:49:14 +0000
Subject: [PATCH 030/143] "without serialization -> "without synchronization"

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@35 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/xdocs/userguide.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/JodaTime/xdocs/userguide.xml b/JodaTime/xdocs/userguide.xml
index d34a187ad..535c31772 100644
--- a/JodaTime/xdocs/userguide.xml
+++ b/JodaTime/xdocs/userguide.xml
@@ -70,7 +70,7 @@ The design principle is the same as the Java Collections Framework (List/Map/Set
 The main date instance used is <a href="apidocs\org\joda\time\DateTime.html">DateTime</a>.
 This holds the millisecond time of the date and the chronology used to calculate the fields.
 DateTime is immutable, and once created the values do not change.
-Thus, this class can safely be passed around and used in multiple threads without serialization.
+Thus, this class can safely be passed around and used in multiple threads without synchronization.
 </p>
 <p>
 A companion class to DateTime is <a href="apidocs\org\joda\time\MutableDateTime.html">MutableDateTime</a>.

From 53457442041be78d8945396c2f2893c7d93a52f6 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 20 Dec 2003 19:00:10 +0000
Subject: [PATCH 031/143] Fixed post goal.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@36 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/maven.xml | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/JodaTime/maven.xml b/JodaTime/maven.xml
index 01a1741bd..f6fb36190 100644
--- a/JodaTime/maven.xml
+++ b/JodaTime/maven.xml
@@ -6,14 +6,13 @@
     <ant:mkdir dir="${maven.build.dest}/org/joda/time/tz/data" />
     <ant:java classname="org.joda.time.tz.ZoneInfoCompiler"
           fork="true"
-          dir="${pom.build.sourceDirectory}/org/joda/time/tz/src"
           failonerror="true">
       <classpath path="${maven.build.dest}" />
       <!-- Override default provider since data directory doesn't exist yet -->
       <sysproperty key="org.joda.time.DateTimeZone.Provider"
                    value="org.joda.time.tz.UTCProvider" />
       <!-- Specify destination directory for compiled data files -->
-      <arg line="-d ${maven.build.dest}/org/joda/time/tz/data" />
+      <arg line="-src ${pom.build.sourceDirectory}/org/joda/time/tz/src -dst ${maven.build.dest}/org/joda/time/tz/data" />
       <!-- Specify all the data files to compile -->
       <arg value="africa" />
       <arg value="antarctica" />

From 079c0cbdce53e51d57d5ff113201a7da7cfc89a8 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 21 Dec 2003 03:48:45 +0000
Subject: [PATCH 032/143] Fix links.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@37 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/xdocs/userguide.xml | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/JodaTime/xdocs/userguide.xml b/JodaTime/xdocs/userguide.xml
index 535c31772..d74ac8de2 100644
--- a/JodaTime/xdocs/userguide.xml
+++ b/JodaTime/xdocs/userguide.xml
@@ -22,9 +22,9 @@ This document outlines what you really need to know to use the API.
 <section name="Chronology">
 
 <p>
-The Joda-Time design is based around the <a href="apidocs\org\joda\time\Chronology.html">Chronology</a>.
+The Joda-Time design is based around the <a href="apidocs/org/joda/time/Chronology.html">Chronology</a>.
 This is the calculation engine that defines the complex rules for a calendar system.
-It uses a number of <a href="apidocs\org\joda\time\DateTimeField.html">fields</a>
+It uses a number of <a href="apidocs/org/joda/time/DateTimeField.html">fields</a>
 to split the time, stored in milliseconds, into a recognisable fields like 'day of week'.
 </p>
 <p>
@@ -52,7 +52,7 @@ or if you need a specific chronology like BuddhistChronology.
 
 <p>
 Joda-Time defines a number of new interfaces.
-The most important is <a href="apidocs\org\joda\time\ReadableInstant.html">ReadableInstant</a>.
+The most important is <a href="apidocs/org/joda/time/ReadableInstant.html">ReadableInstant</a>.
 This defines an instant in time that can be read.
 Other interfaces are defined for datetimes and durations.
 </p>
@@ -67,13 +67,13 @@ The design principle is the same as the Java Collections Framework (List/Map/Set
 <section name="DateTime">
 
 <p>
-The main date instance used is <a href="apidocs\org\joda\time\DateTime.html">DateTime</a>.
+The main date instance used is <a href="apidocs/org/joda/time/DateTime.html">DateTime</a>.
 This holds the millisecond time of the date and the chronology used to calculate the fields.
 DateTime is immutable, and once created the values do not change.
 Thus, this class can safely be passed around and used in multiple threads without synchronization.
 </p>
 <p>
-A companion class to DateTime is <a href="apidocs\org\joda\time\MutableDateTime.html">MutableDateTime</a>.
+A companion class to DateTime is <a href="apidocs/org/joda/time/MutableDateTime.html">MutableDateTime</a>.
 This class is mutable, and has a full set of set and add methods.
 When calculating a date, or making changes, this is the best class to use.
 </p>
@@ -91,7 +91,7 @@ Interoperability is also made simple via the <code>toDate()</code>, <code>toCale
 The main API of DateTime has been kept small, limited to just get methods for each field.
 There is much more power available however through the use of <i>properties</i>.
 In addition to the <code>getDayOfYear()</code> method you will find <code>dayOfYear()</code>.
-This returns a <a href="apidocs\org\joda\time\DateTimeFieldProperty.html">property</a> with considerable functionality.
+This returns a <a href="apidocs/org/joda/time/DateTimeFieldProperty.html">property</a> with considerable functionality.
 </p>
 <p>
 The property has methods to:

From d35adaa57344333867137791839159565a2ccf7c Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 21 Dec 2003 03:49:11 +0000
Subject: [PATCH 033/143] Remove unused import.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@38 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/DateTimeZone.java | 1 -
 1 file changed, 1 deletion(-)

diff --git a/JodaTime/src/java/org/joda/time/DateTimeZone.java b/JodaTime/src/java/org/joda/time/DateTimeZone.java
index 795668991..53b490e26 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeZone.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeZone.java
@@ -59,7 +59,6 @@
 import java.io.ObjectOutputStream;
 import java.io.ObjectStreamException;
 import java.io.Serializable;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.Locale;
 import java.util.Map;

From 60cd3a8f9107cc1e547bdcfd04c34b67c990eea9 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 21 Dec 2003 03:49:24 +0000
Subject: [PATCH 034/143] Added.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@39 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../joda/time/format/ISODurationFormat.java   | 212 ++++++++++++++++++
 1 file changed, 212 insertions(+)
 create mode 100644 JodaTime/src/java/org/joda/time/format/ISODurationFormat.java

diff --git a/JodaTime/src/java/org/joda/time/format/ISODurationFormat.java b/JodaTime/src/java/org/joda/time/format/ISODurationFormat.java
new file mode 100644
index 000000000..d3e1ea3f4
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/format/ISODurationFormat.java
@@ -0,0 +1,212 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.format;
+
+/**
+ * ISODurationFormat provides factory methods for the ISO8601 standard.
+ * <p>
+ * ISODurationFormat is thread-safe and immutable, and the formatters it
+ * returns are as well.
+ *
+ * @author Brian S O'Neill
+ * @see DurationFormat
+ * @see DurationFormatterBuilder
+ */
+public class ISODurationFormat {
+    private static final ISODurationFormat INSTANCE = new ISODurationFormat();
+
+    /**
+     * Returns a singleton instance of ISODurationFormat.
+     */
+    public static ISODurationFormat getInstance() {
+        return INSTANCE;
+    }
+
+    private transient DurationFormatter
+        iStandard,
+        iAlternate,
+        iAlternateExtended,
+        iAlternateWithWeeks,
+        iAlternateExtendedWihWeeks;
+
+    private ISODurationFormat() {
+    }
+
+    /**
+     * PyYmMwWdDThHmMsS
+     */
+    public DurationFormatter standard() {
+        if (iStandard == null) {
+            iStandard = new DurationFormatterBuilder()
+                .appendLiteral("P")
+                .printZeroIfSupported()
+                .appendYears()
+                .appendSuffix("Y")
+                .appendMonths()
+                .appendSuffix("M")
+                .appendWeeks()
+                .appendSuffix("W")
+                .appendDays()
+                .appendSuffix("D")
+                .appendSeparator("T")
+                .appendHours()
+                .appendSuffix("H")
+                .appendMinutes()
+                .appendSuffix("M")
+                .appendSeconds()
+                .appendSuffix("S")
+                .toFormatter();
+        }
+        return iStandard;
+    }
+
+    /**
+     * PyyyymmddThhmmss
+     */
+    public DurationFormatter alternate() {
+        if (iAlternate == null) {
+            iAlternate = new DurationFormatterBuilder()
+                .appendLiteral("P")
+                .printZeroAlways()
+                .minimumPrintedDigits(4)
+                .appendYears()
+                .minimumPrintedDigits(2)
+                .appendMonths()
+                .appendDays()
+                .appendSeparator("T")
+                .appendHours()
+                .appendMinutes()
+                .appendSeconds()
+                .toFormatter();
+        }
+        return iAlternate;
+    }
+
+    /**
+     * Pyyyy-mm-ddThh:mm:ss
+     */
+    public DurationFormatter alternateExtended() {
+        if (iAlternateExtended == null) {
+            iAlternateExtended = new DurationFormatterBuilder()
+                .appendLiteral("P")
+                .printZeroAlways()
+                .minimumPrintedDigits(4)
+                .appendYears()
+                .appendSeparator("-")
+                .minimumPrintedDigits(2)
+                .appendMonths()
+                .appendSeparator("-")
+                .appendDays()
+                .appendSeparator("T")
+                .appendHours()
+                .appendSeparator(":")
+                .appendMinutes()
+                .appendSeparator(":")
+                .appendSeconds()
+                .toFormatter();
+        }
+        return iAlternateExtended;
+    }
+
+    /**
+     * PyyyyWwwddThhmmss
+     */
+    public DurationFormatter alternateWithWeeks() {
+        if (iAlternateWithWeeks == null) {
+            iAlternateWithWeeks = new DurationFormatterBuilder()
+                .appendLiteral("P")
+                .printZeroAlways()
+                .minimumPrintedDigits(4)
+                .appendYears()
+                .minimumPrintedDigits(2)
+                .appendPrefix("W")
+                .appendWeeks()
+                .appendDays()
+                .appendSeparator("T")
+                .appendHours()
+                .appendMinutes()
+                .appendSeconds()
+                .toFormatter();
+        }
+        return iAlternateWithWeeks;
+    }
+
+    /**
+     * Pyyyy-Www-ddThh:mm:ss
+     */
+    public DurationFormatter alternateExtendedWithWeeks() {
+        if (iAlternateExtendedWihWeeks == null) {
+            iAlternateExtendedWihWeeks = new DurationFormatterBuilder()
+                .appendLiteral("P")
+                .printZeroAlways()
+                .minimumPrintedDigits(4)
+                .appendYears()
+                .appendSeparator("-")
+                .minimumPrintedDigits(2)
+                .appendPrefix("W")
+                .appendWeeks()
+                .appendSeparator("-")
+                .appendDays()
+                .appendSeparator("T")
+                .appendHours()
+                .appendSeparator(":")
+                .appendMinutes()
+                .appendSeparator(":")
+                .appendSeconds()
+                .toFormatter();
+        }
+        return iAlternateExtendedWihWeeks;
+    }
+
+}

From 362a57a143736bf275c4b48cdf0284d0b569a54b Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 21 Dec 2003 03:50:16 +0000
Subject: [PATCH 035/143] Support converting strings to durations.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@40 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../joda/time/convert/ConverterManager.java   |  2 +
 .../joda/time/convert/StringConverter.java    | 43 ++++++++++++++++++-
 2 files changed, 44 insertions(+), 1 deletion(-)

diff --git a/JodaTime/src/java/org/joda/time/convert/ConverterManager.java b/JodaTime/src/java/org/joda/time/convert/ConverterManager.java
index bb74326f8..6fc88a3c7 100644
--- a/JodaTime/src/java/org/joda/time/convert/ConverterManager.java
+++ b/JodaTime/src/java/org/joda/time/convert/ConverterManager.java
@@ -80,6 +80,7 @@
  * The default duration converters are:
  * <ul>
  * <li>ReadableDuration
+ * <li>String
  * <li>Long
  * </ul>
  *
@@ -121,6 +122,7 @@ protected ConverterManager() {
 
         iDurationConverters = new ConverterSet(new Converter[] {
             ReadableDurationConverter.INSTANCE,
+            StringConverter.INSTANCE,
             LongConverter.INSTANCE,
         });
     }
diff --git a/JodaTime/src/java/org/joda/time/convert/StringConverter.java b/JodaTime/src/java/org/joda/time/convert/StringConverter.java
index 797bfd6f4..01fe6c8ba 100644
--- a/JodaTime/src/java/org/joda/time/convert/StringConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/StringConverter.java
@@ -55,17 +55,21 @@
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeZone;
+import org.joda.time.ReadWritableDuration;
 import org.joda.time.chrono.iso.ISOChronology;
 import org.joda.time.format.DateTimeParser;
+import org.joda.time.format.DurationParser;
 import org.joda.time.format.ISODateTimeFormat;
+import org.joda.time.format.ISODurationFormat;
 
 /**
  * StringConverter converts a String to milliseconds in the ISOChronology.
  *
  * @author Stephen Colebourne
+ * @author Brian S O'Neill
  * @since 1.0
  */
-class StringConverter extends AbstractConverter implements InstantConverter {
+class StringConverter extends AbstractConverter implements InstantConverter, DurationConverter {
     
     /**
      * Singleton instance.
@@ -110,6 +114,43 @@ public long getInstantMillis(Object object, Chronology chrono) {
         return p.parseMillis(str);
     }
     
+    //-----------------------------------------------------------------------
+    /**
+     * Returns false always.
+     */
+    public boolean isPrecise(Object object) {
+        return false;
+    }
+
+    /**
+     * @throws UnsupportedOperationException always
+     */
+    public long getDurationMillis(Object object) {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Extracts duration values from an object of this converter's type, and
+     * sets them into the given ReadWritableDuration.
+     *
+     * @param duration duration to get modified
+     * @param object  the object to convert, must not be null
+     * @return the millisecond duration
+     * @throws ClassCastException if the object is invalid
+     */
+    public void setInto(ReadWritableDuration duration, Object object) {
+        String str = (String) object;
+        DurationParser parser = ISODurationFormat.getInstance().standard();
+        int pos = parser.parseInto(duration, str, 0);
+        if (pos < str.length()) {
+            if (pos < 0) {
+                // Parse again to get a better exception thrown.
+                parser.parseMutableDuration(duration.getDurationType(), str);
+            }
+            throw new IllegalArgumentException("Invalid format: \"" + str + '"');
+        }
+    }
+
     //-----------------------------------------------------------------------
     /**
      * Returns String.class.

From cfe3388edd8cd2e60bdbae5e0097275dde52c7a7 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 21 Dec 2003 03:50:32 +0000
Subject: [PATCH 036/143] Added more methods to DurationConverter.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@41 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../joda/time/convert/DurationConverter.java  | 27 +++++++++++++++++--
 .../joda/time/convert/InstantConverter.java   | 12 ++++-----
 .../org/joda/time/convert/LongConverter.java  | 25 ++++++++++++++++-
 .../convert/ReadableDurationConverter.java    | 25 +++++++++++++++++
 4 files changed, 80 insertions(+), 9 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/convert/DurationConverter.java b/JodaTime/src/java/org/joda/time/convert/DurationConverter.java
index 3bd56c076..cfee63b30 100644
--- a/JodaTime/src/java/org/joda/time/convert/DurationConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/DurationConverter.java
@@ -53,21 +53,44 @@
  */
 package org.joda.time.convert;
 
+import org.joda.time.ReadableDuration;
+import org.joda.time.ReadWritableDuration;
+
 /**
  * DurationConverter defines how an object is converted to a millisecond duration.
  *
  * @author Stephen Colebourne
+ * @author Brian S O'Neill
  * @since 1.0
  */
 public interface DurationConverter extends Converter {
 
+    /**
+     * Returns true if the given support object represents a precice
+     * duration. If so, getDurationMillis can be called.
+     *
+     * @throws ClassCastException if the object is invalid
+     */
+    boolean isPrecise(Object object);
+
     /**
      * Extracts the millis from an object of this convertor's type.
      * 
      * @param object  the object to convert, must not be null
      * @return the millisecond duration
-     * @throws IllegalArgumentException if the object is invalid
+     * @throws ClassCastException if the object is invalid
      */
     long getDurationMillis(Object object);
-    
+
+    /**
+     * Extracts duration values from an object of this converter's type, and
+     * sets them into the given ReadWritableDuration.
+     *
+     * @param duration duration to get modified
+     * @param object  the object to convert, must not be null
+     * @return the millisecond duration
+     * @throws ClassCastException if the object is invalid
+     */
+    void setInto(ReadWritableDuration duration, Object object);
+
 }
diff --git a/JodaTime/src/java/org/joda/time/convert/InstantConverter.java b/JodaTime/src/java/org/joda/time/convert/InstantConverter.java
index 4a4b0ffda..f1fb34f61 100644
--- a/JodaTime/src/java/org/joda/time/convert/InstantConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/InstantConverter.java
@@ -65,7 +65,7 @@
 public interface InstantConverter extends Converter {
 
     /**
-     * Extracts the millis from an object of this convertor's type.
+     * Extracts the millis from an object of this converter's type.
      * 
      * @param object  the object to convert, must not be null
      * @return the millisecond instant
@@ -74,7 +74,7 @@
     long getInstantMillis(Object object);
     
     /**
-     * Extracts the millis from an object of this convertor's type. The zone
+     * Extracts the millis from an object of this converter's type. The zone
      * parameter is a hint to the converter, should it require a time zone to
      * aid in conversion.
      * 
@@ -86,7 +86,7 @@
     long getInstantMillis(Object object, DateTimeZone zone);
     
     /**
-     * Extracts the millis from an object of this convertor's type. The chrono
+     * Extracts the millis from an object of this converter's type. The chrono
      * parameter is a hint to the converter, should it require a chronology to
      * aid in conversion.
      * 
@@ -99,7 +99,7 @@
     
     //-----------------------------------------------------------------------
     /**
-     * Extracts the chronology from an object of this convertor's type.
+     * Extracts the chronology from an object of this converter's type.
      * 
      * @param object  the object to convert, must not be null
      * @return the chronology, never null
@@ -108,7 +108,7 @@
     Chronology getChronology(Object object);
     
     /**
-     * Extracts the chronology from an object of this convertor's type
+     * Extracts the chronology from an object of this converter's type
      * where the time zone is specified.
      * 
      * @param object  the object to convert, must not be null
@@ -119,7 +119,7 @@
     Chronology getChronology(Object object, DateTimeZone zone);
     
     /**
-     * Extracts the chronology from an object of this convertor's type
+     * Extracts the chronology from an object of this converter's type
      * where the chronology is specified.
      * 
      * @param object  the object to convert, must not be null
diff --git a/JodaTime/src/java/org/joda/time/convert/LongConverter.java b/JodaTime/src/java/org/joda/time/convert/LongConverter.java
index 93c876444..6512335ed 100644
--- a/JodaTime/src/java/org/joda/time/convert/LongConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/LongConverter.java
@@ -53,11 +53,13 @@
  */
 package org.joda.time.convert;
 
+import org.joda.time.ReadWritableDuration;
 
 /**
  * LongConverter converts a Long to milliseconds in the ISOChronology.
  *
  * @author Stephen Colebourne
+ * @author Brian S O'Neill
  * @since 1.0
  */
 class LongConverter extends AbstractConverter implements InstantConverter, DurationConverter {
@@ -85,6 +87,14 @@ public long getInstantMillis(Object object) {
         return ((Long) object).longValue();
     }
     
+    //-----------------------------------------------------------------------
+    /**
+     * Returns true always.
+     */
+    public boolean isPrecise(Object object) {
+        return true;
+    }
+
     /**
      * Gets the millisecond duration, which is the Long value.
      * 
@@ -94,7 +104,20 @@ public long getInstantMillis(Object object) {
     public long getDurationMillis(Object object) {
         return ((Long) object).longValue();
     }
-    
+
+    /**
+     * Extracts duration values from an object of this converter's type, and
+     * sets them into the given ReadWritableDuration.
+     *
+     * @param duration duration to get modified
+     * @param object  the object to convert, must not be null
+     * @return the millisecond duration
+     * @throws IllegalArgumentException if the object is invalid
+     */
+    public void setInto(ReadWritableDuration duration, Object object) {
+        duration.setTotalMillis(((Long) object).longValue());
+    }
+
     //-----------------------------------------------------------------------
     /**
      * Returns Long.class.
diff --git a/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java b/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java
index a5385b655..58132f188 100644
--- a/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java
@@ -54,11 +54,13 @@
 package org.joda.time.convert;
 
 import org.joda.time.ReadableDuration;
+import org.joda.time.ReadWritableDuration;
 
 /**
  * ReadableDurationConverter extracts milliseconds and chronology from a ReadableDuration.
  *
  * @author Stephen Colebourne
+ * @author Brian S O'Neill
  * @since 1.0
  */
 class ReadableDurationConverter extends AbstractConverter implements DurationConverter {
@@ -76,6 +78,16 @@ protected ReadableDurationConverter() {
     }
 
     //-----------------------------------------------------------------------
+    /**
+     * Returns true if the given support object represents a precice
+     * duration. If so, getDurationMillis can be called.
+     *
+     * @throws ClassCastException if the object is invalid
+     */
+    public boolean isPrecise(Object object) {
+        return ((ReadableDuration) object).isPrecise();
+    }
+
     /**
      * Extracts the millis from an object of this convertor's type.
      * 
@@ -86,6 +98,19 @@ public long getDurationMillis(Object object) {
         return ((ReadableDuration) object).getTotalMillis();
     }
     
+    /**
+     * Extracts duration values from an object of this converter's type, and
+     * sets them into the given ReadWritableDuration.
+     *
+     * @param duration duration to get modified
+     * @param object  the object to convert, must not be null
+     * @return the millisecond duration
+     * @throws ClassCastException if the object is invalid
+     */
+    public void setInto(ReadWritableDuration duration, Object object) {
+        duration.setDuration((ReadableDuration) object);
+    }
+
     //-----------------------------------------------------------------------
     /**
      * Returns ReadableDuration.class.

From 878682b9d17ac4549bec889b8b051bbf254c2c1d Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 21 Dec 2003 03:51:10 +0000
Subject: [PATCH 037/143] Minor change to add(Object) method.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@42 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/MutableDateTime.java | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/MutableDateTime.java b/JodaTime/src/java/org/joda/time/MutableDateTime.java
index 1f8130da2..6a02734c3 100644
--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java
+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java
@@ -391,13 +391,13 @@ public void add(final ReadableDuration duration, final int scalar) {
      * Add an amount of time to the date.
      * <p>
      * The recognised object types are defined in {@link ConverterManager} and
-     * include ReadableDuration, String and Long.
+     * include ReadableDuration, and Long.
      * 
      * @param duration  an object representing a duration
      */
     public void add(final Object duration) {
         if (duration instanceof ReadableDuration) {
-            add((ReadableDuration) duration);
+            add((ReadableDuration) duration, 1);
         } else {
             DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);
             add(converter.getDurationMillis(duration));

From c2c22fdf9e93a644898218f462096e2cadbb9058 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 21 Dec 2003 03:51:41 +0000
Subject: [PATCH 038/143] Supports construction via ConverterManager.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@43 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/AbstractDuration.java  | 45 +++++++++++++++++--
 JodaTime/src/java/org/joda/time/Duration.java | 22 +++++++++
 .../java/org/joda/time/MutableDuration.java   | 27 +++++++++++
 3 files changed, 91 insertions(+), 3 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/AbstractDuration.java b/JodaTime/src/java/org/joda/time/AbstractDuration.java
index b82958b02..ac50959b8 100644
--- a/JodaTime/src/java/org/joda/time/AbstractDuration.java
+++ b/JodaTime/src/java/org/joda/time/AbstractDuration.java
@@ -55,6 +55,10 @@
 
 import java.io.Serializable;
 
+import org.joda.time.convert.DurationConverter;
+import org.joda.time.convert.ConverterManager;
+import org.joda.time.format.ISODurationFormat;
+
 /**
  * AbstractDuration provides the common behaviour for duration classes.
  * <p>
@@ -112,10 +116,20 @@ public AbstractDuration(ReadableDuration duration) {
         setDuration(iType = duration.getDurationType(), duration);
     }
 
+    /**
+     * Creates a zero length duration.
+     *
+     * @param type determines which set of fields this duration supports
+     */
+    public AbstractDuration(DurationType type) {
+        iType = type;
+    }
+
     /**
      * Copies another duration to this one.
      *
      * @param type use a different DurationType
+     * @param duration duration to copy
      * @throws UnsupportedOperationException if an unsupported field's value is
      * non-zero
      */
@@ -124,6 +138,30 @@ public AbstractDuration(DurationType type, ReadableDuration duration) {
         setDuration(iType = type, duration);
     }
 
+    /**
+     * Copies another duration to this one.
+     *
+     * @param type use a different DurationType
+     * @param duration duration to convert
+     * @throws UnsupportedOperationException if an unsupported field's value is
+     * non-zero
+     */
+    public AbstractDuration(DurationType type, Object duration) {
+        if (duration instanceof ReadableDuration) {
+            // Only call a private method
+            setDuration(iType = type, (ReadableDuration) duration);
+        } else {
+            DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);
+            if (converter.isPrecise(duration)) {
+                // Only call a private method
+                setTotalMillis(iType = type, converter.getDurationMillis(duration));
+            } else {
+                // Only call a private method
+                setDuration(iType = type, new MutableDuration(type, duration));
+            }
+        }
+    }
+
     /**
      * Create a duration from a set of field values.
      *
@@ -663,12 +701,13 @@ public int hashCode() {
     /**
      * Gets the value as a String in the ISO8601 duration format.
      * <p>
-     * For example, "P6H3M5S" represents 6 hours, 3 minutes, 5 seconds.
+     * For example, "P6H3M7S" represents 6 hours, 3 minutes, 7 seconds.
      *
      * @return the value as an ISO8601 string
      */
-    // TODO
-    //public String toString();
+    public String toString() {
+        return ISODurationFormat.getInstance().standard().print(this);
+    }
 
     /**
      * Sets all the fields in one go from another ReadableDuration.
diff --git a/JodaTime/src/java/org/joda/time/Duration.java b/JodaTime/src/java/org/joda/time/Duration.java
index 96384504d..22387c897 100644
--- a/JodaTime/src/java/org/joda/time/Duration.java
+++ b/JodaTime/src/java/org/joda/time/Duration.java
@@ -84,10 +84,20 @@ public Duration(ReadableDuration duration) {
         super(duration);
     }
 
+    /**
+     * Creates a zero length duration.
+     *
+     * @param type determines which set of fields this duration supports
+     */
+    public Duration(DurationType type) {
+        super(type);
+    }
+
     /**
      * Copies another duration to this one.
      *
      * @param type use a different DurationType
+     * @param duration duration to copy
      * @throws UnsupportedOperationException if an unsupported field's value is
      * non-zero
      */
@@ -95,6 +105,18 @@ public Duration(DurationType type, ReadableDuration duration) {
         super(type, duration);
     }
 
+    /**
+     * Copies another duration to this one.
+     *
+     * @param type use a different DurationType
+     * @param duration duration to convert
+     * @throws UnsupportedOperationException if an unsupported field's value is
+     * non-zero
+     */
+    public Duration(DurationType type, Object duration) {
+        super(type, duration);
+    }
+
     /**
      * Create a duration from a set of field values.
      *
diff --git a/JodaTime/src/java/org/joda/time/MutableDuration.java b/JodaTime/src/java/org/joda/time/MutableDuration.java
index 3e7a83994..67e24d3a2 100644
--- a/JodaTime/src/java/org/joda/time/MutableDuration.java
+++ b/JodaTime/src/java/org/joda/time/MutableDuration.java
@@ -55,6 +55,9 @@
 
 import java.io.Serializable;
 
+import org.joda.time.convert.DurationConverter;
+import org.joda.time.convert.ConverterManager;
+
 /**
  * Standard mutable duration implementation.
  * <p>
@@ -81,10 +84,20 @@ public MutableDuration(ReadableDuration duration) {
         super(duration);
     }
 
+    /**
+     * Creates a zero length duration.
+     *
+     * @param type determines which set of fields this duration supports
+     */
+    public MutableDuration(DurationType type) {
+        super(type);
+    }
+
     /**
      * Copies another duration to this one.
      *
      * @param type use a different DurationType
+     * @param duration duration to copy
      * @throws UnsupportedOperationException if an unsupported field's value is
      * non-zero
      */
@@ -92,6 +105,20 @@ public MutableDuration(DurationType type, ReadableDuration duration) {
         super(type, duration);
     }
 
+    /**
+     * Copies another duration to this one.
+     *
+     * @param type use a different DurationType
+     * @param duration duration to convert
+     * @throws UnsupportedOperationException if an unsupported field's value is
+     * non-zero
+     */
+    public MutableDuration(DurationType type, Object duration) {
+        super(type);
+        DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);
+        converter.setInto(this, duration);
+    }
+
     /**
      * Create a duration from a set of field values.
      *

From 05349230aac1dc50546f500d32f889dc5410e4d3 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 21 Dec 2003 03:52:47 +0000
Subject: [PATCH 039/143] Duration formatting in place.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@44 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/ToDo.txt | 1 -
 1 file changed, 1 deletion(-)

diff --git a/JodaTime/ToDo.txt b/JodaTime/ToDo.txt
index 001398346..54aa6e1c4 100644
--- a/JodaTime/ToDo.txt
+++ b/JodaTime/ToDo.txt
@@ -4,7 +4,6 @@ JodaTime ToDo list
 1.0
 ---
 Duration:
- Write formatters/parsers
  Write tests
  
 Interval:

From 310e0c4ed66945c5863075d4d6a84b96342151ef Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 21 Dec 2003 03:55:21 +0000
Subject: [PATCH 040/143] Usage comment fix.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@45 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java b/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java
index 5f866a602..fe55a6f79 100644
--- a/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java
+++ b/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java
@@ -105,10 +105,10 @@
      * Launches the ZoneInfoCompiler tool.
      *
      * <pre>
-     * Usage: java org.joda.time.tz.ZoneInfoCompiler &lt;options&gt; &lt;source files&gt;");
-     * where possible options include:");
-     *   -src &lt;directory&gt;    Specify where to read source files");
-     *   -dst &lt;directory&gt;    Specify where to write generated files");
+     * Usage: java org.joda.time.tz.ZoneInfoCompiler &lt;options&gt; &lt;source files&gt;
+     * where possible options include:
+     *   -src &lt;directory&gt;    Specify where to read source files
+     *   -dst &lt;directory&gt;    Specify where to write generated files
      * </pre>
      */
     public static void main(String[] args) throws Exception {

From 358fb5d5d9adec6fdede6a0436b3d6bcf2b1b36a Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 21 Dec 2003 06:22:02 +0000
Subject: [PATCH 041/143] Intervals are back.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@46 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/ToDo.txt                             |   1 -
 .../java/org/joda/time/AbstractInterval.java  | 476 ++++++++++++++++++
 JodaTime/src/java/org/joda/time/Interval.java | 159 ++++++
 .../java/org/joda/time/MutableInterval.java   | 184 +++++++
 .../org/joda/time/ReadWritableInterval.java   |  94 ++++
 .../java/org/joda/time/ReadableInterval.java  | 247 +++++++++
 6 files changed, 1160 insertions(+), 1 deletion(-)
 create mode 100644 JodaTime/src/java/org/joda/time/AbstractInterval.java
 create mode 100644 JodaTime/src/java/org/joda/time/Interval.java
 create mode 100644 JodaTime/src/java/org/joda/time/MutableInterval.java
 create mode 100644 JodaTime/src/java/org/joda/time/ReadWritableInterval.java
 create mode 100644 JodaTime/src/java/org/joda/time/ReadableInterval.java

diff --git a/JodaTime/ToDo.txt b/JodaTime/ToDo.txt
index 54aa6e1c4..d6371bd79 100644
--- a/JodaTime/ToDo.txt
+++ b/JodaTime/ToDo.txt
@@ -7,7 +7,6 @@ Duration:
  Write tests
  
 Interval:
- Write classes
  Write formatters/parsers
  Write tests
  
diff --git a/JodaTime/src/java/org/joda/time/AbstractInterval.java b/JodaTime/src/java/org/joda/time/AbstractInterval.java
new file mode 100644
index 000000000..740cdfeae
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/AbstractInterval.java
@@ -0,0 +1,476 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.format.DateTimePrinter;
+import org.joda.time.format.ISODateTimeFormat;
+
+/**
+ * AbstractInterval provides the common behaviour for time intervals.
+ * <p>
+ * This class should generally not be used directly by API users. The 
+ * {@link ReadableInterval} interface should be used when different 
+ * kinds of intervals are to be referenced.
+ *
+ * @author Brian S O'Neill
+ * @author Stephen Colebourne
+ * @since 1.0
+ */
+public abstract class AbstractInterval implements ReadableInterval {
+    
+    /** The start of the period */
+    private long iStartMillis;
+    /** The end of the period */
+    private long iEndMillis;
+
+    /** Cache the start instant */
+    private transient Instant iStartInstant;
+    /** Cache the end instant */
+    private transient Instant iEndInstant;
+    /** Cache the duration */
+    private transient Duration iDuration;
+    
+    /**
+     * Constructs a time interval as a copy of another.
+     * 
+     * @param interval the time interval to copy
+     * @throws IllegalArgumentException if the interval is null
+     */
+    public AbstractInterval(ReadableInterval interval) {
+        super();
+        if (interval == null) {
+            throw new IllegalArgumentException("The interval must not be null");
+        }
+        iStartMillis = interval.getStartMillis();
+        iEndMillis = interval.getEndMillis();
+    }
+    
+    /**
+     * Constructs an interval from a start and end instant.
+     * 
+     * @param startInstant  start of this interval, as milliseconds from
+     *  1970-01-01T00:00:00Z.
+     * @param endInstant  end of this interval, as milliseconds from
+     *  1970-01-01T00:00:00Z.
+     */
+    public AbstractInterval(long startInstant, long endInstant) {
+        super();
+        iStartMillis = startInstant;
+        iEndMillis = endInstant;
+    }
+    
+    /**
+     * Constructs an interval from a start and end instant.
+     * 
+     * @param start  start of this interval
+     * @param end  end of this interval
+     * @throws IllegalArgumentException if either instant is null
+     */
+    public AbstractInterval(ReadableInstant start, ReadableInstant end) {
+        super();
+        if (start == null) {
+            throw new IllegalArgumentException("The start instant must not be null");
+        }
+        if (end == null) {
+            throw new IllegalArgumentException("The end instant must not be null");
+        }
+        iStartMillis = start.getMillis();
+        if (start instanceof Instant) {
+            iStartInstant = (Instant) start;
+        }
+        iEndMillis = end.getMillis();
+        if (end instanceof Instant) {
+            iEndInstant = (Instant) end;
+        }
+    }
+    
+    /**
+     * Constructs an interval from a start instant and a duration.
+     * 
+     * @param start  start of this interval
+     * @param duration  duration of this interval
+     */
+    public AbstractInterval(ReadableInstant start, ReadableDuration duration) {
+        super();
+        if (start == null) {
+            throw new IllegalArgumentException("The start instant must not be null");
+        }
+        if (duration == null) {
+            throw new IllegalArgumentException("The duration must not be null");
+        }
+        iStartMillis = start.getMillis();
+        if (start instanceof Instant) {
+            iStartInstant = (Instant) start;
+        }
+        iEndMillis = duration.addTo((ReadableInstant) start, 1).getMillis();
+    }
+    
+    /**
+     * Constructs an interval from a duration and an end instant.
+     * 
+     * @param duration duration of this interval
+     * @param end end of this interval
+     */
+    public AbstractInterval(ReadableDuration duration, ReadableInstant end) {
+        super();
+        if (duration == null) {
+            throw new IllegalArgumentException("The duration must not be null");
+        }
+        if (end == null) {
+            throw new IllegalArgumentException("The end instant must not be null");
+        }
+        iEndMillis = end.getMillis();
+        if (end instanceof Instant) {
+            iEndInstant = (Instant) end;
+        }
+        iStartMillis = duration.addTo((ReadableInstant) end, -1).getMillis();
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the start of this interval as the number of milliseconds elapsed
+     * since 1970-01-01T00:00:00Z.
+     *
+     * @return the start of the interval
+     */
+    public long getStartMillis() {
+        return iStartMillis;
+    }
+
+    /**
+     * Gets the start of this time interval as an Instant.
+     *
+     * @return the start of the time interval
+     */
+    public Instant getStartInstant() {
+        if (iStartInstant == null) {
+            iStartInstant = new Instant(getStartMillis());
+        }
+        return iStartInstant;
+    }
+
+    /**
+     * Gets the end of this interval as the number of milliseconds elapsed
+     * since 1970-01-01T00:00:00Z.
+     *
+     * @return the start of the interval
+     */
+    public long getEndMillis() {
+        return iEndMillis;
+    }
+
+    /**
+     * Gets the end of this time interval as an Instant.
+     *
+     * @return the end of the time interval
+     */
+    public Instant getEndInstant() {
+        if (iEndInstant == null) {
+            iEndInstant = new Instant(getEndMillis());
+        }
+        return iEndInstant;
+    }
+
+    /**
+     * Gets the duration of this time interval in milliseconds.
+     * <p>
+     * The duration returned will always be precise because it is relative to
+     * a known date.
+     *
+     * @return the duration of the time interval in milliseconds
+     */
+    public long getDurationMillis() {
+        return (getEndMillis() - getStartMillis());
+    }
+
+    /**
+     * Gets the duration of this time interval.
+     * <p>
+     * The duration returned will always be precise because it is relative to
+     * a known date.
+     *
+     * @return the duration of the time interval
+     */
+    public Duration getDuration() {
+        if (iDuration == null) {
+            iDuration = new Duration(DurationType.getDayHourType(),
+                                     getEndMillis() - getStartMillis());
+        }
+        return iDuration;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Does this time interval contain the specified millisecond instant.
+     * 
+     * @param millisInstant  the instant to compare to,
+     *  millisecond instant from 1970-01-01T00:00:00Z
+     * @return true if this time interval contains the millisecond
+     */
+    public boolean contains(long millisInstant) {
+        return (millisInstant >= getStartMillis() && millisInstant <= getEndMillis());
+    }
+    
+    /**
+     * Does this time interval contain the specified instant.
+     * 
+     * @param instant  the instant
+     * @return true if this time interval contains the instant
+     * @throws IllegalArgumentException if the instant is null
+     */
+    public boolean contains(ReadableInstant instant) {
+        if (instant == null) {
+            throw new IllegalArgumentException("The instant must not be null");
+        }
+        return contains(instant.getMillis());
+    }
+    
+    /**
+     * Does this time interval contain the specified time interval completely.
+     * 
+     * @param interval  the time interval to compare to
+     * @return true if this interval contains the time interval
+     * @throws IllegalArgumentException if the interval is null
+     */
+    public boolean contains(ReadableInterval interval) {
+        if (interval == null) {
+            throw new IllegalArgumentException("The time interval must not be null");
+        }
+        long otherStart = interval.getStartMillis();
+        long otherEnd = interval.getEndMillis();
+        return 
+            (otherStart >= getStartMillis() && otherStart <= getEndMillis())
+            && (otherEnd >= getStartMillis() && otherEnd <= getEndMillis());
+    }
+    
+    /**
+     * Does this time interval overlap the specified time interval.
+     * <p>
+     * The intervals overlap if at least some of the time interval is in common.
+     * 
+     * @param interval  the time interval to compare to
+     * @return true if the time intervals overlap
+     * @throws IllegalArgumentException if the interval is null
+     */
+    public boolean overlaps(ReadableInterval interval) {
+        if (interval == null) {
+            throw new IllegalArgumentException("The time interval must not be null");
+        }
+        long otherStart = interval.getStartMillis();
+        long otherEnd = interval.getEndMillis();
+        return 
+            (otherStart >= getStartMillis() && otherStart <= getEndMillis())
+            || (otherEnd >= getStartMillis() && otherEnd <= getEndMillis());
+    }
+    
+    //-----------------------------------------------------------------------
+    /**
+     * Is this time interval before the specified millisecond instant.
+     * 
+     * @param millisInstant  the instant to compare to,
+     *  millisecond instant from 1970-01-01T00:00:00Z
+     * @return true if this time interval is before the instant
+     */
+    public boolean isBefore(long millisInstant) {
+        return (getStartMillis() < millisInstant && getEndMillis() < millisInstant);
+    }
+    
+    /**
+     * Is this time interval before the specified instant.
+     * 
+     * @param instant  the instant to compare to
+     * @return true if this time interval is before the instant
+     * @throws IllegalArgumentException if the instant is null
+     */
+    public boolean isBefore(ReadableInstant instant) {
+        if (instant == null) {
+            throw new IllegalArgumentException("The instant must not be null");
+        }
+        return isBefore(instant.getMillis());
+    }
+    
+    /**
+     * Is this time interval after the specified millisecond instant.
+     * 
+     * @param millisInstant  the instant to compare to,
+     *  millisecond instant from 1970-01-01T00:00:00Z
+     * @return true if this time interval is after the instant
+     */
+    public boolean isAfter(long millisInstant) {
+        return (getStartMillis() > millisInstant && getEndMillis() > millisInstant);
+    }
+    
+    /**
+     * Is this time interval after the specified instant.
+     * 
+     * @param instant  the instant to compare to
+     * @return true if this time interval is after the instant
+     * @throws IllegalArgumentException if the instant is null
+     */
+    public boolean isAfter(ReadableInstant instant) {
+        if (instant == null) {
+            throw new IllegalArgumentException("The instant must not be null");
+        }
+        return isAfter(instant.getMillis());
+    }
+    
+    //-----------------------------------------------------------------------
+    /**
+     * Get the object as an Interval.
+     * 
+     * @return an immutable interval object
+     */
+    public Interval toInterval() {
+        if (this instanceof Interval) {
+            return (Interval) this;
+        }
+        return new Interval(this);
+    }
+
+    /**
+     * Get the object as a MutableInterval.
+     * 
+     * @return a mutable interval object
+     */
+    public MutableInterval toMutableInterval() {
+        return new MutableInterval(this);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Compares this object with the specified object for equality based
+     * on start and end millis. All ReadableInterval instances are accepted.
+     * <p>
+     * To compare the duration of two time intervals, use {@link #getDuration()}
+     * to get the durations and compare those.
+     *
+     * @param readableInterval  a readable interval to check against
+     * @return true if the start and end millis are equal
+     */
+    public boolean equals(Object readableInterval) {
+        if (this == readableInterval) {
+            return true;
+        }
+        if (readableInterval instanceof ReadableInterval == false) {
+            return false;
+        }
+        ReadableInterval other = (ReadableInterval) readableInterval;
+        return 
+            (getStartMillis() == other.getStartMillis() 
+            && getEndMillis() == other.getEndMillis());
+    }
+
+    /**
+     * Hashcode compatable with equals method.
+     *
+     * @return suitable hashcode
+     */
+    public int hashCode() {
+        int result = 97;
+        result = 31 * result + ((int) (getStartMillis() ^ (getStartMillis() >>> 32)));
+        result = 31 * result + ((int) (getEndMillis() ^ (getEndMillis() >>> 32)));
+        return result;
+    }
+
+    /**
+     * Output a string in ISO8601 interval format.
+     *
+     * @return re-parsable string
+     */
+    public String toString() {
+        DateTimePrinter printer =
+            ISODateTimeFormat.getInstance(ISOChronology.getInstanceUTC())
+            .dateHourMinuteSecondFraction();
+        StringBuffer buf = new StringBuffer(48);
+        printer.printTo(buf, getStartMillis());
+        buf.append('/');
+        printer.printTo(buf, getEndMillis());
+        return buf.toString();
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the start of this time interval.
+     * <p>
+     * Subclasses that wish to be immutable should override this method with an
+     * empty implementation that is protected and final. This also ensures that
+     * all lower subclasses are also immutable.
+     *
+     * @param millisInstant  the start of the time interval,
+     *  millisecond instant from 1970-01-01T00:00:00Z
+     */
+    protected void setStartMillis(long millisInstant) {
+        iStartMillis = millisInstant;
+        iStartInstant = null;
+        iDuration = null;
+    }
+
+    /** 
+     * Sets the end of this time interval.
+     * <p>
+     * Subclasses that wish to be immutable should override this method with an
+     * empty implementation that is protected and final. This also ensures that
+     * all lower subclasses are also immutable.
+     *
+     * @param millisInstant  the end of the time interval,
+     *  millisecond instant from 1970-01-01T00:00:00Z
+     */
+    protected void setEndMillis(long millisInstant) {
+        iEndMillis = millisInstant;
+        iEndInstant = null;
+        iDuration = null;
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/Interval.java b/JodaTime/src/java/org/joda/time/Interval.java
new file mode 100644
index 000000000..62ce2b33e
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/Interval.java
@@ -0,0 +1,159 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+import java.io.Serializable;
+import java.text.ParseException;
+
+/**
+ * Interval is the standard implementation of an immutable time interval
+ * class. The duration of the time interval is always a precise amount of
+ * milliseconds even if a variable length duration was passed into the
+ * constructor.
+ *
+ * @author Brian S O'Neill
+ * @author Sean Geoghegan
+ * @author Stephen Colebourne
+ * @since 1.0
+ */
+public final class Interval extends AbstractInterval
+        implements ReadableInterval, Serializable {
+
+    static final long serialVersionUID = 4922451897541386752L;
+
+    /**
+     * Constructs a time interval as a copy of another.
+     * 
+     * @param interval  the time interval to copy
+     * @throws IllegalArgumentException if the interval is null
+     */
+    public Interval(ReadableInterval interval) {
+        super(interval);
+    }
+
+    /**
+     * Constructs an interval from a start and end instant.
+     * 
+     * @param startInstant  start of this interval, as milliseconds from
+     *  1970-01-01T00:00:00Z.
+     * @param endInstant  end of this interval, as milliseconds from
+     *  1970-01-01T00:00:00Z.
+     */
+    public Interval(long startInstant, long endInstant) {
+        super(startInstant, endInstant);
+    }
+
+    /**
+     * Constructs an interval from a start and end instant.
+     * 
+     * @param start  start of this interval
+     * @param end  end of this interval
+     * @throws IllegalArgumentException if either instant is null
+     */
+    public Interval(ReadableInstant start, ReadableInstant end) {
+        super(start, end);
+    }
+
+    /**
+     * Constructs an interval from a start instant and a duration.
+     * 
+     * @param start  start of this interval
+     * @param duration  duration of this interval
+     */
+    public Interval(ReadableInstant start, ReadableDuration duration) {
+        super(start, duration);
+    }
+
+    /**
+     * Constructs an interval from a duration and an end instant.
+     * 
+     * @param duration duration of this interval
+     * @param end end of this interval
+     */
+    public Interval(ReadableDuration duration, ReadableInstant end) {
+        super(duration, end);
+    }
+
+    /** 
+     * Creates new TimePeriod.
+     *
+     * TimePeriod is created from an ISO formatted
+     * TimePeriod string. Only accepts strings in the
+     * ISO_STANDARD_BASIC_FORMAT pattern.
+     *
+     * @param period an ISO interval string
+     */
+    /* TODO
+    public Interval(String period) throws ParseException {
+        Interval temp = (Interval)TimePeriodFormat.ISO_STANDARD_BASIC_FORMAT.parseObject(period);
+        iStartMillis = temp.iStartMillis;
+        iEndMillis = temp.iEndMillis;
+    }
+    */
+
+    /**
+     * Overridden to do nothing, ensuring this class and all subclasses are
+     * immutable.
+     */
+    protected void setStartMillis(long millisInstant) {
+    }
+
+    /**
+     * Overridden to do nothing, ensuring this class and all subclasses are
+     * immutable.
+     */
+    protected void setEndMillis(long millisInstant) {
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/MutableInterval.java b/JodaTime/src/java/org/joda/time/MutableInterval.java
new file mode 100644
index 000000000..7e49df9fb
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/MutableInterval.java
@@ -0,0 +1,184 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+import java.io.Serializable;
+import java.text.ParseException;
+
+/**
+ * MutableInterval is the standard implementation of a mutable time interval.
+ * <p>
+ * If performing significant calculations on an interval, it may be faster to
+ * convert an Interval object to a MutableInterval one.
+ *
+ * @author Stephen Colebourne
+ * @since 1.0
+ */
+public final class MutableInterval extends AbstractInterval
+        implements ReadWritableInterval, Serializable {
+
+    static final long serialVersionUID = -5982824024992428470L;
+
+    /**
+     * Constructs a time interval as a copy of another.
+     * 
+     * @param interval the time interval to copy
+     * @throws IllegalArgumentException if the interval is null
+     */
+    public MutableInterval(ReadableInterval interval) {
+        super(interval);
+    }
+    
+    /**
+     * Constructs an interval from a start and end instant.
+     * 
+     * @param startInstant  start of this interval, as milliseconds from
+     *  1970-01-01T00:00:00Z.
+     * @param endInstant  end of this interval, as milliseconds from
+     *  1970-01-01T00:00:00Z.
+     */
+    public MutableInterval(long startInstant, long endInstant) {
+        super(startInstant, endInstant);
+    }
+    
+    /**
+     * Constructs an interval from a start and end instant.
+     * 
+     * @param start  start of this interval
+     * @param end  end of this interval
+     * @throws IllegalArgumentException if either instant is null
+     */
+    public MutableInterval(ReadableInstant start, ReadableInstant end) {
+        super(start, end);
+    }
+    
+    /**
+     * Constructs an interval from a start instant and a duration.
+     * 
+     * @param start  start of this interval
+     * @param duration  duration of this interval
+     */
+    public MutableInterval(ReadableInstant start, ReadableDuration duration) {
+        super(start, duration);
+    }
+    
+    /**
+     * Constructs an interval from a duration and an end instant.
+     * 
+     * @param duration duration of this interval
+     * @param end end of this interval
+     */
+    public MutableInterval(ReadableDuration duration, ReadableInstant end) {
+        super(duration, end);
+    }
+    
+    /**
+     * Constructors an interval from an ISO format string.
+     *
+     * @param intervalStr  an ISO interval string
+     */
+    /* TODO
+    public MutableInterval(String intervalStr) throws ParseException {
+        Interval interval = (Interval) TimePeriodFormat.ISO_STANDARD_BASIC_FORMAT.parseObject(intervalStr);
+        iStartMillis = interval.getStartMillis();
+        iEndMillis = interval.getEndMillis();
+    }
+    */
+    
+    //-----------------------------------------------------------------------
+    /**
+     * Sets the start of this time interval.
+     *
+     * @param millisInstant  the start of the time interval,
+     *  millisecond instant from 1970-01-01T00:00:00Z
+     */
+    public void setStartMillis(long millisInstant) {
+        super.setStartMillis(millisInstant);
+    }
+
+    /**
+     * Sets the start of this time interval as an Instant.
+     *
+     * @param instant  the start of the time interval
+     */
+    public void setStartInstant(ReadableInstant instant) {
+        if (instant == null) {
+            throw new IllegalArgumentException("The instant must not be null");
+        }
+        super.setStartMillis(instant.getMillis());
+    }
+
+    /** 
+     * Sets the end of this time interval.
+     *
+     * @param millisInstant  the end of the time interval,
+     *  millisecond instant from 1970-01-01T00:00:00Z
+     */
+    public void setEndMillis(long millisInstant) {
+        super.setEndMillis(millisInstant);
+    }
+
+    /** 
+     * Sets the end of this time interval as an Instant.
+     *
+     * @param instant  the end of the time interval
+     */
+    public void setEndInstant(ReadableInstant instant) {
+        if (instant == null) {
+            throw new IllegalArgumentException("The instant must not be null");
+        }
+        super.setEndMillis(instant.getMillis());
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/ReadWritableInterval.java b/JodaTime/src/java/org/joda/time/ReadWritableInterval.java
new file mode 100644
index 000000000..a976ee2cb
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/ReadWritableInterval.java
@@ -0,0 +1,94 @@
+/* 
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+/**
+ * Writable interface for an interval.
+ *
+ * @author Stephen Colebourne
+ * @since 1.0
+ */
+public interface ReadWritableInterval extends ReadableInterval {
+
+    /**
+     * Sets the start of this time interval.
+     *
+     * @param millisInstant  the start of the time interval,
+     *  millisecond instant from 1970-01-01T00:00:00Z
+     */
+    void setStartMillis(long millisInstant);
+
+    /**
+     * Sets the start of this time interval as an Instant.
+     *
+     * @param instant  the start of the time interval
+     */
+    void setStartInstant(ReadableInstant instant);
+
+    /** 
+     * Sets the end of this time interval.
+     *
+     * @param millisInstant  the end of the time interval,
+     *  millisecond instant from 1970-01-01T00:00:00Z
+     */
+    void setEndMillis(long millisInstant);
+
+    /** 
+     * Sets the end of this time interval as an Instant.
+     *
+     * @param instant  the end of the time interval
+     */
+    void setEndInstant(ReadableInstant instant);
+
+}
diff --git a/JodaTime/src/java/org/joda/time/ReadableInterval.java b/JodaTime/src/java/org/joda/time/ReadableInterval.java
new file mode 100644
index 000000000..90e0e10b7
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/ReadableInterval.java
@@ -0,0 +1,247 @@
+/* 
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+/** 
+ * Readable interface for a time interval.
+ * <p>
+ * A time interval represents a period of time between two instants.
+ * This interval has a duration, represented separately by ReadableDuration.
+ *
+ * @author Sean Geoghegan
+ * @author Brian S O'Neill
+ * @author Stephen Colebourne
+ * @since 1.0
+ */
+public interface ReadableInterval {
+
+    /**
+     * Gets the start of this time interval.
+     *
+     * @return the start of the time interval,
+     *  millisecond instant from 1970-01-01T00:00:00Z
+     */
+    long getStartMillis();
+
+    /**
+     * Gets the start of this time interval as an Instant.
+     *
+     * @return the start of the time interval
+     */
+    Instant getStartInstant();
+
+    /** 
+     * Gets the end of this time interval.
+     *
+     * @return the end of the time interval,
+     *  millisecond instant from 1970-01-01T00:00:00Z
+     */
+    long getEndMillis();
+
+    /** 
+     * Gets the end of this time interval as an Instant.
+     *
+     * @return the end of the time interval
+     */
+    Instant getEndInstant();
+
+    /** 
+     * Gets the duration of this time interval in milliseconds.
+     * <p>
+     * The duration returned will always be precise because it is relative to
+     * a known date.
+     *
+     * @return the duration of the time interval in milliseconds
+     */
+    long getDurationMillis();
+
+    /** 
+     * Gets the duration of this time interval.
+     * <p>
+     * The duration returned will always be precise because it is relative to
+     * a known date.
+     *
+     * @return the duration of the time interval
+     */
+    Duration getDuration();
+
+    //-----------------------------------------------------------------------
+    /**
+     * Does this time interval contain the specified millisecond instant.
+     * 
+     * @param millisInstant  the instant to compare to,
+     *  millisecond instant from 1970-01-01T00:00:00Z
+     * @return true if this time interval contains the millisecond
+     */
+    public boolean contains(long millisInstant);
+    
+    /**
+     * Does this time interval contain the specified instant.
+     * 
+     * @param instant  the instant
+     * @return true if this time interval contains the instant
+     * @throws IllegalArgumentException if the instant is null
+     */
+    public boolean contains(ReadableInstant instant);
+    
+    /**
+     * Does this time interval contain the specified time interval completely.
+     * 
+     * @param interval  the time interval to compare to
+     * @return true if this time interval contains the time interval
+     * @throws IllegalArgumentException if the interval is null
+     */
+    public boolean contains(ReadableInterval interval);
+    
+    /**
+     * Does this time interval overlap the specified time interval.
+     * <p>
+     * The intervals overlap if at least some of the time interval is in common.
+     * 
+     * @param interval  the time interval to compare to
+     * @return true if the time intervals overlap
+     * @throws IllegalArgumentException if the interval is null
+     */
+    public boolean overlaps(ReadableInterval interval);
+    
+    //-----------------------------------------------------------------------
+    /**
+     * Is this time interval before the specified millisecond instant.
+     * 
+     * @param millisInstant  the instant to compare to,
+     *  millisecond instant from 1970-01-01T00:00:00Z
+     * @return true if this time interval is before the instant
+     */
+    public boolean isBefore(long millisInstant);
+    
+    /**
+     * Is this time interval before the specified instant.
+     * 
+     * @param instant  the instant to compare to
+     * @return true if this time interval is before the instant
+     * @throws IllegalArgumentException if the instant is null
+     */
+    public boolean isBefore(ReadableInstant instant);
+    
+    /**
+     * Is this time interval after the specified millisecond instant.
+     * 
+     * @param millisInstant  the instant to compare to,
+     *  millisecond instant from 1970-01-01T00:00:00Z
+     * @return true if this time interval is after the instant
+     */
+    public boolean isAfter(long millisInstant);
+    
+    /**
+     * Is this time interval after the specified instant.
+     * 
+     * @param instant  the instant to compare to
+     * @return true if this time interval is after the instant
+     * @throws IllegalArgumentException if the instant is null
+     */
+    public boolean isAfter(ReadableInstant instant);
+    
+    //-----------------------------------------------------------------------
+    /**
+     * Get the value as a simple immutable object. This can be useful if you
+     * don't trust the implementation of the interface to be well-behaved, or
+     * to get a guaranteed immutable object.
+     *
+     * @return the value as an Interval object
+     */
+    Interval toInterval();
+
+    /**
+     * Get this time interval as a MutableInterval object.
+     *
+     * @return the time interval as a MutableInterval object
+     */
+    MutableInterval toMutableInterval();
+
+    //-----------------------------------------------------------------------
+    /**
+     * Compares this object with the specified object for equality based
+     * on start and end millis. All ReadableInterval instances are accepted.
+     * <p>
+     * To compare the duration of two time intervals, use {@link #getDuration()}
+     * to get the durations and compare those.
+     *
+     * @param readableInterval  a readable interval to check against
+     * @return true if the start and end millis are equal
+     */
+    boolean equals(Object readableInterval);
+
+    /**
+     * Gets a hash code for the time interval that is compatable with the 
+     * equals method.
+     * <p>
+     * The formula used must be as follows:
+     * <pre>int result = 97;
+     * result = 31 * result + ((int) (getStartMillis() ^ (getStartMillis() >>> 32)));
+     * result = 31 * result + ((int) (getEndMillis() ^ (getEndMillis() >>> 32)));
+     * return result;</pre>
+     *
+     * @return a hash code
+     */
+    int hashCode();
+
+    //-----------------------------------------------------------------------
+    /**
+     * Get the value as a String in the ISO8601 interval format.
+     *
+     * @return the value as an ISO8601 string
+     */
+    String toString();
+
+}

From 22e073ec195960a3b0b1bc21806223dd668acd59 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 21 Dec 2003 06:23:04 +0000
Subject: [PATCH 042/143] Support convertng intervals to durations.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@47 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../joda/time/convert/ConverterManager.java   |   2 +
 .../convert/ReadableIntervalConverter.java    | 101 ++++++++++++++++++
 2 files changed, 103 insertions(+)
 create mode 100644 JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java

diff --git a/JodaTime/src/java/org/joda/time/convert/ConverterManager.java b/JodaTime/src/java/org/joda/time/convert/ConverterManager.java
index 6fc88a3c7..72e617994 100644
--- a/JodaTime/src/java/org/joda/time/convert/ConverterManager.java
+++ b/JodaTime/src/java/org/joda/time/convert/ConverterManager.java
@@ -80,6 +80,7 @@
  * The default duration converters are:
  * <ul>
  * <li>ReadableDuration
+ * <li>ReadableInterval
  * <li>String
  * <li>Long
  * </ul>
@@ -122,6 +123,7 @@ protected ConverterManager() {
 
         iDurationConverters = new ConverterSet(new Converter[] {
             ReadableDurationConverter.INSTANCE,
+            ReadableIntervalConverter.INSTANCE,
             StringConverter.INSTANCE,
             LongConverter.INSTANCE,
         });
diff --git a/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java b/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java
new file mode 100644
index 000000000..3a65bad1e
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java
@@ -0,0 +1,101 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.convert;
+
+import org.joda.time.ReadableInterval;
+import org.joda.time.ReadWritableDuration;
+
+/**
+ * Converts intervals into durations of any requested duration type.
+ *
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+class ReadableIntervalConverter implements DurationConverter {
+
+    /**
+     * Singleton instance.
+     */
+    static final ReadableIntervalConverter INSTANCE = new ReadableIntervalConverter();
+    
+    /**
+     * Restricted constructor.
+     */
+    protected ReadableIntervalConverter() {
+        super();
+    }
+
+    /**
+     * Returns true always.
+     */
+    public boolean isPrecise(Object object) {
+        return true;
+    }
+
+    public long getDurationMillis(Object object) {
+        return (((ReadableInterval) object)).getDurationMillis();
+    }
+
+    public void setInto(ReadWritableDuration duration, Object object) {
+        ReadableInterval interval = (ReadableInterval) object;
+        duration.setTotalMillis(interval.getStartMillis(), interval.getEndMillis());
+    }
+
+    /**
+     * Returns ReadableInterval.class.
+     */
+    public Class getSupportedType() {
+        return ReadableInterval.class;
+    }
+}

From 58eac4bfddb5cf9f5fbae6f2b61dee33075c54a6 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 21 Dec 2003 06:23:17 +0000
Subject: [PATCH 043/143] Comment fix.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@48 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/convert/DurationConverter.java | 1 -
 1 file changed, 1 deletion(-)

diff --git a/JodaTime/src/java/org/joda/time/convert/DurationConverter.java b/JodaTime/src/java/org/joda/time/convert/DurationConverter.java
index cfee63b30..94d7e3753 100644
--- a/JodaTime/src/java/org/joda/time/convert/DurationConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/DurationConverter.java
@@ -88,7 +88,6 @@
      *
      * @param duration duration to get modified
      * @param object  the object to convert, must not be null
-     * @return the millisecond duration
      * @throws ClassCastException if the object is invalid
      */
     void setInto(ReadWritableDuration duration, Object object);

From 5c7f319af15d672f6842d1f25ae3edbf2ae8e279 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 21 Dec 2003 06:25:11 +0000
Subject: [PATCH 044/143] Added special conversion check.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@49 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/AbstractDuration.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/JodaTime/src/java/org/joda/time/AbstractDuration.java b/JodaTime/src/java/org/joda/time/AbstractDuration.java
index ac50959b8..3a701b7d3 100644
--- a/JodaTime/src/java/org/joda/time/AbstractDuration.java
+++ b/JodaTime/src/java/org/joda/time/AbstractDuration.java
@@ -152,7 +152,7 @@ public AbstractDuration(DurationType type, Object duration) {
             setDuration(iType = type, (ReadableDuration) duration);
         } else {
             DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);
-            if (converter.isPrecise(duration)) {
+            if (type.isPrecise() && converter.isPrecise(duration)) {
                 // Only call a private method
                 setTotalMillis(iType = type, converter.getDurationMillis(duration));
             } else {

From 35d7ba61e5a7ac5551494a3c85b249c236abdfd3 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 21 Dec 2003 06:25:32 +0000
Subject: [PATCH 045/143] Added isPrecise method.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@50 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/DurationType.java  | 46 +++++++++++++++++++
 1 file changed, 46 insertions(+)

diff --git a/JodaTime/src/java/org/joda/time/DurationType.java b/JodaTime/src/java/org/joda/time/DurationType.java
index f74b9df72..cd07f3b9a 100644
--- a/JodaTime/src/java/org/joda/time/DurationType.java
+++ b/JodaTime/src/java/org/joda/time/DurationType.java
@@ -272,6 +272,11 @@ protected DurationType() {
      */
     public abstract DurationType withChronology(Chronology chrono);
 
+    /**
+     * Returns true if every supported field in this type is precise.
+     */
+    public abstract boolean isPrecise();
+
     /**
      * Returns a DurationField representing years.
      *
@@ -479,6 +484,10 @@ public int hashCode() {
     private static final class MillisType extends DurationType {
         static final long serialVersionUID = -4314867016852780422L;
 
+        public boolean isPrecise() {
+            return true;
+        }
+
         public final DurationField millis() {
             return MillisDurationField.INSTANCE;
         }
@@ -516,6 +525,14 @@ public DurationType withChronology(Chronology chrono) {
             return new DayHourType(iChronology);
         }
 
+        public boolean isPrecise() {
+            return days().isPrecise()
+                && hours().isPrecise()
+                && minutes().isPrecise()
+                && seconds().isPrecise()
+                && minutes().isPrecise();
+        }
+
         public final DurationField days() {
             return iChronology.days();
         }
@@ -555,6 +572,12 @@ public DurationType withChronology(Chronology chrono) {
             return new YearMonthType(iChronology);
         }
 
+        public boolean isPrecise() {
+            return years().isPrecise()
+                && months().isPrecise()
+                && super.isPrecise();
+        }
+
         public DurationField years() {
             return iChronology.years();
         }
@@ -585,6 +608,12 @@ public DurationType withChronology(Chronology chrono) {
             return new ISOYearMonthType(iChronology);
         }
 
+        public boolean isPrecise() {
+            return years().isPrecise()
+                && months().isPrecise()
+                && super.isPrecise();
+        }
+
         public DurationField years() {
             return iChronology.years();
         }
@@ -612,6 +641,12 @@ public DurationType withChronology(Chronology chrono) {
             return new YearWeekType(iChronology);
         }
 
+        public boolean isPrecise() {
+            return years().isPrecise()
+                && weeks().isPrecise()
+                && super.isPrecise();
+        }
+
         public DurationField years() {
             return iChronology.weekyears();
         }
@@ -663,6 +698,17 @@ public DurationType withChronology(Chronology chrono) {
             return mask(iType.withChronology(chrono), iMask);
         }
 
+        public boolean isPrecise() {
+            return years().isPrecise()
+                && months().isPrecise()
+                && weeks().isPrecise()
+                && days().isPrecise()
+                && hours().isPrecise()
+                && minutes().isPrecise()
+                && seconds().isPrecise()
+                && minutes().isPrecise();
+        }
+
         public DurationField years() {
             if ((iMask & (1 << 0)) != 0) {
                 return UnsupportedDurationField.INSTANCE;

From 6f093d3b46504572cb78284517d0d3ea9f06b203 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 21 Dec 2003 06:26:43 +0000
Subject: [PATCH 046/143] Comment consistency.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@51 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/ReadableDuration.java        | 3 +++
 .../src/java/org/joda/time/format/DateTimeFormatter.java     | 5 ++++-
 JodaTime/src/java/org/joda/time/format/DateTimeParser.java   | 1 +
 JodaTime/src/java/org/joda/time/format/DateTimePrinter.java  | 1 +
 .../src/java/org/joda/time/format/DurationFormatter.java     | 1 +
 JodaTime/src/java/org/joda/time/format/DurationParser.java   | 5 ++++-
 JodaTime/src/java/org/joda/time/format/DurationPrinter.java  | 5 ++++-
 7 files changed, 18 insertions(+), 3 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/ReadableDuration.java b/JodaTime/src/java/org/joda/time/ReadableDuration.java
index 2effe3fe1..9ca5a908f 100644
--- a/JodaTime/src/java/org/joda/time/ReadableDuration.java
+++ b/JodaTime/src/java/org/joda/time/ReadableDuration.java
@@ -56,6 +56,9 @@
 /**
  * Defines a duration of time that can be queried using fields.
  * <p>
+ * The implementation of this interface may be mutable or immutable. This
+ * interface only gives access to retrieve data, never to change it.
+ * <p>
  * Durations can be split up into multiple fields, but implementations are not
  * required to evenly distribute the values across the fields. Nor are they
  * required to normalize the fields nor match the signs.
diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java b/JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java
index 1becd45c6..1cda3527a 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java
@@ -54,9 +54,12 @@
 package org.joda.time.format;
 
 /**
- * Defines a combined interface for printing and parsing.
+ * Combined interface for printing and parsing.
+ * <p>
+ * See each extended interface for details of the methods.
  *
  * @author Brian S O'Neill
+ * @since 1.0
  */
 public interface DateTimeFormatter extends DateTimePrinter, DateTimeParser {
     
diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeParser.java b/JodaTime/src/java/org/joda/time/format/DateTimeParser.java
index 64b00c243..7a75653fd 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeParser.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeParser.java
@@ -66,6 +66,7 @@
  * @see DateTimeFormatter
  * @see DateTimeFormatterBuilder
  * @see DateTimeFormat
+ * @since 1.0
  */
 public interface DateTimeParser {
 
diff --git a/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java b/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java
index 114a03750..31dd850be 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java
@@ -67,6 +67,7 @@
  * @see DateTimeFormatter
  * @see DateTimeFormatterBuilder
  * @see DateTimeFormat
+ * @since 1.0
  */
 public interface DateTimePrinter {
     
diff --git a/JodaTime/src/java/org/joda/time/format/DurationFormatter.java b/JodaTime/src/java/org/joda/time/format/DurationFormatter.java
index 9f0fe5ee6..792494ab7 100644
--- a/JodaTime/src/java/org/joda/time/format/DurationFormatter.java
+++ b/JodaTime/src/java/org/joda/time/format/DurationFormatter.java
@@ -64,4 +64,5 @@
  */
 public interface DurationFormatter extends DurationPrinter, DurationParser {
 
+    // Methods inherited
 }
diff --git a/JodaTime/src/java/org/joda/time/format/DurationParser.java b/JodaTime/src/java/org/joda/time/format/DurationParser.java
index 71ee4f134..7fdc1128e 100644
--- a/JodaTime/src/java/org/joda/time/format/DurationParser.java
+++ b/JodaTime/src/java/org/joda/time/format/DurationParser.java
@@ -59,9 +59,12 @@
 import org.joda.time.ReadWritableDuration;
 
 /**
- * Converts sequences of human-readable characters into durations.
+ * Defines an interface for parsing textual representations of durations.
  *
  * @author Brian S O'Neill
+ * @see DurationFormatter
+ * @see DurationFormatterBuilder
+ * @see DurationFormat
  * @since 1.0
  */
 public interface DurationParser {
diff --git a/JodaTime/src/java/org/joda/time/format/DurationPrinter.java b/JodaTime/src/java/org/joda/time/format/DurationPrinter.java
index 7d64fdd50..691f758a7 100644
--- a/JodaTime/src/java/org/joda/time/format/DurationPrinter.java
+++ b/JodaTime/src/java/org/joda/time/format/DurationPrinter.java
@@ -59,9 +59,12 @@
 import org.joda.time.ReadableDuration;
 
 /**
- * Converts durations into a sequence of human-readable characters.
+ * Defines an interface for creating textual representations of durations.
  *
  * @author Brian S O'Neill
+ * @see DurationFormatter
+ * @see DurationFormatterBuilder
+ * @see DurationFormat
  * @since 1.0
  */
 public interface DurationPrinter {

From b8197b0ff8e97855a7cbbc6fcb9d520825a169fc Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 21 Dec 2003 06:27:51 +0000
Subject: [PATCH 047/143] Removed redundant public keywords.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@52 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/DateTimeField.java | 68 +++++++++----------
 .../src/java/org/joda/time/DurationField.java | 42 ++++++------
 2 files changed, 55 insertions(+), 55 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/DateTimeField.java b/JodaTime/src/java/org/joda/time/DateTimeField.java
index 0378cf31e..6adb3fd38 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeField.java
@@ -75,14 +75,14 @@
      * 
      * @return field name
      */
-    public String getName();
+    String getName();
 
     /**
      * Returns true if this field is supported.
      * 
      * @return true if this field is supported
      */
-    public boolean isSupported();
+    boolean isSupported();
 
     /**
      * Returns true if the set method is lenient. If so, it accepts values that
@@ -91,7 +91,7 @@
      * 
      * @return true if this field is lenient
      */
-    public boolean isLenient();
+    boolean isLenient();
 
     // Main access API
     //------------------------------------------------------------------------
@@ -101,7 +101,7 @@
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
      * @return the value of the field, in the units of the field
      */
-    public int get(long instant);
+    int get(long instant);
 
     /**
      * Get the human-readable, text value of this field from the milliseconds.
@@ -111,7 +111,7 @@
      * @param locale the locale to use for selecting a text symbol, null for default
      * @return the text value of the field
      */
-    public String getAsText(long instant, Locale locale);
+    String getAsText(long instant, Locale locale);
 
     /**
      * Get the human-readable, text value of this field from the milliseconds.
@@ -119,7 +119,7 @@
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
      * @return the text value of the field
      */
-    public String getAsText(long instant);
+    String getAsText(long instant);
 
     /**
      * Get the human-readable, short text value of this field from the
@@ -129,7 +129,7 @@
      * @param locale the locale to use for selecting a text symbol, null for default
      * @return the short text value of the field
      */
-    public String getAsShortText(long instant, Locale locale);
+    String getAsShortText(long instant, Locale locale);
 
     /**
      * Get the human-readable, short text value of this field from the
@@ -138,7 +138,7 @@
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
      * @return the short text value of the field
      */
-    public String getAsShortText(long instant);
+    String getAsShortText(long instant);
 
     /**
      * Adds a value (which may be negative) to the millis value,
@@ -161,7 +161,7 @@
      * @param value  the value to add, in the units of the field
      * @return the updated milliseconds
      */
-    public long add(long instant, int value);
+    long add(long instant, int value);
 
     /**
      * Adds a value (which may be negative) to the millis value,
@@ -173,7 +173,7 @@
      * @throws IllegalArgumentException if value is too large
      * @see #add(long,int)
      */
-    public long add(long instant, long value);
+    long add(long instant, long value);
 
     /**
      * Adds a value (which may be negative) to the millis value,
@@ -196,7 +196,7 @@
      * @param value  the value to add, in the units of the field
      * @return the updated milliseconds
      */
-    public long addWrapped(long instant, int value) ;
+    long addWrapped(long instant, int value) ;
 
     /**
      * Computes the difference between two instants, as measured in the units
@@ -217,7 +217,7 @@
      * subtract off the minuend
      * @return the difference in the units of this field
      */
-    public int getDifference(long minuendInstant, long subtrahendInstant);
+    int getDifference(long minuendInstant, long subtrahendInstant);
 
     /**
      * Computes the difference between two instants, as measured in the units
@@ -238,7 +238,7 @@
      * subtract off the minuend
      * @return the difference in the units of this field
      */
-    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant);
+    long getDifferenceAsLong(long minuendInstant, long subtrahendInstant);
 
     /**
      * Sets a value in the milliseconds supplied.
@@ -251,7 +251,7 @@
      * @return the updated milliseconds
      * @throws IllegalArgumentException if the value is invalid
      */
-    public long set(long instant, int value);
+    long set(long instant, int value);
 
     /**
      * Sets a value in the milliseconds supplied from a human-readable, text
@@ -264,7 +264,7 @@
      * @return the updated milliseconds
      * @throws IllegalArgumentException if the text value is invalid
      */
-    public long set(long instant, String text, Locale locale);
+    long set(long instant, String text, Locale locale);
 
     /**
      * Sets a value in the milliseconds supplied from a human-readable, text
@@ -275,7 +275,7 @@
      * @return the updated milliseconds
      * @throws IllegalArgumentException if the text value is invalid
      */
-    public long set(long instant, String text);
+    long set(long instant, String text);
 
     // Extra information API
     //------------------------------------------------------------------------
@@ -286,7 +286,7 @@
      * @return the duration of this field, or UnsupportedDurationField if field
      * has no duration
      */
-    public DurationField getDurationField();
+    DurationField getDurationField();
 
     /**
      * Returns the range duration of this field. For example, if this field
@@ -294,7 +294,7 @@
      *
      * @return the range duration of this field, or null if field has no range
      */
-    public DurationField getRangeDurationField();
+    DurationField getRangeDurationField();
 
     /**
      * Returns whether this field is 'leap' for the specified instant.
@@ -304,7 +304,7 @@
      * 
      * @return true if the field is 'leap'
      */
-    public boolean isLeap(long instant);
+    boolean isLeap(long instant);
 
     /**
      * Gets the amount by which this field is 'leap' for the specified instant.
@@ -312,13 +312,13 @@
      * For example, a leap year would return one, a non leap year would return
      * zero.
      */
-    public int getLeapAmount(long instant);
+    int getLeapAmount(long instant);
 
     /**
      * If this field were to leap, then it would be in units described by the
      * returned duration. If this field doesn't ever leap, null is returned.
      */
-    public DurationField getLeapDurationField();
+    DurationField getLeapDurationField();
 
     /**
      * Get the minimum allowable value for this field.
@@ -326,7 +326,7 @@
      * @return the minimum valid value for this field, in the units of the
      * field
      */
-    public int getMinimumValue();
+    int getMinimumValue();
 
     /**
      * Get the minimum value for this field evaluated at the specified time.
@@ -334,7 +334,7 @@
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
      * @return the minimum value for this field, in the units of the field
      */
-    public int getMinimumValue(long instant);
+    int getMinimumValue(long instant);
 
     /**
      * Get the maximum allowable value for this field.
@@ -342,7 +342,7 @@
      * @return the maximum valid value for this field, in the units of the
      * field
      */
-    public int getMaximumValue();
+    int getMaximumValue();
 
     /**
      * Get the maximum value for this field evaluated at the specified time.
@@ -350,7 +350,7 @@
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query
      * @return the maximum value for this field, in the units of the field
      */
-    public int getMaximumValue(long instant);
+    int getMaximumValue(long instant);
 
     /**
      * Get the maximum text value for this field.
@@ -358,7 +358,7 @@
      * @param locale  the locale to use for selecting a text symbol
      * @return the maximum text length
      */
-    public int getMaximumTextLength(Locale locale);
+    int getMaximumTextLength(Locale locale);
 
     /**
      * Get the maximum short text value for this field.
@@ -366,7 +366,7 @@
      * @param locale  the locale to use for selecting a text symbol
      * @return the maximum short text length
      */
-    public int getMaximumShortTextLength(Locale locale);
+    int getMaximumShortTextLength(Locale locale);
 
     // Calculation API
     //------------------------------------------------------------------------
@@ -382,7 +382,7 @@
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
      * @return rounded milliseconds
      */
-    public long roundFloor(long instant);
+    long roundFloor(long instant);
 
     /**
      * Round to the highest whole unit of this field. The value of this field
@@ -396,7 +396,7 @@
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
      * @return rounded milliseconds
      */
-    public long roundCeiling(long instant);
+    long roundCeiling(long instant);
 
     /**
      * Round to the nearest whole unit of this field. If the given millisecond
@@ -407,7 +407,7 @@
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
      * @return rounded milliseconds
      */
-    public long roundHalfFloor(long instant);
+    long roundHalfFloor(long instant);
 
     /**
      * Round to the nearest whole unit of this field. If the given millisecond
@@ -418,7 +418,7 @@
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
      * @return rounded milliseconds
      */
-    public long roundHalfCeiling(long instant);
+    long roundHalfCeiling(long instant);
 
     /**
      * Round to the nearest whole unit of this field. If the given millisecond
@@ -433,7 +433,7 @@
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round
      * @return rounded milliseconds
      */
-    public long roundHalfEven(long instant);
+    long roundHalfEven(long instant);
 
     /**
      * Returns the fractional duration milliseconds of this field. In other
@@ -447,13 +447,13 @@
      * remainder
      * @return remainder duration, in milliseconds
      */
-    public long remainder(long instant);
+    long remainder(long instant);
 
     /**
      * Get a suitable debug string.
      * 
      * @return debug string
      */
-    public String toString();
+    String toString();
     
 }
diff --git a/JodaTime/src/java/org/joda/time/DurationField.java b/JodaTime/src/java/org/joda/time/DurationField.java
index 3febd5f22..1b5ca051a 100644
--- a/JodaTime/src/java/org/joda/time/DurationField.java
+++ b/JodaTime/src/java/org/joda/time/DurationField.java
@@ -72,14 +72,14 @@
      * 
      * @return field name
      */
-    public String getName();
+    String getName();
 
     /**
      * Returns true if this field is supported.
      * 
      * @return true if this field is supported
      */
-    public boolean isSupported();
+    boolean isSupported();
 
     /**
      * Is this field precise. A precise field can calculate its value from
@@ -89,7 +89,7 @@
      * @return true if precise
      * @see #getUnitMillis()
      */
-    public boolean isPrecise();
+    boolean isPrecise();
     
     /**
      * Returns the amount of milliseconds per unit value of this field. For
@@ -102,7 +102,7 @@
      * @return the unit size of this field, in milliseconds
      * @see #isPrecise()
      */
-    public long getUnitMillis();
+    long getUnitMillis();
 
     //------------------------------------------------------------------------
     /**
@@ -114,7 +114,7 @@
      * negative
      * @throws ArithmeticException if the value is too large for an int
      */
-    public int getValue(long duration);
+    int getValue(long duration);
 
     /**
      * Get the value of this field from the milliseconds, which is approximate
@@ -124,7 +124,7 @@
      * @return the value of the field, in the units of the field, which may be
      * negative
      */
-    public long getValueAsLong(long duration);
+    long getValueAsLong(long duration);
 
     /**
      * Get the value of this field from the milliseconds relative to an
@@ -140,7 +140,7 @@
      * negative
      * @throws ArithmeticException if the value is too large for an int
      */
-    public int getValue(long duration, long instant);
+    int getValue(long duration, long instant);
 
     /**
      * Get the value of this field from the milliseconds relative to an
@@ -155,7 +155,7 @@
      * @return the value of the field, in the units of the field, which may be
      * negative
      */
-    public long getValueAsLong(long duration, long instant);
+    long getValueAsLong(long duration, long instant);
 
     //------------------------------------------------------------------------
     /**
@@ -166,7 +166,7 @@
      * @return the milliseconds that the field represents, which may be
      * negative
      */
-    public long getMillis(int value);
+    long getMillis(int value);
 
     /**
      * Get the millisecond duration of this field from its value, which is
@@ -176,7 +176,7 @@
      * @return the milliseconds that the field represents, which may be
      * negative
      */
-    public long getMillis(long value);
+    long getMillis(long value);
 
     /**
      * Get the millisecond duration of this field from its value relative to an
@@ -191,7 +191,7 @@
      * @return the millisecond duration that the field represents, which may be
      * negative
      */
-    public long getMillis(int value, long instant);
+    long getMillis(int value, long instant);
 
     /**
      * Get the millisecond duration of this field from its value relative to an
@@ -206,7 +206,7 @@
      * @return the millisecond duration that the field represents, which may be
      * negative
      */
-    public long getMillis(long value, long instant);
+    long getMillis(long value, long instant);
 
     /**
      * Adds a duration value (which may be negative) to the instant.
@@ -215,7 +215,7 @@
      * @param value  the value to add, in the units of the field
      * @return the updated milliseconds
      */
-    public long add(long instant, int value);
+    long add(long instant, int value);
 
     /**
      * Adds a duration value (which may be negative) to the instant.
@@ -224,7 +224,7 @@
      * @param value  the value to add, in the units of the field
      * @return the updated milliseconds
      */
-    public long add(long instant, long value);
+    long add(long instant, long value);
 
     /**
      * Computes the difference between two instants, as measured in the units
@@ -245,7 +245,7 @@
      * subtract off the minuend
      * @return the difference in the units of this field
      */
-    public int getDifference(long minuendInstant, long subtrahendInstant);
+    int getDifference(long minuendInstant, long subtrahendInstant);
 
     /**
      * Computes the difference between two instants, as measured in the units
@@ -266,7 +266,7 @@
      * subtract off the minuend
      * @return the difference in the units of this field
      */
-    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant);
+    long getDifferenceAsLong(long minuendInstant, long subtrahendInstant);
 
     /**
      * Compares this duration field with another duration field for ascending
@@ -278,7 +278,7 @@
      * @throws NullPointerException if the object is null
      * @throws ClassCastException if the object type is not supported
      */
-    public int compareTo(Object durationField);
+    int compareTo(Object durationField);
 
     /**
      * Returns a localized unit name of this field, using the given value as an
@@ -287,7 +287,7 @@
      * @param value the duration value to use for selecting a unit name
      * @param locale the locale to use for selecting a name, null for default
      */
-    //public String getUnitName(long value, Locale locale);
+    //String getUnitName(long value, Locale locale);
 
     /**
      * Returns a localized unit name of this field, using the given value as an
@@ -295,7 +295,7 @@
      *
      * @param value the duration value to use for selecting a unit name
      */
-    //public String getUnitName(long value);
+    //String getUnitName(long value);
 
     /**
      * Get the maximum length string returned by getUnitName.
@@ -304,7 +304,7 @@
      * default
      * @return the maximum name length
      */
-    //public int getMaximumUnitNameLength(Locale locale);
+    //int getMaximumUnitNameLength(Locale locale);
 
     //------------------------------------------------------------------------
     /**
@@ -312,6 +312,6 @@
      * 
      * @return debug string
      */
-    public String toString();
+    String toString();
     
 }

From 029dcff9f9a82b60002d7acf347d66324195ad56 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 21 Dec 2003 23:54:48 +0000
Subject: [PATCH 048/143] Support selecting a duration type.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@53 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/time/convert/DurationConverter.java     | 10 ++++++++++
 .../java/org/joda/time/convert/LongConverter.java    | 12 ++++++++++++
 .../joda/time/convert/ReadableDurationConverter.java | 12 ++++++++++++
 3 files changed, 34 insertions(+)

diff --git a/JodaTime/src/java/org/joda/time/convert/DurationConverter.java b/JodaTime/src/java/org/joda/time/convert/DurationConverter.java
index 94d7e3753..38b0b4e29 100644
--- a/JodaTime/src/java/org/joda/time/convert/DurationConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/DurationConverter.java
@@ -53,6 +53,7 @@
  */
 package org.joda.time.convert;
 
+import org.joda.time.DurationType;
 import org.joda.time.ReadableDuration;
 import org.joda.time.ReadWritableDuration;
 
@@ -92,4 +93,13 @@
      */
     void setInto(ReadWritableDuration duration, Object object);
 
+    /**
+     * Selects a suitable duration type for the given object.
+     *
+     * @param object  the object to examine, must not be null
+     * @return the duration type, never null
+     * @throws ClassCastException if the object is invalid
+     */
+    DurationType getDurationType(Object object);
+
 }
diff --git a/JodaTime/src/java/org/joda/time/convert/LongConverter.java b/JodaTime/src/java/org/joda/time/convert/LongConverter.java
index 6512335ed..bfdcbfde2 100644
--- a/JodaTime/src/java/org/joda/time/convert/LongConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/LongConverter.java
@@ -53,6 +53,7 @@
  */
 package org.joda.time.convert;
 
+import org.joda.time.DurationType;
 import org.joda.time.ReadWritableDuration;
 
 /**
@@ -118,6 +119,17 @@ public void setInto(ReadWritableDuration duration, Object object) {
         duration.setTotalMillis(((Long) object).longValue());
     }
 
+    /**
+     * Selects a suitable duration type for the given object.
+     *
+     * @param object  the object to examine, must not be null
+     * @return the duration type, never null
+     * @throws ClassCastException if the object is invalid
+     */
+    public DurationType getDurationType(Object object) {
+        return DurationType.getAverageYearMonthType();
+    }
+
     //-----------------------------------------------------------------------
     /**
      * Returns Long.class.
diff --git a/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java b/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java
index 58132f188..6480287de 100644
--- a/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java
@@ -53,6 +53,7 @@
  */
 package org.joda.time.convert;
 
+import org.joda.time.DurationType;
 import org.joda.time.ReadableDuration;
 import org.joda.time.ReadWritableDuration;
 
@@ -111,6 +112,17 @@ public void setInto(ReadWritableDuration duration, Object object) {
         duration.setDuration((ReadableDuration) object);
     }
 
+    /**
+     * Selects a suitable duration type for the given object.
+     *
+     * @param object  the object to examine, must not be null
+     * @return the duration type, never null
+     * @throws ClassCastException if the object is invalid
+     */
+    public DurationType getDurationType(Object object) {
+        return ((ReadableDuration) object).getDurationType();
+    }
+
     //-----------------------------------------------------------------------
     /**
      * Returns ReadableDuration.class.

From fa7e966cd0162ac3c21d46c56448a47de251c6b9 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 21 Dec 2003 23:55:53 +0000
Subject: [PATCH 049/143] Support converting intervals.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@54 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../joda/time/convert/ConverterManager.java   | 100 +++++++++++++++++-
 .../joda/time/convert/IntervalConverter.java  |  76 +++++++++++++
 .../convert/ReadableIntervalConverter.java    |  21 +++-
 .../joda/time/convert/StringConverter.java    |  75 ++++++++++++-
 4 files changed, 267 insertions(+), 5 deletions(-)
 create mode 100644 JodaTime/src/java/org/joda/time/convert/IntervalConverter.java

diff --git a/JodaTime/src/java/org/joda/time/convert/ConverterManager.java b/JodaTime/src/java/org/joda/time/convert/ConverterManager.java
index 72e617994..2b30a9893 100644
--- a/JodaTime/src/java/org/joda/time/convert/ConverterManager.java
+++ b/JodaTime/src/java/org/joda/time/convert/ConverterManager.java
@@ -62,7 +62,8 @@
  * <p>
  * This class enables additional conversion classes to be added via
  * {@link #addInstantConverter(InstantConverter)}, which may replace an
- * existing converter. Similar methods exist for duration converters.
+ * existing converter. Similar methods exist for duration and interval
+ * converters.
  * <p>
  * This class is threadsafe, so adding/removing converters can be done at any
  * time. Updating the set of convertors is relatively expensive, and so should
@@ -85,6 +86,12 @@
  * <li>Long
  * </ul>
  *
+ * The default interval converters are:
+ * <ul>
+ * <li>ReadableInterval
+ * <li>String
+ * </ul>
+ *
  * @author Stephen Colebourne
  * @author Brian S O'Neill
  * @since 1.0
@@ -105,6 +112,7 @@ public static ConverterManager getInstance() {
     
     private ConverterSet iInstantConverters;
     private ConverterSet iDurationConverters;
+    private ConverterSet iIntervalConverters;
     
     /**
      * Restricted constructor.
@@ -127,6 +135,11 @@ protected ConverterManager() {
             StringConverter.INSTANCE,
             LongConverter.INSTANCE,
         });
+
+        iIntervalConverters = new ConverterSet(new Converter[] {
+            ReadableIntervalConverter.INSTANCE,
+            StringConverter.INSTANCE,
+        });
     }
     
     //-----------------------------------------------------------------------
@@ -293,6 +306,88 @@ public DurationConverter removeDurationConverter(int index) {
         return removed[0];
     }
 
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the best converter for the object specified.
+     * 
+     * @param object  the object to convert
+     * @return the converter to use
+     * @throws IllegalArgumentException if no suitable converter
+     * @throws IllegalStateException if multiple converters match the type
+     * equally well
+     */
+    public IntervalConverter getIntervalConverter(Object object) {
+        IntervalConverter converter =
+            (IntervalConverter)iIntervalConverters.select(object == null ? null : object.getClass());
+        if (converter != null) {
+            return converter;
+        }
+        throw new IllegalArgumentException("No interval converter found for type: " +
+            (object == null ? "null" : object.getClass().getName()));
+    }
+    
+    //-----------------------------------------------------------------------
+    /**
+     * Gets a copy of the list of converters.
+     * 
+     * @return the converters, a copy of the real data, never null
+     */
+    public IntervalConverter[] getIntervalConverters() {
+        ConverterSet set = iIntervalConverters;
+        IntervalConverter[] converters = new IntervalConverter[set.size()];
+        set.copyInto(converters);
+        return converters;
+    }
+    
+    /**
+     * Adds a converter to the set of converters. If a matching converter is
+     * already in the set, the given converter replaces it. If the converter is
+     * exactly the same as one already in the set, no changes are made.
+     * <p>
+     * The order in which converters are added is not relevent. The best
+     * converter is selected by examining the object hierarchy.
+     * 
+     * @param converter  the converter to add, null ignored
+     * @return replaced converter, or null
+     */
+    public IntervalConverter addIntervalConverter(IntervalConverter converter) {
+        if (converter == null) {
+            return null;
+        }
+        IntervalConverter[] removed = new IntervalConverter[1];
+        iIntervalConverters = iIntervalConverters.add(converter, removed);
+        return removed[0];
+    }
+    
+    /**
+     * Removes a converter from the set of converters. If the converter was
+     * not in the set, no changes are made.
+     * 
+     * @param converter  the converter to remove, null ignored
+     * @return replaced converter, or null
+     */
+    public IntervalConverter removeIntervalConverter(IntervalConverter converter) {
+        if (converter == null) {
+            return null;
+        }
+        IntervalConverter[] removed = new IntervalConverter[1];
+        iIntervalConverters = iIntervalConverters.remove(converter, removed);
+        return removed[0];
+    }
+    
+    /**
+     * Removes a converter from the set of converters, by index.
+     * 
+     * @param index  the index to remove
+     * @return replaced converter, or null
+     * @throws IndexOutOfBoundsException if the index is invalid
+     */
+    public IntervalConverter removeIntervalConverter(int index) {
+        IntervalConverter[] removed = new IntervalConverter[1];
+        iIntervalConverters = iIntervalConverters.remove(index, removed);
+        return removed[0];
+    }
+
     //-----------------------------------------------------------------------
     /**
      * Gets a debug representation of the object
@@ -300,7 +395,8 @@ public DurationConverter removeDurationConverter(int index) {
     public String toString() {
         return "ConverterManager[" +
             iInstantConverters.size() + " instant converters," +
-            iDurationConverters.size() + " duration converters]";
+            iDurationConverters.size() + " duration converters," +
+            iIntervalConverters.size() + " interval converters]";
     }
 
 }
diff --git a/JodaTime/src/java/org/joda/time/convert/IntervalConverter.java b/JodaTime/src/java/org/joda/time/convert/IntervalConverter.java
new file mode 100644
index 000000000..94b9202b2
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/convert/IntervalConverter.java
@@ -0,0 +1,76 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.convert;
+
+import org.joda.time.ReadWritableInterval;
+
+/**
+ * IntervalConverter defines how an object is converted to an interval.
+ *
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+public interface IntervalConverter extends Converter {
+
+    /**
+     * Extracts interval endpoint values from an object of this converter's
+     * type, and sets them into the given ReadWritableInterval.
+     *
+     * @param interval interval to get modified
+     * @param object  the object to convert, must not be null
+     * @throws ClassCastException if the object is invalid
+     */
+    void setInto(ReadWritableInterval interval, Object object);
+
+}
diff --git a/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java b/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java
index 3a65bad1e..7d178b157 100644
--- a/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java
@@ -53,8 +53,10 @@
  */
 package org.joda.time.convert;
 
+import org.joda.time.DurationType;
 import org.joda.time.ReadableInterval;
 import org.joda.time.ReadWritableDuration;
+import org.joda.time.ReadWritableInterval;
 
 /**
  * Converts intervals into durations of any requested duration type.
@@ -62,7 +64,7 @@
  * @author Brian S O'Neill
  * @since 1.0
  */
-class ReadableIntervalConverter implements DurationConverter {
+class ReadableIntervalConverter implements IntervalConverter, DurationConverter {
 
     /**
      * Singleton instance.
@@ -92,6 +94,23 @@ public void setInto(ReadWritableDuration duration, Object object) {
         duration.setTotalMillis(interval.getStartMillis(), interval.getEndMillis());
     }
 
+    /**
+     * Selects a suitable duration type for the given object.
+     *
+     * @param object  the object to examine, must not be null
+     * @return the duration type, never null
+     * @throws ClassCastException if the object is invalid
+     */
+    public DurationType getDurationType(Object object) {
+        return ((ReadableInterval) object).getDuration().getDurationType();
+    }
+
+    public void setInto(ReadWritableInterval writableInterval, Object object) {
+        ReadableInterval interval = (ReadableInterval) object;
+        writableInterval.setStartMillis(interval.getStartMillis());
+        writableInterval.setEndMillis(interval.getEndMillis());
+    }
+
     /**
      * Returns ReadableInterval.class.
      */
diff --git a/JodaTime/src/java/org/joda/time/convert/StringConverter.java b/JodaTime/src/java/org/joda/time/convert/StringConverter.java
index 01fe6c8ba..f8fd21c5f 100644
--- a/JodaTime/src/java/org/joda/time/convert/StringConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/StringConverter.java
@@ -55,7 +55,12 @@
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeZone;
+import org.joda.time.DurationType;
+import org.joda.time.MutableDuration;
+import org.joda.time.ReadableDuration;
+import org.joda.time.ReadableInstant;
 import org.joda.time.ReadWritableDuration;
+import org.joda.time.ReadWritableInterval;
 import org.joda.time.chrono.iso.ISOChronology;
 import org.joda.time.format.DateTimeParser;
 import org.joda.time.format.DurationParser;
@@ -69,7 +74,8 @@
  * @author Brian S O'Neill
  * @since 1.0
  */
-class StringConverter extends AbstractConverter implements InstantConverter, DurationConverter {
+class StringConverter extends AbstractConverter
+    implements InstantConverter, DurationConverter, IntervalConverter {
     
     /**
      * Singleton instance.
@@ -151,6 +157,71 @@ public void setInto(ReadWritableDuration duration, Object object) {
         }
     }
 
+    /**
+     * Selects a suitable duration type for the given object.
+     *
+     * @param object  the object to examine, must not be null
+     * @return the duration type, never null
+     * @throws ClassCastException if the object is invalid
+     */
+    public DurationType getDurationType(Object object) {
+        String str = (String) object;
+        if (str.indexOf('W') >= 0) {
+            return DurationType.getYearWeekType();
+        }
+        return DurationType.getYearMonthType();
+    }
+
+    public void setInto(ReadWritableInterval writableInterval, Object object) {
+        String str = (String) object;
+
+        int separator = str.indexOf('/');
+        if (separator < 0) {
+            throw new IllegalArgumentException("Format requires a '/' separator: " + str);
+        }
+
+        String leftStr = str.substring(0, separator);
+        if (leftStr.length() <= 0) {
+            throw new IllegalArgumentException();
+        }
+        String rightStr = str.substring(separator + 1);
+        if (rightStr.length() <= 0) {
+            throw new IllegalArgumentException();
+        }
+
+        long startInstant;
+        ReadableDuration duration;
+
+        char c = leftStr.charAt(0);
+        if (c == 'P' || c == 'p') {
+            startInstant = 0;
+            duration = ISODurationFormat.getInstance().standard()
+                .parseDuration(getDurationType(leftStr), leftStr);
+        } else {
+            startInstant = ISODateTimeFormat.getInstanceUTC().dateTimeParser().parseMillis(leftStr);
+            duration = null;
+        }
+
+        c = rightStr.charAt(0);
+        if (c == 'P' || c == 'p') {
+            if (duration != null) {
+                throw new IllegalArgumentException("Interval composed of two durations: " + str);
+            }
+            duration = ISODurationFormat.getInstance().standard()
+                .parseDuration(getDurationType(rightStr), rightStr);
+            writableInterval.setStartMillis(startInstant);
+            writableInterval.setDurationAfterStart(duration);
+        } else {
+            long endInstant = ISODateTimeFormat.getInstanceUTC().dateTimeParser().parseMillis(rightStr);
+            writableInterval.setEndMillis(endInstant);
+            if (duration == null) {
+                writableInterval.setStartMillis(startInstant);
+            } else {
+                writableInterval.setDurationBeforeEnd(duration);
+            }
+        }
+    }
+
     //-----------------------------------------------------------------------
     /**
      * Returns String.class.
@@ -160,5 +231,5 @@ public void setInto(ReadWritableDuration duration, Object object) {
     public Class getSupportedType() {
         return String.class;
     }
-    
+
 }

From d40f8536582e8c74ecf20735f5b2263e514d3ad6 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 21 Dec 2003 23:56:20 +0000
Subject: [PATCH 050/143] Remove unused import.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@55 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/chrono/gj/GJDayOfMonthDateTimeField.java  | 1 -
 1 file changed, 1 deletion(-)

diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfMonthDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfMonthDateTimeField.java
index 456d4a661..f466f5a7c 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfMonthDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfMonthDateTimeField.java
@@ -53,7 +53,6 @@
  */
 package org.joda.time.chrono.gj;
 
-import org.joda.time.DateTimeConstants;
 import org.joda.time.DurationField;
 import org.joda.time.chrono.PreciseDurationDateTimeField;
 import org.joda.time.chrono.Utils;

From 5b168ff99eb76ec0663c9167ba0a236c7ea85f23 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 21 Dec 2003 23:59:27 +0000
Subject: [PATCH 051/143] Comment typos.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@56 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/AbstractDateTime.java  |  8 ++++----
 .../src/java/org/joda/time/AbstractPartialInstant.java |  2 +-
 JodaTime/src/java/org/joda/time/DateTime.java          |  6 +++---
 JodaTime/src/java/org/joda/time/MutableDateTime.java   | 10 +++++-----
 .../src/java/org/joda/time/ReadWritableDateTime.java   |  4 ++--
 .../src/java/org/joda/time/ReadWritableInstant.java    |  2 +-
 JodaTime/src/java/org/joda/time/TimeOnly.java          |  4 ++--
 7 files changed, 18 insertions(+), 18 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/AbstractDateTime.java b/JodaTime/src/java/org/joda/time/AbstractDateTime.java
index 108446cf0..445807fa6 100644
--- a/JodaTime/src/java/org/joda/time/AbstractDateTime.java
+++ b/JodaTime/src/java/org/joda/time/AbstractDateTime.java
@@ -256,7 +256,7 @@ protected AbstractDateTime(final Object instant, final Chronology chronology) {
      * @param hourOfDay  the hour of the day
      * @param minuteOfHour  the minute of the hour
      * @param secondOfMinute  the second of the minute
-     * @param millisOfSecond  the milisecond of the second
+     * @param millisOfSecond  the millisecond of the second
      */
     protected AbstractDateTime(
             final int year,
@@ -284,7 +284,7 @@ protected AbstractDateTime(
      * @param hourOfDay  the hour of the day
      * @param minuteOfHour  the minute of the hour
      * @param secondOfMinute  the second of the minute
-     * @param millisOfSecond  the milisecond of the second
+     * @param millisOfSecond  the millisecond of the second
      * @param zone  the time zone, null means default time zone
      */
     protected AbstractDateTime(
@@ -315,7 +315,7 @@ protected AbstractDateTime(
      * @param hourOfDay  the hour of the day
      * @param minuteOfHour  the minute of the hour
      * @param secondOfMinute  the second of the minute
-     * @param millisOfSecond  the milisecond of the second
+     * @param millisOfSecond  the millisecond of the second
      * @param chronology  the chronology, null means ISOChronology in default zone
      */
     protected AbstractDateTime(
@@ -582,7 +582,7 @@ public String toString(String pattern, Locale locale) throws IllegalArgumentExce
     }
 
     /**
-     * Set the value as the number of miliseconds since the epoch,
+     * Set the value as the number of milliseconds since the epoch,
      * 1970-01-01T00:00:00Z.
      * <p>
      * Subclasses that wish to be immutable should override this method with an
diff --git a/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java b/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
index fa84346b7..980cd596f 100644
--- a/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
+++ b/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
@@ -400,7 +400,7 @@ public int hashCode() {
     public abstract String toString();
 
     /**
-     * Set the value as the number of miliseconds since the epoch,
+     * Set the value as the number of milliseconds since the epoch,
      * 1970-01-01T00:00:00Z.
      * <p>
      * Subclasses that wish to be immutable should override this method with an
diff --git a/JodaTime/src/java/org/joda/time/DateTime.java b/JodaTime/src/java/org/joda/time/DateTime.java
index b29d0ef5e..a142d8c1a 100644
--- a/JodaTime/src/java/org/joda/time/DateTime.java
+++ b/JodaTime/src/java/org/joda/time/DateTime.java
@@ -237,7 +237,7 @@ public DateTime(Object instant, Chronology chronology) {
      * @param hourOfDay  the hour of the day
      * @param minuteOfHour  the minute of the hour
      * @param secondOfMinute  the second of the minute
-     * @param millisOfSecond  the milisecond of the second
+     * @param millisOfSecond  the millisecond of the second
      */
     public DateTime(
             int year,
@@ -262,7 +262,7 @@ public DateTime(
      * @param hourOfDay  the hour of the day
      * @param minuteOfHour  the minute of the hour
      * @param secondOfMinute  the second of the minute
-     * @param millisOfSecond  the milisecond of the second
+     * @param millisOfSecond  the millisecond of the second
      * @param zone  the time zone, null means default time zone
      */
     public DateTime(
@@ -291,7 +291,7 @@ public DateTime(
      * @param hourOfDay  the hour of the day
      * @param minuteOfHour  the minute of the hour
      * @param secondOfMinute  the second of the minute
-     * @param millisOfSecond  the milisecond of the second
+     * @param millisOfSecond  the millisecond of the second
      * @param chronology  the chronology, null means ISOChronology in default zone
      */
     public DateTime(
diff --git a/JodaTime/src/java/org/joda/time/MutableDateTime.java b/JodaTime/src/java/org/joda/time/MutableDateTime.java
index 6a02734c3..ad86d1e49 100644
--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java
+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java
@@ -241,7 +241,7 @@ public MutableDateTime(Object instant, Chronology chronology) {
      * @param hourOfDay  the hour of the day
      * @param minuteOfHour  the minute of the hour
      * @param secondOfMinute  the second of the minute
-     * @param millisOfSecond  the milisecond of the second
+     * @param millisOfSecond  the millisecond of the second
      */
     public MutableDateTime(
             int year,
@@ -266,7 +266,7 @@ public MutableDateTime(
      * @param hourOfDay  the hour of the day
      * @param minuteOfHour  the minute of the hour
      * @param secondOfMinute  the second of the minute
-     * @param millisOfSecond  the milisecond of the second
+     * @param millisOfSecond  the millisecond of the second
      * @param zone  the time zone, null means default time zone
      */
     public MutableDateTime(
@@ -295,7 +295,7 @@ public MutableDateTime(
      * @param hourOfDay  the hour of the day
      * @param minuteOfHour  the minute of the hour
      * @param secondOfMinute  the second of the minute
-     * @param millisOfSecond  the milisecond of the second
+     * @param millisOfSecond  the millisecond of the second
      * @param chronology  the chronology, null means ISOChronology in default zone
      */
     public MutableDateTime(
@@ -832,7 +832,7 @@ public void setTime(final Object instant) {
      * @param hour  the hour
      * @param minuteOfHour  the minute of the hour
      * @param secondOfMinute  the second of the minute
-     * @param millisOfSecond  the milisecond of the second
+     * @param millisOfSecond  the millisecond of the second
      * @throws IllegalArgumentException if the value is invalid
      */
     public void setTime(
@@ -880,7 +880,7 @@ public void setDateTime(final Object instant) {
      * @param hourOfDay  the hour of the day
      * @param minuteOfHour  the minute of the hour
      * @param secondOfMinute  the second of the minute
-     * @param millisOfSecond  the milisecond of the second
+     * @param millisOfSecond  the millisecond of the second
      * @throws IllegalArgumentException if the value is invalid
      */
     public void setDateTime(
diff --git a/JodaTime/src/java/org/joda/time/ReadWritableDateTime.java b/JodaTime/src/java/org/joda/time/ReadWritableDateTime.java
index 620617425..0e3b134a0 100644
--- a/JodaTime/src/java/org/joda/time/ReadWritableDateTime.java
+++ b/JodaTime/src/java/org/joda/time/ReadWritableDateTime.java
@@ -327,7 +327,7 @@
      * @param hour  the hour
      * @param minuteOfHour  the minute of the hour
      * @param secondOfMinute  the second of the minute
-     * @param millisOfSecond  the milisecond of the second
+     * @param millisOfSecond  the millisecond of the second
      * @throws IllegalArgumentException if the value is invalid
      */
     void setTime(int hour, int minuteOfHour, int secondOfMinute, int millisOfSecond);
@@ -363,7 +363,7 @@
      * @param hourOfDay  the hour of the day
      * @param minuteOfHour  the minute of the hour
      * @param secondOfMinute  the second of the minute
-     * @param millisOfSecond  the milisecond of the second
+     * @param millisOfSecond  the millisecond of the second
      * @throws IllegalArgumentException if the value is invalid
      */
     void setDateTime(
diff --git a/JodaTime/src/java/org/joda/time/ReadWritableInstant.java b/JodaTime/src/java/org/joda/time/ReadWritableInstant.java
index 355678489..509119d21 100644
--- a/JodaTime/src/java/org/joda/time/ReadWritableInstant.java
+++ b/JodaTime/src/java/org/joda/time/ReadWritableInstant.java
@@ -69,7 +69,7 @@
 public interface ReadWritableInstant extends ReadableInstant {
 
     /**
-     * Set the value as the number of miliseconds since
+     * Set the value as the number of milliseconds since
      * the epoch, 1970-01-01T00:00:00Z.
      * 
      * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the
diff --git a/JodaTime/src/java/org/joda/time/TimeOnly.java b/JodaTime/src/java/org/joda/time/TimeOnly.java
index d2a661da4..7182a0698 100644
--- a/JodaTime/src/java/org/joda/time/TimeOnly.java
+++ b/JodaTime/src/java/org/joda/time/TimeOnly.java
@@ -180,7 +180,7 @@ public TimeOnly(Object instant, Chronology chronology) {
      * @param hourOfDay  the hour of the day
      * @param minuteOfHour  the minute of the hour
      * @param secondOfMinute  the second of the minute
-     * @param millisOfSecond  the milisecond of the second
+     * @param millisOfSecond  the millisecond of the second
      */
     public TimeOnly(
             final int hourOfDay,
@@ -203,7 +203,7 @@ public TimeOnly(
      * @param hourOfDay  the hour of the day
      * @param minuteOfHour  the minute of the hour
      * @param secondOfMinute  the second of the minute
-     * @param millisOfSecond  the milisecond of the second
+     * @param millisOfSecond  the millisecond of the second
      * @param chronology  the chronology, null means ISOChronology
      */
     public TimeOnly(

From 2c4229d024d32e4d7bbd3f8efe8cdc6cff84b969 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Mon, 22 Dec 2003 00:00:09 +0000
Subject: [PATCH 052/143] Support object conversion using automatic duration
 type selection.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@57 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/AbstractDuration.java  | 65 ++++++++++++++++++-
 JodaTime/src/java/org/joda/time/Duration.java | 21 ++++++
 .../java/org/joda/time/MutableDuration.java   | 25 ++++++-
 3 files changed, 106 insertions(+), 5 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/AbstractDuration.java b/JodaTime/src/java/org/joda/time/AbstractDuration.java
index 3a701b7d3..714460be1 100644
--- a/JodaTime/src/java/org/joda/time/AbstractDuration.java
+++ b/JodaTime/src/java/org/joda/time/AbstractDuration.java
@@ -108,21 +108,57 @@ private static void checkPrecise(DurationField field, String name) {
     /**
      * Copies another duration to this one.
      *
+     * @param duration duration to copy
+     * @throws IllegalArgumentException if duration is null
      * @throws UnsupportedOperationException if an unsupported field's value is
      * non-zero
      */
     public AbstractDuration(ReadableDuration duration) {
+        super();
         // Only call a private method
         setDuration(iType = duration.getDurationType(), duration);
     }
 
+    /**
+     * Copies another duration to this one.
+     *
+     * @param duration duration to convert
+     * @throws IllegalArgumentException if duration is null
+     * @throws UnsupportedOperationException if an unsupported field's value is
+     * non-zero
+     */
+    public AbstractDuration(Object duration) {
+        super();
+        if (duration instanceof ReadableDuration) {
+            // Only call a private method
+            ReadableDuration rd = (ReadableDuration) duration;
+            setDuration(iType = rd.getDurationType(), rd);
+        } else {
+            DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);
+            DurationType type = converter.getDurationType(duration);
+            if (type.isPrecise() && converter.isPrecise(duration)) {
+                // Only call a private method
+                setTotalMillis(iType = type, converter.getDurationMillis(duration));
+            } else if (this instanceof ReadWritableDuration) {
+                iType = type;
+                converter.setInto((ReadWritableDuration) this, duration);
+            } else {
+                // Only call a private method
+                setDuration(iType = type, new MutableDuration(type, duration));
+            }
+        }
+    }
+
     /**
      * Creates a zero length duration.
      *
      * @param type determines which set of fields this duration supports
+     * @throws IllegalArgumentException if type is null
      */
     public AbstractDuration(DurationType type) {
-        iType = type;
+        super();
+        // Only call a private method
+        setTotalMillis(iType = type, 0);
     }
 
     /**
@@ -130,10 +166,12 @@ public AbstractDuration(DurationType type) {
      *
      * @param type use a different DurationType
      * @param duration duration to copy
+     * @throws IllegalArgumentException if type or duration is null
      * @throws UnsupportedOperationException if an unsupported field's value is
      * non-zero
      */
     public AbstractDuration(DurationType type, ReadableDuration duration) {
+        super();
         // Only call a private method
         setDuration(iType = type, duration);
     }
@@ -143,10 +181,12 @@ public AbstractDuration(DurationType type, ReadableDuration duration) {
      *
      * @param type use a different DurationType
      * @param duration duration to convert
+     * @throws IllegalArgumentException if type or duration is null
      * @throws UnsupportedOperationException if an unsupported field's value is
      * non-zero
      */
     public AbstractDuration(DurationType type, Object duration) {
+        super();
         if (duration instanceof ReadableDuration) {
             // Only call a private method
             setDuration(iType = type, (ReadableDuration) duration);
@@ -155,6 +195,9 @@ public AbstractDuration(DurationType type, Object duration) {
             if (type.isPrecise() && converter.isPrecise(duration)) {
                 // Only call a private method
                 setTotalMillis(iType = type, converter.getDurationMillis(duration));
+            } else if (this instanceof ReadWritableDuration) {
+                iType = type;
+                converter.setInto((ReadWritableDuration) this, duration);
             } else {
                 // Only call a private method
                 setDuration(iType = type, new MutableDuration(type, duration));
@@ -182,12 +225,14 @@ public AbstractDuration(DurationType type, Object duration) {
      * unsupported.
      * @param millis amount of milliseconds in this duration, which must be
      * zero if unsupported.
+     * @throws IllegalArgumentException if type is null
      * @throws UnsupportedOperationException if an unsupported field's value is
      * non-zero
      */
     public AbstractDuration(DurationType type,
                             int years, int months, int weeks, int days,
                             int hours, int minutes, int seconds, int millis) {
+        super();
         // Only call a private method
         setDuration(iType = type, years, months, weeks, days, hours, minutes, seconds, millis);
     }
@@ -198,8 +243,10 @@ public AbstractDuration(DurationType type,
      * @param type determines which set of fields this duration supports
      * @param startInstant interval start, in milliseconds
      * @param endInstant interval end, in milliseconds
+     * @throws IllegalArgumentException if type is null
      */
     public AbstractDuration(DurationType type, long startInstant, long endInstant) {
+        super();
         // Only call a private method
         setTotalMillis(iType = type, startInstant, endInstant);
     }
@@ -210,9 +257,11 @@ public AbstractDuration(DurationType type, long startInstant, long endInstant) {
      * @param type determines which set of fields this duration supports
      * @param startInstant interval start
      * @param endInstant interval end
+     * @throws IllegalArgumentException if type is null
      */
     public AbstractDuration(DurationType type,
                             ReadableInstant startInstant, ReadableInstant  endInstant) {
+        super();
         // Only call a private method
         setTotalMillis(iType = type, startInstant.getMillis(), endInstant.getMillis());
     }
@@ -224,9 +273,11 @@ public AbstractDuration(DurationType type,
      *
      * @param type determines which set of fields this duration supports
      * @param duration  the duration, in milliseconds
+     * @throws IllegalArgumentException if type is null
      * @throws UnsupportedOperationException if any fields are imprecise
      */
     public AbstractDuration(DurationType type, long duration) {
+        super();
         // Only call a private method
         setTotalMillis(iType = type, duration);
     }
@@ -776,6 +827,9 @@ protected void setDuration(int years, int months, int weeks, int days,
     private void setDuration(DurationType type,
                              int years, int months, int weeks, int days,
                              int hours, int minutes, int seconds, int millis) {
+        if (type == null) {
+            throw new IllegalArgumentException("The type must not be null");
+        }
 
         if (years != 0) {
             checkSupport(type.years(), "years");
@@ -835,6 +889,10 @@ protected void setTotalMillis(long startInstant, long endInstant) {
      * @param endInstant interval end, in milliseconds
      */
     private void setTotalMillis(DurationType type, long startInstant, long endInstant) {
+        if (type == null) {
+            throw new IllegalArgumentException("The type must not be null");
+        }
+
         iTotalMillis = endInstant - startInstant;
 
         boolean isPrecise = true;
@@ -923,6 +981,10 @@ protected void setTotalMillis(long duration) {
      * @throws UnsupportedOperationException if any fields are imprecise
      */
     private void setTotalMillis(DurationType type, final long duration) {
+        if (type == null) {
+            throw new IllegalArgumentException("The type must not be null");
+        }
+
         if (duration == 0) {
             iTotalMillis = duration;
             iTotalMillisState = 2;
@@ -1309,4 +1371,3 @@ protected void addMillis(int millis) {
     }
 
 }
-
diff --git a/JodaTime/src/java/org/joda/time/Duration.java b/JodaTime/src/java/org/joda/time/Duration.java
index 22387c897..b97b326e7 100644
--- a/JodaTime/src/java/org/joda/time/Duration.java
+++ b/JodaTime/src/java/org/joda/time/Duration.java
@@ -77,6 +77,8 @@
     /**
      * Copies another duration to this one.
      *
+     * @param duration duration to copy
+     * @throws IllegalArgumentException if duration is null
      * @throws UnsupportedOperationException if an unsupported field's value is
      * non-zero
      */
@@ -84,10 +86,23 @@ public Duration(ReadableDuration duration) {
         super(duration);
     }
 
+    /**
+     * Copies another duration to this one.
+     *
+     * @param duration duration to convert
+     * @throws IllegalArgumentException if duration is null
+     * @throws UnsupportedOperationException if an unsupported field's value is
+     * non-zero
+     */
+    public Duration(Object duration) {
+        super(duration);
+    }
+
     /**
      * Creates a zero length duration.
      *
      * @param type determines which set of fields this duration supports
+     * @throws IllegalArgumentException if type is null
      */
     public Duration(DurationType type) {
         super(type);
@@ -98,6 +113,7 @@ public Duration(DurationType type) {
      *
      * @param type use a different DurationType
      * @param duration duration to copy
+     * @throws IllegalArgumentException if type or duration is null
      * @throws UnsupportedOperationException if an unsupported field's value is
      * non-zero
      */
@@ -110,6 +126,7 @@ public Duration(DurationType type, ReadableDuration duration) {
      *
      * @param type use a different DurationType
      * @param duration duration to convert
+     * @throws IllegalArgumentException if type or duration is null
      * @throws UnsupportedOperationException if an unsupported field's value is
      * non-zero
      */
@@ -137,6 +154,7 @@ public Duration(DurationType type, Object duration) {
      * unsupported.
      * @param millis amount of milliseconds in this duration, which must be
      * zero if unsupported.
+     * @throws IllegalArgumentException if type is null
      * @throws UnsupportedOperationException if an unsupported field's value is
      * non-zero
      */
@@ -152,6 +170,7 @@ public Duration(DurationType type,
      * @param type determines which set of fields this duration supports
      * @param startInstant interval start, in milliseconds
      * @param endInstant interval end, in milliseconds
+     * @throws IllegalArgumentException if type is null
      */
     public Duration(DurationType type, long startInstant, long endInstant) {
         super(type, startInstant, endInstant);
@@ -163,6 +182,7 @@ public Duration(DurationType type, long startInstant, long endInstant) {
      * @param type determines which set of fields this duration supports
      * @param startInstant interval start
      * @param endInstant interval end
+     * @throws IllegalArgumentException if type is null
      */
     public Duration(DurationType type,
                     ReadableInstant startInstant, ReadableInstant endInstant) {
@@ -176,6 +196,7 @@ public Duration(DurationType type,
      *
      * @param type determines which set of fields this duration supports
      * @param duration  the duration, in milliseconds
+     * @throws IllegalArgumentException if type is null
      * @throws UnsupportedOperationException if any fields are imprecise
      */
     public Duration(DurationType type, long duration) {
diff --git a/JodaTime/src/java/org/joda/time/MutableDuration.java b/JodaTime/src/java/org/joda/time/MutableDuration.java
index 67e24d3a2..43a166e56 100644
--- a/JodaTime/src/java/org/joda/time/MutableDuration.java
+++ b/JodaTime/src/java/org/joda/time/MutableDuration.java
@@ -77,6 +77,8 @@
     /**
      * Copies another duration to this one.
      *
+     * @param duration duration to copy
+     * @throws IllegalArgumentException if duration is null
      * @throws UnsupportedOperationException if an unsupported field's value is
      * non-zero
      */
@@ -84,10 +86,23 @@ public MutableDuration(ReadableDuration duration) {
         super(duration);
     }
 
+    /**
+     * Copies another duration to this one.
+     *
+     * @param duration duration to convert
+     * @throws IllegalArgumentException if duration is null
+     * @throws UnsupportedOperationException if an unsupported field's value is
+     * non-zero
+     */
+    public MutableDuration(Object duration) {
+        super(duration);
+    }
+
     /**
      * Creates a zero length duration.
      *
      * @param type determines which set of fields this duration supports
+     * @throws IllegalArgumentException if type is null
      */
     public MutableDuration(DurationType type) {
         super(type);
@@ -98,6 +113,7 @@ public MutableDuration(DurationType type) {
      *
      * @param type use a different DurationType
      * @param duration duration to copy
+     * @throws IllegalArgumentException if type or duration is null
      * @throws UnsupportedOperationException if an unsupported field's value is
      * non-zero
      */
@@ -110,13 +126,12 @@ public MutableDuration(DurationType type, ReadableDuration duration) {
      *
      * @param type use a different DurationType
      * @param duration duration to convert
+     * @throws IllegalArgumentException if type or duration is null
      * @throws UnsupportedOperationException if an unsupported field's value is
      * non-zero
      */
     public MutableDuration(DurationType type, Object duration) {
-        super(type);
-        DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);
-        converter.setInto(this, duration);
+        super(type, duration);
     }
 
     /**
@@ -139,6 +154,7 @@ public MutableDuration(DurationType type, Object duration) {
      * unsupported.
      * @param millis amount of milliseconds in this duration, which must be
      * zero if unsupported.
+     * @throws IllegalArgumentException if type is null
      * @throws UnsupportedOperationException if an unsupported field's value is
      * non-zero
      */
@@ -154,6 +170,7 @@ public MutableDuration(DurationType type,
      * @param type determines which set of fields this duration supports
      * @param startInstant interval start, in milliseconds
      * @param endInstant interval end, in milliseconds
+     * @throws IllegalArgumentException if type is null
      */
     public MutableDuration(DurationType type, long startInstant, long endInstant) {
         super(type, startInstant, endInstant);
@@ -165,6 +182,7 @@ public MutableDuration(DurationType type, long startInstant, long endInstant) {
      * @param type determines which set of fields this duration supports
      * @param startInstant interval start
      * @param endInstant interval end
+     * @throws IllegalArgumentException if type is null
      */
     public MutableDuration(DurationType type,
                            ReadableInstant startInstant, ReadableInstant endInstant) {
@@ -178,6 +196,7 @@ public MutableDuration(DurationType type,
      *
      * @param type determines which set of fields this duration supports
      * @param duration  the duration, in milliseconds
+     * @throws IllegalArgumentException if type or duration is null
      * @throws UnsupportedOperationException if any fields are imprecise
      */
     public MutableDuration(DurationType type, long duration) {

From db2191ad089d5ed74d31bf3bf1cb7ab18612434d Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Mon, 22 Dec 2003 00:00:53 +0000
Subject: [PATCH 053/143] Added a few new types and dropped ISOYearMonth.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@58 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/DurationType.java  | 182 ++++++++++++++----
 1 file changed, 145 insertions(+), 37 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/DurationType.java b/JodaTime/src/java/org/joda/time/DurationType.java
index cd07f3b9a..5f207664d 100644
--- a/JodaTime/src/java/org/joda/time/DurationType.java
+++ b/JodaTime/src/java/org/joda/time/DurationType.java
@@ -55,6 +55,7 @@
 
 import java.io.Serializable;
 import org.joda.time.chrono.MillisDurationField;
+import org.joda.time.chrono.PreciseDurationField;
 import org.joda.time.chrono.ScaledDurationField;
 import org.joda.time.chrono.UnsupportedDurationField;
 import org.joda.time.chrono.iso.ISOChronology;
@@ -69,8 +70,11 @@
  * <li>DayHour - the duration is expressed in terms of days, hours, minutes, seconds
  *  and milliseconds
  * <li>YearMonth - the duration is expressed using all fields except weeks
- * <li>ISOYearMonth - as YearMonth, but with the month fixed at 30 days
  * <li>YearWeek - the duration is expressed using all fields except months
+ * <li>AverageYearMonth - as YearMonth, but years and months have fixed average lengths
+ * <li>PreciseYearMonth - as YearMonth, but years are fixed at 365 days,
+ *  and months are fixed at 30 days
+ * <li>PreciseYearWeek - as YearWeek, but years are fixed at 365 days
  * </ul>
  *
  * <p>
@@ -177,8 +181,8 @@ public static DurationType getYearMonthType(Chronology chrono) {
      * Returns a DurationType of:
      *
      * <ul>
-     * <li>years
-     * <li>months (fixed at 30 days)
+     * <li>years (weekyears)
+     * <li>weeks
      * <li>days
      * <li>hours
      * <li>minutes
@@ -186,16 +190,16 @@ public static DurationType getYearMonthType(Chronology chrono) {
      * <li>milliseconds
      * </ul>
      */
-    public static DurationType getISOYearMonthType() {
-        return getISOYearMonthType(null);
+    public static DurationType getYearWeekType() {
+        return getYearWeekType(null);
     }
 
     /**
      * Returns a DurationType of:
      *
      * <ul>
-     * <li>years
-     * <li>months (fixed at 30 days)
+     * <li>years (weekyears)
+     * <li>weeks
      * <li>days
      * <li>hours
      * <li>minutes
@@ -209,19 +213,19 @@ public static DurationType getISOYearMonthType() {
      *
      * @param chrono Chronology to use for calculations.
      */
-    public static DurationType getISOYearMonthType(Chronology chrono) {
+    public static DurationType getYearWeekType(Chronology chrono) {
         if (chrono == null) {
             chrono = ISOChronology.getInstanceUTC();
         }
-        return new ISOYearMonthType(chrono);
+        return new YearWeekType(chrono);
     }
 
     /**
-     * Returns a DurationType of:
+     * Returns a precise DurationType of:
      *
      * <ul>
-     * <li>years (weekyears)
-     * <li>weeks
+     * <li>years (fixed at 365.2425 days)
+     * <li>months (fixed at 30.436875 days)
      * <li>days
      * <li>hours
      * <li>minutes
@@ -229,16 +233,16 @@ public static DurationType getISOYearMonthType(Chronology chrono) {
      * <li>milliseconds
      * </ul>
      */
-    public static DurationType getYearWeekType() {
-        return getYearWeekType(null);
+    public static DurationType getAverageYearMonthType() {
+        return new AverageYearMonthType(ISOChronology.getInstanceUTC());
     }
 
     /**
-     * Returns a DurationType of:
+     * Returns a precise DurationType of:
      *
      * <ul>
-     * <li>years (weekyears)
-     * <li>weeks
+     * <li>years (fixed to chronology's average year)
+     * <li>months (fixed to chronology's average month)
      * <li>days
      * <li>hours
      * <li>minutes
@@ -251,12 +255,52 @@ public static DurationType getYearWeekType() {
      * be UTC or have fixed offsets.
      *
      * @param chrono Chronology to use for calculations.
+     * @throws IllegalArgumentException if chronology produces an imprecise duration type
      */
-    public static DurationType getYearWeekType(Chronology chrono) {
-        if (chrono == null) {
-            chrono = ISOChronology.getInstanceUTC();
+    public static DurationType getAverageYearMonthType(Chronology chrono) {
+        if (chrono == null || chrono.equals(ISOChronology.getInstanceUTC())) {
+            return getAverageYearMonthType();
         }
-        return new YearWeekType(chrono);
+        DurationType type = new AverageYearMonthType(chrono);
+        if (!type.isPrecise()) {
+            throw new IllegalArgumentException
+                ("Chronology produced an imprecise duration type");
+        }
+        return type;
+    }
+
+    /**
+     * Returns a precise DurationType of:
+     *
+     * <ul>
+     * <li>years (fixed at 365 days)
+     * <li>months (fixed at 30 days)
+     * <li>days
+     * <li>hours
+     * <li>minutes
+     * <li>seconds
+     * <li>milliseconds
+     * </ul>
+     */
+    public static DurationType getPreciseYearMonthType() {
+        return new PreciseYearMonthType(ISOChronology.getInstanceUTC());
+    }
+
+    /**
+     * Returns a precise DurationType of:
+     *
+     * <ul>
+     * <li>years (fixed at 365 days)
+     * <li>weeks
+     * <li>days
+     * <li>hours
+     * <li>minutes
+     * <li>seconds
+     * <li>milliseconds
+     * </ul>
+     */
+    public static DurationType getPreciseYearWeekType() {
+        return new PreciseYearWeekType(ISOChronology.getInstanceUTC());
     }
 
     protected DurationType() {
@@ -591,21 +635,85 @@ private Object readResolve() {
         }
     }
 
-    private static final class ISOYearMonthType extends DayHourType {
-        static final long serialVersionUID = 1203161678926193794L;
+    private static final class YearWeekType extends DayHourType {
+        static final long serialVersionUID = 1347170237843447098L;
 
+        public YearWeekType(Chronology chrono) {
+            super(chrono);
+        }
+
+        public DurationType withChronology(Chronology chrono) {
+            if (chrono == iChronology) {
+                return this;
+            }
+            return new YearWeekType(iChronology);
+        }
+
+        public boolean isPrecise() {
+            return years().isPrecise()
+                && weeks().isPrecise()
+                && super.isPrecise();
+        }
+
+        public DurationField years() {
+            return iChronology.weekyears();
+        }
+
+        public DurationField weeks() {
+            return iChronology.weeks();
+        }
+
+        private Object readResolve() {
+            return getYearWeekType(iChronology);
+        }
+    }
+
+    private static final class AverageYearMonthType extends DayHourType {
+        static final long serialVersionUID = -1629017135050918461L;
+
+        private final DurationField iYears;
         private final DurationField iMonths;
         
-        public ISOYearMonthType(Chronology chrono) {
+        public AverageYearMonthType(Chronology chrono) {
             super(chrono);
-            iMonths = new ScaledDurationField(chrono.days(), "ISOMonths", 30);
+            iYears = new PreciseDurationField("AverageYears", chrono.years().getUnitMillis());
+            iMonths = new PreciseDurationField("AverageMonths", chrono.months().getUnitMillis());
         }
 
         public DurationType withChronology(Chronology chrono) {
             if (chrono == iChronology) {
                 return this;
             }
-            return new ISOYearMonthType(iChronology);
+            return getAverageYearMonthType(chrono);
+        }
+
+        public DurationField years() {
+            return iYears;
+        }
+
+        public DurationField months() {
+            return iMonths;
+        }
+
+        private Object readResolve() {
+            return getAverageYearMonthType(iChronology);
+        }
+    }
+
+    private static final class PreciseYearMonthType extends DayHourType {
+        static final long serialVersionUID = 1203161678926193794L;
+
+        private final DurationField iYears;
+        private final DurationField iMonths;
+        
+        public PreciseYearMonthType(Chronology chrono) {
+            super(chrono);
+            iYears = new ScaledDurationField(chrono.days(), "PreciseYears", 365);
+            iMonths = new ScaledDurationField(chrono.days(), "PreciseMonths", 30);
+        }
+
+        public DurationType withChronology(Chronology chrono) {
+            return this;
         }
 
         public boolean isPrecise() {
@@ -615,7 +723,7 @@ public boolean isPrecise() {
         }
 
         public DurationField years() {
-            return iChronology.years();
+            return iYears;
         }
 
         public DurationField months() {
@@ -623,22 +731,22 @@ public DurationField months() {
         }
 
         private Object readResolve() {
-            return getISOYearMonthType(iChronology);
+            return getPreciseYearMonthType();
         }
     }
 
-    private static final class YearWeekType extends DayHourType {
-        static final long serialVersionUID = 1347170237843447098L;
+    private static final class PreciseYearWeekType extends DayHourType {
+        static final long serialVersionUID = -2040324323318740267L;
 
-        public YearWeekType(Chronology chrono) {
+        private final DurationField iYears;
+        
+        public PreciseYearWeekType(Chronology chrono) {
             super(chrono);
+            iYears = new ScaledDurationField(chrono.days(), "PreciseYears", 365);
         }
 
         public DurationType withChronology(Chronology chrono) {
-            if (chrono == iChronology) {
-                return this;
-            }
-            return new YearWeekType(iChronology);
+            return this;
         }
 
         public boolean isPrecise() {
@@ -648,7 +756,7 @@ public boolean isPrecise() {
         }
 
         public DurationField years() {
-            return iChronology.weekyears();
+            return iYears;
         }
 
         public DurationField weeks() {
@@ -656,7 +764,7 @@ public DurationField weeks() {
         }
 
         private Object readResolve() {
-            return getYearWeekType(iChronology);
+            return getPreciseYearWeekType();
         }
     }
 

From 2fb5126755cf8c44b793dde9a751d5b8aa151e8e Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Mon, 22 Dec 2003 00:02:27 +0000
Subject: [PATCH 054/143] Support setting duration.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@59 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/time/ReadWritableInterval.java   | 29 +++++++++++++++++++
 1 file changed, 29 insertions(+)

diff --git a/JodaTime/src/java/org/joda/time/ReadWritableInterval.java b/JodaTime/src/java/org/joda/time/ReadWritableInterval.java
index a976ee2cb..234313da9 100644
--- a/JodaTime/src/java/org/joda/time/ReadWritableInterval.java
+++ b/JodaTime/src/java/org/joda/time/ReadWritableInterval.java
@@ -57,6 +57,7 @@
  * Writable interface for an interval.
  *
  * @author Stephen Colebourne
+ * @author Brian S O'Neill
  * @since 1.0
  */
 public interface ReadWritableInterval extends ReadableInterval {
@@ -91,4 +92,32 @@
      */
     void setEndInstant(ReadableInstant instant);
 
+    /**
+     * Sets the duration of this time interval, preserving the start instant.
+     *
+     * @param millisDuration  new duration for interval
+     */
+    void setDurationAfterStart(long millisDuration);
+
+    /**
+     * Sets the duration of this time interval, preserving the start instant.
+     *
+     * @param duration  new duration for interval
+     */
+    void setDurationAfterStart(ReadableDuration duration);
+
+    /**
+     * Sets the duration of this time interval, preserving the end instant.
+     *
+     * @param millisDuration  new duration for interval
+     */
+    void setDurationBeforeEnd(long millisDuration);
+
+    /**
+     * Sets the duration of this time interval, preserving the end instant.
+     *
+     * @param duration  new duration for interval
+     */
+    void setDurationBeforeEnd(ReadableDuration duration);
+
 }

From 25aa041404f53d3525e35c891fcca2c4c7764296 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Mon, 22 Dec 2003 00:02:45 +0000
Subject: [PATCH 055/143] Support object onversion.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@60 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/AbstractInterval.java  | 65 ++++++++++++++-----
 JodaTime/src/java/org/joda/time/Interval.java | 31 ++++-----
 2 files changed, 62 insertions(+), 34 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/AbstractInterval.java b/JodaTime/src/java/org/joda/time/AbstractInterval.java
index 740cdfeae..f6b08e9ff 100644
--- a/JodaTime/src/java/org/joda/time/AbstractInterval.java
+++ b/JodaTime/src/java/org/joda/time/AbstractInterval.java
@@ -54,6 +54,8 @@
 package org.joda.time;
 
 import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.convert.ConverterManager;
+import org.joda.time.convert.IntervalConverter;
 import org.joda.time.format.DateTimePrinter;
 import org.joda.time.format.ISODateTimeFormat;
 
@@ -63,6 +65,8 @@
  * This class should generally not be used directly by API users. The 
  * {@link ReadableInterval} interface should be used when different 
  * kinds of intervals are to be referenced.
+ * <p>
+ * AbstractInterval subclasses may be mutable and not thread-safe.
  *
  * @author Brian S O'Neill
  * @author Stephen Colebourne
@@ -97,6 +101,31 @@ public AbstractInterval(ReadableInterval interval) {
         iEndMillis = interval.getEndMillis();
     }
     
+    /**
+     * Constructs a time interval as a copy of another.
+     * 
+     * @param interval the time interval to convert
+     * @throws IllegalArgumentException if the interval is null
+     */
+    public AbstractInterval(Object interval) {
+        super();
+        if (interval instanceof ReadableInterval) {
+            ReadableInterval ri = (ReadableInterval) interval;
+            iStartMillis = ri.getStartMillis();
+            iEndMillis = ri.getEndMillis();
+        } else {
+            IntervalConverter converter = ConverterManager.getInstance().getIntervalConverter(interval);
+            if (this instanceof ReadWritableInterval) {
+                converter.setInto((ReadWritableInterval) this, interval);
+            } else {
+                MutableInterval mi = new MutableInterval(0, 0);
+                converter.setInto(mi, interval);
+                iStartMillis = mi.getStartMillis();
+                iEndMillis = mi.getEndMillis();
+            }
+        }
+    }
+
     /**
      * Constructs an interval from a start and end instant.
      * 
@@ -141,6 +170,7 @@ public AbstractInterval(ReadableInstant start, ReadableInstant end) {
      * 
      * @param start  start of this interval
      * @param duration  duration of this interval
+     * @throws IllegalArgumentException if start or duration is null
      */
     public AbstractInterval(ReadableInstant start, ReadableDuration duration) {
         super();
@@ -162,6 +192,7 @@ public AbstractInterval(ReadableInstant start, ReadableDuration duration) {
      * 
      * @param duration duration of this interval
      * @param end end of this interval
+     * @throws IllegalArgumentException if duration or end is null
      */
     public AbstractInterval(ReadableDuration duration, ReadableInstant end) {
         super();
@@ -185,7 +216,7 @@ public AbstractInterval(ReadableDuration duration, ReadableInstant end) {
      *
      * @return the start of the interval
      */
-    public long getStartMillis() {
+    public final long getStartMillis() {
         return iStartMillis;
     }
 
@@ -194,7 +225,7 @@ public long getStartMillis() {
      *
      * @return the start of the time interval
      */
-    public Instant getStartInstant() {
+    public final Instant getStartInstant() {
         if (iStartInstant == null) {
             iStartInstant = new Instant(getStartMillis());
         }
@@ -207,7 +238,7 @@ public Instant getStartInstant() {
      *
      * @return the start of the interval
      */
-    public long getEndMillis() {
+    public final long getEndMillis() {
         return iEndMillis;
     }
 
@@ -216,7 +247,7 @@ public long getEndMillis() {
      *
      * @return the end of the time interval
      */
-    public Instant getEndInstant() {
+    public final Instant getEndInstant() {
         if (iEndInstant == null) {
             iEndInstant = new Instant(getEndMillis());
         }
@@ -231,7 +262,7 @@ public Instant getEndInstant() {
      *
      * @return the duration of the time interval in milliseconds
      */
-    public long getDurationMillis() {
+    public final long getDurationMillis() {
         return (getEndMillis() - getStartMillis());
     }
 
@@ -243,9 +274,9 @@ public long getDurationMillis() {
      *
      * @return the duration of the time interval
      */
-    public Duration getDuration() {
+    public final Duration getDuration() {
         if (iDuration == null) {
-            iDuration = new Duration(DurationType.getDayHourType(),
+            iDuration = new Duration(DurationType.getPreciseYearMonthType(),
                                      getEndMillis() - getStartMillis());
         }
         return iDuration;
@@ -259,7 +290,7 @@ public Duration getDuration() {
      *  millisecond instant from 1970-01-01T00:00:00Z
      * @return true if this time interval contains the millisecond
      */
-    public boolean contains(long millisInstant) {
+    public final boolean contains(long millisInstant) {
         return (millisInstant >= getStartMillis() && millisInstant <= getEndMillis());
     }
     
@@ -270,7 +301,7 @@ public boolean contains(long millisInstant) {
      * @return true if this time interval contains the instant
      * @throws IllegalArgumentException if the instant is null
      */
-    public boolean contains(ReadableInstant instant) {
+    public final boolean contains(ReadableInstant instant) {
         if (instant == null) {
             throw new IllegalArgumentException("The instant must not be null");
         }
@@ -284,7 +315,7 @@ public boolean contains(ReadableInstant instant) {
      * @return true if this interval contains the time interval
      * @throws IllegalArgumentException if the interval is null
      */
-    public boolean contains(ReadableInterval interval) {
+    public final boolean contains(ReadableInterval interval) {
         if (interval == null) {
             throw new IllegalArgumentException("The time interval must not be null");
         }
@@ -304,7 +335,7 @@ public boolean contains(ReadableInterval interval) {
      * @return true if the time intervals overlap
      * @throws IllegalArgumentException if the interval is null
      */
-    public boolean overlaps(ReadableInterval interval) {
+    public final boolean overlaps(ReadableInterval interval) {
         if (interval == null) {
             throw new IllegalArgumentException("The time interval must not be null");
         }
@@ -323,7 +354,7 @@ public boolean overlaps(ReadableInterval interval) {
      *  millisecond instant from 1970-01-01T00:00:00Z
      * @return true if this time interval is before the instant
      */
-    public boolean isBefore(long millisInstant) {
+    public final boolean isBefore(long millisInstant) {
         return (getStartMillis() < millisInstant && getEndMillis() < millisInstant);
     }
     
@@ -334,7 +365,7 @@ public boolean isBefore(long millisInstant) {
      * @return true if this time interval is before the instant
      * @throws IllegalArgumentException if the instant is null
      */
-    public boolean isBefore(ReadableInstant instant) {
+    public final boolean isBefore(ReadableInstant instant) {
         if (instant == null) {
             throw new IllegalArgumentException("The instant must not be null");
         }
@@ -348,7 +379,7 @@ public boolean isBefore(ReadableInstant instant) {
      *  millisecond instant from 1970-01-01T00:00:00Z
      * @return true if this time interval is after the instant
      */
-    public boolean isAfter(long millisInstant) {
+    public final boolean isAfter(long millisInstant) {
         return (getStartMillis() > millisInstant && getEndMillis() > millisInstant);
     }
     
@@ -359,7 +390,7 @@ public boolean isAfter(long millisInstant) {
      * @return true if this time interval is after the instant
      * @throws IllegalArgumentException if the instant is null
      */
-    public boolean isAfter(ReadableInstant instant) {
+    public final boolean isAfter(ReadableInstant instant) {
         if (instant == null) {
             throw new IllegalArgumentException("The instant must not be null");
         }
@@ -372,7 +403,7 @@ public boolean isAfter(ReadableInstant instant) {
      * 
      * @return an immutable interval object
      */
-    public Interval toInterval() {
+    public final Interval toInterval() {
         if (this instanceof Interval) {
             return (Interval) this;
         }
@@ -384,7 +415,7 @@ public Interval toInterval() {
      * 
      * @return a mutable interval object
      */
-    public MutableInterval toMutableInterval() {
+    public final MutableInterval toMutableInterval() {
         return new MutableInterval(this);
     }
 
diff --git a/JodaTime/src/java/org/joda/time/Interval.java b/JodaTime/src/java/org/joda/time/Interval.java
index 62ce2b33e..49f58490a 100644
--- a/JodaTime/src/java/org/joda/time/Interval.java
+++ b/JodaTime/src/java/org/joda/time/Interval.java
@@ -61,6 +61,8 @@
  * class. The duration of the time interval is always a precise amount of
  * milliseconds even if a variable length duration was passed into the
  * constructor.
+ * <p>
+ * Interval is thread-safe and immutable.
  *
  * @author Brian S O'Neill
  * @author Sean Geoghegan
@@ -82,6 +84,16 @@ public Interval(ReadableInterval interval) {
         super(interval);
     }
 
+    /**
+     * Constructs a time interval as a copy of another.
+     * 
+     * @param interval  the time interval to convert
+     * @throws IllegalArgumentException if the interval is null
+     */
+    public Interval(Object interval) {
+        super(interval);
+    }
+
     /**
      * Constructs an interval from a start and end instant.
      * 
@@ -110,6 +122,7 @@ public Interval(ReadableInstant start, ReadableInstant end) {
      * 
      * @param start  start of this interval
      * @param duration  duration of this interval
+     * @throws IllegalArgumentException if start or duration is null
      */
     public Interval(ReadableInstant start, ReadableDuration duration) {
         super(start, duration);
@@ -120,28 +133,12 @@ public Interval(ReadableInstant start, ReadableDuration duration) {
      * 
      * @param duration duration of this interval
      * @param end end of this interval
+     * @throws IllegalArgumentException if duration or end is null
      */
     public Interval(ReadableDuration duration, ReadableInstant end) {
         super(duration, end);
     }
 
-    /** 
-     * Creates new TimePeriod.
-     *
-     * TimePeriod is created from an ISO formatted
-     * TimePeriod string. Only accepts strings in the
-     * ISO_STANDARD_BASIC_FORMAT pattern.
-     *
-     * @param period an ISO interval string
-     */
-    /* TODO
-    public Interval(String period) throws ParseException {
-        Interval temp = (Interval)TimePeriodFormat.ISO_STANDARD_BASIC_FORMAT.parseObject(period);
-        iStartMillis = temp.iStartMillis;
-        iEndMillis = temp.iEndMillis;
-    }
-    */
-
     /**
      * Overridden to do nothing, ensuring this class and all subclasses are
      * immutable.

From cf252ecc2361b0deeb93dd074dbd077ffed16d4e Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Mon, 22 Dec 2003 00:03:04 +0000
Subject: [PATCH 056/143] Support object onversion; define duration setting
 methods

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@61 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/MutableInterval.java   | 71 +++++++++++++++----
 1 file changed, 58 insertions(+), 13 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/MutableInterval.java b/JodaTime/src/java/org/joda/time/MutableInterval.java
index 7e49df9fb..efc48446a 100644
--- a/JodaTime/src/java/org/joda/time/MutableInterval.java
+++ b/JodaTime/src/java/org/joda/time/MutableInterval.java
@@ -61,8 +61,12 @@
  * <p>
  * If performing significant calculations on an interval, it may be faster to
  * convert an Interval object to a MutableInterval one.
+ * <p>
+ * MutableInterval is mutable and not thread-safe, unless concurrent threads
+ * are not invoking mutator methods.
  *
  * @author Stephen Colebourne
+ * @author Brian S O'Neill
  * @since 1.0
  */
 public final class MutableInterval extends AbstractInterval
@@ -80,6 +84,16 @@ public MutableInterval(ReadableInterval interval) {
         super(interval);
     }
     
+    /**
+     * Constructs a time interval as a copy of another.
+     * 
+     * @param interval the time interval to convert
+     * @throws IllegalArgumentException if the interval is null
+     */
+    public MutableInterval(Object interval) {
+        super(interval);
+    }
+
     /**
      * Constructs an interval from a start and end instant.
      * 
@@ -108,6 +122,7 @@ public MutableInterval(ReadableInstant start, ReadableInstant end) {
      * 
      * @param start  start of this interval
      * @param duration  duration of this interval
+     * @throws IllegalArgumentException if start or duration is null
      */
     public MutableInterval(ReadableInstant start, ReadableDuration duration) {
         super(start, duration);
@@ -118,24 +133,12 @@ public MutableInterval(ReadableInstant start, ReadableDuration duration) {
      * 
      * @param duration duration of this interval
      * @param end end of this interval
+     * @throws IllegalArgumentException if duration or end is null
      */
     public MutableInterval(ReadableDuration duration, ReadableInstant end) {
         super(duration, end);
     }
     
-    /**
-     * Constructors an interval from an ISO format string.
-     *
-     * @param intervalStr  an ISO interval string
-     */
-    /* TODO
-    public MutableInterval(String intervalStr) throws ParseException {
-        Interval interval = (Interval) TimePeriodFormat.ISO_STANDARD_BASIC_FORMAT.parseObject(intervalStr);
-        iStartMillis = interval.getStartMillis();
-        iEndMillis = interval.getEndMillis();
-    }
-    */
-    
     //-----------------------------------------------------------------------
     /**
      * Sets the start of this time interval.
@@ -181,4 +184,46 @@ public void setEndInstant(ReadableInstant instant) {
         super.setEndMillis(instant.getMillis());
     }
 
+    /**
+     * Sets the duration of this time interval, preserving the start instant.
+     *
+     * @param millisDuration  new duration for interval
+     */
+    public void setDurationAfterStart(long millisDuration) {
+        super.setEndMillis(getStartMillis() + millisDuration);
+    }
+
+    /**
+     * Sets the duration of this time interval, preserving the start instant.
+     *
+     * @param duration  new duration for interval
+     */
+    public void setDurationAfterStart(ReadableDuration duration) {
+        if (duration == null) {
+            throw new IllegalArgumentException("The duration must not be null");
+        }
+        super.setEndMillis(duration.addTo(getStartMillis(), 1));
+    }
+
+    /**
+     * Sets the duration of this time interval, preserving the end instant.
+     *
+     * @param millisDuration  new duration for interval
+     */
+    public void setDurationBeforeEnd(long millisDuration) {
+        super.setStartMillis(getEndMillis() - millisDuration);
+    }
+
+    /**
+     * Sets the duration of this time interval, preserving the end instant.
+     *
+     * @param duration  new duration for interval
+     */
+    public void setDurationBeforeEnd(ReadableDuration duration) {
+        if (duration == null) {
+            throw new IllegalArgumentException("The duration must not be null");
+        }
+        super.setStartMillis(duration.addTo(getEndMillis(), -1));
+    }
+
 }

From 3bce06852e59d14ae649da30a2cabee50ec76a75 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Mon, 22 Dec 2003 00:03:31 +0000
Subject: [PATCH 057/143] Interval formatting supported.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@62 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/ToDo.txt | 1 -
 1 file changed, 1 deletion(-)

diff --git a/JodaTime/ToDo.txt b/JodaTime/ToDo.txt
index d6371bd79..f4c190cab 100644
--- a/JodaTime/ToDo.txt
+++ b/JodaTime/ToDo.txt
@@ -7,7 +7,6 @@ Duration:
  Write tests
  
 Interval:
- Write formatters/parsers
  Write tests
  
 Tests:

From c667a2051abb4f6499d2a980283f036ec5268e81 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Mon, 22 Dec 2003 00:09:26 +0000
Subject: [PATCH 058/143] Indent with spaces, not tabs.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@63 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/tz/NameProvider.java   | 34 +++++++++----------
 1 file changed, 17 insertions(+), 17 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/tz/NameProvider.java b/JodaTime/src/java/org/joda/time/tz/NameProvider.java
index 1a6e6c6fb..248f17e91 100644
--- a/JodaTime/src/java/org/joda/time/tz/NameProvider.java
+++ b/JodaTime/src/java/org/joda/time/tz/NameProvider.java
@@ -62,21 +62,21 @@
  * @author Brian S O'Neill
  */
 public interface NameProvider {
-	/**
-	 * Returns a localized short name, or null if not found.
-	 *
-	 * @param locale locale to use for selecting name set
-	 * @param id time zone id
-	 * @param nameKey time zone name key
-	 */
-	String getShortName(Locale locale, String id, String nameKey);
-	
-	/**
-	 * Returns a localized name, or null if not found.
-	 *
-	 * @param locale locale to use for selecting name set
-	 * @param id time zone id
-	 * @param nameKey time zone name key
-	 */
-	String getName(Locale locale, String id, String nameKey);
+    /**
+     * Returns a localized short name, or null if not found.
+     *
+     * @param locale locale to use for selecting name set
+     * @param id time zone id
+     * @param nameKey time zone name key
+     */
+    String getShortName(Locale locale, String id, String nameKey);
+    
+    /**
+     * Returns a localized name, or null if not found.
+     *
+     * @param locale locale to use for selecting name set
+     * @param id time zone id
+     * @param nameKey time zone name key
+     */
+    String getName(Locale locale, String id, String nameKey);
 }

From 6291c8bf8789b5fddcbc35af8dac54eb18bad993 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Tue, 23 Dec 2003 03:35:33 +0000
Subject: [PATCH 059/143] Save original duration object if precise.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@64 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/AbstractInterval.java  | 60 ++++++++++++++++++-
 JodaTime/src/java/org/joda/time/Interval.java | 17 +++++-
 .../java/org/joda/time/MutableInterval.java   | 10 +---
 3 files changed, 75 insertions(+), 12 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/AbstractInterval.java b/JodaTime/src/java/org/joda/time/AbstractInterval.java
index f6b08e9ff..6339df744 100644
--- a/JodaTime/src/java/org/joda/time/AbstractInterval.java
+++ b/JodaTime/src/java/org/joda/time/AbstractInterval.java
@@ -79,12 +79,13 @@
     /** The end of the period */
     private long iEndMillis;
 
+    /** The duration, which may be lazily set */
+    private Duration iDuration;
+
     /** Cache the start instant */
     private transient Instant iStartInstant;
     /** Cache the end instant */
     private transient Instant iEndInstant;
-    /** Cache the duration */
-    private transient Duration iDuration;
     
     /**
      * Constructs a time interval as a copy of another.
@@ -99,6 +100,10 @@ public AbstractInterval(ReadableInterval interval) {
         }
         iStartMillis = interval.getStartMillis();
         iEndMillis = interval.getEndMillis();
+        Duration duration = interval.getDuration();
+        if (duration != null && duration.isPrecise()) {
+            iDuration = duration;
+        }
     }
     
     /**
@@ -109,21 +114,28 @@ public AbstractInterval(ReadableInterval interval) {
      */
     public AbstractInterval(Object interval) {
         super();
+        Duration duration;
         if (interval instanceof ReadableInterval) {
             ReadableInterval ri = (ReadableInterval) interval;
             iStartMillis = ri.getStartMillis();
             iEndMillis = ri.getEndMillis();
+            duration = ri.getDuration();
         } else {
             IntervalConverter converter = ConverterManager.getInstance().getIntervalConverter(interval);
             if (this instanceof ReadWritableInterval) {
                 converter.setInto((ReadWritableInterval) this, interval);
+                duration = null;
             } else {
                 MutableInterval mi = new MutableInterval(0, 0);
                 converter.setInto(mi, interval);
                 iStartMillis = mi.getStartMillis();
                 iEndMillis = mi.getEndMillis();
+                duration = mi.getDuration();
             }
         }
+        if (duration != null && duration.isPrecise()) {
+            iDuration = duration;
+        }
     }
 
     /**
@@ -185,6 +197,9 @@ public AbstractInterval(ReadableInstant start, ReadableDuration duration) {
             iStartInstant = (Instant) start;
         }
         iEndMillis = duration.addTo((ReadableInstant) start, 1).getMillis();
+        if (duration.isPrecise()) {
+            iDuration = duration.toDuration();
+        }
     }
     
     /**
@@ -207,6 +222,9 @@ public AbstractInterval(ReadableDuration duration, ReadableInstant end) {
             iEndInstant = (Instant) end;
         }
         iStartMillis = duration.addTo((ReadableInstant) end, -1).getMillis();
+        if (duration.isPrecise()) {
+            iDuration = duration.toDuration();
+        }
     }
 
     //-----------------------------------------------------------------------
@@ -504,4 +522,42 @@ protected void setEndMillis(long millisInstant) {
         iDuration = null;
     }
 
+    /**
+     * Sets the duration of this time interval, preserving the start instant.
+     * <p>
+     * Subclasses that wish to be immutable should override this method with an
+     * empty implementation that is protected and final. This also ensures that
+     * all lower subclasses are also immutable.
+     *
+     * @param duration  new duration for interval
+     */
+    protected void setDurationAfterStart(ReadableDuration duration) {
+        if (duration == null) {
+            throw new IllegalArgumentException("The duration must not be null");
+        }
+        setEndMillis(duration.addTo(getStartMillis(), 1));
+        if (duration.isPrecise()) {
+            iDuration = duration.toDuration();
+        }
+    }
+
+    /**
+     * Sets the duration of this time interval, preserving the end instant.
+     * <p>
+     * Subclasses that wish to be immutable should override this method with an
+     * empty implementation that is protected and final. This also ensures that
+     * all lower subclasses are also immutable.
+     *
+     * @param duration  new duration for interval
+     */
+    protected void setDurationBeforeEnd(ReadableDuration duration) {
+        if (duration == null) {
+            throw new IllegalArgumentException("The duration must not be null");
+        }
+        setStartMillis(duration.addTo(getEndMillis(), -1));
+        if (duration.isPrecise()) {
+            iDuration = duration.toDuration();
+        }
+    }
+
 }
diff --git a/JodaTime/src/java/org/joda/time/Interval.java b/JodaTime/src/java/org/joda/time/Interval.java
index 49f58490a..c60352db1 100644
--- a/JodaTime/src/java/org/joda/time/Interval.java
+++ b/JodaTime/src/java/org/joda/time/Interval.java
@@ -143,14 +143,27 @@ public Interval(ReadableDuration duration, ReadableInstant end) {
      * Overridden to do nothing, ensuring this class and all subclasses are
      * immutable.
      */
-    protected void setStartMillis(long millisInstant) {
+    protected final void setStartMillis(long millisInstant) {
     }
 
     /**
      * Overridden to do nothing, ensuring this class and all subclasses are
      * immutable.
      */
-    protected void setEndMillis(long millisInstant) {
+    protected final void setEndMillis(long millisInstant) {
     }
 
+    /**
+     * Overridden to do nothing, ensuring this class and all subclasses are
+     * immutable.
+     */
+    protected final void setDurationAfterStart(ReadableDuration duration) {
+    }
+
+    /**
+     * Overridden to do nothing, ensuring this class and all subclasses are
+     * immutable.
+     */
+    protected final void setDurationBeforeEnd(ReadableDuration duration) {
+    }
 }
diff --git a/JodaTime/src/java/org/joda/time/MutableInterval.java b/JodaTime/src/java/org/joda/time/MutableInterval.java
index efc48446a..521a63bb3 100644
--- a/JodaTime/src/java/org/joda/time/MutableInterval.java
+++ b/JodaTime/src/java/org/joda/time/MutableInterval.java
@@ -199,10 +199,7 @@ public void setDurationAfterStart(long millisDuration) {
      * @param duration  new duration for interval
      */
     public void setDurationAfterStart(ReadableDuration duration) {
-        if (duration == null) {
-            throw new IllegalArgumentException("The duration must not be null");
-        }
-        super.setEndMillis(duration.addTo(getStartMillis(), 1));
+        super.setDurationAfterStart(duration);
     }
 
     /**
@@ -220,10 +217,7 @@ public void setDurationBeforeEnd(long millisDuration) {
      * @param duration  new duration for interval
      */
     public void setDurationBeforeEnd(ReadableDuration duration) {
-        if (duration == null) {
-            throw new IllegalArgumentException("The duration must not be null");
-        }
-        super.setStartMillis(duration.addTo(getEndMillis(), -1));
+        super.setDurationBeforeEnd(duration);
     }
 
 }

From 21c2608932bee267d90cf1e36e9b5b249ed362ed Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Tue, 23 Dec 2003 03:38:38 +0000
Subject: [PATCH 060/143] Support leap.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@65 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../test/time/chrono/gj/TestGJWeekyearField.java     | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekyearField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekyearField.java
index d2dab646b..64990a3a8 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekyearField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekyearField.java
@@ -87,6 +87,18 @@ public long add(long millis, long value) {
         return set(millis, (int)(get(millis) + value));
     }
 
+    public boolean isLeap(long millis) {
+        return iChronology.weekOfWeekyear().getMaximumValue(millis) > 52;
+    }
+
+    public int getLeapAmount(long millis) {
+        return iChronology.weekOfWeekyear().getMaximumValue(millis) - 52;
+    } 
+
+    public DurationField getLeapDurationField() {
+        return iChronology.weeks();
+    }
+
     public DurationField getRangeDurationField() {
         return null;
     }

From b56257cec50edc6bd2a36c38e889948b286194b9 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Wed, 24 Dec 2003 07:08:38 +0000
Subject: [PATCH 061/143] Added serialVersionUID.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@66 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/tz/CachedDateTimeZone.java    | 3 +++
 JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java   | 4 ++++
 .../src/java/org/joda/time/tz/DateTimeZonePermission.java     | 3 +++
 JodaTime/src/java/org/joda/time/tz/FixedDateTimeZone.java     | 3 +++
 4 files changed, 13 insertions(+)

diff --git a/JodaTime/src/java/org/joda/time/tz/CachedDateTimeZone.java b/JodaTime/src/java/org/joda/time/tz/CachedDateTimeZone.java
index 66306eee0..824703bc7 100644
--- a/JodaTime/src/java/org/joda/time/tz/CachedDateTimeZone.java
+++ b/JodaTime/src/java/org/joda/time/tz/CachedDateTimeZone.java
@@ -66,6 +66,9 @@
  * @author Brian S O'Neill
  */
 public class CachedDateTimeZone extends DateTimeZone {
+
+    static final long serialVersionUID = 5472298452022250685L;
+
     private static final int cInfoCacheMask;
 
     static {
diff --git a/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java b/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java
index 19579d102..1d61b2c5f 100644
--- a/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java
+++ b/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java
@@ -1151,6 +1151,8 @@ public DSTZone buildTailZone(String id) {
     }
 
     private static final class DSTZone extends DateTimeZone {
+        static final long serialVersionUID = 6941492635554961361L;
+
         static DSTZone readFrom(DataInput in, String id) throws IOException {
             return new DSTZone(id, (int)readMillis(in), 
                                Recurrence.readFrom(in), Recurrence.readFrom(in));
@@ -1289,6 +1291,8 @@ private Recurrence findMatchingRecurrence(long instant) {
     }
 
     private static final class PrecalculatedZone extends DateTimeZone {
+        static final long serialVersionUID = 7811976468055766265L;
+
         static PrecalculatedZone readFrom(DataInput in, String id) throws IOException {
             // Read string pool.
             int poolSize = in.readUnsignedShort();
diff --git a/JodaTime/src/java/org/joda/time/tz/DateTimeZonePermission.java b/JodaTime/src/java/org/joda/time/tz/DateTimeZonePermission.java
index 98a74fec0..9383164ac 100644
--- a/JodaTime/src/java/org/joda/time/tz/DateTimeZonePermission.java
+++ b/JodaTime/src/java/org/joda/time/tz/DateTimeZonePermission.java
@@ -68,6 +68,9 @@
  * @author Brian S O'Neill
  */
 public class DateTimeZonePermission extends java.security.BasicPermission {
+
+    static final long serialVersionUID = 3496753502571108448L;
+
     public DateTimeZonePermission(String name) {
         super(name);
     }
diff --git a/JodaTime/src/java/org/joda/time/tz/FixedDateTimeZone.java b/JodaTime/src/java/org/joda/time/tz/FixedDateTimeZone.java
index 58aa89f88..16e954635 100644
--- a/JodaTime/src/java/org/joda/time/tz/FixedDateTimeZone.java
+++ b/JodaTime/src/java/org/joda/time/tz/FixedDateTimeZone.java
@@ -64,6 +64,9 @@
  * @author Brian S O'Neill
  */
 public final class FixedDateTimeZone extends DateTimeZone {
+
+    static final long serialVersionUID = -3513011772763289092L;
+
     private final String iNameKey;
     private final int iWallOffset;
     private final int iStandardOffset;

From 67d0dbff922fbb0ba1736ea5e7b29c1950f8a81f Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 27 Dec 2003 02:26:54 +0000
Subject: [PATCH 062/143] Minor name correction.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@67 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/project.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/JodaTime/project.xml b/JodaTime/project.xml
index e6a411fc3..967a93a36 100644
--- a/JodaTime/project.xml
+++ b/JodaTime/project.xml
@@ -52,7 +52,7 @@
       </roles>
     </developer>
     <developer>
-      <name>Brian O'Neill</name>
+      <name>Brian S O'Neill</name>
       <id>broneill</id>
       <email>broneill@users.sourceforge.net</email>
       <organization></organization>

From 4ae145ad026ff58b135310c383aabaeb2b223e48 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 27 Dec 2003 02:27:28 +0000
Subject: [PATCH 063/143] Add blurb on intervals.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@68 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/package.html | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/JodaTime/src/java/org/joda/time/package.html b/JodaTime/src/java/org/joda/time/package.html
index dada16c04..96b54870c 100644
--- a/JodaTime/src/java/org/joda/time/package.html
+++ b/JodaTime/src/java/org/joda/time/package.html
@@ -83,11 +83,13 @@ <h4>Interfaces</h4>
 <li><code>ReadableInstant</code> - an instant in time
 <li><code>ReadableDateTime</code> - an instant in time with field accessors
 <li><code>ReadableDuration</code> - a duration broken down into fields
+<li><code>ReadableInterval</code> - a period of time between two instants
 </ul>
 <ul>
 <li><code>ReadWritableInstant</code> - an instant that can be modified
 <li><code>ReadWritableDateTime</code> - a datetime that can be modified
 <li><code>ReadWritableDuration</code> - a duration that can be modified
+<li><code>ReadWritableInterval</code> - an interval that can be modified
 </ul>
 <p>
 These define the public interface to dates, times, and durations. As with

From a36dcd697571d264df5e558b72a7120a0b5489e7 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 27 Dec 2003 02:28:00 +0000
Subject: [PATCH 064/143] Intervals done.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@69 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/xdocs/tasks.xml | 1 -
 1 file changed, 1 deletion(-)

diff --git a/JodaTime/xdocs/tasks.xml b/JodaTime/xdocs/tasks.xml
index 4590820d7..55c532d64 100644
--- a/JodaTime/xdocs/tasks.xml
+++ b/JodaTime/xdocs/tasks.xml
@@ -18,7 +18,6 @@ The following tasks still need doing:
 <ul>
 <li>DateOnly/TimeOnly properties</li>
 <li>API consistency</li>
-<li>Interval</li>
 <li>Testing</li>
 <li>Release!</li>
 </ul>

From 2b35ffc2ac783b2cdc92e7dab5228c171abea7b6 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 27 Dec 2003 02:28:14 +0000
Subject: [PATCH 065/143] Add interval.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@70 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/xdocs/index.xml | 1 +
 1 file changed, 1 insertion(+)

diff --git a/JodaTime/xdocs/index.xml b/JodaTime/xdocs/index.xml
index 186dd659b..4c6da66a3 100644
--- a/JodaTime/xdocs/index.xml
+++ b/JodaTime/xdocs/index.xml
@@ -61,6 +61,7 @@ Current interfaces and implementations include:
 <li>DateOnly</li>
 <li>TimeOnly</li>
 <li>Duration</li>
+<li>Interval</li>
 <li>DateTimeZone</li>
 <li>...plus formatting and parsing</li>
 </ul>

From f20dbc8fe7cff026314e5fef7d4688743cded902 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 27 Dec 2003 03:07:31 +0000
Subject: [PATCH 066/143] Fix repository URL.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@71 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/project.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/JodaTime/project.xml b/JodaTime/project.xml
index 967a93a36..ea9393b0d 100644
--- a/JodaTime/project.xml
+++ b/JodaTime/project.xml
@@ -29,7 +29,7 @@
   
   <repository>
     <connection>scm:cvs:pserver:anonymous@cvs.sourceforge.net:/cvsroot/joda-time:JodaTime</connection>
-    <url>http://cvs.sourceforge.net/viewcvs.py/joda-time/</url>
+    <url>http://cvs.sourceforge.net/viewcvs.py/joda-time/JodaTime/</url>
   </repository>
   
   <mailingLists>

From cd675bb9156cd723603ba7dea36cc079b699063b Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 27 Dec 2003 17:16:45 +0000
Subject: [PATCH 067/143] Require appending formatter, not just a printer.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@72 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../time/format/DurationFormatterBuilder.java | 27 +++++++++----------
 1 file changed, 13 insertions(+), 14 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java b/JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java
index 739859e42..495dd40a6 100644
--- a/JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java
+++ b/JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java
@@ -192,19 +192,18 @@ public void clear() {
     }
 
     /**
-     * Appends just a printer. With no matching parser, a parser cannot be
-     * built from this DurationFormatterBuilder.
+     * Appends another formatter.
      *
      * @return this DurationFormatterBuilder
      */
-    public DurationFormatterBuilder append(DurationPrinter printer)
+    public DurationFormatterBuilder append(DurationFormatter formatter)
         throws IllegalArgumentException
     {
-        if (printer == null) {
-            throw new IllegalArgumentException("No printer supplied");
+        if (formatter == null) {
+            throw new IllegalArgumentException("No formatter supplied");
         }
         clearPrefix();
-        iFormatters.add(printer);
+        iFormatters.add(formatter);
         return this;
     }
 
@@ -353,7 +352,7 @@ private DurationFormatterBuilder appendPrefix(DurationFieldAffix prefix) {
     }
 
     /**
-     * Instruct the printer to emit a numeric years field, if supported.
+     * Instruct the printer to emit a decimal years field, if supported.
      *
      * @return this DurationFormatterBuilder
      */
@@ -363,7 +362,7 @@ public DurationFormatterBuilder appendYears() {
     }
 
     /**
-     * Instruct the printer to emit a numeric years field, if supported.
+     * Instruct the printer to emit a decimal years field, if supported.
      *
      * @return this DurationFormatterBuilder
      */
@@ -373,7 +372,7 @@ public DurationFormatterBuilder appendMonths() {
     }
 
     /**
-     * Instruct the printer to emit a numeric weeks field, if supported.
+     * Instruct the printer to emit a decimal weeks field, if supported.
      *
      * @return this DurationFormatterBuilder
      */
@@ -383,7 +382,7 @@ public DurationFormatterBuilder appendWeeks() {
     }
 
     /**
-     * Instruct the printer to emit a numeric days field, if supported.
+     * Instruct the printer to emit a decimal days field, if supported.
      *
      * @return this DurationFormatterBuilder
      */
@@ -393,7 +392,7 @@ public DurationFormatterBuilder appendDays() {
     }
 
     /**
-     * Instruct the printer to emit a numeric hours field, if supported.
+     * Instruct the printer to emit a decimal hours field, if supported.
      *
      * @return this DurationFormatterBuilder
      */
@@ -403,7 +402,7 @@ public DurationFormatterBuilder appendHours() {
     }
 
     /**
-     * Instruct the printer to emit a numeric minutes field, if supported.
+     * Instruct the printer to emit a decimal minutes field, if supported.
      *
      * @return this DurationFormatterBuilder
      */
@@ -413,7 +412,7 @@ public DurationFormatterBuilder appendMinutes() {
     }
 
     /**
-     * Instruct the printer to emit a numeric seconds field, if supported.
+     * Instruct the printer to emit a decimal seconds field, if supported.
      *
      * @return this DurationFormatterBuilder
      */
@@ -423,7 +422,7 @@ public DurationFormatterBuilder appendSeconds() {
     }
 
     /**
-     * Instruct the printer to emit a numeric millis field, if supported.
+     * Instruct the printer to emit a decimal millis field, if supported.
      *
      * @return this DurationFormatterBuilder
      */

From 49b93444b594c2418063c1f95cb07bd30bd639a1 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 27 Dec 2003 17:18:21 +0000
Subject: [PATCH 068/143] Rename appendNumeric to appendDecimal, reserving
 "numeric" for later use.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@73 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/time/format/DateTimeFormat.java  |  2 +-
 .../time/format/DateTimeFormatterBuilder.java | 44 +++++++++----------
 2 files changed, 23 insertions(+), 23 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java b/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java
index 7d587f7be..f19d5725f 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java
@@ -299,7 +299,7 @@ public static void appendPatternTo(DateTimeFormatterBuilder builder, String patt
                             (chronoUTC.yearOfEra(), "yearOfCentury", "centuries", 100);
                         break;
                     }
-                    builder.appendNumeric(field, 2, 2);
+                    builder.appendDecimal(field, 2, 2);
                 } else {
                     // Try to support long year values.
                     int maxDigits = 9;
diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
index ee16b3b0e..0a64bcd66 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
@@ -416,7 +416,7 @@ public DateTimeFormatterBuilder appendLiteral(final String text) {
      * @return this DateTimeFormatterBuilder
      * @throws IllegalArgumentException if field is null
      */
-    public DateTimeFormatterBuilder appendNumeric(
+    public DateTimeFormatterBuilder appendDecimal(
             DateTimeField field, int minDigits, int maxDigits) {
         if (field == null) {
             throw new IllegalArgumentException("Field must not be null");
@@ -445,7 +445,7 @@ public DateTimeFormatterBuilder appendNumeric(
      * @return this DateTimeFormatterBuilder
      * @throws IllegalArgumentException if field is null
      */
-    public DateTimeFormatterBuilder appendSignedNumeric(
+    public DateTimeFormatterBuilder appendSignedDecimal(
             DateTimeField field, int minDigits, int maxDigits) {
         if (field == null) {
             throw new IllegalArgumentException("Field must not be null");
@@ -555,7 +555,7 @@ public DateTimeFormatterBuilder appendFractionOfDay(final int minDigits, final i
      * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendMillisOfSecond(final int minDigits) {
-        return appendNumeric(iChronoUTC.millisOfSecond(), minDigits, 3);
+        return appendDecimal(iChronoUTC.millisOfSecond(), minDigits, 3);
     }
 
     /**
@@ -565,7 +565,7 @@ public DateTimeFormatterBuilder appendMillisOfSecond(final int minDigits) {
      * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendMillisOfDay(final int minDigits) {
-        return appendNumeric(iChronoUTC.millisOfDay(), minDigits, 8);
+        return appendDecimal(iChronoUTC.millisOfDay(), minDigits, 8);
     }
 
     /**
@@ -575,7 +575,7 @@ public DateTimeFormatterBuilder appendMillisOfDay(final int minDigits) {
      * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendSecondOfMinute(final int minDigits) {
-        return appendNumeric(iChronoUTC.secondOfMinute(), minDigits, 2);
+        return appendDecimal(iChronoUTC.secondOfMinute(), minDigits, 2);
     }
 
     /**
@@ -585,7 +585,7 @@ public DateTimeFormatterBuilder appendSecondOfMinute(final int minDigits) {
      * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendSecondOfDay(final int minDigits) {
-        return appendNumeric(iChronoUTC.secondOfDay(), minDigits, 5);
+        return appendDecimal(iChronoUTC.secondOfDay(), minDigits, 5);
     }
 
     /**
@@ -595,7 +595,7 @@ public DateTimeFormatterBuilder appendSecondOfDay(final int minDigits) {
      * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendMinuteOfHour(final int minDigits) {
-        return appendNumeric(iChronoUTC.minuteOfHour(), minDigits, 2);
+        return appendDecimal(iChronoUTC.minuteOfHour(), minDigits, 2);
     }
 
     /**
@@ -605,7 +605,7 @@ public DateTimeFormatterBuilder appendMinuteOfHour(final int minDigits) {
      * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendMinuteOfDay(final int minDigits) {
-        return appendNumeric(iChronoUTC.minuteOfDay(), minDigits, 4);
+        return appendDecimal(iChronoUTC.minuteOfDay(), minDigits, 4);
     }
 
     /**
@@ -615,7 +615,7 @@ public DateTimeFormatterBuilder appendMinuteOfDay(final int minDigits) {
      * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendHourOfDay(final int minDigits) {
-        return appendNumeric(iChronoUTC.hourOfDay(), minDigits, 2);
+        return appendDecimal(iChronoUTC.hourOfDay(), minDigits, 2);
     }
 
     /**
@@ -625,7 +625,7 @@ public DateTimeFormatterBuilder appendHourOfDay(final int minDigits) {
      * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendClockhourOfDay(final int minDigits) {
-        return appendNumeric(iChronoUTC.clockhourOfDay(), minDigits, 2);
+        return appendDecimal(iChronoUTC.clockhourOfDay(), minDigits, 2);
     }
 
     /**
@@ -635,7 +635,7 @@ public DateTimeFormatterBuilder appendClockhourOfDay(final int minDigits) {
      * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendHourOfHalfday(final int minDigits) {
-        return appendNumeric(iChronoUTC.hourOfHalfday(), minDigits, 2);
+        return appendDecimal(iChronoUTC.hourOfHalfday(), minDigits, 2);
     }
 
     /**
@@ -645,7 +645,7 @@ public DateTimeFormatterBuilder appendHourOfHalfday(final int minDigits) {
      * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendClockhourOfHalfday(final int minDigits) {
-        return appendNumeric(iChronoUTC.clockhourOfHalfday(), minDigits, 2);
+        return appendDecimal(iChronoUTC.clockhourOfHalfday(), minDigits, 2);
     }
 
     /**
@@ -655,7 +655,7 @@ public DateTimeFormatterBuilder appendClockhourOfHalfday(final int minDigits) {
      * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendDayOfWeek(final int minDigits) {
-        return appendNumeric(iChronoUTC.dayOfWeek(), minDigits, 1);
+        return appendDecimal(iChronoUTC.dayOfWeek(), minDigits, 1);
     }
 
     /**
@@ -665,7 +665,7 @@ public DateTimeFormatterBuilder appendDayOfWeek(final int minDigits) {
      * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendDayOfMonth(final int minDigits) {
-        return appendNumeric(iChronoUTC.dayOfMonth(), minDigits, 2);
+        return appendDecimal(iChronoUTC.dayOfMonth(), minDigits, 2);
     }
 
     /**
@@ -675,7 +675,7 @@ public DateTimeFormatterBuilder appendDayOfMonth(final int minDigits) {
      * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendDayOfYear(final int minDigits) {
-        return appendNumeric(iChronoUTC.dayOfYear(), minDigits, 3);
+        return appendDecimal(iChronoUTC.dayOfYear(), minDigits, 3);
     }
 
     /**
@@ -685,7 +685,7 @@ public DateTimeFormatterBuilder appendDayOfYear(final int minDigits) {
      * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendWeekOfWeekyear(final int minDigits) {
-        return appendNumeric(iChronoUTC.weekOfWeekyear(), minDigits, 2);
+        return appendDecimal(iChronoUTC.weekOfWeekyear(), minDigits, 2);
     }
 
     /**
@@ -697,7 +697,7 @@ public DateTimeFormatterBuilder appendWeekOfWeekyear(final int minDigits) {
      * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendWeekyear(final int minDigits, final int maxDigits) {
-        return appendNumeric
+        return appendDecimal
             (iChronoUTC.weekyear(), minDigits, maxDigits);
     }
 
@@ -708,7 +708,7 @@ public DateTimeFormatterBuilder appendWeekyear(final int minDigits, final int ma
      * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendMonthOfYear(final int minDigits) {
-        return appendNumeric(iChronoUTC.monthOfYear(), minDigits, 2);
+        return appendDecimal(iChronoUTC.monthOfYear(), minDigits, 2);
     }
 
     /**
@@ -720,7 +720,7 @@ public DateTimeFormatterBuilder appendMonthOfYear(final int minDigits) {
      * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendYear(final int minDigits, final int maxDigits) {
-        return appendSignedNumeric(iChronoUTC.year(), minDigits, maxDigits);
+        return appendSignedDecimal(iChronoUTC.year(), minDigits, maxDigits);
     }
 
     /**
@@ -732,7 +732,7 @@ public DateTimeFormatterBuilder appendYear(final int minDigits, final int maxDig
      * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendYearOfEra(final int minDigits, final int maxDigits) {
-        return appendNumeric(iChronoUTC.yearOfEra(), minDigits, maxDigits);
+        return appendDecimal(iChronoUTC.yearOfEra(), minDigits, maxDigits);
     }
 
     /**
@@ -744,7 +744,7 @@ public DateTimeFormatterBuilder appendYearOfEra(final int minDigits, final int m
      * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendYearOfCentury(final int minDigits, final int maxDigits) {
-        return appendNumeric(iChronoUTC.yearOfCentury(), minDigits, maxDigits);
+        return appendDecimal(iChronoUTC.yearOfCentury(), minDigits, maxDigits);
     }
 
     /**
@@ -756,7 +756,7 @@ public DateTimeFormatterBuilder appendYearOfCentury(final int minDigits, final i
      * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendCenturyOfEra(final int minDigits, final int maxDigits) {
-        return appendSignedNumeric(iChronoUTC.centuryOfEra(), minDigits, maxDigits);
+        return appendSignedDecimal(iChronoUTC.centuryOfEra(), minDigits, maxDigits);
     }
 
     /**

From c0d3d407b3691489e679909edeed40f34d3bdda6 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Fri, 2 Jan 2004 05:44:36 +0000
Subject: [PATCH 069/143] Include usage in javadoc.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@74 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/build.xml | 1 +
 1 file changed, 1 insertion(+)

diff --git a/JodaTime/build.xml b/JodaTime/build.xml
index 3442545e6..99e3cee9a 100644
--- a/JodaTime/build.xml
+++ b/JodaTime/build.xml
@@ -215,6 +215,7 @@
                 private="false"
                 package="false"
                 version="true"
+                    use="yes"
                doctitle="&lt;h1&gt;${component.title}&lt;/h1&gt;"
             windowtitle="${component.title} (Version ${component.version})"
                  bottom="Copyright (c) 2001-2003 - Joda.org">

From 9e164be08b0fc33f73a63ce0b7d7abafeb3cc7e7 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 3 Jan 2004 02:24:58 +0000
Subject: [PATCH 070/143] Moved from parent package.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@75 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../AbstractDateTimeFieldProperty.java        | 359 ++++++++++++++++++
 .../time/property/DateTimeFieldProperty.java  | 292 ++++++++++++++
 .../MutableDateTimeFieldProperty.java         | 235 ++++++++++++
 3 files changed, 886 insertions(+)
 create mode 100644 JodaTime/src/java/org/joda/time/property/AbstractDateTimeFieldProperty.java
 create mode 100644 JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java
 create mode 100644 JodaTime/src/java/org/joda/time/property/MutableDateTimeFieldProperty.java

diff --git a/JodaTime/src/java/org/joda/time/property/AbstractDateTimeFieldProperty.java b/JodaTime/src/java/org/joda/time/property/AbstractDateTimeFieldProperty.java
new file mode 100644
index 000000000..76c7f4893
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/property/AbstractDateTimeFieldProperty.java
@@ -0,0 +1,359 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.property;
+
+import java.util.Locale;
+import java.io.Serializable;
+import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+import org.joda.time.ReadableInstant;
+
+/**
+ * AbstractDateTimeFieldProperty is a base class for binding a
+ * ReadableInstant to a DateTimeField.
+ * <p>
+ * It allows the date and time manipulation code to be field based yet
+ * still easy to use.
+ * <p>
+ * AbstractDateTimeFieldPropery itself is thread-safe and immutable, but the
+ * ReadableInstant being operated on may be mutable and not thread-safe.
+ *
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+public abstract class AbstractDateTimeFieldProperty implements Serializable {
+    
+    static final long serialVersionUID = 1971226328211649661L;
+
+    /**
+     * Constructor.
+     */
+    public AbstractDateTimeFieldProperty() {
+        super();
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the field being used.
+     * 
+     * @return the field
+     */
+    public abstract DateTimeField getField();
+
+    /**
+     * Gets the name of the field.
+     * 
+     * @return the field name
+     */
+    public String getName() {
+        return getField().getName();
+    }
+
+    /**
+     * Gets the instant being used.
+     * 
+     * @return the instant
+     */
+    public abstract ReadableInstant getInstant();
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets a value from the instant.
+     * 
+     * @return the current value
+     * @see DateTimeField#get
+     */
+    public int get() {
+        return getField().get(getInstant().getMillis());
+    }
+
+    /**
+     * Gets a text value from the instant.
+     * 
+     * @param locale  optional locale to use for selecting a text symbol
+     * @return the current text value
+     * @see DateTimeField#getAsText
+     */
+    public String getAsText(Locale locale) {
+        return getField().getAsText(getInstant().getMillis(), locale);
+    }
+
+    /**
+     * Gets a text value from the instant.
+     * 
+     * @return the current text value
+     * @see DateTimeField#getAsText
+     */
+    public final String getAsText() {
+        return getField().getAsText(getInstant().getMillis(), null);
+    }
+
+    /**
+     * Gets a short text value from the instant.
+     * 
+     * @param locale  optional locale to use for selecting a text symbol
+     * @return the current text value
+     * @see DateTimeField#getAsShortText
+     */
+    public String getAsShortText(Locale locale) {
+        return getField().getAsShortText(getInstant().getMillis(), locale);
+    }
+
+    /**
+     * Gets a short text value from the instant.
+     * 
+     * @return the current text value
+     * @see DateTimeField#getAsShortText
+     */
+    public final String getAsShortText() {
+        return getAsShortText(null);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Returns the difference between this field property instant and the one
+     * passed in, in the units of this field. The sign of the difference
+     * matches that of compareTo. In other words, this field property's instant
+     * is the minuend.
+     *
+     * @param instant the subtrahend
+     * @return the difference in the units of this field
+     * @see DateTimeField#getDifference
+     */
+    public int getDifference(ReadableInstant instant) {
+        if (instant == null) {
+            throw new IllegalArgumentException("The instant must not be null");
+        }
+        return getField().getDifference(getInstant().getMillis(), instant.getMillis());
+    }
+
+    /**
+     * Returns the difference between this field property instant and the one
+     * passed in, in the units of this field. The sign of the difference
+     * matches that of compareTo. In other words, this field property's instant
+     * is the minuend.
+     *
+     * @param instant the subtrahend
+     * @return the difference in the units of this field
+     * @see DateTimeField#getDifference
+     */
+    public long getDifferenceAsLong(ReadableInstant instant) {
+        if (instant == null) {
+            throw new IllegalArgumentException("The instant must not be null");
+        }
+        return getField().getDifferenceAsLong(getInstant().getMillis(), instant.getMillis());
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Returns the duration per unit value of this field. For example, if this
+     * field represents "hour of day", then the duration is an hour.
+     *
+     * @return the duration of this field, or UnsupportedDurationField
+     */
+    public DurationField getDurationField() {
+        return getField().getDurationField();
+    }
+
+    /**
+     * Returns the range duration of this field. For example, if this field
+     * represents "hour of day", then the range duration is a day.
+     *
+     * @return the range duration of this field, or null if field has no range
+     */
+    public DurationField getRangeDurationField() {
+        return getField().getRangeDurationField();
+    }
+
+    /**
+     * Gets whether this field is leap.
+     * 
+     * @return true if a leap field
+     * @see DateTimeField#isLeap
+     */
+    public boolean isLeap() {
+        return getField().isLeap(getInstant().getMillis());
+    }
+
+    /**
+     * Gets the amount by which this field is leap.
+     * 
+     * @return the amount by which the field is leap
+     * @see DateTimeField#getLeapAmount
+     */
+    public int getLeapAmount() {
+        return getField().getLeapAmount(getInstant().getMillis());
+    }
+
+    /**
+     * If this field were to leap, then it would be in units described by the
+     * returned duration. If this field doesn't ever leap, null is returned.
+     */
+    public DurationField getLeapDurationField() {
+        return getField().getLeapDurationField();
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the minimum value for the field ignoring the current time.
+     * 
+     * @return the minimum value
+     * @see DateTimeField#getMinimumValue
+     */
+    public int getMinimumValueOverall() {
+        return getField().getMinimumValue();
+    }
+
+    /**
+     * Gets the minimum value for the field.
+     * 
+     * @return the minimum value
+     * @see DateTimeField#getMinimumValue
+     */
+    public int getMinimumValue() {
+        return getField().getMinimumValue(getInstant().getMillis());
+    }
+
+    /**
+     * Gets the maximum value for the field ignoring the current time.
+     * 
+     * @return the maximum value
+     * @see DateTimeField#getMaximumValue
+     */
+    public int getMaximumValueOverall() {
+        return getField().getMaximumValue();
+    }
+
+    /**
+     * Gets the maximum value for the field.
+     * 
+     * @return the maximum value
+     * @see DateTimeField#getMaximumValue
+     */
+    public int getMaximumValue() {
+        return getField().getMaximumValue(getInstant().getMillis());
+    }
+
+    /**
+     * Gets the maximum text length for the field.
+     * 
+     * @param locale  optional locale to use for selecting a text symbol
+     * @return the maximum length
+     * @see DateTimeField#getMaximumTextLength
+     */
+    public int getMaximumTextLength(Locale locale) {
+        return getField().getMaximumTextLength(locale);
+    }
+
+    /**
+     * Gets the maximum short text length for the field.
+     * 
+     * @param locale  optional locale to use for selecting a text symbol
+     * @return the maximum length
+     * @see DateTimeField#getMaximumShortTextLength
+     */
+    public int getMaximumShortTextLength(Locale locale) {
+        return getField().getMaximumShortTextLength(locale);
+    }
+
+
+    /**
+     * Returns the fractional duration milliseconds of this field.
+     *
+     * @see DateTimeField#remainder
+     * @return remainder duration, in milliseconds
+     */
+    public long remainder() {
+        return getField().remainder(getInstant().getMillis());
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Compare this field to the same field on another instant.
+     * <p>
+     * The {@link #get()} method is used to obtain the value to compare for
+     * this instant and the {@link ReadableInstant#get(DateTimeField)} method
+     * is used for the specified instant.
+     * 
+     * @param instant  the instant to compare to
+     * @return negative value if this is less, 0 if equal, or positive value if greater
+     * @throws IllegalArgumentException if the instant is null
+     */
+    public int compareTo(ReadableInstant instant) {
+        if (instant == null) {
+            throw new IllegalArgumentException("The instant must not be null");
+        }
+        int thisValue = get();
+        int otherValue = instant.get(getField());
+        if (thisValue < otherValue) {
+            return -1;
+        } else if (thisValue > otherValue) {
+            return 1;
+        } else {
+            return 0;
+        }
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Output a debugging string.
+     * 
+     * @return debugging string
+     */
+    public String toString() {
+        return "Property[" + getName() + "]";
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java b/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java
new file mode 100644
index 000000000..3412607df
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java
@@ -0,0 +1,292 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.property;
+
+import java.util.Locale;
+import org.joda.time.DateTime;
+import org.joda.time.DateTimeField;
+// Import for @link support
+import org.joda.time.MutableDateTime;
+import org.joda.time.ReadableInstant;
+
+/**
+ * DateTimeFieldProperty binds a DateTime to a DateTimeField allowing powerful
+ * datetime functionality to be easily accessed.
+ * <p>
+ * The simplest use of this class is as an alternative get method, here used to
+ * get the year '1972' (as an int) and the month 'December' (as a String).
+ * <pre>
+ * DateTime dt = new DateTime(1972, 12, 3, 0, 0, 0, 0);
+ * int year = dt.year().get();
+ * String monthStr = dt.month().getAsText();
+ * </pre>
+ * <p>
+ * Methods are also provided that allow date modification. These return new instances
+ * of DateTime - they do not modify the original. The example below yields two
+ * independent immutable date objects 20 years apart.
+ * <pre>
+ * DateTime dt = new DateTime(1972, 12, 3, 0, 0, 0, 0);
+ * DateTime dt20 = dt.year().addToCopy(20);
+ * </pre>
+ * Serious modification of dates (ie. more than just changing one or two fields)
+ * should use the {@link MutableDateTime} class.
+ * <p>
+ * DateTimeFieldPropery itself is thread-safe and immutable, as well as the
+ * DateTime being operated on.
+ *
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+public class DateTimeFieldProperty extends AbstractDateTimeFieldProperty {
+    
+    static final long serialVersionUID = -6983323811635733510L;
+
+    /** The instant this property is working against */
+    private final DateTime iInstant;
+    /** The field this property is working against */
+    private final DateTimeField iField;
+
+    /**
+     * Constructor.
+     * 
+     * @param instant  the instant to set
+     * @param field  the field to use
+     */
+    public DateTimeFieldProperty(DateTime instant, DateTimeField field) {
+        super();
+        iInstant = instant;
+        iField = field;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the field being used.
+     * 
+     * @return the field
+     */
+    public DateTimeField getField() {
+        return iField;
+    }
+
+    /**
+     * Gets the instant being used.
+     * 
+     * @return the instant
+     */
+    public ReadableInstant getInstant() {
+        return iInstant;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Adds to this field in a copy of this DateTime.
+     * <p>
+     * The DateTime attached to this property is unchanged by this call.
+     * This operation is faster than converting a DateTime to a MutableDateTime
+     * and back again when setting one field. When setting multiple fields,
+     * it is generally quicker to make the conversion to MutableDateTime.
+     * 
+     * @param value  the value to add to the field in the copy
+     * @return a copy of the DateTime with the field value changed
+     * @throws IllegalArgumentException if the value isn't valid
+     */
+    public DateTime addToCopy(int value) {
+        DateTime instant = iInstant;
+        return (DateTime)instant.toCopy(iField.add(instant.getMillis(), value));
+    }
+
+    /**
+     * Adds to this field in a copy of this DateTime.
+     * <p>
+     * The DateTime attached to this property is unchanged by this call.
+     * This operation is faster than converting a DateTime to a MutableDateTime
+     * and back again when setting one field. When setting multiple fields,
+     * it is generally quicker to make the conversion to MutableDateTime.
+     * 
+     * @param value  the value to add to the field in the copy
+     * @return a copy of the DateTime with the field value changed
+     * @throws IllegalArgumentException if the value isn't valid
+     */
+    public DateTime addToCopy(long value) {
+        DateTime instant = iInstant;
+        return (DateTime)instant.toCopy(iField.add(instant.getMillis(), value));
+    }
+
+    /**
+     * Adds to this field, possibly wrapped, in a copy of this DateTime.
+     * A wrapped operation only changes this field.
+     * Thus 31st January addWrapped one day goes to the 1st January.
+     * <p>
+     * The DateTime attached to this property is unchanged by this call.
+     * This operation is faster than converting a DateTime to a MutableDateTime
+     * and back again when setting one field. When setting multiple fields,
+     * it is generally quicker to make the conversion to MutableDateTime.
+     * 
+     * @param value  the value to add to the field in the copy
+     * @return a copy of the DateTime with the field value changed
+     * @throws IllegalArgumentException if the value isn't valid
+     */
+    public DateTime addWrappedToCopy(int value) {
+        DateTime instant = iInstant;
+        return (DateTime)instant.toCopy(iField.addWrapped(instant.getMillis(), value));
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets this field in a copy of the DateTime.
+     * <p>
+     * The DateTime attached to this property is unchanged by this call.
+     * This operation is faster than converting a DateTime to a MutableDateTime
+     * and back again when setting one field. When setting multiple fields,
+     * it is generally quicker to make the conversion to MutableDateTime.
+     * 
+     * @param value  the value to set the field in the copy to
+     * @return a copy of the DateTime with the field value changed
+     * @throws IllegalArgumentException if the value isn't valid
+     */
+    public DateTime setCopy(int value) {
+        DateTime instant = iInstant;
+        return (DateTime)instant.toCopy(iField.set(instant.getMillis(), value));
+    }
+    
+    /**
+     * Sets this field in a copy of the DateTime to a parsed text value.
+     * <p>
+     * The DateTime attached to this property is unchanged by this call.
+     * This operation is faster than converting a DateTime to a MutableDateTime
+     * and back again when setting one field. When setting multiple fields,
+     * it is generally quicker to make the conversion to MutableDateTime.
+     * 
+     * @param text  the text value to set
+     * @param locale  optional locale to use for selecting a text symbol
+     * @return a copy of the DateTime with the field value changed
+     * @throws IllegalArgumentException if the text value isn't valid
+     */
+    public DateTime setCopy(String text, Locale locale) {
+        DateTime instant = iInstant;
+        return (DateTime)instant.toCopy(iField.set(instant.getMillis(), text, locale));
+    }
+
+    /**
+     * Sets this field in a copy of the DateTime to a parsed text value.
+     * <p>
+     * The DateTime attached to this property is unchanged by this call.
+     * This operation is faster than converting a DateTime to a MutableDateTime
+     * and back again when setting one field. When setting multiple fields,
+     * it is generally quicker to make the conversion to MutableDateTime.
+     * 
+     * @param text  the text value to set
+     * @return a copy of the DateTime with the field value changed
+     * @throws IllegalArgumentException if the text value isn't valid
+     */
+    public final DateTime setCopy(String text) {
+        return setCopy(text, null);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Rounds to the lowest whole unit of this field on a copy of this DateTime.
+     *
+     * @return a copy of the DateTime with the field value changed
+     */
+    public DateTime roundFloorCopy() {
+        DateTime instant = iInstant;
+        return (DateTime)instant.toCopy(iField.roundFloor(instant.getMillis()));
+    }
+
+    /**
+     * Rounds to the highest whole unit of this field on a copy of this DateTime.
+     *
+     * @return a copy of the DateTime with the field value changed
+     */
+    public DateTime roundCeilingCopy() {
+        DateTime instant = iInstant;
+        return (DateTime)instant.toCopy(iField.roundCeiling(instant.getMillis()));
+    }
+
+    /**
+     * Rounds to the nearest whole unit of this field on a copy of this DateTime,
+     * favoring the floor if halfway.
+     *
+     * @return a copy of the DateTime with the field value changed
+     */
+    public DateTime roundHalfFloorCopy() {
+        DateTime instant = iInstant;
+        return (DateTime)instant.toCopy(iField.roundHalfFloor(instant.getMillis()));
+    }
+
+    /**
+     * Rounds to the nearest whole unit of this field on a copy of this DateTime,
+     * favoring the ceiling if halfway.
+     *
+     * @return a copy of the DateTime with the field value changed
+     */
+    public DateTime roundHalfCeilingCopy() {
+        DateTime instant = iInstant;
+        return (DateTime)instant.toCopy(iField.roundHalfCeiling(instant.getMillis()));
+    }
+
+    /**
+     * Rounds to the nearest whole unit of this field on a copy of this DateTime.
+     * If halfway, the ceiling is favored over the floor only if it makes this field's value even.
+     *
+     * @return a copy of the DateTime with the field value changed
+     */
+    public DateTime roundHalfEvenCopy() {
+        DateTime instant = iInstant;
+        return (DateTime)instant.toCopy(iField.roundHalfEven(instant.getMillis()));
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/property/MutableDateTimeFieldProperty.java b/JodaTime/src/java/org/joda/time/property/MutableDateTimeFieldProperty.java
new file mode 100644
index 000000000..7bc47477d
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/property/MutableDateTimeFieldProperty.java
@@ -0,0 +1,235 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.property;
+
+import java.util.Locale;
+import org.joda.time.DateTimeField;
+import org.joda.time.ReadableInstant;
+import org.joda.time.ReadWritableInstant;
+
+/**
+ * MutableDateTimeFieldProperty binds a ReadWritableInstant to a DateTimeField
+ * allowing powerful datetime functionality to be easily accessed.
+ * <p>
+ * The example below shows how to use the property to change the value of a
+ * MutableDateTime object.
+ * <pre>
+ * MutableDateTime dt = new MutableDateTime(1972, 12, 3, 0, 0, 0, 0);
+ * dt.year().add(20);
+ * dt.second().roundFloor();
+ * dt.minute().set(10);
+ * </pre>
+ * <p>
+ * MutableDateTimeFieldPropery itself is thread-safe and immutable, but the
+ * ReadWritableInstant being operated on may not be thread-safe.
+ *
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+public class MutableDateTimeFieldProperty extends AbstractDateTimeFieldProperty {
+
+    static final long serialVersionUID = -4481126543819298617L;
+
+    /** The instant this property is working against */
+    private final ReadWritableInstant iInstant;
+    /** The field this property is working against */
+    private final DateTimeField iField;
+
+    /**
+     * Constructor.
+     * 
+     * @param instant  the instant to set
+     * @param field  the field to use
+     */
+    public MutableDateTimeFieldProperty(ReadWritableInstant instant, DateTimeField field) {
+        super();
+        iInstant = instant;
+        iField = field;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the field being used.
+     * 
+     * @return the field
+     */
+    public DateTimeField getField() {
+        return iField;
+    }
+
+    /**
+     * Gets the instant being used.
+     * 
+     * @return the instant
+     */
+    public ReadableInstant getInstant() {
+        return iInstant;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Adds a value to the millis value.
+     * 
+     * @param value  the value to add
+     * @see DateTimeField#add(long,int)
+     */
+    public void add(int value) {
+        iInstant.setMillis(getField().add(iInstant.getMillis(), value));
+    }
+
+    /**
+     * Adds a value to the millis value.
+     * 
+     * @param value  the value to add
+     * @see DateTimeField#add(long,long)
+     */
+    public void add(long value) {
+        iInstant.setMillis(getField().add(iInstant.getMillis(), value));
+    }
+
+    /**
+     * Adds a value, possibly wrapped, to the millis value.
+     * 
+     * @param value  the value to add
+     * @see DateTimeField#addWrapped
+     */
+    public void addWrapped(int value) {
+        iInstant.setMillis(getField().addWrapped(iInstant.getMillis(), value));
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets a value.
+     * 
+     * @param value  the value to set.
+     * @see DateTimeField#set(long,int)
+     */
+    public void set(int value) {
+        iInstant.setMillis(getField().set(iInstant.getMillis(), value));
+    }
+
+    /**
+     * Sets a text value.
+     * 
+     * @param text  the text value to set
+     * @param locale  optional locale to use for selecting a text symbol
+     * @throws IllegalArgumentException if the text value isn't valid
+     * @see DateTimeField#set(long,java.lang.String,java.util.Locale)
+     */
+    public void set(String text, Locale locale) {
+        iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale));
+    }
+
+    /**
+     * Sets a text value.
+     * 
+     * @param text  the text value to set
+     * @throws IllegalArgumentException if the text value isn't valid
+     * @see DateTimeField#set(long,java.lang.String)
+     */
+    public final void set(String text) {
+        set(text, null);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Round to the lowest whole unit of this field.
+     *
+     * @see DateTimeField#roundFloor
+     */
+    public void roundFloor() {
+        iInstant.setMillis(getField().roundFloor(iInstant.getMillis()));
+    }
+
+    /**
+     * Round to the highest whole unit of this field.
+     *
+     * @see DateTimeField#roundCeiling
+     */
+    public void roundCeiling() {
+        iInstant.setMillis(getField().roundCeiling(iInstant.getMillis()));
+    }
+
+    /**
+     * Round to the nearest whole unit of this field, favoring the floor if
+     * halfway.
+     *
+     * @see DateTimeField#roundHalfFloor
+     */
+    public void roundHalfFloor() {
+        iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis()));
+    }
+
+    /**
+     * Round to the nearest whole unit of this field, favoring the ceiling if
+     * halfway.
+     *
+     * @see DateTimeField#roundHalfCeiling
+     */
+    public void roundHalfCeiling() {
+        iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis()));
+    }
+
+    /**
+     * Round to the nearest whole unit of this field. If halfway, the ceiling
+     * is favored over the floor only if it makes this field's value even.
+     *
+     * @see DateTimeField#roundHalfEven
+     */
+    public void roundHalfEven() {
+        iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis()));
+    }
+
+}

From 33e118fc3fe4542f9f93096c74b84b1b0d98ee5f Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 3 Jan 2004 02:25:14 +0000
Subject: [PATCH 071/143] Moved to new property package.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@76 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../time/AbstractDateTimeFieldProperty.java   | 359 ------------------
 .../org/joda/time/DateTimeFieldProperty.java  | 299 ---------------
 .../time/MutableDateTimeFieldProperty.java    | 244 ------------
 3 files changed, 902 deletions(-)
 delete mode 100644 JodaTime/src/java/org/joda/time/AbstractDateTimeFieldProperty.java
 delete mode 100644 JodaTime/src/java/org/joda/time/DateTimeFieldProperty.java
 delete mode 100644 JodaTime/src/java/org/joda/time/MutableDateTimeFieldProperty.java

diff --git a/JodaTime/src/java/org/joda/time/AbstractDateTimeFieldProperty.java b/JodaTime/src/java/org/joda/time/AbstractDateTimeFieldProperty.java
deleted file mode 100644
index 12192b1d3..000000000
--- a/JodaTime/src/java/org/joda/time/AbstractDateTimeFieldProperty.java
+++ /dev/null
@@ -1,359 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-03 Stephen Colebourne.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time;
-
-import java.util.Locale;
-import java.io.Serializable;
-
-/**
- * AbstractDateTimeFieldProperty is a base class for binding a
- * ReadableDateTime to a DateTimeField.
- * <p>
- * It allows the date and time manipulation code to be field based yet
- * still easy to use.
- * <p>
- * AbstractDateTimeFieldPropery itself is thread-safe and immutable, but the
- * ReadableDateTime being operated on may be mutable and not thread-safe.
- *
- * @see ReadableInstant
- * @see DateTimeField
- * 
- * @author Stephen Colebourne
- * @author Brian S O'Neill
- * @since 1.0
- */
-public abstract class AbstractDateTimeFieldProperty implements Serializable {
-    
-    static final long serialVersionUID = 1971226328211649661L;
-
-    /**
-     * Constructor.
-     */
-    public AbstractDateTimeFieldProperty() {
-        super();
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Gets the field being used.
-     * 
-     * @return the field
-     */
-    public abstract DateTimeField getField();
-
-    /**
-     * Gets the name of the field.
-     * 
-     * @return the field name
-     */
-    public String getName() {
-        return getField().getName();
-    }
-
-    /**
-     * Gets the instant being used.
-     * 
-     * @return the instant
-     */
-    public abstract ReadableDateTime getInstant();
-
-    //-----------------------------------------------------------------------
-    /**
-     * Gets a value from the instant.
-     * 
-     * @return the current value
-     * @see DateTimeField#get
-     */
-    public int get() {
-        return getField().get(getInstant().getMillis());
-    }
-
-    /**
-     * Gets a text value from the instant.
-     * 
-     * @param locale  optional locale to use for selecting a text symbol
-     * @return the current text value
-     * @see DateTimeField#getAsText
-     */
-    public String getAsText(Locale locale) {
-        return getField().getAsText(getInstant().getMillis(), locale);
-    }
-
-    /**
-     * Gets a text value from the instant.
-     * 
-     * @return the current text value
-     * @see DateTimeField#getAsText
-     */
-    public final String getAsText() {
-        return getField().getAsText(getInstant().getMillis(), null);
-    }
-
-    /**
-     * Gets a short text value from the instant.
-     * 
-     * @param locale  optional locale to use for selecting a text symbol
-     * @return the current text value
-     * @see DateTimeField#getAsShortText
-     */
-    public String getAsShortText(Locale locale) {
-        return getField().getAsShortText(getInstant().getMillis(), locale);
-    }
-
-    /**
-     * Gets a short text value from the instant.
-     * 
-     * @return the current text value
-     * @see DateTimeField#getAsShortText
-     */
-    public final String getAsShortText() {
-        return getAsShortText(null);
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Returns the difference between this field property instant and the one
-     * passed in, in the units of this field. The sign of the difference
-     * matches that of compareTo. In other words, this field property's instant
-     * is the minuend.
-     *
-     * @param instant the subtrahend
-     * @return the difference in the units of this field
-     * @see DateTimeField#getDifference
-     */
-    public int getDifference(ReadableInstant instant) {
-        if (instant == null) {
-            throw new IllegalArgumentException("The instant must not be null");
-        }
-        return getField().getDifference(getInstant().getMillis(), instant.getMillis());
-    }
-
-    /**
-     * Returns the difference between this field property instant and the one
-     * passed in, in the units of this field. The sign of the difference
-     * matches that of compareTo. In other words, this field property's instant
-     * is the minuend.
-     *
-     * @param instant the subtrahend
-     * @return the difference in the units of this field
-     * @see DateTimeField#getDifference
-     */
-    public long getDifferenceAsLong(ReadableInstant instant) {
-        if (instant == null) {
-            throw new IllegalArgumentException("The instant must not be null");
-        }
-        return getField().getDifferenceAsLong(getInstant().getMillis(), instant.getMillis());
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Returns the duration per unit value of this field. For example, if this
-     * field represents "hour of day", then the duration is an hour.
-     *
-     * @return the duration of this field, or UnsupportedDurationField
-     */
-    public DurationField getDurationField() {
-        return getField().getDurationField();
-    }
-
-    /**
-     * Returns the range duration of this field. For example, if this field
-     * represents "hour of day", then the range duration is a day.
-     *
-     * @return the range duration of this field, or null if field has no range
-     */
-    public DurationField getRangeDurationField() {
-        return getField().getRangeDurationField();
-    }
-
-    /**
-     * Gets whether this field is leap.
-     * 
-     * @return true if a leap field
-     * @see DateTimeField#isLeap
-     */
-    public boolean isLeap() {
-        return getField().isLeap(getInstant().getMillis());
-    }
-
-    /**
-     * Gets the amount by which this field is leap.
-     * 
-     * @return the amount by which the field is leap
-     * @see DateTimeField#getLeapAmount
-     */
-    public int getLeapAmount() {
-        return getField().getLeapAmount(getInstant().getMillis());
-    }
-
-    /**
-     * If this field were to leap, then it would be in units described by the
-     * returned duration. If this field doesn't ever leap, null is returned.
-     */
-    public DurationField getLeapDurationField() {
-        return getField().getLeapDurationField();
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Gets the minimum value for the field ignoring the current time.
-     * 
-     * @return the minimum value
-     * @see DateTimeField#getMinimumValue
-     */
-    public int getMinimumValueOverall() {
-        return getField().getMinimumValue();
-    }
-
-    /**
-     * Gets the minimum value for the field.
-     * 
-     * @return the minimum value
-     * @see DateTimeField#getMinimumValue
-     */
-    public int getMinimumValue() {
-        return getField().getMinimumValue(getInstant().getMillis());
-    }
-
-    /**
-     * Gets the maximum value for the field ignoring the current time.
-     * 
-     * @return the maximum value
-     * @see DateTimeField#getMaximumValue
-     */
-    public int getMaximumValueOverall() {
-        return getField().getMaximumValue();
-    }
-
-    /**
-     * Gets the maximum value for the field.
-     * 
-     * @return the maximum value
-     * @see DateTimeField#getMaximumValue
-     */
-    public int getMaximumValue() {
-        return getField().getMaximumValue(getInstant().getMillis());
-    }
-
-    /**
-     * Gets the maximum text length for the field.
-     * 
-     * @param locale  optional locale to use for selecting a text symbol
-     * @return the maximum length
-     * @see DateTimeField#getMaximumTextLength
-     */
-    public int getMaximumTextLength(Locale locale) {
-        return getField().getMaximumTextLength(locale);
-    }
-
-    /**
-     * Gets the maximum short text length for the field.
-     * 
-     * @param locale  optional locale to use for selecting a text symbol
-     * @return the maximum length
-     * @see DateTimeField#getMaximumShortTextLength
-     */
-    public int getMaximumShortTextLength(Locale locale) {
-        return getField().getMaximumShortTextLength(locale);
-    }
-
-
-    /**
-     * Returns the fractional duration milliseconds of this field.
-     *
-     * @see DateTimeField#remainder
-     * @return remainder duration, in milliseconds
-     */
-    public long remainder() {
-        return getField().remainder(getInstant().getMillis());
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Compare this field to the same field on another instant.
-     * <p>
-     * The {@link #get()} method is used to obtain the value to compare for
-     * this instant and the {@link ReadableInstant#get(DateTimeField)} method
-     * is used for the specified instant.
-     * 
-     * @param instant  the instant to compare to
-     * @return negative value if this is less, 0 if equal, or positive value if greater
-     * @throws IllegalArgumentException if the instant is null
-     */
-    public int compareTo(ReadableDateTime instant) {
-        if (instant == null) {
-            throw new IllegalArgumentException("The instant must not be null");
-        }
-        int thisValue = get();
-        int otherValue = instant.get(getField());
-        if (thisValue < otherValue) {
-            return -1;
-        } else if (thisValue > otherValue) {
-            return 1;
-        } else {
-            return 0;
-        }
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Output a debugging string.
-     * 
-     * @return debugging string
-     */
-    public String toString() {
-        return "Property[" + getName() + "]";
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/DateTimeFieldProperty.java b/JodaTime/src/java/org/joda/time/DateTimeFieldProperty.java
deleted file mode 100644
index 79af26ca7..000000000
--- a/JodaTime/src/java/org/joda/time/DateTimeFieldProperty.java
+++ /dev/null
@@ -1,299 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-03 Stephen Colebourne.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time;
-
-import java.util.Locale;
-
-/**
- * DateTimeFieldProperty binds a DateTime to a DateTimeField allowing powerful
- * datetime functionality to be easily accessed.
- * <p>
- * The simplest use of this class is as an alternative get method, here used to
- * get the year '1972' (as an int) and the month 'December' (as a String).
- * <pre>
- * DateTime dt = new DateTime(1972, 12, 3, 0, 0, 0, 0);
- * int year = dt.year().get();
- * String monthStr = dt.month().getAsText();
- * </pre>
- * <p>
- * Methods are also provided that allow date modification. These return new instances
- * of DateTime - they do not modify the original. The example below yields two
- * independent immutable date objects 20 years apart.
- * <pre>
- * DateTime dt = new DateTime(1972, 12, 3, 0, 0, 0, 0);
- * DateTime dt20 = dt.year().addToCopy(20);
- * </pre>
- * Serious modification of dates (ie. more than just changing one or two fields)
- * should use the {@link MutableDateTime} class.
- * <p>
- * DateTimeFieldPropery itself is thread-safe and immutable, as well as the
- * DateTime being operated on.
- *
- * @see ReadableInstant
- * @see DateTimeField
- * 
- * @author Stephen Colebourne
- * @author Brian S O'Neill
- * @since 1.0
- */
-public class DateTimeFieldProperty extends AbstractDateTimeFieldProperty {
-    
-    static final long serialVersionUID = -6983323811635733510L;
-
-    /** The instant this property is working against */
-    private final DateTime iInstant;
-    /** The field this property is working against */
-    private final DateTimeField iField;
-
-    /**
-     * Constructor.
-     * 
-     * @param instant  the instant to set
-     * @param field  the field to use
-     */
-    public DateTimeFieldProperty(DateTime instant, DateTimeField field) {
-        super();
-        iInstant = instant;
-        iField = field;
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Gets the field being used.
-     * 
-     * @return the field
-     */
-    public DateTimeField getField() {
-        return iField;
-    }
-
-    /**
-     * Gets the instant being used.
-     * 
-     * @return the instant
-     */
-    public ReadableDateTime getInstant() {
-        return iInstant;
-    }
-
-    /**
-     * Gets the instant being used.
-     * 
-     * @return the instant
-     */
-    public DateTime getDateTime() {
-        return iInstant;
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Adds to this field in a copy of this DateTime.
-     * <p>
-     * The DateTime attached to this property is unchanged by this call.
-     * This operation is faster than converting a DateTime to a MutableDateTime
-     * and back again when setting one field. When setting multiple fields,
-     * it is generally quicker to make the conversion to MutableDateTime.
-     * 
-     * @param value  the value to add to the field in the copy
-     * @return a copy of the DateTime with the field value changed
-     * @throws IllegalArgumentException if the value isn't valid
-     */
-    public DateTime addToCopy(int value) {
-        long newMillis = iField.add(iInstant.getMillis(), value);
-        return iInstant.createDateTime(newMillis, iInstant.getChronology());
-    }
-
-    /**
-     * Adds to this field in a copy of this DateTime.
-     * <p>
-     * The DateTime attached to this property is unchanged by this call.
-     * This operation is faster than converting a DateTime to a MutableDateTime
-     * and back again when setting one field. When setting multiple fields,
-     * it is generally quicker to make the conversion to MutableDateTime.
-     * 
-     * @param value  the value to add to the field in the copy
-     * @return a copy of the DateTime with the field value changed
-     * @throws IllegalArgumentException if the value isn't valid
-     */
-    public DateTime addToCopy(long value) {
-        long newMillis = iField.add(iInstant.getMillis(), value);
-        return iInstant.createDateTime(newMillis, iInstant.getChronology());
-    }
-
-    /**
-     * Adds to this field, possibly wrapped, in a copy of this DateTime.
-     * A wrapped operation only changes this field.
-     * Thus 31st January addWrapped one day goes to the 1st January.
-     * <p>
-     * The DateTime attached to this property is unchanged by this call.
-     * This operation is faster than converting a DateTime to a MutableDateTime
-     * and back again when setting one field. When setting multiple fields,
-     * it is generally quicker to make the conversion to MutableDateTime.
-     * 
-     * @param value  the value to add to the field in the copy
-     * @return a copy of the DateTime with the field value changed
-     * @throws IllegalArgumentException if the value isn't valid
-     */
-    public DateTime addWrappedToCopy(int value) {
-        long newMillis = iField.addWrapped(iInstant.getMillis(), value);
-        return iInstant.createDateTime(newMillis, iInstant.getChronology());
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Sets this field in a copy of the DateTime.
-     * <p>
-     * The DateTime attached to this property is unchanged by this call.
-     * This operation is faster than converting a DateTime to a MutableDateTime
-     * and back again when setting one field. When setting multiple fields,
-     * it is generally quicker to make the conversion to MutableDateTime.
-     * 
-     * @param value  the value to set the field in the copy to
-     * @return a copy of the DateTime with the field value changed
-     * @throws IllegalArgumentException if the value isn't valid
-     */
-    public DateTime setCopy(int value) {
-        long newMillis = iField.set(iInstant.getMillis(), value);
-        return iInstant.createDateTime(newMillis, iInstant.getChronology());
-    }
-    
-    /**
-     * Sets this field in a copy of the DateTime to a parsed text value.
-     * <p>
-     * The DateTime attached to this property is unchanged by this call.
-     * This operation is faster than converting a DateTime to a MutableDateTime
-     * and back again when setting one field. When setting multiple fields,
-     * it is generally quicker to make the conversion to MutableDateTime.
-     * 
-     * @param text  the text value to set
-     * @param locale  optional locale to use for selecting a text symbol
-     * @return a copy of the DateTime with the field value changed
-     * @throws IllegalArgumentException if the text value isn't valid
-     */
-    public DateTime setCopy(String text, Locale locale) {
-        long newMillis = iField.set(iInstant.getMillis(), text, locale);
-        return iInstant.createDateTime(newMillis, iInstant.getChronology());
-    }
-
-    /**
-     * Sets this field in a copy of the DateTime to a parsed text value.
-     * <p>
-     * The DateTime attached to this property is unchanged by this call.
-     * This operation is faster than converting a DateTime to a MutableDateTime
-     * and back again when setting one field. When setting multiple fields,
-     * it is generally quicker to make the conversion to MutableDateTime.
-     * 
-     * @param text  the text value to set
-     * @return a copy of the DateTime with the field value changed
-     * @throws IllegalArgumentException if the text value isn't valid
-     */
-    public final DateTime setCopy(String text) {
-        return setCopy(text, null);
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Rounds to the lowest whole unit of this field on a copy of this DateTime.
-     *
-     * @return a copy of the DateTime with the field value changed
-     */
-    public DateTime roundFloorCopy() {
-        long newMillis = iField.roundFloor(iInstant.getMillis());
-        return iInstant.createDateTime(newMillis, iInstant.getChronology());
-    }
-
-    /**
-     * Rounds to the highest whole unit of this field on a copy of this DateTime.
-     *
-     * @return a copy of the DateTime with the field value changed
-     */
-    public DateTime roundCeilingCopy() {
-        long newMillis = iField.roundCeiling(iInstant.getMillis());
-        return iInstant.createDateTime(newMillis, iInstant.getChronology());
-    }
-
-    /**
-     * Rounds to the nearest whole unit of this field on a copy of this DateTime,
-     * favoring the floor if halfway.
-     *
-     * @return a copy of the DateTime with the field value changed
-     */
-    public DateTime roundHalfFloorCopy() {
-        long newMillis = iField.roundHalfFloor(iInstant.getMillis());
-        return iInstant.createDateTime(newMillis, iInstant.getChronology());
-    }
-
-    /**
-     * Rounds to the nearest whole unit of this field on a copy of this DateTime,
-     * favoring the ceiling if halfway.
-     *
-     * @return a copy of the DateTime with the field value changed
-     */
-    public DateTime roundHalfCeilingCopy() {
-        long newMillis = iField.roundHalfCeiling(iInstant.getMillis());
-        return iInstant.createDateTime(newMillis, iInstant.getChronology());
-    }
-
-    /**
-     * Rounds to the nearest whole unit of this field on a copy of this DateTime.
-     * If halfway, the ceiling is favored over the floor only if it makes this field's value even.
-     *
-     * @return a copy of the DateTime with the field value changed
-     */
-    public DateTime roundHalfEvenCopy() {
-        long newMillis = iField.roundHalfEven(iInstant.getMillis());
-        return iInstant.createDateTime(newMillis, iInstant.getChronology());
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/MutableDateTimeFieldProperty.java b/JodaTime/src/java/org/joda/time/MutableDateTimeFieldProperty.java
deleted file mode 100644
index ffea8adb4..000000000
--- a/JodaTime/src/java/org/joda/time/MutableDateTimeFieldProperty.java
+++ /dev/null
@@ -1,244 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-03 Stephen Colebourne.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time;
-
-import java.util.Locale;
-
-/**
- * MutableDateTimeFieldProperty binds a MutableDateTime to a DateTimeField
- * allowing powerful datetime functionality to be easily accessed.
- * <p>
- * The example below shows how to use the property to change the value of a
- * MutableDateTime object.
- * <pre>
- * MutableDateTime dt = new MutableDateTime(1972, 12, 3, 0, 0, 0, 0);
- * dt.year().add(20);
- * dt.second().roundFloor();
- * dt.minute().set(10);
- * </pre>
- * <p>
- * MutableDateTimeFieldPropery itself is thread-safe and immutable, but the
- * MutableDateTime being operated on may not be thread-safe.
- *
- * @see ReadWritableInstant
- * @see DateTimeField
- * 
- * @author Stephen Colebourne
- * @author Brian S O'Neill
- * @since 1.0
- */
-public class MutableDateTimeFieldProperty extends AbstractDateTimeFieldProperty {
-
-    static final long serialVersionUID = -4481126543819298617L;
-
-    /** The instant this property is working against */
-    private final MutableDateTime iInstant;
-    /** The field this property is working against */
-    private final DateTimeField iField;
-
-    /**
-     * Constructor.
-     * 
-     * @param instant  the instant to set
-     * @param field  the field to use
-     */
-    public MutableDateTimeFieldProperty(MutableDateTime instant, DateTimeField field) {
-        super();
-        iInstant = instant;
-        iField = field;
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Gets the field being used.
-     * 
-     * @return the field
-     */
-    public DateTimeField getField() {
-        return iField;
-    }
-
-    /**
-     * Gets the instant being used.
-     * 
-     * @return the instant
-     */
-    public ReadableDateTime getInstant() {
-        return iInstant;
-    }
-
-    /**
-     * Gets the instant being used.
-     * 
-     * @return the instant
-     */
-    public MutableDateTime getMutableDateTime() {
-        return iInstant;
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Adds a value to the millis value.
-     * 
-     * @param value  the value to add
-     * @see DateTimeField#add(long,int)
-     */
-    public void add(int value) {
-        iInstant.setMillis(getField().add(iInstant.getMillis(), value));
-    }
-
-    /**
-     * Adds a value to the millis value.
-     * 
-     * @param value  the value to add
-     * @see DateTimeField#add(long,long)
-     */
-    public void add(long value) {
-        iInstant.setMillis(getField().add(iInstant.getMillis(), value));
-    }
-
-    /**
-     * Adds a value, possibly wrapped, to the millis value.
-     * 
-     * @param value  the value to add
-     * @see DateTimeField#addWrapped
-     */
-    public void addWrapped(int value) {
-        iInstant.setMillis(getField().addWrapped(iInstant.getMillis(), value));
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Sets a value.
-     * 
-     * @param value  the value to set.
-     * @see DateTimeField#set(long,int)
-     */
-    public void set(int value) {
-        iInstant.setMillis(getField().set(iInstant.getMillis(), value));
-    }
-
-    /**
-     * Sets a text value.
-     * 
-     * @param text  the text value to set
-     * @param locale  optional locale to use for selecting a text symbol
-     * @throws IllegalArgumentException if the text value isn't valid
-     * @see DateTimeField#set(long,java.lang.String,java.util.Locale)
-     */
-    public void set(String text, Locale locale) {
-        iInstant.setMillis(getField().set(iInstant.getMillis(), text, locale));
-    }
-
-    /**
-     * Sets a text value.
-     * 
-     * @param text  the text value to set
-     * @throws IllegalArgumentException if the text value isn't valid
-     * @see DateTimeField#set(long,java.lang.String)
-     */
-    public final void set(String text) {
-        set(text, null);
-    }
-
-    //-----------------------------------------------------------------------
-    /**
-     * Round to the lowest whole unit of this field.
-     *
-     * @see DateTimeField#roundFloor
-     */
-    public void roundFloor() {
-        iInstant.setMillis(getField().roundFloor(iInstant.getMillis()));
-    }
-
-    /**
-     * Round to the highest whole unit of this field.
-     *
-     * @see DateTimeField#roundCeiling
-     */
-    public void roundCeiling() {
-        iInstant.setMillis(getField().roundCeiling(iInstant.getMillis()));
-    }
-
-    /**
-     * Round to the nearest whole unit of this field, favoring the floor if
-     * halfway.
-     *
-     * @see DateTimeField#roundHalfFloor
-     */
-    public void roundHalfFloor() {
-        iInstant.setMillis(getField().roundHalfFloor(iInstant.getMillis()));
-    }
-
-    /**
-     * Round to the nearest whole unit of this field, favoring the ceiling if
-     * halfway.
-     *
-     * @see DateTimeField#roundHalfCeiling
-     */
-    public void roundHalfCeiling() {
-        iInstant.setMillis(getField().roundHalfCeiling(iInstant.getMillis()));
-    }
-
-    /**
-     * Round to the nearest whole unit of this field. If halfway, the ceiling
-     * is favored over the floor only if it makes this field's value even.
-     *
-     * @see DateTimeField#roundHalfEven
-     */
-    public void roundHalfEven() {
-        iInstant.setMillis(getField().roundHalfEven(iInstant.getMillis()));
-    }
-
-}

From a5de35caa131cfcf72d2c34cce18fb939fab66b7 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 3 Jan 2004 02:25:33 +0000
Subject: [PATCH 072/143] Support properties.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@77 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/DateOnly.java | 136 +++++++------
 JodaTime/src/java/org/joda/time/TimeOnly.java | 189 +++++++++++++-----
 2 files changed, 220 insertions(+), 105 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/DateOnly.java b/JodaTime/src/java/org/joda/time/DateOnly.java
index 9df6fb7c7..a46003e1f 100644
--- a/JodaTime/src/java/org/joda/time/DateOnly.java
+++ b/JodaTime/src/java/org/joda/time/DateOnly.java
@@ -59,8 +59,18 @@
 // Import for @link support
 import org.joda.time.convert.ConverterManager;
 import org.joda.time.format.ISODateTimeFormat;
+import org.joda.time.property.DateOnlyFieldProperty;
 
-/*
+/**
+ * DateOnly is the basic implementation of a date only class supporting
+ * chronologies. It holds the date as milliseconds from the Java epoch of
+ * 1970-01-01. The time component and time zone is fixed at T00:00:00Z.
+ * <p>
+ * This class uses a Chronology internally. The Chronology determines how the
+ * millisecond instant value is converted into the date time fields.
+ * The default Chronology is <code>ISOChronology</code> which is the agreed
+ * international standard and compatable with the modern Gregorian calendar.
+ *
  * <p>Each individual field can be queried in two ways:
  * <ul>
  * <li><code>getYear()</code>
@@ -75,12 +85,6 @@
  * <li>maximum value
  * <li>minimum value
  * </ul>
- */
-
-/**
- * DateOnly is the basic implementation of a date only class supporting
- * chronologies. It holds the date as milliseconds from the Java epoch of
- * 1970-01-01. The time component and time zone is fixed at T00:00:00Z.
  * <p>
  * DateOnly is thread-safe and immutable, provided that the Chronology is as
  * well. All standard Chronology classes supplied are thread-safe and
@@ -89,6 +93,7 @@
  * @author Stephen Colebourne
  * @author Brian S O'Neill
  * @since 1.0
+ * @see MutableDateOnly
  * @see TimeOnly
  * @see DateTime
  */
@@ -214,6 +219,40 @@ public DateOnly(
               chronology);
     }
 
+    /**
+     * Gets a copy of this instant with different millis.
+     * <p>
+     * The returned object will be a new instance of the same implementation type.
+     * Only the millis will change, the chronology is kept.
+     * Immutable subclasses may return <code>this</code> if appropriate.
+     *
+     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
+     * @return a copy of this instant with different millis
+     */
+    public ReadableInstant toCopy(long newMillis) {
+        newMillis = resetUnsupportedFields(newMillis);
+        return newMillis == getMillis() ? this : new DateOnly(newMillis, getChronology());
+    }
+    
+    /**
+     * Gets a copy of this instant with a different chronology.
+     * <p>
+     * The returned object will be a new instance of the same implementation type.
+     * Only the chronology will change, the millis are kept.
+     * Immutable subclasses may return <code>this</code> if appropriate.
+     *
+     * @param newChronology  the new chronology
+     * @return a copy of this instant with a different chronology
+     * @throws IllegalArgumentException if the chronology is null
+     */
+    public ReadableInstant toCopy(Chronology newChronology) {
+        if (newChronology == null) {
+            throw new IllegalArgumentException("The Chronology must not be null");
+        }
+        newChronology = newChronology.withUTC();
+        return newChronology == getChronology() ? this : new DateOnly(getMillis(), newChronology);
+    }
+
     /**
      * Returns the lower limiting field, dayOfYear.
      *
@@ -232,10 +271,6 @@ public final DateTimeField getUpperLimit() {
         return null;
     }
 
-    public final boolean isMatchingType(ReadableInstant instant) {
-        return instant instanceof DateOnly;
-    }
-
     // Date field access
     //-----------------------------------------------------------------------
     /**
@@ -341,8 +376,6 @@ public final int getDayOfWeek() {
         return getChronology().dayOfWeek().get(getMillis());
     }
 
-    // TODO: DateTimeFieldProperty cannot be constructed with anything but
-    // DateTime.
 
     // Properties
     //-----------------------------------------------------------------------
@@ -352,101 +385,100 @@ public final int getDayOfWeek() {
      * The values for day of week are defined in {@link DateTimeConstants}.
      * 
      * @return the day of week property
-     * /
-    public final DateTimeFieldProperty dayOfWeek() {
-        return new DateTimeFieldProperty(this, getChronology().dayOfWeek());
+     */
+    public final DateOnlyFieldProperty dayOfWeek() {
+        return new DateOnlyFieldProperty(this, getChronology().dayOfWeek());
     }
 
     /**
      * Get the day of month property.
      * 
      * @return the day of month property
-     * /
-    public final DateTimeFieldProperty dayOfMonth() {
-        return new DateTimeFieldProperty(this, getChronology().dayOfMonth());
+     */
+    public final DateOnlyFieldProperty dayOfMonth() {
+        return new DateOnlyFieldProperty(this, getChronology().dayOfMonth());
     }
 
     /**
      * Get the day of year property.
      * 
      * @return the day of year property
-     * /
-    public final DateTimeFieldProperty dayOfYear() {
-        return new DateTimeFieldProperty(this, getChronology().dayOfYear());
+     */
+    public final DateOnlyFieldProperty dayOfYear() {
+        return new DateOnlyFieldProperty(this, getChronology().dayOfYear());
     }
 
     /**
      * Get the week of a week based year property.
      * 
      * @return the week of a week based year property
-     * /
-    public final DateTimeFieldProperty weekOfWeekyear() {
-        return new DateTimeFieldProperty(this, getChronology().weekOfWeekyear());
+     */
+    public final DateOnlyFieldProperty weekOfWeekyear() {
+        return new DateOnlyFieldProperty(this, getChronology().weekOfWeekyear());
     }
 
     /**
      * Get the year of a week based year property.
      * 
      * @return the year of a week based year property
-     * /
-    public final DateTimeFieldProperty weekyear() {
-        return new DateTimeFieldProperty(this, getChronology().weekyear());
+     */
+    public final DateOnlyFieldProperty weekyear() {
+        return new DateOnlyFieldProperty(this, getChronology().weekyear());
     }
 
     /**
      * Get the month of year property.
      * 
      * @return the month of year property
-     * /
-    public final DateTimeFieldProperty monthOfYear() {
-        return new DateTimeFieldProperty(this, getChronology().monthOfYear());
+     */
+    public final DateOnlyFieldProperty monthOfYear() {
+        return new DateOnlyFieldProperty(this, getChronology().monthOfYear());
     }
 
     /**
      * Get the year property.
      * 
      * @return the year property
-     * /
-    public final DateTimeFieldProperty year() {
-        return new DateTimeFieldProperty(this, getChronology().year());
+     */
+    public final DateOnlyFieldProperty year() {
+        return new DateOnlyFieldProperty(this, getChronology().year());
     }
 
     /**
      * Get the year of era property.
      * 
      * @return the year of era property
-     * /
-    public final DateTimeFieldProperty yearOfEra() {
-        return new DateTimeFieldProperty(this, getChronology().yearOfEra());
+     */
+    public final DateOnlyFieldProperty yearOfEra() {
+        return new DateOnlyFieldProperty(this, getChronology().yearOfEra());
     }
 
     /**
      * Get the year of century property.
      * 
      * @return the year of era property
-     * /
-    public final DateTimeFieldProperty yearOfCentury() {
-        return new DateTimeFieldProperty(this, getChronology().yearOfCentury());
+     */
+    public final DateOnlyFieldProperty yearOfCentury() {
+        return new DateOnlyFieldProperty(this, getChronology().yearOfCentury());
     }
 
     /**
      * Get the century of era property.
      * 
      * @return the year of era property
-     * /
-    public final DateTimeFieldProperty centuryOfEra() {
-        return new DateTimeFieldProperty(this, getChronology().centuryOfEra());
+     */
+    public final DateOnlyFieldProperty centuryOfEra() {
+        return new DateOnlyFieldProperty(this, getChronology().centuryOfEra());
     }
 
     /**
      * Get the era property.
      * 
      * @return the era property
-     * /
-    public final DateTimeFieldProperty era() {
-        return new DateTimeFieldProperty(this, getChronology().era());
+     */
+    public final DateOnlyFieldProperty era() {
+        return new DateOnlyFieldProperty(this, getChronology().era());
     }
-    */
 
     // Output
     //-----------------------------------------------------------------------
@@ -459,16 +491,6 @@ public final String toString() {
         return ISODateTimeFormat.getInstance(getChronology()).date().print(getMillis());
     }
 
-    protected ReadableInstant create(long millis, Chronology chronology) {
-        if (chronology == null) {
-            throw new IllegalArgumentException("The Chronology must not be null");
-        }
-        if (millis == getMillis() && chronology == getChronology()) {
-            return this;
-        }
-        return new DateOnly(millis, chronology);
-    }
-
     /**
      * Overridden to do nothing, ensuring this class and all subclasses are
      * immutable.
diff --git a/JodaTime/src/java/org/joda/time/TimeOnly.java b/JodaTime/src/java/org/joda/time/TimeOnly.java
index 7182a0698..6aeff9596 100644
--- a/JodaTime/src/java/org/joda/time/TimeOnly.java
+++ b/JodaTime/src/java/org/joda/time/TimeOnly.java
@@ -59,8 +59,18 @@
 // Import for @link support
 import org.joda.time.convert.ConverterManager;
 import org.joda.time.format.ISODateTimeFormat;
+import org.joda.time.property.TimeOnlyFieldProperty;
 
-/*
+/**
+ * TimeOnly is the basic implementation of a time only class supporting
+ * chronologies. It holds the time as milliseconds from T00:00:00. The date
+ * component and time zone is fixed at 1970-01-01TZ.
+ * <p>
+ * This class uses a Chronology internally. The Chronology determines how the
+ * millisecond instant value is converted into the date time fields.
+ * The default Chronology is <code>ISOChronology</code> which is the agreed
+ * international standard and compatable with the modern Gregorian calendar.
+ *
  * <p>Each individual field can be queried in two ways:
  * <ul>
  * <li><code>getHourOfDay()</code>
@@ -75,12 +85,6 @@
  * <li>maximum value
  * <li>minimum value
  * </ul>
- */
-
-/**
- * TimeOnly is the basic implementation of a time only class supporting
- * chronologies. It holds the time as milliseconds from T00:00:00. The date
- * component and time zone is fixed at 1970-01-01TZ.
  * <p>
  * TimeOnly is thread-safe and immutable, provided that the Chronology is as
  * well. All standard Chronology classes supplied are thread-safe and
@@ -89,6 +93,7 @@
  * @author Stephen Colebourne
  * @author Brian S O'Neill
  * @since 1.0
+ * @see MutableTimeOnly
  * @see DateOnly
  * @see DateTime
  */
@@ -218,6 +223,40 @@ public TimeOnly(
               chronology);
     }
 
+    /**
+     * Gets a copy of this instant with different millis.
+     * <p>
+     * The returned object will be a new instance of the same implementation type.
+     * Only the millis will change, the chronology is kept.
+     * Immutable subclasses may return <code>this</code> if appropriate.
+     *
+     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
+     * @return a copy of this instant with different millis
+     */
+    public ReadableInstant toCopy(long newMillis) {
+        newMillis = resetUnsupportedFields(newMillis);
+        return newMillis == getMillis() ? this : new TimeOnly(newMillis, getChronology());
+    }
+    
+    /**
+     * Gets a copy of this instant with a different chronology.
+     * <p>
+     * The returned object will be a new instance of the same implementation type.
+     * Only the chronology will change, the millis are kept.
+     * Immutable subclasses may return <code>this</code> if appropriate.
+     *
+     * @param newChronology  the new chronology
+     * @return a copy of this instant with a different chronology
+     * @throws IllegalArgumentException if the chronology is null
+     */
+    public ReadableInstant toCopy(Chronology newChronology) {
+        if (newChronology == null) {
+            throw new IllegalArgumentException("The Chronology must not be null");
+        }
+        newChronology = newChronology.withUTC();
+        return newChronology == getChronology() ? this : new TimeOnly(getMillis(), newChronology);
+    }
+
     /**
      * Returns the lower limiting field, null.
      *
@@ -236,14 +275,10 @@ public final DateTimeField getUpperLimit() {
         return getChronology().dayOfYear();
     }
 
-    public final boolean isMatchingType(ReadableInstant instant) {
-        return instant instanceof TimeOnly;
-    }
-
     // Time field access
     //-----------------------------------------------------------------------
     /**
-     * Get the hour of day field value.
+     * Get the hour of day (0-23) field value.
      *
      * @return the hour of day
      */
@@ -251,6 +286,42 @@ public final int getHourOfDay() {
         return getChronology().hourOfDay().get(getMillis());
     }
 
+    /**
+     * Get the hour of day (offset to 1-24) field value.
+     * 
+     * @return the clockhour of day
+     */
+    public final int getClockhourOfDay() {
+        return getChronology().clockhourOfDay().get(getMillis());
+    }
+
+    /**
+     * Get the hour of am/pm (0-11) field value.
+     * 
+     * @return the hour of halfday
+     */
+    public final int getHourOfHalfday() {
+        return getChronology().hourOfHalfday().get(getMillis());
+    }
+
+    /**
+     * Get the hour of am/pm (offset to 1-12) field value.
+     * 
+     * @return the clockhour of halfday
+     */
+    public final int getClockhourOfHalfday() {
+        return getChronology().clockhourOfHalfday().get(getMillis());
+    }
+
+    /**
+     * Get the AM(0) PM(1) field value.
+     * 
+     * @return the halfday of day
+     */
+    public final int getHalfdayOfDay() {
+        return getChronology().halfdayOfDay().get(getMillis());
+    }
+
     /**
      * Get the minute of day field value.
      *
@@ -305,74 +376,106 @@ public final int getMillisOfSecond() {
         return getChronology().millisOfSecond().get(getMillis());
     }
 
-    // TODO: DateTimeFieldProperty cannot be constructed with anything but
-    // DateTime.
-
     // Properties
     //-----------------------------------------------------------------------
     /**
-     * Get the hour of day field property
+     * Get the hour of day (0-23) field property
      * 
      * @return the hour of day property
-     * /
-    public final DateTimeFieldProperty hourOfDay() {
-        return new DateTimeFieldProperty(this, getChronology().hourOfDay());
+     */
+    public final TimeOnlyFieldProperty hourOfDay() {
+        return new TimeOnlyFieldProperty(this, getChronology().hourOfDay());
+    }
+
+    /**
+     * Get the hour of day (offset to 1-24) field property
+     * 
+     * @return the clockhour of day property
+     */
+    public final TimeOnlyFieldProperty clockhourOfDay() {
+        return new TimeOnlyFieldProperty(this, getChronology().clockhourOfDay());
+    }
+
+    /**
+     * Get the hour of am/pm (0-11) field property
+     * 
+     * @return the hour of halfday property
+     */
+    public final TimeOnlyFieldProperty hourOfHalfday() {
+        return new TimeOnlyFieldProperty(this, getChronology().hourOfHalfday());
+    }
+
+    /**
+     * Get the hour of am/pm (offset to 1-12) field property
+     * 
+     * @return the clockhour of halfday property
+     */
+    public final TimeOnlyFieldProperty clockhourOfHalfday() {
+        return new TimeOnlyFieldProperty(this, getChronology().clockhourOfHalfday());
+    }
+
+    /**
+     * Get the AM(0) PM(1) field property
+     * 
+     * @return the halfday of day property
+     */
+    public final TimeOnlyFieldProperty halfdayOfDay() {
+        return new TimeOnlyFieldProperty(this, getChronology().halfdayOfDay());
     }
 
     /**
      * Get the minute of day property
      * 
      * @return the minute of day property
-     * /
-    public final DateTimeFieldProperty minuteOfDay() {
-        return new DateTimeFieldProperty(this, getChronology().minuteOfDay());
+     */
+    public final TimeOnlyFieldProperty minuteOfDay() {
+        return new TimeOnlyFieldProperty(this, getChronology().minuteOfDay());
     }
 
     /**
      * Get the minute of hour field property
      * 
      * @return the minute of hour property
-     * /
-    public final DateTimeFieldProperty minuteOfHour() {
-        return new DateTimeFieldProperty(this, getChronology().minuteOfHour());
+     */
+    public final TimeOnlyFieldProperty minuteOfHour() {
+        return new TimeOnlyFieldProperty(this, getChronology().minuteOfHour());
     }
 
     /**
      * Get the second of day property
      * 
      * @return the second of day property
-     * /
-    public final DateTimeFieldProperty secondOfDay() {
-        return new DateTimeFieldProperty(this, getChronology().secondOfDay());
+     */
+    public final TimeOnlyFieldProperty secondOfDay() {
+        return new TimeOnlyFieldProperty(this, getChronology().secondOfDay());
     }
 
     /**
      * Get the second of minute field property
      * 
      * @return the second of minute property
-     * /
-    public final DateTimeFieldProperty secondOfMinute() {
-        return new DateTimeFieldProperty(this, getChronology().secondOfMinute());
+     */
+    public final TimeOnlyFieldProperty secondOfMinute() {
+        return new TimeOnlyFieldProperty(this, getChronology().secondOfMinute());
     }
 
     /**
      * Get the millis of day property
      * 
      * @return the millis of day property
-     * /
-    public final DateTimeFieldProperty millisOfDay() {
-        return new DateTimeFieldProperty(this, getChronology().millisOfDay());
+     */
+    public final TimeOnlyFieldProperty millisOfDay() {
+        return new TimeOnlyFieldProperty(this, getChronology().millisOfDay());
     }
 
     /**
      * Get the millis of second property
      * 
      * @return the millis of second property
-     * /
-    public final DateTimeFieldProperty millisOfSecond() {
-        return new DateTimeFieldProperty(this, getChronology().millisOfSecond());
+     */
+    public final TimeOnlyFieldProperty millisOfSecond() {
+        return new TimeOnlyFieldProperty(this, getChronology().millisOfSecond());
     }
-    */
 
     // Output
     //-----------------------------------------------------------------------
@@ -386,16 +489,6 @@ public final String toString() {
             .hourMinuteSecondFraction().print(getMillis());
     }
 
-    protected ReadableInstant create(long millis, Chronology chronology) {
-        if (chronology == null) {
-            throw new IllegalArgumentException("The Chronology must not be null");
-        }
-        if (millis == getMillis() && chronology == getChronology()) {
-            return this;
-        }
-        return new TimeOnly(millis, chronology);
-    }
-    
     /**
      * Overridden to do nothing, ensuring this class and all subclasses are
      * immutable.

From 31c46e10acddd02e88628b82144993b237cfab1b Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 3 Jan 2004 02:25:44 +0000
Subject: [PATCH 073/143] Property support.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@78 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../time/property/DateOnlyFieldProperty.java  | 299 ++++++++++++++++++
 .../time/property/TimeOnlyFieldProperty.java  | 299 ++++++++++++++++++
 2 files changed, 598 insertions(+)
 create mode 100644 JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java
 create mode 100644 JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java

diff --git a/JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java b/JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java
new file mode 100644
index 000000000..94518b294
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java
@@ -0,0 +1,299 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-04 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.property;
+
+import java.util.Locale;
+import org.joda.time.DateOnly;
+import org.joda.time.DateTimeField;
+// Import for @link support
+import org.joda.time.MutableDateOnly;
+import org.joda.time.ReadableInstant;
+
+/**
+ * DateOnlyFieldProperty binds a DateOnly to a DateTimeField allowing powerful
+ * date functionality to be easily accessed.
+ * <p>
+ * The simplest use of this class is as an alternative get method, here used to
+ * get the year '1972' (as an int) and the month 'December' (as a String).
+ * <pre>
+ * DateOnly date = new DateOnly(1972, 12, 3);
+ * int year = date.year().get();
+ * String monthStr = date.month().getAsText();
+ * </pre>
+ * <p>
+ * Methods are also provided that allow date modification. These return new instances
+ * of DateOnly - they do not modify the original. The example below yields two
+ * independent immutable date objects 20 years apart.
+ * <pre>
+ * DateOnly date = new DateOnly(1972, 12, 3);
+ * DateOnly date20 = date.year().addToCopy(20);
+ * </pre>
+ * Serious modification of dates (ie. more than just changing one or two fields)
+ * should use the {@link MutableDateOnly} class.
+ * <p>
+ * DateOnlyFieldPropery itself is thread-safe and immutable, as well as the
+ * DateOnly being operated on.
+ *
+ * @author Brian S O'Neill
+ */
+public class DateOnlyFieldProperty extends AbstractDateTimeFieldProperty {
+
+    static final long serialVersionUID = -7764886769525930067L;
+
+    /** The instant this property is working against */
+    private final DateOnly iInstant;
+    /** The field this property is working against */
+    private final DateTimeField iField;
+
+    /**
+     * Constructor.
+     * 
+     * @param instant  the instant to set
+     * @param field  the field to use
+     */
+    public DateOnlyFieldProperty(DateOnly instant, DateTimeField field) {
+        super();
+        iInstant = instant;
+        iField = field;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the field being used.
+     * 
+     * @return the field
+     */
+    public DateTimeField getField() {
+        return iField;
+    }
+
+    /**
+     * Gets the instant being used.
+     * 
+     * @return the instant
+     */
+    public ReadableInstant getInstant() {
+        return iInstant;
+    }
+
+    /**
+     * Gets the instant being used.
+     * 
+     * @return the instant
+     */
+    public DateOnly getDateTime() {
+        return iInstant;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Adds to this field in a copy of this DateOnly.
+     * <p>
+     * The DateOnly attached to this property is unchanged by this call.
+     * This operation is faster than converting a DateOnly to a MutableDateOnly
+     * and back again when setting one field. When setting multiple fields,
+     * it is generally quicker to make the conversion to MutableDateOnly.
+     * 
+     * @param value  the value to add to the field in the copy
+     * @return a copy of the DateOnly with the field value changed
+     * @throws IllegalArgumentException if the value isn't valid
+     */
+    public DateOnly addToCopy(int value) {
+        DateOnly instant = iInstant;
+        return (DateOnly)instant.toCopy(iField.add(instant.getMillis(), value));
+    }
+
+    /**
+     * Adds to this field in a copy of this DateOnly.
+     * <p>
+     * The DateOnly attached to this property is unchanged by this call.
+     * This operation is faster than converting a DateOnly to a MutableDateOnly
+     * and back again when setting one field. When setting multiple fields,
+     * it is generally quicker to make the conversion to MutableDateOnly.
+     * 
+     * @param value  the value to add to the field in the copy
+     * @return a copy of the DateOnly with the field value changed
+     * @throws IllegalArgumentException if the value isn't valid
+     */
+    public DateOnly addToCopy(long value) {
+        DateOnly instant = iInstant;
+        return (DateOnly)instant.toCopy(iField.add(instant.getMillis(), value));
+    }
+
+    /**
+     * Adds to this field, possibly wrapped, in a copy of this DateOnly.
+     * A wrapped operation only changes this field.
+     * Thus 31st January addWrapped one day goes to the 1st January.
+     * <p>
+     * The DateOnly attached to this property is unchanged by this call.
+     * This operation is faster than converting a DateOnly to a MutableDateOnly
+     * and back again when setting one field. When setting multiple fields,
+     * it is generally quicker to make the conversion to MutableDateOnly.
+     * 
+     * @param value  the value to add to the field in the copy
+     * @return a copy of the DateOnly with the field value changed
+     * @throws IllegalArgumentException if the value isn't valid
+     */
+    public DateOnly addWrappedToCopy(int value) {
+        DateOnly instant = iInstant;
+        return (DateOnly)instant.toCopy(iField.addWrapped(instant.getMillis(), value));
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets this field in a copy of the DateOnly.
+     * <p>
+     * The DateOnly attached to this property is unchanged by this call.
+     * This operation is faster than converting a DateOnly to a MutableDateOnly
+     * and back again when setting one field. When setting multiple fields,
+     * it is generally quicker to make the conversion to MutableDateOnly.
+     * 
+     * @param value  the value to set the field in the copy to
+     * @return a copy of the DateOnly with the field value changed
+     * @throws IllegalArgumentException if the value isn't valid
+     */
+    public DateOnly setCopy(int value) {
+        DateOnly instant = iInstant;
+        return (DateOnly)instant.toCopy(iField.set(instant.getMillis(), value));
+    }
+    
+    /**
+     * Sets this field in a copy of the DateOnly to a parsed text value.
+     * <p>
+     * The DateOnly attached to this property is unchanged by this call.
+     * This operation is faster than converting a DateOnly to a MutableDateOnly
+     * and back again when setting one field. When setting multiple fields,
+     * it is generally quicker to make the conversion to MutableDateOnly.
+     * 
+     * @param text  the text value to set
+     * @param locale  optional locale to use for selecting a text symbol
+     * @return a copy of the DateOnly with the field value changed
+     * @throws IllegalArgumentException if the text value isn't valid
+     */
+    public DateOnly setCopy(String text, Locale locale) {
+        DateOnly instant = iInstant;
+        return (DateOnly)instant.toCopy(iField.set(instant.getMillis(), text, locale));
+    }
+
+    /**
+     * Sets this field in a copy of the DateOnly to a parsed text value.
+     * <p>
+     * The DateOnly attached to this property is unchanged by this call.
+     * This operation is faster than converting a DateOnly to a MutableDateOnly
+     * and back again when setting one field. When setting multiple fields,
+     * it is generally quicker to make the conversion to MutableDateOnly.
+     * 
+     * @param text  the text value to set
+     * @return a copy of the DateOnly with the field value changed
+     * @throws IllegalArgumentException if the text value isn't valid
+     */
+    public final DateOnly setCopy(String text) {
+        return setCopy(text, null);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Rounds to the lowest whole unit of this field on a copy of this DateOnly.
+     *
+     * @return a copy of the DateOnly with the field value changed
+     */
+    public DateOnly roundFloorCopy() {
+        DateOnly instant = iInstant;
+        return (DateOnly)instant.toCopy(iField.roundFloor(instant.getMillis()));
+    }
+
+    /**
+     * Rounds to the highest whole unit of this field on a copy of this DateOnly.
+     *
+     * @return a copy of the DateOnly with the field value changed
+     */
+    public DateOnly roundCeilingCopy() {
+        DateOnly instant = iInstant;
+        return (DateOnly)instant.toCopy(iField.roundCeiling(instant.getMillis()));
+    }
+
+    /**
+     * Rounds to the nearest whole unit of this field on a copy of this DateOnly,
+     * favoring the floor if halfway.
+     *
+     * @return a copy of the DateOnly with the field value changed
+     */
+    public DateOnly roundHalfFloorCopy() {
+        DateOnly instant = iInstant;
+        return (DateOnly)instant.toCopy(iField.roundHalfFloor(instant.getMillis()));
+    }
+
+    /**
+     * Rounds to the nearest whole unit of this field on a copy of this DateOnly,
+     * favoring the ceiling if halfway.
+     *
+     * @return a copy of the DateOnly with the field value changed
+     */
+    public DateOnly roundHalfCeilingCopy() {
+        DateOnly instant = iInstant;
+        return (DateOnly)instant.toCopy(iField.roundHalfCeiling(instant.getMillis()));
+    }
+
+    /**
+     * Rounds to the nearest whole unit of this field on a copy of this DateOnly.
+     * If halfway, the ceiling is favored over the floor only if it makes this field's value even.
+     *
+     * @return a copy of the DateOnly with the field value changed
+     */
+    public DateOnly roundHalfEvenCopy() {
+        DateOnly instant = iInstant;
+        return (DateOnly)instant.toCopy(iField.roundHalfEven(instant.getMillis()));
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java b/JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java
new file mode 100644
index 000000000..a6085e2b0
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java
@@ -0,0 +1,299 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-04 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.property;
+
+import java.util.Locale;
+import org.joda.time.TimeOnly;
+import org.joda.time.DateTimeField;
+// Import for @link support
+import org.joda.time.MutableTimeOnly;
+import org.joda.time.ReadableInstant;
+
+/**
+ * TimeOnlyFieldProperty binds a TimeOnly to a DateTimeField allowing powerful
+ * time functionality to be easily accessed.
+ * <p>
+ * The simplest use of this class is as an alternative get method, here used to
+ * get the clockhour '8' (as an int) and the AM/PM string.
+ * <pre>
+ * TimeOnly time = new TimeOnly(20, 30, 0);
+ * int clockhour = time.clockhourOfHalfday().get();
+ * String amPmStr = time.halfdayOfDay().getAsText();
+ * </pre>
+ * <p>
+ * Methods are also provided that allow time modification. These return new instances
+ * of TimeOnly - they do not modify the original. The example below yields two
+ * independent immutable time objects 20 minutes apart.
+ * <pre>
+ * TimeOnly time = new TimeOnly(20, 30, 0);
+ * TimeOnly time20 = time.minuteOfHour().addToCopy(20);
+ * </pre>
+ * Serious modification of times (ie. more than just changing one or two fields)
+ * should use the {@link MutableTimeOnly} class.
+ * <p>
+ * TimeOnlyFieldPropery itself is thread-safe and immutable, as well as the
+ * TimeOnly being operated on.
+ *
+ * @author Brian S O'Neill
+ */
+public class TimeOnlyFieldProperty extends AbstractDateTimeFieldProperty {
+
+    static final long serialVersionUID = 8826542069120527929L;
+
+    /** The instant this property is working against */
+    private final TimeOnly iInstant;
+    /** The field this property is working against */
+    private final DateTimeField iField;
+
+    /**
+     * Constructor.
+     * 
+     * @param instant  the instant to set
+     * @param field  the field to use
+     */
+    public TimeOnlyFieldProperty(TimeOnly instant, DateTimeField field) {
+        super();
+        iInstant = instant;
+        iField = field;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the field being used.
+     * 
+     * @return the field
+     */
+    public DateTimeField getField() {
+        return iField;
+    }
+
+    /**
+     * Gets the instant being used.
+     * 
+     * @return the instant
+     */
+    public ReadableInstant getInstant() {
+        return iInstant;
+    }
+
+    /**
+     * Gets the instant being used.
+     * 
+     * @return the instant
+     */
+    public TimeOnly getDateTime() {
+        return iInstant;
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Adds to this field in a copy of this TimeOnly.
+     * <p>
+     * The TimeOnly attached to this property is unchanged by this call.
+     * This operation is faster than converting a TimeOnly to a MutableTimeOnly
+     * and back again when setting one field. When setting multiple fields,
+     * it is generally quicker to make the conversion to MutableTimeOnly.
+     * 
+     * @param value  the value to add to the field in the copy
+     * @return a copy of the TimeOnly with the field value changed
+     * @throws IllegalArgumentException if the value isn't valid
+     */
+    public TimeOnly addToCopy(int value) {
+        TimeOnly instant = iInstant;
+        return (TimeOnly)instant.toCopy(iField.add(instant.getMillis(), value));
+    }
+
+    /**
+     * Adds to this field in a copy of this TimeOnly.
+     * <p>
+     * The TimeOnly attached to this property is unchanged by this call.
+     * This operation is faster than converting a TimeOnly to a MutableTimeOnly
+     * and back again when setting one field. When setting multiple fields,
+     * it is generally quicker to make the conversion to MutableTimeOnly.
+     * 
+     * @param value  the value to add to the field in the copy
+     * @return a copy of the TimeOnly with the field value changed
+     * @throws IllegalArgumentException if the value isn't valid
+     */
+    public TimeOnly addToCopy(long value) {
+        TimeOnly instant = iInstant;
+        return (TimeOnly)instant.toCopy(iField.add(instant.getMillis(), value));
+    }
+
+    /**
+     * Adds to this field, possibly wrapped, in a copy of this TimeOnly.
+     * A wrapped operation only changes this field.
+     * Thus 12:59:00 addWrapped one minute goes to 12:00:00.
+     * <p>
+     * The TimeOnly attached to this property is unchanged by this call.
+     * This operation is faster than converting a TimeOnly to a MutableTimeOnly
+     * and back again when setting one field. When setting multiple fields,
+     * it is generally quicker to make the conversion to MutableTimeOnly.
+     * 
+     * @param value  the value to add to the field in the copy
+     * @return a copy of the TimeOnly with the field value changed
+     * @throws IllegalArgumentException if the value isn't valid
+     */
+    public TimeOnly addWrappedToCopy(int value) {
+        TimeOnly instant = iInstant;
+        return (TimeOnly)instant.toCopy(iField.addWrapped(instant.getMillis(), value));
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Sets this field in a copy of the TimeOnly.
+     * <p>
+     * The TimeOnly attached to this property is unchanged by this call.
+     * This operation is faster than converting a TimeOnly to a MutableTimeOnly
+     * and back again when setting one field. When setting multiple fields,
+     * it is generally quicker to make the conversion to MutableTimeOnly.
+     * 
+     * @param value  the value to set the field in the copy to
+     * @return a copy of the TimeOnly with the field value changed
+     * @throws IllegalArgumentException if the value isn't valid
+     */
+    public TimeOnly setCopy(int value) {
+        TimeOnly instant = iInstant;
+        return (TimeOnly)instant.toCopy(iField.set(instant.getMillis(), value));
+    }
+    
+    /**
+     * Sets this field in a copy of the TimeOnly to a parsed text value.
+     * <p>
+     * The TimeOnly attached to this property is unchanged by this call.
+     * This operation is faster than converting a TimeOnly to a MutableTimeOnly
+     * and back again when setting one field. When setting multiple fields,
+     * it is generally quicker to make the conversion to MutableTimeOnly.
+     * 
+     * @param text  the text value to set
+     * @param locale  optional locale to use for selecting a text symbol
+     * @return a copy of the TimeOnly with the field value changed
+     * @throws IllegalArgumentException if the text value isn't valid
+     */
+    public TimeOnly setCopy(String text, Locale locale) {
+        TimeOnly instant = iInstant;
+        return (TimeOnly)instant.toCopy(iField.set(instant.getMillis(), text, locale));
+    }
+
+    /**
+     * Sets this field in a copy of the TimeOnly to a parsed text value.
+     * <p>
+     * The TimeOnly attached to this property is unchanged by this call.
+     * This operation is faster than converting a TimeOnly to a MutableTimeOnly
+     * and back again when setting one field. When setting multiple fields,
+     * it is generally quicker to make the conversion to MutableTimeOnly.
+     * 
+     * @param text  the text value to set
+     * @return a copy of the TimeOnly with the field value changed
+     * @throws IllegalArgumentException if the text value isn't valid
+     */
+    public final TimeOnly setCopy(String text) {
+        return setCopy(text, null);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Rounds to the lowest whole unit of this field on a copy of this TimeOnly.
+     *
+     * @return a copy of the TimeOnly with the field value changed
+     */
+    public TimeOnly roundFloorCopy() {
+        TimeOnly instant = iInstant;
+        return (TimeOnly)instant.toCopy(iField.roundFloor(instant.getMillis()));
+    }
+
+    /**
+     * Rounds to the highest whole unit of this field on a copy of this TimeOnly.
+     *
+     * @return a copy of the TimeOnly with the field value changed
+     */
+    public TimeOnly roundCeilingCopy() {
+        TimeOnly instant = iInstant;
+        return (TimeOnly)instant.toCopy(iField.roundCeiling(instant.getMillis()));
+    }
+
+    /**
+     * Rounds to the nearest whole unit of this field on a copy of this TimeOnly,
+     * favoring the floor if halfway.
+     *
+     * @return a copy of the TimeOnly with the field value changed
+     */
+    public TimeOnly roundHalfFloorCopy() {
+        TimeOnly instant = iInstant;
+        return (TimeOnly)instant.toCopy(iField.roundHalfFloor(instant.getMillis()));
+    }
+
+    /**
+     * Rounds to the nearest whole unit of this field on a copy of this TimeOnly,
+     * favoring the ceiling if halfway.
+     *
+     * @return a copy of the TimeOnly with the field value changed
+     */
+    public TimeOnly roundHalfCeilingCopy() {
+        TimeOnly instant = iInstant;
+        return (TimeOnly)instant.toCopy(iField.roundHalfCeiling(instant.getMillis()));
+    }
+
+    /**
+     * Rounds to the nearest whole unit of this field on a copy of this TimeOnly.
+     * If halfway, the ceiling is favored over the floor only if it makes this field's value even.
+     *
+     * @return a copy of the TimeOnly with the field value changed
+     */
+    public TimeOnly roundHalfEvenCopy() {
+        TimeOnly instant = iInstant;
+        return (TimeOnly)instant.toCopy(iField.roundHalfEven(instant.getMillis()));
+    }
+
+}

From abfd97121e4a1aa47faa67b5554892ee9f96317f Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 3 Jan 2004 02:26:19 +0000
Subject: [PATCH 074/143] Support mutable forms.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@79 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/MutableDateOnly.java   | 833 +++++++++++++++++
 .../java/org/joda/time/MutableTimeOnly.java   | 867 ++++++++++++++++++
 2 files changed, 1700 insertions(+)
 create mode 100644 JodaTime/src/java/org/joda/time/MutableDateOnly.java
 create mode 100644 JodaTime/src/java/org/joda/time/MutableTimeOnly.java

diff --git a/JodaTime/src/java/org/joda/time/MutableDateOnly.java b/JodaTime/src/java/org/joda/time/MutableDateOnly.java
new file mode 100644
index 000000000..38547916f
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/MutableDateOnly.java
@@ -0,0 +1,833 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-04 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+import java.io.Serializable;
+
+import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.convert.ConverterManager;
+import org.joda.time.convert.DurationConverter;
+import org.joda.time.format.ISODateTimeFormat;
+import org.joda.time.property.MutableDateTimeFieldProperty;
+
+/**
+ * MutableDateOnly is the basic implementation of a modifiable date only class.
+ * It holds the date as milliseconds from the Java epoch of 1970-01-01. The
+ * time component and time zone is fixed at T00:00:00Z.
+ * <p>
+ * This class uses a Chronology internally. The Chronology determines how the
+ * millisecond instant value is converted into the date time fields.
+ * The default Chronology is <code>ISOChronology</code> which is the agreed
+ * international standard and compatable with the modern Gregorian calendar.
+ *
+ * <p>
+ * Each individual field can be accessed in two ways:
+ * <ul>
+ * <li><code>getYear()</code>
+ * <li><code>year().get()</code>
+ * </ul>
+ * The second technique also provides access to other useful methods on the
+ * field:
+ * <ul>
+ * <li>get numeric value
+ * <li>set numeric value
+ * <li>add to numeric value
+ * <li>add to numeric value wrapping with the field
+ * <li>get text vlaue
+ * <li>get short text value
+ * <li>set text value
+ * <li>field maximum value
+ * <li>field minimum value
+ * </ul>
+ *
+ * <p>
+ * MutableDateOnly is mutable and not thread-safe, unless concurrent threads
+ * are not invoking mutator methods.
+ *
+ * @author Brian S O'Neill
+ * @since 1.0
+ * @see DateOnly
+ */
+public class MutableDateOnly extends AbstractPartialInstant
+    implements ReadWritableInstant, Cloneable, Serializable {
+
+    static final long serialVersionUID = 7781405642158513308L;
+
+    // Constructors
+    //-----------------------------------------------------------------------
+    /**
+     * Constructs a MutableDateOnly to the current date in the default time zone.
+     */
+    public MutableDateOnly() {
+        super();
+    }
+
+    /**
+     * Constructs a MutableDateOnly to the current date in the given time zone.
+     *
+     * @param zone  the time zone, null means default zone
+     */
+    public MutableDateOnly(DateTimeZone zone) {
+        super(zone);
+    }
+
+    /**
+     * Constructs a MutableDateOnly to the current date in the time zone of the given
+     * chronology.
+     *
+     * @param chronology  the chronology, null means ISOChronology in default zone
+     */
+    public MutableDateOnly(Chronology chronology) {
+        super(chronology);
+    }
+
+    /**
+     * Constructs a MutableDateOnly set to the milliseconds from 1970-01-01T00:00:00Z.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
+     */
+    public MutableDateOnly(long instant) {
+        super(instant);
+    }
+
+    /**
+     * Constructs a MutableDateOnly set to the milliseconds from
+     * 1970-01-01T00:00:00Z. If the time zone of the given chronology is not
+     * null or UTC, then the instant is converted to local time.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
+     * @param chronology  the chronology, null means ISOChronology
+     */
+    public MutableDateOnly(long instant, Chronology chronology) {
+        super(instant, chronology);
+    }
+
+    /**
+     * Constructs an instance from an Object that represents a date.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     *
+     * @param instant  the datetime object, must not be null
+     * @throws IllegalArgumentException if the date is null
+     */
+    public MutableDateOnly(Object instant) {
+        super(instant);
+    }
+
+    /**
+     * Constructs an instance from an Object that represents a date, using the
+     * specified chronology.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     *
+     * @param instant  the datetime object, must not be null
+     * @param chronology  the chronology, must not be null
+     * @throws IllegalArgumentException if the date or chronology is null
+     */
+    public MutableDateOnly(Object instant, Chronology chronology) {
+        super(instant, chronology);
+    }
+
+    /**
+     * Constructs an instance from date field values using
+     * <code>ISOChronology</code>.
+     *
+     * @param year  the year
+     * @param monthOfYear  the month of the year
+     * @param dayOfMonth  the day of the month
+     */
+    public MutableDateOnly(
+            final int year,
+            final int monthOfYear,
+            final int dayOfMonth) {
+
+        super(ISOChronology.getInstanceUTC()
+              .getDateOnlyMillis(year, monthOfYear, dayOfMonth),
+              ISOChronology.getInstanceUTC());
+    }
+
+    /**
+     * Constructs an instance from date field values
+     * using the specified chronology.
+     * <p>
+     * If the chronology is null, <code>ISOChronology</code>
+     * is used.
+     *
+     * @param year  the year
+     * @param monthOfYear  the month of the year
+     * @param dayOfMonth  the day of the month
+     * @param chronology  the chronology, null means ISOChronology
+     */
+    public MutableDateOnly(
+            final int year,
+            final int monthOfYear,
+            final int dayOfMonth,
+            Chronology chronology) {
+
+        super((chronology == null ? (chronology = ISOChronology.getInstanceUTC()) : chronology)
+              .getDateOnlyMillis(year, monthOfYear, dayOfMonth),
+              chronology);
+    }
+
+    /**
+     * Gets a copy of this instant with different millis.
+     * <p>
+     * The returned object will be a new instance of the same implementation type.
+     * Only the millis will change, the chronology is kept.
+     *
+     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
+     * @return a copy of this instant with different millis
+     */
+    public ReadableInstant toCopy(long newMillis) {
+        return new MutableDateOnly(newMillis, getChronology());
+    }
+    
+    /**
+     * Gets a copy of this instant with a different chronology.
+     * <p>
+     * The returned object will be a new instance of the same implementation type.
+     * Only the chronology will change, the millis are kept.
+     *
+     * @param newChronology  the new chronology
+     * @return a copy of this instant with a different chronology
+     * @throws IllegalArgumentException if the chronology is null
+     */
+    public ReadableInstant toCopy(Chronology newChronology) {
+        if (newChronology == null) {
+            throw new IllegalArgumentException("The Chronology must not be null");
+        }
+        return new MutableDateOnly(getMillis(), newChronology);
+    }
+
+    /**
+     * Returns the lower limiting field, dayOfYear.
+     *
+     * @return dayOfYear field
+     */
+    public final DateTimeField getLowerLimit() {
+        return getChronology().dayOfYear();
+    }
+
+    /**
+     * Returns the upper limiting field, null.
+     *
+     * @return null
+     */
+    public final DateTimeField getUpperLimit() {
+        return null;
+    }
+
+    /**
+     * Set the value as the number of milliseconds since the epoch,
+     * 1970-01-01T00:00:00Z.
+     *
+     * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the
+     * instant to
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void setMillis(long instant) {
+        super.setMillis(instant);
+    }
+
+    /**
+     * Set the value from an Object representing an instant.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     * 
+     * @param instant  an object representing an instant
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void setMillis(Object instant) {
+        super.setMillis(instant);
+    }
+
+    /**
+     * Set the chronology of the instant.
+     * 
+     * @param chronology  the chronology to use, null means ISOChronology/UTC
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void setChronology(Chronology chronology) {
+        super.setChronology(chronology);
+    }
+    
+    /**
+     * Since time zones are ignored, this method does nothing.
+     *
+     * @param zone  ignored
+     */
+    public void setDateTimeZone(DateTimeZone zone) {
+    }
+
+    /**
+     * Since time zones are ignored, this method does nothing.
+     *
+     * @param zone  ignored
+     */
+    public void moveDateTimeZone(DateTimeZone zone) {
+    }
+
+    // Add
+    //-----------------------------------------------------------------------
+    /**
+     * Add an amount of time to the date.
+     * 
+     * @param duration  the millis to add
+     */
+    public void add(final long duration) {
+        setMillis(getMillis() + duration);
+    }
+
+    /**
+     * Add an amount of time to the date.
+     * 
+     * @param duration  duration to add.
+     */
+    public void add(final ReadableDuration duration) {
+        duration.addInto(this, 1);
+    }
+
+    /**
+     * Add an amount of time to the date.
+     * 
+     * @param duration  duration to add.
+     * @param scalar  direction and amount to add, which may be negative
+     */
+    public void add(final ReadableDuration duration, final int scalar) {
+        duration.addInto(this, scalar);
+    }
+
+    /**
+     * Add an amount of time to the date.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableDuration, and Long.
+     * 
+     * @param duration  an object representing a duration
+     */
+    public void add(final Object duration) {
+        if (duration instanceof ReadableDuration) {
+            add((ReadableDuration) duration, 1);
+        } else {
+            DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);
+            add(converter.getDurationMillis(duration));
+        }
+    }
+
+    // Field based
+    //-----------------------------------------------------------------------
+    /**
+     * Set a value in the specified field.
+     * This could be used to set a field using a different Chronology.
+     * For example:
+     * <pre>
+     * MutableDateOnly date = new MutableDateOnly();
+     * date.set(GJChronology.getInstance().year(), 2002);
+     * </pre>
+     * 
+     * @param field  the DateTimeField to use
+     * @param value the value
+     * @throws NullPointerException if the field is null
+     */
+    public void set(final DateTimeField field, final int value) {
+        setMillis(field.set(getMillis(), value));
+    }
+
+    /**
+     * Add a value to the specified field.
+     * This could be used to set a field using a different Chronology.
+     * For example:
+     * <pre>
+     * MutableDateOnly date = new MutableDateOnly();
+     * date.add(GJChronology.getInstance().year(), 2);
+     * </pre>
+     * 
+     * @param field  the DateTimeField to use
+     * @param value the value
+     * @throws NullPointerException if the field is null
+     */
+    public void add(final DateTimeField field, final int value) {
+        setMillis(field.add(getMillis(), value));
+    }
+
+    /**
+     * Add a value to the specified field, wrapping within that field.
+     * This could be used to set a field using a different Chronology.
+     * For example:
+     * <pre>
+     * MutableDateOnly date = new MutableDateOnly();
+     * date.addWrapped(GJChronology.getInstance().monthOfYear(), 6);
+     * </pre>
+     * 
+     * @param field  the DateTimeField to use
+     * @param value the value
+     * @throws NullPointerException if the field is null
+     */
+    public void addWrapped(final DateTimeField field, final int value) {
+        setMillis(field.addWrapped(getMillis(), value));
+    }
+
+    // Date methods
+    //-----------------------------------------------------------------------
+    /**
+     * Set the year to the specified value.
+     *
+     * @param year  the year
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void setYear(final int year) {
+        setMillis(getChronology().year().set(getMillis(), year));
+    }
+
+    /**
+     * Add a number of years to the date.
+     *
+     * @param years  the years to add
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void addYears(final int years) {
+        setMillis(getChronology().years().add(getMillis(), years));
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Set the weekyear to the specified value.
+     *
+     * @param weekyear  the weekyear
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void setWeekyear(final int weekyear) {
+        setMillis(getChronology().weekyear().set(getMillis(), weekyear));
+    }
+
+    /**
+     * Add a number of weekyears to the date.
+     *
+     * @param weekyears  the weekyears to add
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void addWeekyears(final int weekyears) {
+        setMillis(getChronology().weekyears().add(getMillis(), weekyears));
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Set the month of the year to the specified value.
+     *
+     * @param monthOfYear  the month of the year
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void setMonthOfYear(final int monthOfYear) {
+        setMillis(getChronology().monthOfYear().set(getMillis(), monthOfYear));
+    }
+
+    /**
+     * Add a number of months to the date.
+     *
+     * @param months  the months to add
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void addMonths(final int months) {
+        setMillis(getChronology().months().add(getMillis(), months));
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Set the week of weekyear to the specified value.
+     *
+     * @param weekOfWeekyear the week of the weekyear
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void setWeekOfWeekyear(final int weekOfWeekyear) {
+        setMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear));
+    }
+
+    /**
+     * Add a number of weeks to the date.
+     *
+     * @param weeks  the weeks to add
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void addWeeks(final int weeks) {
+        setMillis(getChronology().weeks().add(getMillis(), weeks));
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Set the day of year to the specified value.
+     *
+     * @param dayOfYear the day of the year
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void setDayOfYear(final int dayOfYear) {
+        setMillis(getChronology().dayOfYear().set(getMillis(), dayOfYear));
+    }
+
+    /**
+     * Set the day of the month to the specified value.
+     *
+     * @param dayOfMonth  the day of the month
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void setDayOfMonth(final int dayOfMonth) {
+        setMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth));
+    }
+
+    /**
+     * Set the day of week to the specified value.
+     *
+     * @param dayOfWeek  the day of the week
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void setDayOfWeek(final int dayOfWeek) {
+        setMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek));
+    }
+
+    /**
+     * Add a number of days to the date.
+     *
+     * @param days  the days to add
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void addDays(final int days) {
+        setMillis(getChronology().days().add(getMillis(), days));
+    }
+
+    // Date field access
+    //-----------------------------------------------------------------------
+    /**
+     * Get the era field value.
+     * 
+     * @return the era
+     */
+    public final int getEra() {
+        return getChronology().era().get(getMillis());
+    }
+
+    /**
+     * Get the year of era field value.
+     * 
+     * @return the year of era
+     */
+    public final int getCenturyOfEra() {
+        return getChronology().centuryOfEra().get(getMillis());
+    }
+
+    /**
+     * Get the year of era field value.
+     * 
+     * @return the year of era
+     */
+    public final int getYearOfEra() {
+        return getChronology().yearOfEra().get(getMillis());
+    }
+
+    /**
+     * Get the year of century field value.
+     * 
+     * @return the year of century
+     */
+    public final int getYearOfCentury() {
+        return getChronology().yearOfCentury().get(getMillis());
+    }
+
+    /**
+     * Get the year field value.
+     * 
+     * @return the year
+     */
+    public final int getYear() {
+        return getChronology().year().get(getMillis());
+    }
+
+    /**
+     * Get the weekyear field value.
+     * 
+     * @return the year of a week based year
+     */
+    public final int getWeekyear() {
+        return getChronology().weekyear().get(getMillis());
+    }
+
+    /**
+     * Get the month of year field value.
+     * 
+     * @return the month of year
+     */
+    public final int getMonthOfYear() {
+        return getChronology().monthOfYear().get(getMillis());
+    }
+
+    /**
+     * Get the week of weekyear field value.
+     * 
+     * @return the week of a week based year
+     */
+    public final int getWeekOfWeekyear() {
+        return getChronology().weekOfWeekyear().get(getMillis());
+    }
+
+    /**
+     * Get the day of year field value.
+     * 
+     * @return the day of year
+     */
+    public final int getDayOfYear() {
+        return getChronology().dayOfYear().get(getMillis());
+    }
+
+    /**
+     * Get the day of month field value.
+     * <p>
+     * The values for the day of month are defined in {@link DateTimeConstants}.
+     * 
+     * @return the day of month
+     */
+    public final int getDayOfMonth() {
+        return getChronology().dayOfMonth().get(getMillis());
+    }
+
+    /**
+     * Get the day of week field value.
+     * <p>
+     * The values for the day of week are defined in {@link DateTimeConstants}.
+     * 
+     * @return the day of week
+     */
+    public final int getDayOfWeek() {
+        return getChronology().dayOfWeek().get(getMillis());
+    }
+
+    // Setters
+    //-----------------------------------------------------------------------
+    /**
+     * Set the date from milliseconds.
+     *
+     * @param instant  milliseconds from 1970-01-01T00:00:00Z, time part ignored
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void setDate(final long instant) {
+        setMillis(instant);
+    }
+
+    /**
+     * Set the date from an object representing an instant.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     *
+     * @param instant  an object representing an instant, time part ignored
+     * @throws IllegalArgumentException if the object is null or invalid
+     */
+    public void setDate(final Object instant) {
+        setMillis(instant);
+    }
+
+    /**
+     * Set the date from fields.
+     *
+     * @param year  the year
+     * @param monthOfYear  the month of the year
+     * @param dayOfMonth  the day of the month
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void setDate(
+            final int year,
+            final int monthOfYear,
+            final int dayOfMonth) {
+        setMillis(getChronology().getDateOnlyMillis(year, monthOfYear, dayOfMonth));
+    }
+
+    // Properties
+    //-----------------------------------------------------------------------
+    /**
+     * Get the day of week property.
+     * <p>
+     * The values for day of week are defined in {@link DateTimeConstants}.
+     * 
+     * @return the day of week property
+     */
+    public final MutableDateTimeFieldProperty dayOfWeek() {
+        return new MutableDateTimeFieldProperty(this, getChronology().dayOfWeek());
+    }
+
+    /**
+     * Get the day of month property.
+     * 
+     * @return the day of month property
+     */
+    public final MutableDateTimeFieldProperty dayOfMonth() {
+        return new MutableDateTimeFieldProperty(this, getChronology().dayOfMonth());
+    }
+
+    /**
+     * Get the day of year property.
+     * 
+     * @return the day of year property
+     */
+    public final MutableDateTimeFieldProperty dayOfYear() {
+        return new MutableDateTimeFieldProperty(this, getChronology().dayOfYear());
+    }
+
+    /**
+     * Get the week of a week based year property.
+     * 
+     * @return the week of a week based year property
+     */
+    public final MutableDateTimeFieldProperty weekOfWeekyear() {
+        return new MutableDateTimeFieldProperty(this, getChronology().weekOfWeekyear());
+    }
+
+    /**
+     * Get the year of a week based year property.
+     * 
+     * @return the year of a week based year property
+     */
+    public final MutableDateTimeFieldProperty weekyear() {
+        return new MutableDateTimeFieldProperty(this, getChronology().weekyear());
+    }
+
+    /**
+     * Get the month of year property.
+     * 
+     * @return the month of year property
+     */
+    public final MutableDateTimeFieldProperty monthOfYear() {
+        return new MutableDateTimeFieldProperty(this, getChronology().monthOfYear());
+    }
+
+    /**
+     * Get the year property.
+     * 
+     * @return the year property
+     */
+    public final MutableDateTimeFieldProperty year() {
+        return new MutableDateTimeFieldProperty(this, getChronology().year());
+    }
+
+    /**
+     * Get the year of era property.
+     * 
+     * @return the year of era property
+     */
+    public final MutableDateTimeFieldProperty yearOfEra() {
+        return new MutableDateTimeFieldProperty(this, getChronology().yearOfEra());
+    }
+
+    /**
+     * Get the year of century property.
+     * 
+     * @return the year of era property
+     */
+    public final MutableDateTimeFieldProperty yearOfCentury() {
+        return new MutableDateTimeFieldProperty(this, getChronology().yearOfCentury());
+    }
+
+    /**
+     * Get the century of era property.
+     * 
+     * @return the year of era property
+     */
+    public final MutableDateTimeFieldProperty centuryOfEra() {
+        return new MutableDateTimeFieldProperty(this, getChronology().centuryOfEra());
+    }
+
+    /**
+     * Get the era property.
+     * 
+     * @return the era property
+     */
+    public final MutableDateTimeFieldProperty era() {
+        return new MutableDateTimeFieldProperty(this, getChronology().era());
+    }
+
+    // Misc
+    //-----------------------------------------------------------------------
+    /**
+     * Clone this object without having to cast the returned object.
+     *
+     * @return a clone of the this object.
+     */
+    public MutableDateOnly copy() {
+        return (MutableDateOnly)clone();
+    }
+
+    /**
+     * Clone this object.
+     *
+     * @return a clone of this object.
+     */
+    public Object clone() {
+        try {
+            return super.clone();
+        } catch (CloneNotSupportedException ex) {
+            throw new InternalError("Clone error");
+        }
+    }
+
+    // Output
+    //-----------------------------------------------------------------------
+    /**
+     * Output the date in ISO8601 date only format (yyyy-MM-dd).
+     * 
+     * @return ISO8601 date formatted string
+     */
+    public final String toString() {
+        return ISODateTimeFormat.getInstance(getChronology()).date().print(getMillis());
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/MutableTimeOnly.java b/JodaTime/src/java/org/joda/time/MutableTimeOnly.java
new file mode 100644
index 000000000..d848a5fe4
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/MutableTimeOnly.java
@@ -0,0 +1,867 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-04 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time;
+
+import java.io.Serializable;
+
+import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.convert.ConverterManager;
+import org.joda.time.convert.DurationConverter;
+import org.joda.time.format.ISODateTimeFormat;
+import org.joda.time.property.MutableDateTimeFieldProperty;
+
+/**
+ * MutableTimeOnly is the basic implementation of a modifiable time only class.
+ * It holds the time as milliseconds from T00:00:00. The date component and
+ * time zone is fixed at 1970-01-01TZ.
+ * <p>
+ * This class uses a Chronology internally. The Chronology determines how the
+ * millisecond instant value is converted into the date time fields.
+ * The default Chronology is <code>ISOChronology</code> which is the agreed
+ * international standard and compatable with the modern Gregorian calendar.
+ *
+ * <p>
+ * Each individual field can be accessed in two ways:
+ * <ul>
+ * <li><code>getHourOfDay()</code>
+ * <li><code>hourOfDay().get()</code>
+ * </ul>
+ * The second technique also provides access to other useful methods on the
+ * field:
+ * <ul>
+ * <li>get numeric value
+ * <li>set numeric value
+ * <li>add to numeric value
+ * <li>add to numeric value wrapping with the field
+ * <li>get text vlaue
+ * <li>get short text value
+ * <li>set text value
+ * <li>field maximum value
+ * <li>field minimum value
+ * </ul>
+ *
+ * <p>
+ * MutableTimeOnly is mutable and not thread-safe, unless concurrent threads
+ * are not invoking mutator methods.
+ *
+ * @author Brian S O'Neill
+ * @since 1.0
+ * @see TimeOnly
+ */
+public class MutableTimeOnly extends AbstractPartialInstant
+    implements ReadWritableInstant, Cloneable, Serializable {
+
+    static final long serialVersionUID = -1438532408790831231L;
+
+    // Constructors
+    //-----------------------------------------------------------------------
+    /**
+     * Constructs a MutableTimeOnly to the current time in the default time zone.
+     */
+    public MutableTimeOnly() {
+        super();
+    }
+
+    /**
+     * Constructs a MutableTimeOnly to the current time in the given time zone.
+     *
+     * @param zone  the time zone, null means default zone
+     */
+    public MutableTimeOnly(DateTimeZone zone) {
+        super(zone);
+    }
+
+    /**
+     * Constructs a MutableTimeOnly to the current time in the time zone of the given
+     * chronology.
+     *
+     * @param chronology  the chronology, null means ISOChronology in default zone
+     */
+    public MutableTimeOnly(Chronology chronology) {
+        super(chronology);
+    }
+
+    /**
+     * Constructs a MutableTimeOnly set to the milliseconds from 1970-01-01T00:00:00Z.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
+     */
+    public MutableTimeOnly(long instant) {
+        super(instant);
+    }
+
+    /**
+     * Constructs a MutableTimeOnly set to the milliseconds from
+     * 1970-01-01T00:00:00Z. If the time zone of the given chronology is not
+     * null or UTC, then the instant is converted to local time.
+     *
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z
+     * @param chronology  the chronology, null means ISOChronology
+     */
+    public MutableTimeOnly(long instant, Chronology chronology) {
+        super(instant, chronology);
+    }
+
+    /**
+     * Constructs an instance from an Object that represents a time.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     *
+     * @param instant  the datetime object, must not be null
+     * @throws IllegalArgumentException if the date is null
+     */
+    public MutableTimeOnly(Object instant) {
+        super(instant);
+    }
+
+    /**
+     * Constructs an instance from an Object that represents a time, using the
+     * specified chronology.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     *
+     * @param instant  the datetime object, must not be null
+     * @param chronology  the chronology, must not be null
+     * @throws IllegalArgumentException if the date or chronology is null
+     */
+    public MutableTimeOnly(Object instant, Chronology chronology) {
+        super(instant, chronology);
+    }
+
+    /**
+     * Constructs an instance from time field values using
+     * <code>ISOChronology</code>.
+     *
+     * @param hourOfDay  the hour of the day
+     * @param minuteOfHour  the minute of the hour
+     * @param secondOfMinute  the second of the minute
+     * @param millisOfSecond  the millisecond of the second
+     */
+    public MutableTimeOnly(
+            final int hourOfDay,
+            final int minuteOfHour,
+            final int secondOfMinute,
+            final int millisOfSecond) {
+
+        super(ISOChronology.getInstanceUTC()
+              .getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond),
+              ISOChronology.getInstanceUTC());
+    }
+
+    /**
+     * Constructs an instance from time field values
+     * using the specified chronology.
+     * <p>
+     * If the chronology is null, <code>ISOChronology</code>
+     * is used.
+     *
+     * @param hourOfDay  the hour of the day
+     * @param minuteOfHour  the minute of the hour
+     * @param secondOfMinute  the second of the minute
+     * @param millisOfSecond  the millisecond of the second
+     * @param chronology  the chronology, null means ISOChronology
+     */
+    public MutableTimeOnly(
+            final int hourOfDay,
+            final int minuteOfHour,
+            final int secondOfMinute,
+            final int millisOfSecond,
+            Chronology chronology) {
+
+        super((chronology == null ? (chronology = ISOChronology.getInstanceUTC()) : chronology)
+              .getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond),
+              chronology);
+    }
+
+    /**
+     * Gets a copy of this instant with different millis.
+     * <p>
+     * The returned object will be a new instance of the same implementation type.
+     * Only the millis will change, the chronology is kept.
+     * Immutable subclasses may return <code>this</code> if appropriate.
+     *
+     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
+     * @return a copy of this instant with different millis
+     */
+    public ReadableInstant toCopy(long newMillis) {
+        return new MutableTimeOnly(newMillis, getChronology());
+    }
+    
+    /**
+     * Gets a copy of this instant with a different chronology.
+     * <p>
+     * The returned object will be a new instance of the same implementation type.
+     * Only the chronology will change, the millis are kept.
+     * Immutable subclasses may return <code>this</code> if appropriate.
+     *
+     * @param newChronology  the new chronology
+     * @return a copy of this instant with a different chronology
+     * @throws IllegalArgumentException if the chronology is null
+     */
+    public ReadableInstant toCopy(Chronology newChronology) {
+        if (newChronology == null) {
+            throw new IllegalArgumentException("The Chronology must not be null");
+        }
+        return new MutableTimeOnly(getMillis(), newChronology);
+    }
+
+    /**
+     * Returns the lower limiting field, null.
+     *
+     * @return null.
+     */
+    public final DateTimeField getLowerLimit() {
+        return null;
+    }
+
+    /**
+     * Returns the upper limiting field, dayOfYear.
+     *
+     * @return dayOfYear field
+     */
+    public final DateTimeField getUpperLimit() {
+        return getChronology().dayOfYear();
+    }
+
+    /**
+     * Set the value as the number of milliseconds since the epoch,
+     * 1970-01-01T00:00:00Z.
+     *
+     * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the
+     * instant to
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void setMillis(long instant) {
+        super.setMillis(instant);
+    }
+
+    /**
+     * Set the value from an Object representing an instant.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     * 
+     * @param instant  an object representing an instant
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void setMillis(Object instant) {
+        super.setMillis(instant);
+    }
+
+    /**
+     * Set the chronology of the instant.
+     * 
+     * @param chronology  the chronology to use, null means ISOChronology/UTC
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void setChronology(Chronology chronology) {
+        super.setChronology(chronology);
+    }
+    
+    /**
+     * Since time zones are ignored, this method does nothing.
+     *
+     * @param zone  ignored
+     */
+    public void setDateTimeZone(DateTimeZone zone) {
+    }
+
+    /**
+     * Since time zones are ignored, this method does nothing.
+     *
+     * @param zone  ignored
+     */
+    public void moveDateTimeZone(DateTimeZone zone) {
+    }
+
+    // Add
+    //-----------------------------------------------------------------------
+    /**
+     * Add an amount of time to the time.
+     * 
+     * @param duration  the millis to add
+     */
+    public void add(final long duration) {
+        setMillis(getMillis() + duration);
+    }
+
+    /**
+     * Add an amount of time to the time.
+     * 
+     * @param duration  duration to add.
+     */
+    public void add(final ReadableDuration duration) {
+        duration.addInto(this, 1);
+    }
+
+    /**
+     * Add an amount of time to the time.
+     * 
+     * @param duration  duration to add.
+     * @param scalar  direction and amount to add, which may be negative
+     */
+    public void add(final ReadableDuration duration, final int scalar) {
+        duration.addInto(this, scalar);
+    }
+
+    /**
+     * Add an amount of time to the time.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableDuration, and Long.
+     * 
+     * @param duration  an object representing a duration
+     */
+    public void add(final Object duration) {
+        if (duration instanceof ReadableDuration) {
+            add((ReadableDuration) duration, 1);
+        } else {
+            DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration);
+            add(converter.getDurationMillis(duration));
+        }
+    }
+
+    // Field based
+    //-----------------------------------------------------------------------
+    /**
+     * Set a value in the specified field.
+     * This could be used to set a field using a different Chronology.
+     * For example:
+     * <pre>
+     * MutableTimeOnly time = new MutableTimeOnly();
+     * time.set(GJChronology.getInstance().hourOfDay(), 12);
+     * </pre>
+     * 
+     * @param field  the DateTimeField to use
+     * @param value the value
+     * @throws NullPointerException if the field is null
+     */
+    public void set(final DateTimeField field, final int value) {
+        setMillis(field.set(getMillis(), value));
+    }
+
+    /**
+     * Add a value to the specified field.
+     * This could be used to set a field using a different Chronology.
+     * For example:
+     * <pre>
+     * MutableTimeOnly time = new MutableTimeOnly();
+     * time.add(GJChronology.getInstance().hourOfDay(), 2);
+     * </pre>
+     * 
+     * @param field  the DateTimeField to use
+     * @param value the value
+     * @throws NullPointerException if the field is null
+     */
+    public void add(final DateTimeField field, final int value) {
+        setMillis(field.add(getMillis(), value));
+    }
+
+    /**
+     * Add a value to the specified field, wrapping within that field.
+     * This could be used to set a field using a different Chronology.
+     * For example:
+     * <pre>
+     * MutableTimeOnly time = new MutableTimeOnly();
+     * time.addWrapped(GJChronology.getInstance().minuteOfHour(), 30);
+     * </pre>
+     * 
+     * @param field  the DateTimeField to use
+     * @param value the value
+     * @throws NullPointerException if the field is null
+     */
+    public void addWrapped(final DateTimeField field, final int value) {
+        setMillis(field.addWrapped(getMillis(), value));
+    }
+
+    // Time methods
+    //-----------------------------------------------------------------------
+    /**
+     * Set the hour of the day to the specified value.
+     *
+     * @param hourOfDay  the hour of day
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void setHourOfDay(final int hourOfDay) {
+        setMillis(getChronology().hourOfDay().set(getMillis(), hourOfDay));
+    }
+
+    /**
+     * Set the hour of day (offset to 1-24) to the specified value.
+     * 
+     * @param clockhourOfDay  the clockhour of day
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void setClockhourOfDay(final int clockhourOfDay) {
+        setMillis(getChronology().clockhourOfDay().set(getMillis(), clockhourOfDay));
+    }
+
+    /**
+     * Set the hour of am/pm (0-11) to the specified value.
+     * 
+     * @param hourOfHalfday  the hour of halfday
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void setHourOfHalfday(final int hourOfHalfday) {
+        setMillis(getChronology().hourOfHalfday().set(getMillis(), hourOfHalfday));
+    }
+
+    /**
+     * Set the hour of am/pm (offset to 1-12) to the specified value.
+     * 
+     * @param clockhourOfHalfday  the clockhour of halfday
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void setClockhourOfHalfday(final int clockhourOfHalfday) {
+        setMillis(getChronology().clockhourOfHalfday().set(getMillis(), clockhourOfHalfday));
+    }
+
+    /**
+     * Set the AM(0) PM(1) field value.
+     * 
+     * @param halfdayOfDay  the halfday of day
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void setHalfdayOfDay(final int halfdayOfDay) {
+        setMillis(getChronology().halfdayOfDay().set(getMillis(), halfdayOfDay));
+    }
+
+    /**
+     * Add a number of hours to the date.
+     *
+     * @param hours  the hours to add
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void addHours(final int hours) {
+        setMillis(getChronology().hours().add(getMillis(), hours));
+    }
+    
+    //-----------------------------------------------------------------------
+    /**
+     * Set the minute of the day to the specified value.
+     *
+     * @param minuteOfDay  the minute of day
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void setMinuteOfDay(final int minuteOfDay) {
+        setMillis(getChronology().minuteOfDay().set(getMillis(), minuteOfDay));
+    }
+
+    /**
+     * Set the minute of the hour to the specified value.
+     *
+     * @param minuteOfHour  the minute of hour
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void setMinuteOfHour(final int minuteOfHour) {
+        setMillis(getChronology().minuteOfHour().set(getMillis(), minuteOfHour));
+    }
+
+    /**
+     * Add a number of minutes to the date.
+     *
+     * @param minutes  the minutes to add
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void addMinutes(final int minutes) {
+        setMillis(getChronology().minutes().add(getMillis(), minutes));
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Set the second of the day to the specified value.
+     *
+     * @param secondOfDay  the second of day
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void setSecondOfDay(final int secondOfDay) {
+        setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay));
+    }
+
+    /**
+     * Set the second of the minute to the specified value.
+     *
+     * @param secondOfMinute  the second of minute
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void setSecondOfMinute(final int secondOfMinute) {
+        setMillis(getChronology().secondOfMinute().set(getMillis(), secondOfMinute));
+    }
+
+    /**
+     * Add a number of seconds to the date.
+     *
+     * @param seconds  the seconds to add
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void addSeconds(final int seconds) {
+        setMillis(getChronology().seconds().add(getMillis(), seconds));
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Set the millis of the day to the specified value.
+     *
+     * @param millisOfDay  the millis of day
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void setMillisOfDay(final int millisOfDay) {
+        setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay));
+    }
+
+    /**
+     * Set the millis of the second to the specified value.
+     *
+     * @param millisOfSecond  the millis of second
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void setMillisOfSecond(final int millisOfSecond) {
+        setMillis(getChronology().millisOfSecond().set(getMillis(), millisOfSecond));
+    }
+
+    /**
+     * Add a number of milliseconds to the date. The implementation of this
+     * method differs from the {@link #add(long)} method in that a
+     * DateTimeField performs the addition.
+     *
+     * @param millis  the milliseconds to add
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void addMillis(final int millis) {
+        setMillis(getChronology().millis().add(getMillis(), millis));
+    }
+
+    // Time field access
+    //-----------------------------------------------------------------------
+    /**
+     * Get the hour of day (0-23) field value.
+     *
+     * @return the hour of day
+     */
+    public final int getHourOfDay() {
+        return getChronology().hourOfDay().get(getMillis());
+    }
+
+    /**
+     * Get the hour of day (offset to 1-24) field value.
+     * 
+     * @return the clockhour of day
+     */
+    public final int getClockhourOfDay() {
+        return getChronology().clockhourOfDay().get(getMillis());
+    }
+
+    /**
+     * Get the hour of am/pm (0-11) field value.
+     * 
+     * @return the hour of halfday
+     */
+    public final int getHourOfHalfday() {
+        return getChronology().hourOfHalfday().get(getMillis());
+    }
+
+    /**
+     * Get the hour of am/pm (offset to 1-12) field value.
+     * 
+     * @return the clockhour of halfday
+     */
+    public final int getClockhourOfHalfday() {
+        return getChronology().clockhourOfHalfday().get(getMillis());
+    }
+
+    /**
+     * Get the AM(0) PM(1) field value.
+     * 
+     * @return the halfday of day
+     */
+    public final int getHalfdayOfDay() {
+        return getChronology().halfdayOfDay().get(getMillis());
+    }
+
+    /**
+     * Get the minute of day field value.
+     *
+     * @return the minute of day
+     */
+    public final int getMinuteOfDay() {
+        return getChronology().minuteOfDay().get(getMillis());
+    }
+
+    /**
+     * Get the minute of hour field value.
+     *
+     * @return the minute of hour
+     */
+    public final int getMinuteOfHour() {
+        return getChronology().minuteOfHour().get(getMillis());
+    }
+
+    /**
+     * Get the second of day field value.
+     *
+     * @return the second of day
+     */
+    public final int getSecondOfDay() {
+        return getChronology().secondOfDay().get(getMillis());
+    }
+
+    /**
+     * Get the second of minute field value.
+     *
+     * @return the second of minute
+     */
+    public final int getSecondOfMinute() {
+        return getChronology().secondOfMinute().get(getMillis());
+    }
+
+    /**
+     * Get the millis of day field value.
+     *
+     * @return the millis of day
+     */
+    public final int getMillisOfDay() {
+        return getChronology().millisOfDay().get(getMillis());
+    }
+
+    /**
+     * Get the millis of second field value.
+     *
+     * @return the millis of second
+     */
+    public final int getMillisOfSecond() {
+        return getChronology().millisOfSecond().get(getMillis());
+    }
+
+    // Setters
+    //-----------------------------------------------------------------------
+    /**
+     * Set the time from milliseconds.
+     *
+     * @param millis milliseconds from T00:00:00Z, date part ignored
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void setTime(final long millis) {
+        setMillis(millis);
+    }
+
+    /**
+     * Set the date from an object representing an instant.
+     * <p>
+     * The recognised object types are defined in {@link ConverterManager} and
+     * include ReadableInstant, String, Calendar and Date.
+     *
+     * @param instant  an object representing an instant, date part ignored
+     * @throws IllegalArgumentException if the object is null or invalid
+     */
+    public void setTime(final Object instant) {
+        setMillis(instant);
+    }
+
+    /**
+     * Set the time from fields.
+     *
+     * @param hour  the hour
+     * @param minuteOfHour  the minute of the hour
+     * @param secondOfMinute  the second of the minute
+     * @param millisOfSecond  the millisecond of the second
+     * @throws IllegalArgumentException if the value is invalid
+     */
+    public void setTime(
+            final int hour,
+            final int minuteOfHour,
+            final int secondOfMinute,
+            final int millisOfSecond) {
+        setMillis(getChronology().getTimeOnlyMillis(hour, minuteOfHour, secondOfMinute, millisOfSecond));
+    }
+
+    // Properties
+    //-----------------------------------------------------------------------
+    /**
+     * Get the hour of day (0-23) field property
+     * 
+     * @return the hour of day property
+     */
+    public final MutableDateTimeFieldProperty hourOfDay() {
+        return new MutableDateTimeFieldProperty(this, getChronology().hourOfDay());
+    }
+
+    /**
+     * Get the hour of day (offset to 1-24) field property
+     * 
+     * @return the clockhour of day property
+     */
+    public final MutableDateTimeFieldProperty clockhourOfDay() {
+        return new MutableDateTimeFieldProperty(this, getChronology().clockhourOfDay());
+    }
+
+    /**
+     * Get the hour of am/pm (0-11) field property
+     * 
+     * @return the hour of halfday property
+     */
+    public final MutableDateTimeFieldProperty hourOfHalfday() {
+        return new MutableDateTimeFieldProperty(this, getChronology().hourOfHalfday());
+    }
+
+    /**
+     * Get the hour of am/pm (offset to 1-12) field property
+     * 
+     * @return the clockhour of halfday property
+     */
+    public final MutableDateTimeFieldProperty clockhourOfHalfday() {
+        return new MutableDateTimeFieldProperty(this, getChronology().clockhourOfHalfday());
+    }
+
+    /**
+     * Get the AM(0) PM(1) field property
+     * 
+     * @return the halfday of day property
+     */
+    public final MutableDateTimeFieldProperty halfdayOfDay() {
+        return new MutableDateTimeFieldProperty(this, getChronology().halfdayOfDay());
+    }
+
+    /**
+     * Get the minute of day property
+     * 
+     * @return the minute of day property
+     */
+    public final MutableDateTimeFieldProperty minuteOfDay() {
+        return new MutableDateTimeFieldProperty(this, getChronology().minuteOfDay());
+    }
+
+    /**
+     * Get the minute of hour field property
+     * 
+     * @return the minute of hour property
+     */
+    public final MutableDateTimeFieldProperty minuteOfHour() {
+        return new MutableDateTimeFieldProperty(this, getChronology().minuteOfHour());
+    }
+
+    /**
+     * Get the second of day property
+     * 
+     * @return the second of day property
+     */
+    public final MutableDateTimeFieldProperty secondOfDay() {
+        return new MutableDateTimeFieldProperty(this, getChronology().secondOfDay());
+    }
+
+    /**
+     * Get the second of minute field property
+     * 
+     * @return the second of minute property
+     */
+    public final MutableDateTimeFieldProperty secondOfMinute() {
+        return new MutableDateTimeFieldProperty(this, getChronology().secondOfMinute());
+    }
+
+    /**
+     * Get the millis of day property
+     * 
+     * @return the millis of day property
+     */
+    public final MutableDateTimeFieldProperty millisOfDay() {
+        return new MutableDateTimeFieldProperty(this, getChronology().millisOfDay());
+    }
+
+    /**
+     * Get the millis of second property
+     * 
+     * @return the millis of second property
+     */
+    public final MutableDateTimeFieldProperty millisOfSecond() {
+        return new MutableDateTimeFieldProperty(this, getChronology().millisOfSecond());
+    }
+
+    // Misc
+    //-----------------------------------------------------------------------
+    /**
+     * Clone this object without having to cast the returned object.
+     *
+     * @return a clone of the this object.
+     */
+    public MutableTimeOnly copy() {
+        return (MutableTimeOnly)clone();
+    }
+
+    /**
+     * Clone this object.
+     *
+     * @return a clone of this object.
+     */
+    public Object clone() {
+        try {
+            return super.clone();
+        } catch (CloneNotSupportedException ex) {
+            throw new InternalError("Clone error");
+        }
+    }
+
+    // Output
+    //-----------------------------------------------------------------------
+    /**
+     * Output the time in ISO8601 date only format (hh:mm:ss.SSS).
+     * 
+     * @return ISO8601 date formatted string
+     */
+    public final String toString() {
+        return ISODateTimeFormat.getInstance(getChronology())
+            .hourMinuteSecondFraction().print(getMillis());
+    }
+
+}

From 32cdb3a285be401c9798c03ed02791d209c9b88f Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 3 Jan 2004 02:28:10 +0000
Subject: [PATCH 075/143] Remove protected create method.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@80 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/AbstractInstant.java   | 42 -------------------
 JodaTime/src/java/org/joda/time/DateTime.java | 35 +++++++---------
 JodaTime/src/java/org/joda/time/Instant.java  | 31 ++++++++------
 .../java/org/joda/time/MutableDateTime.java   | 39 +++++++++++------
 4 files changed, 60 insertions(+), 87 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/AbstractInstant.java b/JodaTime/src/java/org/joda/time/AbstractInstant.java
index 808317662..221164949 100644
--- a/JodaTime/src/java/org/joda/time/AbstractInstant.java
+++ b/JodaTime/src/java/org/joda/time/AbstractInstant.java
@@ -95,18 +95,6 @@ public final DateTimeZone getDateTimeZone() {
         return (chrono != null ? chrono.getDateTimeZone() : null);
     }
 
-    /**
-     * Creates a new instance of this class.
-     * <p>
-     * The returned object will be a new instance of the implementation.
-     * Immutable subclasses may return <code>this</code> if appropriate.
-     *
-     * @param instant  the new instant, from 1970-01-01T00:00:00Z
-     * @param chrono  the new chronology
-     * @return a new instance of this class
-     */
-    protected abstract ReadableInstant create(long instant, Chronology chrono);
-    
     // Accessors
     //-----------------------------------------------------------------------
     /**
@@ -130,36 +118,6 @@ public final int get(DateTimeField field) {
         return field.get(getMillis());
     }
 
-    // Updates
-    //-----------------------------------------------------------------------
-    /**
-     * Gets a copy of this instant with different millis.
-     * <p>
-     * The returned object will be a new instance of this type.
-     * Only the millis will change, the chronology and time zone are kept.
-     * If the millis is the same, <code>this</code> will be returned.
-     *
-     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
-     * @return a copy of this instant with different millis
-     */
-    public final ReadableInstant toCopy(long newMillis) {
-        return create(newMillis, getChronology());
-    }
-    
-    /**
-     * Gets a copy of this instant with a different chronology.
-     * <p>
-     * The returned object will be a new instance of this type.
-     * Only the chronology will change, the millis are kept.
-     * If the chronology is the same, <code>this</code> will be returned.
-     *
-     * @param newChronology  the new chronology
-     * @return a copy of this instant with a different chronology
-     */
-    public final ReadableInstant toCopy(Chronology newChronology) {
-        return create(getMillis(), newChronology);
-    }
-
     // Conversion
     //-----------------------------------------------------------------------
     /**
diff --git a/JodaTime/src/java/org/joda/time/DateTime.java b/JodaTime/src/java/org/joda/time/DateTime.java
index a142d8c1a..6798b29cb 100644
--- a/JodaTime/src/java/org/joda/time/DateTime.java
+++ b/JodaTime/src/java/org/joda/time/DateTime.java
@@ -58,6 +58,7 @@
 // Import for @link support
 import org.joda.time.convert.ConverterManager;
 import org.joda.time.format.ISODateTimeFormat;
+import org.joda.time.property.DateTimeFieldProperty;
 
 /**
  * DateTime is the standard implementation of an unmodifiable datetime class.
@@ -309,39 +310,35 @@ public DateTime(
 
     //-----------------------------------------------------------------------
     /**
-     * Creates a new instance of this class.
+     * Gets a copy of this instant with different millis.
      * <p>
-     * The returned object will be a new instance of the implementation.
+     * The returned object will be a new instance of the same implementation type.
+     * Only the millis will change, the chronology and time zone are kept.
      * Immutable subclasses may return <code>this</code> if appropriate.
      *
-     * @param instant  the new instant, from 1970-01-01T00:00:00Z
-     * @param chrono  the new chronology
-     * @return a new instance of this class
-     * @throws IllegalArgumentException if the chronology is null
+     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
+     * @return a copy of this instant with different millis
      */
-    protected final ReadableInstant create(final long instant, final Chronology chrono) {
-        return createDateTime(instant, chrono);
+    public ReadableInstant toCopy(long newMillis) {
+        return newMillis == getMillis() ? this : new DateTime(newMillis, getChronology());
     }
     
     /**
-     * Creates a new instance of this class.
+     * Gets a copy of this instant with a different chronology.
      * <p>
-     * The returned object will be a new instance of DateTime, or a subclass.
+     * The returned object will be a new instance of the same implementation type.
+     * Only the chronology will change, the millis are kept.
      * Immutable subclasses may return <code>this</code> if appropriate.
      *
-     * @param instant  the new instant, from 1970-01-01T00:00:00Z
-     * @param chrono  the new chronology
-     * @return a new instance of this class
+     * @param newChronology  the new chronology
+     * @return a copy of this instant with a different chronology
      * @throws IllegalArgumentException if the chronology is null
      */
-    protected DateTime createDateTime(final long instant, final Chronology chrono) {
-        if (chrono == null) {
+    public ReadableInstant toCopy(Chronology newChronology) {
+        if (newChronology == null) {
             throw new IllegalArgumentException("The Chronology must not be null");
         }
-        if (instant == getMillis() && chrono == getChronology()) {
-            return this;
-        }
-        return new DateTime(instant, chrono);
+        return newChronology == getChronology() ? this : new DateTime(getMillis(), newChronology);
     }
     
     // Date properties
diff --git a/JodaTime/src/java/org/joda/time/Instant.java b/JodaTime/src/java/org/joda/time/Instant.java
index f90087c64..4c12bfa48 100644
--- a/JodaTime/src/java/org/joda/time/Instant.java
+++ b/JodaTime/src/java/org/joda/time/Instant.java
@@ -127,22 +127,27 @@ public Instant(Object instant) {
     }
 
     /**
-     * Creates a new instance of this class.
+     * Gets a copy of this instant with different millis, as an Instant.
      * <p>
-     * The returned object will be a new instance of the implementation.
-     * Immutable subclasses may return <code>this</code> if appropriate.
+     * The returned object will be either be a new Instant or
+     * <code>this</code>.
      *
-     * @param instant  the new instant, from 1970-01-01T00:00:00Z
-     * @param chrono  the new chronology
-     * @return a new instance of this class
-     * @throws IllegalArgumentException if the chronology is null
+     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
+     * @return a copy of this instant with different millis
      */
-    protected ReadableInstant create(long instant, Chronology chrono) {
-        // ignore chrono
-        if (instant == getMillis()) {
-            return this;
-        }
-        return new Instant(instant);
+    public ReadableInstant toCopy(long newMillis) {
+        return newMillis == iMillis ? this : new Instant(newMillis);
+    }
+    
+    /**
+     * Since Instant does not support chronologies, this method always returns
+     * <code>this</code>.
+     *
+     * @param newChronology  ignored
+     * @return this
+     */
+    public ReadableInstant toCopy(Chronology newChronology) {
+        return this;
     }
     
     // Accessors
diff --git a/JodaTime/src/java/org/joda/time/MutableDateTime.java b/JodaTime/src/java/org/joda/time/MutableDateTime.java
index ad86d1e49..7dadac8a8 100644
--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java
+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java
@@ -61,6 +61,7 @@
 import org.joda.time.convert.DurationConverter;
 import org.joda.time.convert.InstantConverter;
 import org.joda.time.format.ISODateTimeFormat;
+import org.joda.time.property.MutableDateTimeFieldProperty;
 
 /**
  * MutableDateTime is the standard implementation of a modifiable datetime class.
@@ -313,21 +314,33 @@ public MutableDateTime(
 
     //-----------------------------------------------------------------------
     /**
-     * Creates a new instance of this class.
+     * Gets a copy of this instant with different millis.
      * <p>
-     * The returned object will be a new instance of the implementation.
-     * Immutable subclasses may return <code>this</code> if appropriate.
+     * The returned object will be a new instance of the same implementation type.
+     * Only the millis will change, the chronology and time zone are kept.
      *
-     * @param instant  the new instant, from 1970-01-01T00:00:00Z
-     * @param chrono  the new chronology
-     * @return a new instance of this class
+     * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
+     * @return a copy of this instant with different millis
+     */
+    public ReadableInstant toCopy(long newMillis) {
+        return new MutableDateTime(newMillis, getChronology());
+    }
+    
+    /**
+     * Gets a copy of this instant with a different chronology.
+     * <p>
+     * The returned object will be a new instance of the same implementation type.
+     * Only the chronology will change, the millis are kept.
+     *
+     * @param newChronology  the new chronology
+     * @return a copy of this instant with a different chronology
      * @throws IllegalArgumentException if the chronology is null
      */
-    protected ReadableInstant create(long instant, Chronology chrono) {
-        if (chrono == null) {
+    public ReadableInstant toCopy(Chronology newChronology) {
+        if (newChronology == null) {
             throw new IllegalArgumentException("The Chronology must not be null");
         }
-        return new MutableDateTime(instant, chrono);
+        return new MutableDateTime(getMillis(), newChronology);
     }
     
     // Millis
@@ -369,7 +382,7 @@ public void add(final long duration) {
     }
 
     /**
-     * Add an amount of time to the date.
+     * Add an amount of time to the datetime.
      * 
      * @param duration  duration to add.
      */
@@ -378,7 +391,7 @@ public void add(final ReadableDuration duration) {
     }
 
     /**
-     * Add an amount of time to the date.
+     * Add an amount of time to the datetime.
      * 
      * @param duration  duration to add.
      * @param scalar  direction and amount to add, which may be negative
@@ -388,7 +401,7 @@ public void add(final ReadableDuration duration, final int scalar) {
     }
 
     /**
-     * Add an amount of time to the date.
+     * Add an amount of time to the datetime.
      * <p>
      * The recognised object types are defined in {@link ConverterManager} and
      * include ReadableDuration, and Long.
@@ -522,7 +535,7 @@ public void addYears(final int years) {
 
     //-----------------------------------------------------------------------
     /**
-     * Set the week of the year to the specified value.
+     * Set the weekyear to the specified value.
      *
      * @param weekyear  the weekyear
      * @throws IllegalArgumentException if the value is invalid

From db0d0b1b635a08feffe1dacb74337ef9939fd4c2 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 3 Jan 2004 02:28:58 +0000
Subject: [PATCH 076/143] Removed isMatchingType method.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@81 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/time/AbstractPartialInstant.java | 32 ++++++++++++-------
 .../java/org/joda/time/PartialInstant.java    | 12 -------
 2 files changed, 20 insertions(+), 24 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java b/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
index 980cd596f..20e188675 100644
--- a/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
+++ b/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
@@ -300,17 +300,6 @@ public final Chronology getChronology() {
      */
     public abstract DateTimeField getUpperLimit();
 
-    /**
-     * Returns true if the given instant is a PartialDateTime that supports the
-     * same exact set of fields. Implementations may simply do the following:
-     * <pre>
-     *     return instant instanceof &lt;this class&gt;;
-     * </pre>
-     *
-     * @return true if instant is same type as this
-     */
-    public abstract boolean isMatchingType(ReadableInstant instant);
-
     /**
      * Returns the given instant, except with lower and upper limits
      * applied. Field values are reset below the lower limit and at or above
@@ -362,13 +351,32 @@ public final long resetSupportedFields(final long instant) {
      *  not or the instant is null or of an incorrect type
      */
     public boolean equals(Object readableInstant) {
-        return super.equals(readableInstant) && isMatchingType((ReadableInstant) readableInstant);
+        if (this == readableInstant) {
+            return true;
+        }
+        return super.equals(readableInstant) && isMatchingType(readableInstant);
     }
 
     private static boolean equals(Object a, Object b) {
         return (a == b) || (a != null && a.equals(b));
     }
 
+    /**
+     * Returns true if the given instant is a PartialInstant that supports the
+     * same exact set of fields.
+     *
+     * @param instant  the instant to compare to
+     * @return true if instant is same type as this
+     */
+    private boolean isMatchingType(Object instant) {
+        if (instant instanceof PartialInstant) {
+            PartialInstant partial = (PartialInstant)instant;
+            return equals(getLowerLimit(), partial.getLowerLimit())
+                && equals(getUpperLimit(), partial.getUpperLimit());
+        }
+        return false;
+    }
+
     /**
      * Gets a hash code for the instant that is compatable with the 
      * equals method.
diff --git a/JodaTime/src/java/org/joda/time/PartialInstant.java b/JodaTime/src/java/org/joda/time/PartialInstant.java
index c71da5d9b..6aea954a8 100644
--- a/JodaTime/src/java/org/joda/time/PartialInstant.java
+++ b/JodaTime/src/java/org/joda/time/PartialInstant.java
@@ -121,18 +121,6 @@
      */
     DateTimeField getUpperLimit();
 
-    /**
-     * Returns true if the given instant is a PartialDateTime that supports the
-     * same exact set of fields. Implementations may simply do the following:
-     * <pre>
-     *     return instant instanceof &lt;this class&gt;;
-     * </pre>
-     *
-     * @param instant  the instant to compare to
-     * @return true if instant is same type as this
-     */
-    boolean isMatchingType(ReadableInstant instant);
-
     /**
      * Returns the given instant, except with lower and upper limits
      * applied. Field values are reset below the lower limit and at or above

From 83fbf52a40b44405f5f94e6f3fcaaa313428ad6d Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 3 Jan 2004 02:30:00 +0000
Subject: [PATCH 077/143] Completed Date/TimeOnly properties task.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@82 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/ToDo.txt        | 18 +++++-------------
 JodaTime/xdocs/tasks.xml |  1 -
 2 files changed, 5 insertions(+), 14 deletions(-)

diff --git a/JodaTime/ToDo.txt b/JodaTime/ToDo.txt
index f4c190cab..6964b3615 100644
--- a/JodaTime/ToDo.txt
+++ b/JodaTime/ToDo.txt
@@ -3,22 +3,14 @@ JodaTime ToDo list
 
 1.0
 ---
-Duration:
- Write tests
- 
-Interval:
- Write tests
- 
+
 Tests:
- Write tests to cover functionality
+ Write tests for Durations...
+ Write tests for Intervals...
+ Write tests for serialization...
+ ...write tests to cover all functionality
  Ensure all tests pass!
 
-Serializable:
- Tests
- 
-DateOnly/TimeOnly:
- Enable DateTimeProperty
-
 Consistency:
  Check API for design and naming consistency
  eg. withXxx() vs toXxx() vs asXxx vs toCopyXxx()
diff --git a/JodaTime/xdocs/tasks.xml b/JodaTime/xdocs/tasks.xml
index 55c532d64..1d4f9d712 100644
--- a/JodaTime/xdocs/tasks.xml
+++ b/JodaTime/xdocs/tasks.xml
@@ -16,7 +16,6 @@ The following tasks still need doing:
 </p>
 
 <ul>
-<li>DateOnly/TimeOnly properties</li>
 <li>API consistency</li>
 <li>Testing</li>
 <li>Release!</li>

From c7049ff9c7f8f741bb0ad9e1eed053bf77f45b8e Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 3 Jan 2004 02:42:14 +0000
Subject: [PATCH 078/143] Updated to version 2003e.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@83 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/tz/src/Readme.txt  |  2 +-
 JodaTime/src/java/org/joda/time/tz/src/asia   | 50 +++++++-----
 JodaTime/src/java/org/joda/time/tz/src/europe | 38 +++++----
 .../java/org/joda/time/tz/src/northamerica    | 79 ++++++++++++-------
 .../java/org/joda/time/tz/src/southamerica    | 33 ++++++--
 5 files changed, 126 insertions(+), 76 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/tz/src/Readme.txt b/JodaTime/src/java/org/joda/time/tz/src/Readme.txt
index 1f03610f4..d4a52c7aa 100644
--- a/JodaTime/src/java/org/joda/time/tz/src/Readme.txt
+++ b/JodaTime/src/java/org/joda/time/tz/src/Readme.txt
@@ -1,2 +1,2 @@
 The data files in this directory were obtained from the public tz database,
-http://www.twinsun.com/tz/tz-link.htm, version 2003d.
+http://www.twinsun.com/tz/tz-link.htm, version 2003e.
diff --git a/JodaTime/src/java/org/joda/time/tz/src/asia b/JodaTime/src/java/org/joda/time/tz/src/asia
index 6a1dd7699..97a7b1377 100644
--- a/JodaTime/src/java/org/joda/time/tz/src/asia
+++ b/JodaTime/src/java/org/joda/time/tz/src/asia
@@ -1,4 +1,4 @@
-# @(#)asia	7.72
+# @(#)asia	7.73
 
 # This data is by no means authoritative; if you think you know better,
 # go ahead and edit the file (and please send any changes to
@@ -1011,22 +1011,33 @@ Zone	Asia/Beirut	2:22:00 -	LMT	1880
 Rule	NBorneo	1935	1941	-	Sep	14	0:00	0:20	TS # one-Third Summer
 Rule	NBorneo	1935	1941	-	Dec	14	0:00	0	-
 #
-# Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 # peninsular Malaysia
+# From Paul Eggert (2003-11-01):
+# The data here are taken from Mok Ly Yng (2003-10-30)
+# <http://www.math.nus.edu.sg/aslaksen/teaching/timezone.html>.
+# Before 1901, Penang, Malacca and Singapore each had their own time zone;
+# assume Kuala Lumpur used Malaccan time.
+# Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone Asia/Kuala_Lumpur	6:46:48 -	LMT	1880
-			6:55:24	-	SMT	1905 Jun # Singapore Mean Time
-			7:00	-	MALT	1933	 # Malaya Time
-			7:20	-	MALT	1942 Feb 15
-			9:00	-	JST	1945 Sep 2
-			7:20	-	MALT	1950
-			7:30	-	MALT	1982 May
+			6:49:00	-	MMT	1901 Jan  1 # Malacca Mean Time
+			6:55:25	-	SMT	1905 Jun  1 # Singapore M.T.
+			7:00	-	MALT	1933 Jan  1 # Malaya Time
+			7:00	0:20	MALST	1936
+			7:20	-	MALT	1941 Sep  1
+			7:30	-	MALT	1942 Feb 16
+			9:00	-	JST	1945 Sep 12
+			7:30	-	MALT	1982 Jan  1
 			8:00	-	MYT	# Malaysia Time
 # Sabah & Sarawak
+# From Paul Eggert (2003-11-01):
+# The data here are mostly from Shanks, but the 1942, 1945 and 1982
+# transition dates are from Mok Ly Yng.
+# Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone Asia/Kuching	7:21:20	-	LMT	1926 Mar
 			7:30	-	BORT	1933	# Borneo Time
-			8:00	NBorneo	BOR%sT	1942
-			9:00	-	JST	1945 Sep 2
-			8:00	-	BORT	1982 May
+			8:00	NBorneo	BOR%sT	1942 Feb 16
+			9:00	-	JST	1945 Sep 12
+			8:00	-	BORT	1982 Jan  1
 			8:00	-	MYT
 
 # Maldives
@@ -1295,15 +1306,18 @@ Zone	Asia/Riyadh	3:06:52 -	LMT	1950
 			3:00	-	AST
 
 # Singapore
+# The data here are taken from Mok Ly Yng (2003-10-30)
+# <http://www.math.nus.edu.sg/aslaksen/teaching/timezone.html>.
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
-Zone	Asia/Singapore	6:55:24 -	LMT	1880
-			6:55:24	-	SMT	1905 Jun # Singapore Mean Time
-			7:00	-	MALT	1933	 # Malaya Time
-			7:20	-	MALT	1942 Feb 15
-			9:00	-	JST	1945 Sep  2
-			7:20	-	MALT	1950
+Zone	Asia/Singapore	6:55:25 -	LMT	1880
+			6:55:25	-	SMT	1905 Jun  1 # Singapore M.T.
+			7:00	-	MALT	1933 Jan  1 # Malaya Time
+			7:00	0:20	MALST	1936
+			7:20	-	MALT	1941 Sep  1
+			7:30	-	MALT	1942 Feb 16
+			9:00	-	JST	1945 Sep 12
 			7:30	-	MALT	1965 Aug  9 # independence
-			7:30	-	SGT	1982 May # Singapore Time
+			7:30	-	SGT	1982 Jan  1 # Singapore Time
 			8:00	-	SGT
 
 # Spratly Is
diff --git a/JodaTime/src/java/org/joda/time/tz/src/europe b/JodaTime/src/java/org/joda/time/tz/src/europe
index d1e7178e8..dc7b78052 100644
--- a/JodaTime/src/java/org/joda/time/tz/src/europe
+++ b/JodaTime/src/java/org/joda/time/tz/src/europe
@@ -1,4 +1,4 @@
-# @(#)europe	7.84
+# @(#)europe	7.86
 
 # This data is by no means authoritative; if you think you know better,
 # go ahead and edit the file (and please send any changes to
@@ -129,7 +129,7 @@
 # transition date for London, namely 1847-12-01.  We don't know as much
 # about Dublin, so we use 1880-08-02, the legal transition time.
 
-# From Paul Eggert (2003-07-29):
+# From Paul Eggert (2003-09-27):
 # Summer Time was first seriously proposed by William Willett (1857-1915),
 # a London builder and member of the Royal Astronomical Society
 # who circulated a pamphlet ``The Waste of Daylight'' (1907)
@@ -141,7 +141,7 @@
 # it was eventually adopted as a wartime measure in 1916.
 # See: Summer Time Arrives Early, The Times (2000-05-18).
 # A monument to Willett was unveiled on 1927-05-21, in an open space in
-# a 45-acre wood near Chiselhurst, Kent that was purchased by popular
+# a 45-acre wood near Chislehurst, Kent that was purchased by popular
 # subscription and open to the public.  On the south face of the monolith,
 # designed by G. W. Miller, is the the William Willett Memorial Sundial,
 # which is permanently set to Summer Time.
@@ -1831,7 +1831,7 @@ Zone Europe/Bucharest	1:44:24 -	LMT	1891 Oct
 #
 # From Andrey A. Chernov <ache@nagual.ru> (1996-10-04):
 # `MSK' and `MSD' were born and used initially on Moscow computers with
-# Unix-like OSes by several developer groups (e.g. Demos group, Kiae group)....
+# UNIX-like OSes by several developer groups (e.g. Demos group, Kiae group)....
 # The next step was the UUCP network, the Relcom predecessor
 # (used mainly for mail), and MSK/MSD was actively used there.
 #
@@ -1952,28 +1952,26 @@ Zone Asia/Irkutsk	 6:57:20 -	LMT	1880
 			 7:00	Russia	IRK%sT	1992 Jan 19 2:00s
 			 8:00	Russia	IRK%sT
 #
-# From Oscar van Vlijmen (2001-08-25): [This region consists of]
+# From Oscar van Vlijmen (2003-10-18): [This region consists of]
 # Aginskij Buryatskij avtonomnyj okrug, Amurskaya oblast',
 # [parts of] Respublika Sakha (Yakutiya), Chitinskaya oblast'.
-#
-# From Alan Pritchard (2001-08-24): [The Sakha districts are:]
-# Aldansky, Amginsky, Anabarsky, Bulunsky, Churapchinsky,
-# Eveno-Bytantaisky, Gorny, Khangalassky, Kobyaisky, Lensky,
-# Megino-Kangalassky, Mirninsky, Namsky, Nyurbinsky, Olenyoksky,
-# Olyokminsky, Srednekolymsky, Suntarsky, Tattinsky, Ust-Aldansky,
-# Verkhnekolymsky, Verkhnevilyuisky, Vilyuisky, Zhigansky.
+# The Sakha districts are: Aldanskij, Amginskij, Anabarskij,
+# Bulunskij, Verkhnekolymskij, Verkhnevilyujskij, Vilyujskij, Gornyj,
+# Zhiganskij, Kobyajskij, Lenskij, Megino-Kangalasskij, Mirninskij,
+# Namskij, Nyurbinskij, Olenekskij, Olekminskij, Srednekolymskij,
+# Suntarskij, Tattinskij, Ust'-Aldanskij, Khangalasskij,
+# Churapchinskij, Eveno-Bytantajskij.
 Zone Asia/Yakutsk	 8:38:40 -	LMT	1919 Dec 15
 			 8:00	-	YAKT	1930 Jun 21 # Yakutsk Time
 			 9:00	Russia	YAK%sT	1991 Mar 31 2:00s
 			 8:00	Russia	YAK%sT	1992 Jan 19 2:00s
 			 9:00	Russia	YAK%sT
 #
-# From Oscar van Vlijmen (2001-08-25): [This region consists of]
+# From Oscar van Vlijmen (2003-10-18): [This region consists of]
 # Evrejskaya avtonomnaya oblast', Khabarovskij kraj, Primorskij kraj,
 # [parts of] Respublika Sakha (Yakutiya).
-#
-# From Alan Pritchard (2001-08-24): [The Sakha districts are:]
-# Tomponsky, Ust-Maisky, Ust-Yansky, Verkhoyansky.
+# The Sakha districts are: Verkhoyanskij, Tomponskij, Ust'-Majskij,
+# Ust'-Yanskij.
 Zone Asia/Vladivostok	 8:47:44 -	LMT	1922 Nov 15
 			 9:00	-	VLAT	1930 Jun 21 # Vladivostok Time
 			10:00	Russia	VLA%sT	1991 Mar 31 2:00s
@@ -1990,11 +1988,11 @@ Zone Asia/Sakhalin	 9:30:48 -	LMT	1905 Aug 23
 			11:00	Russia	SAK%sT	1997 Mar lastSun 2:00s
 			10:00	Russia	SAK%sT
 #
-# From Oscar van Vlijmen (2001-08-25): [This region consists of]
+# From Oscar van Vlijmen (2003-10-18): [This region consists of]
 # Magadanskaya oblast', Respublika Sakha (Yakutiya).
-#
-# From Alan Pritchard (2001-08-24): [The Sakha districts are:]
-# Abyisky, Allaikhovsky, Momsky, Nizhnekolymsky, Oimyakonsky.
+# Probably also: Kuril Islands.
+# The Sakha districts are: Abyjskij, Allaikhovskij, Momskij,
+# Nizhnekolymskij, Ojmyakonskij.
 Zone Asia/Magadan	10:03:12 -	LMT	1924 May  2
 			10:00	-	MAGT	1930 Jun 21 # Magadan Time
 			11:00	Russia	MAG%sT	1991 Mar 31 2:00s
diff --git a/JodaTime/src/java/org/joda/time/tz/src/northamerica b/JodaTime/src/java/org/joda/time/tz/src/northamerica
index 6b7674778..61058bb76 100644
--- a/JodaTime/src/java/org/joda/time/tz/src/northamerica
+++ b/JodaTime/src/java/org/joda/time/tz/src/northamerica
@@ -1,4 +1,4 @@
-# @(#)northamerica	7.63
+# @(#)northamerica	7.67
 # also includes Central America and the Caribbean
 
 # This data is by no means authoritative; if you think you know better,
@@ -228,7 +228,9 @@ Zone America/New_York	-4:56:02 -	LMT	1883 Nov 18 12:00
 
 # US central time, represented by Chicago
 
-# Alabama, Arkansas, Florida panhandle, Illinois, western Indiana
+# Alabama, Arkansas, Florida panhandle (Bay, Calhoun, Escambia,
+# Gulf, Holmes, Jackson, Okaloosa, Santa Rosa, Walton, and
+# Washington counties), Illinois, western Indiana
 # (Gibson, Jasper, Lake, LaPorte, Newton, Porter, Posey, Spencer,
 # Vanderburgh, and Warrick counties), Iowa, most of Kansas, western
 # Kentucky, Louisiana, Minnesota, Mississippi, Missouri, eastern
@@ -258,7 +260,7 @@ Zone America/North_Dakota/Center -6:45:12 - LMT	1883 Nov 18 12:00
 
 # US mountain time, represented by Denver
 #
-# Colorado, southern Idaho, far western Kansas, Montana, western
+# Colorado, far western Kansas, Montana, western
 # Nebraska, Nevada border (Jackpot, Owyhee, and Mountain City),
 # New Mexico, southwestern North Dakota, far eastern Oregon,
 # western South Dakota, far western Texas (El Paso County, Hudspeth County,
@@ -280,7 +282,9 @@ Zone America/Denver	-6:59:56 -	LMT	1883 Nov 18 12:00
 
 # US Pacific time, represented by Los Angeles
 #
-# California, northern Idaho, most of Nevada, most of Oregon, and Washington
+# California, northern Idaho (Benewah, Bonner, Boundary, Clearwater,
+# Idaho, Kootenai, Latah, Lewis, Nez Perce, and Shoshone counties),
+# most of Nevada, most of Oregon, and Washington
 #
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER
 Rule	CA	1948	only	-	Mar	14	2:00	1:00	D
@@ -405,14 +409,20 @@ Zone America/Phoenix	-7:28:18 -	LMT	1883 Nov 18 12:00
 			-7:00	-	MST
 # From Arthur David Olson (1988-02-13):
 # A writer from the Inter Tribal Council of Arizona, Inc.,
-# notes in private correspondence dated 12/28/87 that "Presently, only the
+# notes in private correspondence dated 1987-12-28 that "Presently, only the
 # Navajo Nation participates in the Daylight Saving Time policy, due to its
 # large size and location in three states."  (The "only" means that other
 # tribal nations don't use DST.)
 
 Link America/Denver America/Shiprock
 
-# Southern Idaho and eastern Oregon switched four weeks late in 1974.
+# Southern Idaho (Ada, Adams, Bannock, Bear Lake, Bingham, Blaine,
+# Boise, Bonneville, Butte, Camas, Canyon, Caribou, Cassia, Clark,
+# Custer, Elmore, Franklin, Fremont, Gem, Gooding, Jefferson, Jerome,
+# Lemhi, Lincoln, Madison, Minidoka, Oneida, Owyhee, Payette, Power,
+# Teton, Twin Falls, Valley, Washington counties) and eastern Oregon
+# switched four weeks late in 1974.
+# 
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone America/Boise	-7:44:49 -	LMT	1883 Nov 18 12:00
 			-8:00	US	P%sT	1923 May 13 2:00
@@ -951,10 +961,18 @@ Rule	Mont	1922	only	-	Apr	30	2:00	1:00	D
 Rule	Mont	1924	only	-	May	17	2:00	1:00	D
 Rule	Mont	1924	1926	-	Sep	lastSun	2:30	0	S
 Rule	Mont	1925	1926	-	May	Sun>=1	2:00	1:00	D
-Rule	Mont	1927	1937	-	Apr	lastSat	24:00	1:00	D
-Rule	Mont	1927	1937	-	Sep	lastSat	24:00	0	S
-Rule	Mont	1938	1940	-	Apr	lastSun	0:00	1:00	D
-Rule	Mont	1938	1939	-	Sep	lastSun	0:00	0	S
+# The 1927-to-1937 rules can be expressed more simply as
+# Rule	Mont	1927	1937	-	Apr	lastSat	24:00	1:00	D
+# Rule	Mont	1927	1937	-	Sep	lastSat	24:00	0	S
+# The rules below avoid use of 24:00
+# (which pre-1998 versions of zic cannot handle).
+Rule	Mont	1927	only	-	May	1	0:00	1:00	D
+Rule	Mont	1927	1932	-	Sep	lastSun	0:00	0	S
+Rule	Mont	1928	1931	-	Apr	lastSun	0:00	1:00	D
+Rule	Mont	1932	only	-	May	1	0:00	1:00	D
+Rule	Mont	1933	1940	-	Apr	lastSun	0:00	1:00	D
+Rule	Mont	1933	only	-	Oct	1	0:00	0	S
+Rule	Mont	1934	1939	-	Sep	lastSun	0:00	0	S
 Rule	Mont	1946	1973	-	Apr	lastSun	2:00	1:00	D
 Rule	Mont	1945	1948	-	Sep	lastSun	2:00	0	S
 Rule	Mont	1949	1950	-	Oct	lastSun	2:00	0	S
@@ -971,14 +989,12 @@ Rule	Toronto	1922	1923	-	May	Sun>=8	2:00	1:00	D
 # Shanks says 1923-09-19; assume it's a typo and that "-16" was meant.
 Rule	Toronto	1922	1926	-	Sep	Sun>=15	2:00	0	S
 Rule	Toronto	1924	1927	-	May	Sun>=1	2:00	1:00	D
-Rule	Toronto	1927	1928	-	Sep	lastSun	2:00	0	S
-Rule	Toronto	1928	only	-	Apr	lastSun	2:00	1:00	D
-Rule	Toronto	1929	only	-	Apr	lastSun	0:00	1:00	D
-Rule	Toronto	1929	only	-	Sep	lastSun	0:00	0	S
-Rule	Toronto	1930	1937	-	Apr	lastSat	24:00	1:00	D
-Rule	Toronto	1930	1937	-	Sep	lastSat	24:00	0	S
-Rule	Toronto	1938	1940	-	Apr	lastSun	0:00	1:00	D
-Rule	Toronto	1938	1939	-	Sep	lastSun	0:00	0	S
+Rule	Toronto	1927	1932	-	Sep	lastSun	2:00	0	S
+Rule	Toronto	1928	1931	-	Apr	lastSun	2:00	1:00	D
+Rule	Toronto	1932	only	-	May	1	2:00	1:00	D
+Rule	Toronto	1933	1940	-	Apr	lastSun	2:00	1:00	D
+Rule	Toronto	1933	only	-	Oct	1	2:00	0	S
+Rule	Toronto	1934	1939	-	Sep	lastSun	2:00	0	S
 Rule	Toronto	1945	1946	-	Sep	lastSun	2:00	0	S
 Rule	Toronto	1946	only	-	Apr	lastSun	2:00	1:00	D
 Rule	Toronto	1947	1949	-	Apr	lastSun	0:00	1:00	D
@@ -996,15 +1012,19 @@ Rule	Toronto	1957	1973	-	Oct	lastSun	2:00	0	S
 # Willett (1914-03) writes (p. 17) "In the Cities of Fort William, and
 # Port Arthur, Ontario, the principle of the Bill has been in
 # operation for the past three years, and in the City of Moose Jaw,
-# Saskatchewan, for one year."  Assume that the Thunder Bay region
-# observed DST starting 1910, and Moose Jaw starting 1912, as this
-# matches the Toronto Star report about Moose Jaw.  For lack of better
-# info, assume the Thunder Bay region used Willett's proposal, namely
-# third Sunday in April at 02:00 to third Sunday in September at
-# 03:00; also assume that they continued until Canada instituted
-# uniform DST in 1918.
-Rule	Thunder	1910	1917	-	Apr	Sun>=15	2:00s	1:00	D
-Rule	Thunder	1910	1917	-	Sep	Sun>=15	2:00s	0	S
+# Saskatchewan, for one year."
+
+# From David Bryan via Tory Tronrud, Director/Curator,
+# Thunder Bay Museum (2003-11-12):
+# There is some suggestion, however, that, by-law or not, daylight
+# savings time was being practiced in Fort William and Port Arthur
+# before 1909.... [I]n 1910, the line between the Eastern and Central
+# Time Zones was permanently moved about two hundred miles west to
+# include the Thunder Bay area....  When Canada adopted daylight
+# savings time in 1916, Fort William and Port Arthur, having done so
+# already, did not change their clocks....  During the Second World
+# War,... [t]he cities agreed to implement DST during the summer
+# months for the remainder of the war years.
 
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone America/Montreal	-4:54:16 -	LMT	1884
@@ -1021,9 +1041,8 @@ Zone America/Toronto	-5:17:32 -	LMT	1895
 			-5:00	Toronto	E%sT	1974
 			-5:00	Canada	E%sT
 Zone America/Thunder_Bay -5:57:00 -	LMT	1895
-			-5:00	Thunder	E%sT	1918
-			-5:00	Canada	E%sT	1940 Sep 29
-			-5:00	1:00	EDT	1942 Feb  9 2:00s
+			-6:00	-	CST	1910
+			-5:00	-	EST	1942
 			-5:00	Canada	E%sT	1970
 			-5:00	Mont	E%sT	1973
 			-5:00	-	EST	1974
diff --git a/JodaTime/src/java/org/joda/time/tz/src/southamerica b/JodaTime/src/java/org/joda/time/tz/src/southamerica
index 6d9b8ac6b..3373756f8 100644
--- a/JodaTime/src/java/org/joda/time/tz/src/southamerica
+++ b/JodaTime/src/java/org/joda/time/tz/src/southamerica
@@ -1,4 +1,4 @@
-# @(#)southamerica	7.49
+# @(#)southamerica	7.50
 
 # This data is by no means authoritative; if you think you know better,
 # go ahead and edit the file (and please send any changes to
@@ -390,9 +390,9 @@ Rule	Brazil	1993	only	-	Jan	31	 0:00	0	-
 # Decree <a href="http://pcdsh01.on.br/HV942.htm">942</a> (1993-09-28)
 # adopted by same states, plus AM.
 # Decree <a href="http://pcdsh01.on.br/HV1252.htm">1,252</a> (1994-09-22)
-# adopted by same states, minus AM.
+# adopted by same states, minus AM and MT.
 # Decree <a href="http://pcdsh01.on.br/HV1636.htm">1,636</a> (1995-09-14)
-# adopted by same states, plus TO.
+# adopted by same states, plus MT and TO.
 # Decree <a href="http://pcdsh01.on.br/HV1674.htm">1,674</a> (1995-10-13)
 # adds AL, SE.
 Rule	Brazil	1993	1995	-	Oct	Sun>=11	 0:00	1:00	S
@@ -455,11 +455,19 @@ Rule	Brazil	2003	max	-	Oct	Sun>=15	 0:00	1:00	S
 
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 #
-# Atlantic islands: Fernando de Noronha, Trindade, Martin Vaz,
-# Atol das Rocas, and Penedos de Sao Pedro e Sao Paulo
+# Fernando de Noronha (administratively part of PE)
 Zone America/Noronha	-2:09:40 -	LMT	1914
 			-2:00	Brazil	FN%sT	1990 Sep 17
+			-2:00	-	FNT	1999 Sep 30
+			-2:00	Brazil	FN%sT	2000 Oct 15
+			-2:00	-	FNT	2001 Sep 13
+			-2:00	Brazil	FN%sT	2002 Oct  1
 			-2:00	-	FNT
+# Other Atlantic islands have no permanent settlement.
+# These include Trindade and Martin Vaz (administratively part of ES),
+# Atol das Rocas (RN), and Penedos de Sao Pedro e Sao Paulo (PE).
+# Fernando de Noronha was a separate territory from 1942-09-02 to 1989-01-01;
+# it also included the Penedos.
 #
 # Amapa (AP), east Para (PA)
 # East Para includes Belem, Maraba, Serra Norte, and Sao Felix do Xingu.
@@ -528,6 +536,8 @@ Zone America/Campo_Grande -3:38:28 -	LMT	1914
 #
 # Mato Grosso (MT)
 Zone America/Cuiaba	-3:44:20 -	LMT	1914
+			-4:00	Brazil	AM%sT	1994 Sep 22
+			-4:00	-	AMT	1995 Sep 14
 			-4:00	Brazil	AM%sT	2003 Sep 24
 			-4:00	-	AMT
 #
@@ -811,13 +821,22 @@ Zone America/Asuncion	-3:50:40 -	LMT	1890
 			-4:00	Para	PY%sT
 
 # Peru
+#
+# <a href="news:xrGmb.39935$gA1.13896113@news4.srv.hcvlny.cv.net">
+# From Evelyn C. Leeper via Mark Brader (2003-10-26):</a>
+# When we were in Peru in 1985-1986, they apparently switched over 
+# sometime between December 29 and January 3 while we were on the Amazon.
+#
+# From Paul Eggert (2003-11-02):
+# Shanks doesn't have this transition.  Assume 1986 was like 1987.
+
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 Rule	Peru	1938	only	-	Jan	 1	0:00	1:00	S
 Rule	Peru	1938	only	-	Apr	 1	0:00	0	-
 Rule	Peru	1938	1939	-	Sep	lastSun	0:00	1:00	S
 Rule	Peru	1939	1940	-	Mar	Sun>=24	0:00	0	-
-Rule	Peru	1987	only	-	Jan	 1	0:00	1:00	S
-Rule	Peru	1987	only	-	Apr	 1	0:00	0	-
+Rule	Peru	1986	1987	-	Jan	 1	0:00	1:00	S
+Rule	Peru	1986	1987	-	Apr	 1	0:00	0	-
 Rule	Peru	1990	only	-	Jan	 1	0:00	1:00	S
 Rule	Peru	1990	only	-	Apr	 1	0:00	0	-
 # IATA is ambiguous for 1993/1995; go with Shanks.

From face183fb114dc6c322e26c7dca81598db2a69b7 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 3 Jan 2004 02:51:03 +0000
Subject: [PATCH 079/143] Minor spelling error.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@84 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/xdocs/index.xml     | 2 +-
 JodaTime/xdocs/userguide.xml | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/JodaTime/xdocs/index.xml b/JodaTime/xdocs/index.xml
index 4c6da66a3..e08e9de7e 100644
--- a/JodaTime/xdocs/index.xml
+++ b/JodaTime/xdocs/index.xml
@@ -29,7 +29,7 @@ The Joda Dates project seeks to provide an implementation of dates and times for
 The 'default' calendar system implemented will be the ISO8601 standard.
 This specifies a framework for date and time independent of locale.
 Thus, in the standard, the first day of the week is Monday, and this has the index 1.
-This avoids any ambiguity accross national boundaries.
+This avoids any ambiguity across national boundaries.
 </p>
 
 <p>
diff --git a/JodaTime/xdocs/userguide.xml b/JodaTime/xdocs/userguide.xml
index d74ac8de2..9f8cc48af 100644
--- a/JodaTime/xdocs/userguide.xml
+++ b/JodaTime/xdocs/userguide.xml
@@ -31,7 +31,7 @@ to split the time, stored in milliseconds, into a recognisable fields like 'day
 The current chronologies supplied are:
 </p>
 <ul>
-<li>ISOChronology - Implements the ISO8601 standard, which is compatable with Gregorian in modern times.</li>
+<li>ISOChronology - Implements the ISO8601 standard, which is compatible with Gregorian in modern times.</li>
 <li>GJChronology - The Gregorian/Julian calendar system, for historical use.</li>
 <li>BuddhistChronology - Offset from Gregorian/Julian by 543 years.</li>
 </ul>

From c97dc410de66b2c4aeba494d150e6ab044e0b3c2 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 3 Jan 2004 03:05:54 +0000
Subject: [PATCH 080/143] Describe package.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@85 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/property/package.html  | 78 +++++++++++++++++++
 1 file changed, 78 insertions(+)
 create mode 100644 JodaTime/src/java/org/joda/time/property/package.html

diff --git a/JodaTime/src/java/org/joda/time/property/package.html b/JodaTime/src/java/org/joda/time/property/package.html
new file mode 100644
index 000000000..8dd8490a8
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/property/package.html
@@ -0,0 +1,78 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<html>
+<head>
+<title>org.joda.time.property package</title>
+<!--
+
+   Joda Software License, Version 1.0
+  
+  
+   Copyright (c) 2001-03 Stephen Colebourne.
+   All rights reserved.
+  
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions
+   are met:
+  
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+  
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+  
+   3. The end-user documentation included with the redistribution,
+      if any, must include the following acknowledgment:
+         "This product includes software developed by the
+          Joda project (http://www.joda.org/)."
+      Alternately, this acknowledgment may appear in the software itself,
+      if and wherever such third-party acknowledgments normally appear.
+  
+   4. The name "Joda" must not be used to endorse or promote products
+      derived from this software without prior written permission. For
+      written permission, please contact licence@joda.org.
+  
+   5. Products derived from this software may not be called "Joda",
+      nor may "Joda" appear in their name, without prior written
+      permission of the Joda project.
+  
+   THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+   USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+   OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+   SUCH DAMAGE.
+   ====================================================================
+  
+   This software consists of voluntary contributions made by many
+   individuals on behalf of the Joda project and was originally
+   created by Stephen Colebourne <scolebourne@joda.org>. For more
+   information on the Joda project, please see <http://www.joda.org/>.
+
+-->
+</head>
+<body>
+<p>
+Provides field property support for datetimes.
+</p>
+<p>
+Generally, classes in this package need not be explicitly imported. Property
+objects are intended to have a single use, and they don't need to be referenced
+by a variable. Here is an example using DateTimeFieldProperty:
+<pre>
+DateTime dt = new DateTime(1972, 12, 3, 0, 0, 0, 0);
+int year = dt.year().get();
+String monthStr = dt.month().getAsText();
+</pre>
+The calls to <code>year()</code> and <code>month()</code> return a
+DateTimeFieldProperty instance which is only used to call <code>get()</code>
+and <code>getAsText()</code>, respectively.
+</body>
+</html>

From 5286892077cd18e8e13d60de9b519b4b6ce8a2ee Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 3 Jan 2004 07:41:06 +0000
Subject: [PATCH 081/143] Support week date formats.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@86 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../joda/time/format/ISODateTimeFormat.java   | 250 ++++++++++++++----
 1 file changed, 197 insertions(+), 53 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
index 48484cc89..c8536c9e5 100644
--- a/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
+++ b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
@@ -142,18 +142,25 @@ public static synchronized ISODateTimeFormat getInstance(Chronology chrono) {
 
     private transient DateTimeFormatter
         ye,  // year element (yyyy)
-        me,  // month element (-MM)
-        de,  // day element (-dd)
-        he,  // hour element (HH)
-        mne, // minute element (:mm)
-        se,  // second element (:ss)
-        fe,  // fraction element (.SSS)
+        mye, // monthOfYear element (-MM)
+        dme, // dayOfMonth element (-dd)
+        we,  // weekyear element (xxxx)
+        wwe, // weekOfWeekyear element (-ww)
+        dwe, // dayOfWeek element (-ee)
+        hde, // hourOfDay element (HH)
+        mhe, // minuteOfHour element (:mm)
+        sme, // secondOfMinute element (:ss)
+        fse, // fractionOfSecond element (.SSS)
         ze,  // zone offset element
         
         //y,   // year (same as year element)
         ym,  // year month
         ymd, // year month day
 
+        //w,   // weekyear (same as weekyear element)
+        ww,  // weekyear week
+        wwd, // weekyear week day
+
         //h,    // hour (same as hour element)
         hm,   // hour minute
         hms,  // hour minute second
@@ -168,15 +175,21 @@ public static synchronized ISODateTimeFormat getInstance(Chronology chrono) {
         t,  // time
         dt, // date time
 
+        //wd,  // week date (same as wwd)
+        wdt, // week date time
+
         bd,  // basic date
         bt,  // basic time
-        bdt; // basic date time
+        bdt, // basic date time
+
+        bwd,  // basic week date
+        bwdt; // basic week date time
 
     private transient DateTimeParser
         dpe, // date parser element
         tpe, // time parser element
-        dp, // date parser
-        tp, // time parser
+        dp,  // date parser
+        tp,  // time parser
         dtp; // date time parser
 
     /**
@@ -193,9 +206,10 @@ private ISODateTimeFormat(final Chronology chrono) {
      * Returns a generic ISO date parser. It accepts formats described by
      * the following syntax:
      * <pre>
-     * date         = date-element ['T' offset]
-     * date-element = yyyy ['-' MM ['-' dd]]
-     * offset       = 'Z' | (('+' | '-') HH ':' mm)
+     * date              = date-element ['T' offset]
+     * date-element      = (yyyy ['-' MM ['-' dd]]) | week-date-element
+     * week-date-element = xxxx '-W' ww ['-' e]
+     * offset            = 'Z' | (('+' | '-') HH ':' mm)
      * </pre>
      */
     public DateTimeParser dateParser() {
@@ -216,18 +230,28 @@ public DateTimeParser dateParser() {
      * Returns a generic ISO date parser. It accepts formats described by
      * the following syntax:
      * <pre>
-     * date-element = yyyy ['-' MM ['-' dd]]
+     * date-element      = (yyyy ['-' MM ['-' dd]]) | week-date-element
+     * week-date-element = xxxx '-W' ww ['-' e]
      * </pre>
      */
     public DateTimeParser dateElementParser() {
         if (dpe == null) {
             dpe = new DateTimeFormatterBuilder(iChrono)
-                .append(yearElement())
-                .appendOptional
-                (new DateTimeFormatterBuilder(iChrono)
-                 .append(monthElement())
-                 .appendOptional(dayElement())
-                 .toParser())
+                .append(null, new DateTimeParser[] {
+                    new DateTimeFormatterBuilder(iChrono)
+                    .append(yearElement())
+                    .appendOptional
+                    (new DateTimeFormatterBuilder(iChrono)
+                     .append(monthElement())
+                     .appendOptional(dayOfMonthElement())
+                     .toParser())
+                    .toParser(),
+                    new DateTimeFormatterBuilder(iChrono)
+                    .append(weekyearElement())
+                    .append(weekElement())
+                    .appendOptional(dayOfWeekElement())
+                    .toParser()
+                })
                 .toParser();
         }
         return dpe;
@@ -285,11 +309,12 @@ public DateTimeParser timeElementParser() {
      * Returns a generic ISO datetime parser. It accepts formats described by
      * the following syntax:
      * <pre>
-     * datetime     = time | (date-element [time | ('T' offset)])
-     * time         = 'T' time-element [offset]
-     * date-element = yyyy ['-' MM ['-' dd]]
-     * time-element = HH [':' mm [':' ss ['.' SSS]]]
-     * offset       = 'Z' | (('+' | '-') HH ':' mm)
+     * datetime          = time | (date-element [time | ('T' offset)])
+     * time              = 'T' time-element [offset]
+     * date-element      = (yyyy ['-' MM ['-' dd]]) | week-date-element
+     * week-date-element = xxxx '-W' ww ['-' e]
+     * time-element      = HH [':' mm [':' ss ['.' SSS]]]
+     * offset            = 'Z' | (('+' | '-') HH ':' mm)
      * </pre>
      */
     public DateTimeParser dateTimeParser() {
@@ -334,8 +359,8 @@ public DateTimeFormatter date() {
     /**
      * Returns a formatter for a two digit hour of day, two digit minute of
      * hour, two digit second of minute, three digit fraction of second, and
-     * time zone offset. (HH:mm:ss.SSSZ) The time zone offset is 'Z' for zero, and
-     * of the form '\u00b1HH:mm' for non-zero.
+     * time zone offset. (HH:mm:ss.SSSZ) The time zone offset is 'Z' for zero,
+     * and of the form '\u00b1HH:mm' for non-zero.
      */
     public DateTimeFormatter time() {
         if (t == null) {
@@ -348,8 +373,8 @@ public DateTimeFormatter time() {
     }
 
     /**
-     * Returns a formatter that combines a full date and time, separated by a 'T'.
-     * (yyyy-MM-ddTHH:mm:ss.SSSZ)
+     * Returns a formatter that combines a full date and time, separated by a
+     * 'T'. (yyyy-MM-dd'T'HH:mm:ss.SSSZ)
      */
     public DateTimeFormatter dateTime() {
         if (dt == null) {
@@ -362,6 +387,29 @@ public DateTimeFormatter dateTime() {
         return dt;
     }
 
+    /**
+     * Returns a formatter for a full date as four digit weekyear, two digit
+     * week of weekyear, and one digit day of week. (xxxx-'W'ww-e)
+     */
+    public DateTimeFormatter weekDate() {
+        return weekyearWeekDay();
+    }
+
+    /**
+     * Returns a formatter that combines a full weekyear date and time,
+     * separated by a 'T'. (xxxx-'W'ww-e'T'HH:mm:ss.SSSZ)
+     */
+    public DateTimeFormatter weekDateTime() {
+        if (wdt == null) {
+            wdt = new DateTimeFormatterBuilder(iChrono)
+                .append(weekDate())
+                .appendLiteral('T')
+                .append(time())
+                .toFormatter();
+        }
+        return wdt;
+    }
+
     //-----------------------------------------------------------------------
     /**
      * Returns a basic formatter for a full date as four digit year, two digit
@@ -397,7 +445,7 @@ public DateTimeFormatter basicTime() {
 
     /**
      * Returns a basic formatter that combines a basic date and time, separated
-     * by a 'T'. (yyyyMMddTHHmmssZ)
+     * by a 'T'. (yyyyMMdd'T'HHmmssZ)
      */
     public DateTimeFormatter basicDateTime() {
         if (bdt == null) {
@@ -410,6 +458,37 @@ public DateTimeFormatter basicDateTime() {
         return bdt;
     }
 
+    /**
+     * Returns a basic formatter for a full date as four digit weekyear, two
+     * digit week of weekyear, and one digit day of week. (xxxx'W'wwe)
+     */
+    public DateTimeFormatter basicWeekDate() {
+        if (bwd == null) {
+            bwd = new DateTimeFormatterBuilder(iChrono)
+                .appendWeekyear(4, 4)
+                .appendLiteral('W')
+                .appendWeekOfWeekyear(2)
+                .appendDayOfWeek(1)
+                .toFormatter();
+        }
+        return bwd;
+    }
+
+    /**
+     * Returns a basic formatter that combines a basic weekyear date and time,
+     * separated by a 'T'. (xxxx'W'wwe'T'HHmmssZ)
+     */
+    public DateTimeFormatter basicWeekDateTime() {
+        if (bwdt == null) {
+            bwdt = new DateTimeFormatterBuilder(iChrono)
+                .append(basicWeekDate())
+                .appendLiteral('T')
+                .append(basicTime())
+                .toFormatter();
+        }
+        return bwdt;
+    }
+
     //-----------------------------------------------------------------------
     /**
      * Returns a formatter for a four digit year. (yyyy)
@@ -441,12 +520,48 @@ public DateTimeFormatter yearMonthDay() {
             ymd = new DateTimeFormatterBuilder(iChrono)
                 .append(yearElement())
                 .append(monthElement())
-                .append(dayElement())
+                .append(dayOfMonthElement())
                 .toFormatter();
         }
         return ymd;
     }
 
+    /**
+     * Returns a formatter for a four digit weekyear. (xxxx)
+     */
+    public DateTimeFormatter weekyear() {
+        return weekyearElement();
+    }
+
+    /**
+     * Returns a formatter for a four digit weekyear and two digit week of
+     * weekyear. (xxxx-'W'ww)
+     */
+    public DateTimeFormatter weekyearWeek() {
+        if (ww == null) {
+            ww = new DateTimeFormatterBuilder(iChrono)
+                .append(weekyearElement())
+                .append(weekElement())
+                .toFormatter();
+        }
+        return ww;
+    }
+
+    /**
+     * Returns a formatter for a four digit weekyear, two digit week of
+     * weekyear, and one digit day of week. (xxxx-'W'ww-e)
+     */
+    public DateTimeFormatter weekyearWeekDay() {
+        if (wwd == null) {
+            wwd = new DateTimeFormatterBuilder(iChrono)
+                .append(weekyearElement())
+                .append(weekElement())
+                .append(dayOfWeekElement())
+                .toFormatter();
+        }
+        return wwd;
+    }
+
     /**
      * Returns a formatter for a two digit hour of day. (HH)
      */
@@ -502,7 +617,7 @@ public DateTimeFormatter hourMinuteSecondFraction() {
 
     /**
      * Returns a formatter that combines a full date and two digit hour of
-     * day. (yyyy-MM-ddTHH)
+     * day. (yyyy-MM-dd'T'HH)
      */
     public DateTimeFormatter dateHour() {
         if (dh == null) {
@@ -517,7 +632,7 @@ public DateTimeFormatter dateHour() {
 
     /**
      * Returns a formatter that combines a full date, two digit hour of day,
-     * and two digit minute of hour. (yyyy-MM-ddTHH:mm)
+     * and two digit minute of hour. (yyyy-MM-dd'T'HH:mm)
      */
     public DateTimeFormatter dateHourMinute() {
         if (dhm == null) {
@@ -533,7 +648,7 @@ public DateTimeFormatter dateHourMinute() {
     /**
      * Returns a formatter that combines a full date, two digit hour of day,
      * two digit minute of hour, and two digit second of
-     * minute. (yyyy-MM-ddTHH:mm:ss)
+     * minute. (yyyy-MM-dd'T'HH:mm:ss)
      */
     public DateTimeFormatter dateHourMinuteSecond() {
         if (dhms == null) {
@@ -549,7 +664,7 @@ public DateTimeFormatter dateHourMinuteSecond() {
     /**
      * Returns a formatter that combines a full date, two digit hour of day,
      * two digit minute of hour, two digit second of minute, and three digit
-     * fraction of second. (yyyy-MM-ddTHH:mm:ss.SSS)
+     * fraction of second. (yyyy-MM-dd'T'HH:mm:ss.SSS)
      */
     public DateTimeFormatter dateHourMinuteSecondFraction() {
         if (dhmsf == null) {
@@ -573,64 +688,93 @@ private DateTimeFormatter yearElement() {
     }
 
     private DateTimeFormatter monthElement() {
-        if (me == null) {
-            me = new DateTimeFormatterBuilder(iChrono)
+        if (mye == null) {
+            mye = new DateTimeFormatterBuilder(iChrono)
                 .appendLiteral('-')
                 .appendMonthOfYear(2)
                 .toFormatter();
         }
-        return me;
+        return mye;
     }
 
-    private DateTimeFormatter dayElement() {
-        if (de == null) {
-            de = new DateTimeFormatterBuilder(iChrono)
+    private DateTimeFormatter dayOfMonthElement() {
+        if (dme == null) {
+            dme = new DateTimeFormatterBuilder(iChrono)
                 .appendLiteral('-')
                 .appendDayOfMonth(2)
                 .toFormatter();
         }
-        return de;
+        return dme;
+    }
+
+    private DateTimeFormatter weekyearElement() {
+        if (we == null) {
+            we = new DateTimeFormatterBuilder(iChrono)
+                .appendWeekyear(4, 9)
+                .toFormatter();
+        }
+        return we;
+    }
+
+    private DateTimeFormatter weekElement() {
+        if (wwe == null) {
+            wwe = new DateTimeFormatterBuilder(iChrono)
+                .appendLiteral("-W")
+                .appendWeekOfWeekyear(2)
+                .toFormatter();
+        }
+        return wwe;
+    }
+
+    private DateTimeFormatter dayOfWeekElement() {
+        if (dwe == null) {
+            dwe = new DateTimeFormatterBuilder(iChrono)
+                .appendLiteral('-')
+                .appendDayOfWeek(1)
+                .toFormatter();
+        }
+        return dwe;
     }
 
     private DateTimeFormatter hourElement() {
-        if (he == null) {
-            he = new DateTimeFormatterBuilder(iChrono)
+        if (hde == null) {
+            hde = new DateTimeFormatterBuilder(iChrono)
                 .appendHourOfDay(2)
                 .toFormatter();
         }
-        return he;
+        return hde;
     }
 
     private DateTimeFormatter minuteElement() {
-        if (mne == null) {
-            mne = new DateTimeFormatterBuilder(iChrono)
+        if (mhe == null) {
+            mhe = new DateTimeFormatterBuilder(iChrono)
                 .appendLiteral(':')
                 .appendMinuteOfHour(2)
                 .toFormatter();
         }
-        return mne;
+        return mhe;
     }
 
     private DateTimeFormatter secondElement() {
-        if (se == null) {
-            se = new DateTimeFormatterBuilder(iChrono)
+        if (sme == null) {
+            sme = new DateTimeFormatterBuilder(iChrono)
                 .appendLiteral(':')
                 .appendSecondOfMinute(2)
                 .toFormatter();
         }
-        return se;
+        return sme;
     }
 
     private DateTimeFormatter fractionElement() {
-        if (fe == null) {
-            fe = new DateTimeFormatterBuilder(iChrono)
+        if (fse == null) {
+            fse = new DateTimeFormatterBuilder(iChrono)
                 .appendLiteral('.')
                 // Support parsing up to nanosecond precision even though
                 // those extra digits will be dropped.
                 .appendFractionOfSecond(3, 9)
                 .toFormatter();
         }
-        return fe;
+        return fse;
     }
 
     private DateTimeFormatter offsetElement() {

From 7804df458169ae3a64e8481d8c5cdf84827552c2 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 3 Jan 2004 07:41:51 +0000
Subject: [PATCH 082/143] Mathematically correct range error message.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@87 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/chrono/Utils.java | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/chrono/Utils.java b/JodaTime/src/java/org/joda/time/chrono/Utils.java
index 9154e5429..202ef09cc 100644
--- a/JodaTime/src/java/org/joda/time/chrono/Utils.java
+++ b/JodaTime/src/java/org/joda/time/chrono/Utils.java
@@ -134,15 +134,15 @@ public static void verifyValueBounds(DateTimeField field,
                                          int value, int lowerBound, int upperBound) {
         if ((value < lowerBound) || (value > upperBound)) {
             throw new IllegalArgumentException(
-                "Value: "
+                "Value "
                     + value
                     + " for "
                     + field.getName()
-                    + " must be in the range ("
+                    + " must be in the range ["
                     + lowerBound
                     + ','
                     + upperBound
-                    + ')');
+                    + ']');
         }
     }
 
@@ -158,15 +158,15 @@ public static void verifyValueBounds(String fieldName,
                                          int value, int lowerBound, int upperBound) {
         if ((value < lowerBound) || (value > upperBound)) {
             throw new IllegalArgumentException(
-                "Value: "
+                "Value "
                     + value
                     + " for "
                     + fieldName
-                    + " must be in the range ("
+                    + " must be in the range ["
                     + lowerBound
                     + ','
                     + upperBound
-                    + ')');
+                    + ']');
         }
     }
 

From 61f556bb104017fc71379c2268ab69662b2eb9a0 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 3 Jan 2004 07:42:51 +0000
Subject: [PATCH 083/143] In set, fix range check for fields with imprecise
 ranges.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@88 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../chrono/PreciseDurationDateTimeField.java    | 17 ++++++++++++++++-
 1 file changed, 16 insertions(+), 1 deletion(-)

diff --git a/JodaTime/src/java/org/joda/time/chrono/PreciseDurationDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/PreciseDurationDateTimeField.java
index a670d6f5c..f14598d3b 100644
--- a/JodaTime/src/java/org/joda/time/chrono/PreciseDurationDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/PreciseDurationDateTimeField.java
@@ -144,7 +144,13 @@ public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
      * @throws IllegalArgumentException if value is too large or too small.
      */
     public long set(long instant, int value) {
-        Utils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValue());
+        int max;
+        if (getRangeDurationField().isPrecise()) {
+            max = getMaximumValue();
+        } else {
+            max = getMaximumValueForSet(instant, value);
+        }
+        Utils.verifyValueBounds(this, value, getMinimumValue(), max);
         return instant + (value - get(instant)) * iUnitMillis;
     }
 
@@ -222,4 +228,13 @@ public final long getUnitMillis() {
         return iUnitMillis;
     }
 
+    /**
+     * Called by the set method if the range duration field is imprecise. By
+     * default, returns getMaximumValue(instant). Override to provide a faster
+     * implementation.
+     */
+    protected int getMaximumValueForSet(long instant, int value) {
+        return getMaximumValue(instant);
+    }
+
 }

From f5cf1fabe1e0dccc06f928d18190aa898a34807a Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 3 Jan 2004 07:43:38 +0000
Subject: [PATCH 084/143] Optimized getMaximumValueForSet method.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@89 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/time/chrono/gj/GJDayOfMonthDateTimeField.java    | 4 ++++
 .../org/joda/time/chrono/gj/GJDayOfYearDateTimeField.java     | 4 ++++
 .../joda/time/chrono/gj/GJWeekOfWeekyearDateTimeField.java    | 4 ++++
 3 files changed, 12 insertions(+)

diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfMonthDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfMonthDateTimeField.java
index f466f5a7c..2dae10e26 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfMonthDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfMonthDateTimeField.java
@@ -107,6 +107,10 @@ public int getMaximumValue(long instant) {
         return iChronology.getDaysInYearMonth(thisYear, thisMonth);
     }
 
+    protected int getMaximumValueForSet(long instant, int value) {
+        return value > 28 ? getMaximumValue(instant) : 28;
+    }
+
     /**
      * Serialization singleton
      */
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfYearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfYearDateTimeField.java
index 8f5536d96..cc8e502d3 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfYearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfYearDateTimeField.java
@@ -108,6 +108,10 @@ public int getMaximumValue(long instant) {
         return iChronology.getDaysInYear(thisYear);
     }
 
+    protected int getMaximumValueForSet(long instant, int value) {
+        return value > 365 ? getMaximumValue(instant) : 365;
+    }
+
     /**
      * Serialization singleton
      */
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekOfWeekyearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekOfWeekyearDateTimeField.java
index 6fa3a695d..56ee69d2e 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekOfWeekyearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekOfWeekyearDateTimeField.java
@@ -137,6 +137,10 @@ public int getMaximumValue(long instant) {
         return iChronology.getWeeksInYear(thisYear);
     }
 
+    protected int getMaximumValueForSet(long instant, int value) {
+        return value > 52 ? getMaximumValue(instant) : 52;
+    }
+
     /**
      * Serialization singleton
      */

From 6d19e6d7842a8be61d5895703b448b8d3e7af617 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 3 Jan 2004 12:09:19 +0000
Subject: [PATCH 085/143] Organize imports

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@90 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/convert/ConverterManager.java    | 6 +-----
 .../src/java/org/joda/time/convert/DurationConverter.java   | 3 +--
 .../src/java/org/joda/time/convert/StringConverter.java     | 6 ++----
 3 files changed, 4 insertions(+), 11 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/convert/ConverterManager.java b/JodaTime/src/java/org/joda/time/convert/ConverterManager.java
index 2b30a9893..aa56c508f 100644
--- a/JodaTime/src/java/org/joda/time/convert/ConverterManager.java
+++ b/JodaTime/src/java/org/joda/time/convert/ConverterManager.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -53,10 +53,6 @@
  */
 package org.joda.time.convert;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
 /**
  * ConverterManager controls the date and time converters.
  * <p>
diff --git a/JodaTime/src/java/org/joda/time/convert/DurationConverter.java b/JodaTime/src/java/org/joda/time/convert/DurationConverter.java
index 38b0b4e29..84447a113 100644
--- a/JodaTime/src/java/org/joda/time/convert/DurationConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/DurationConverter.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -54,7 +54,6 @@
 package org.joda.time.convert;
 
 import org.joda.time.DurationType;
-import org.joda.time.ReadableDuration;
 import org.joda.time.ReadWritableDuration;
 
 /**
diff --git a/JodaTime/src/java/org/joda/time/convert/StringConverter.java b/JodaTime/src/java/org/joda/time/convert/StringConverter.java
index f8fd21c5f..94a8edae6 100644
--- a/JodaTime/src/java/org/joda/time/convert/StringConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/StringConverter.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -56,11 +56,9 @@
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeZone;
 import org.joda.time.DurationType;
-import org.joda.time.MutableDuration;
-import org.joda.time.ReadableDuration;
-import org.joda.time.ReadableInstant;
 import org.joda.time.ReadWritableDuration;
 import org.joda.time.ReadWritableInterval;
+import org.joda.time.ReadableDuration;
 import org.joda.time.chrono.iso.ISOChronology;
 import org.joda.time.format.DateTimeParser;
 import org.joda.time.format.DurationParser;

From 35aca9c2020c7c426b67fbe19e57ddcb9f1b389d Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 3 Jan 2004 12:24:25 +0000
Subject: [PATCH 086/143] Update to 2004

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@91 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/LICENSE.txt                                  |  2 +-
 JodaTime/build.xml                                    |  2 +-
 .../example/org/joda/example/time/AgeCalculator.java  |  9 ++++-----
 .../org/joda/example/time/DateTimeBrowser.java        | 11 ++++-------
 .../org/joda/example/time/DateTimePerformance.java    |  8 ++++----
 JodaTime/src/java/org/joda/time/AbstractDateTime.java |  8 ++++----
 JodaTime/src/java/org/joda/time/AbstractDuration.java |  8 ++++----
 JodaTime/src/java/org/joda/time/AbstractInstant.java  |  8 ++++----
 JodaTime/src/java/org/joda/time/AbstractInterval.java |  8 ++++----
 .../java/org/joda/time/AbstractPartialInstant.java    |  8 ++++----
 JodaTime/src/java/org/joda/time/Chronology.java       |  8 ++++----
 JodaTime/src/java/org/joda/time/DateOnly.java         |  8 ++++----
 JodaTime/src/java/org/joda/time/DateTime.java         |  8 ++++----
 .../src/java/org/joda/time/DateTimeComparator.java    |  8 ++++----
 .../src/java/org/joda/time/DateTimeConstants.java     |  8 ++++----
 JodaTime/src/java/org/joda/time/DateTimeField.java    |  8 ++++----
 JodaTime/src/java/org/joda/time/DateTimeZone.java     |  9 ++++-----
 JodaTime/src/java/org/joda/time/Duration.java         |  4 ++--
 JodaTime/src/java/org/joda/time/DurationField.java    |  8 ++++----
 JodaTime/src/java/org/joda/time/DurationType.java     |  4 ++--
 JodaTime/src/java/org/joda/time/Instant.java          |  8 ++++----
 JodaTime/src/java/org/joda/time/Interval.java         |  8 ++++----
 JodaTime/src/java/org/joda/time/MutableDateOnly.java  |  8 ++++----
 JodaTime/src/java/org/joda/time/MutableDateTime.java  |  9 ++++-----
 JodaTime/src/java/org/joda/time/MutableDuration.java  |  8 ++++----
 JodaTime/src/java/org/joda/time/MutableInterval.java  |  8 ++++----
 JodaTime/src/java/org/joda/time/MutableTimeOnly.java  |  8 ++++----
 JodaTime/src/java/org/joda/time/PartialInstant.java   |  8 ++++----
 .../src/java/org/joda/time/ReadWritableDateTime.java  |  8 ++++----
 .../src/java/org/joda/time/ReadWritableDuration.java  |  8 ++++----
 .../src/java/org/joda/time/ReadWritableInstant.java   |  8 ++++----
 .../src/java/org/joda/time/ReadWritableInterval.java  |  4 ++--
 JodaTime/src/java/org/joda/time/ReadableDateTime.java |  8 ++++----
 JodaTime/src/java/org/joda/time/ReadableDuration.java |  4 ++--
 JodaTime/src/java/org/joda/time/ReadableInstant.java  |  8 ++++----
 JodaTime/src/java/org/joda/time/ReadableInterval.java |  4 ++--
 JodaTime/src/java/org/joda/time/TimeOnly.java         |  8 ++++----
 .../org/joda/time/chrono/AbstractDateTimeField.java   |  8 ++++----
 .../org/joda/time/chrono/AbstractDurationField.java   |  8 ++++----
 .../org/joda/time/chrono/DecoratedChronology.java     |  8 ++++----
 .../org/joda/time/chrono/DecoratedDateTimeField.java  |  8 ++++----
 .../org/joda/time/chrono/DecoratedDurationField.java  |  9 ++++-----
 .../org/joda/time/chrono/DelegatedChronology.java     |  8 ++++----
 .../org/joda/time/chrono/DelegatedDateTimeField.java  |  8 ++++----
 .../org/joda/time/chrono/DelegatedDurationField.java  |  9 ++++-----
 .../org/joda/time/chrono/DividedDateTimeField.java    |  8 ++++----
 .../org/joda/time/chrono/ImpreciseDateTimeField.java  |  9 ++++-----
 .../java/org/joda/time/chrono/LenientChronology.java  |  8 ++++----
 .../org/joda/time/chrono/LenientDateTimeField.java    |  8 ++++----
 .../java/org/joda/time/chrono/LimitChronology.java    |  8 ++++----
 .../org/joda/time/chrono/MillisDurationField.java     |  4 ++--
 .../org/joda/time/chrono/NonZeroDateTimeField.java    |  8 ++++----
 .../org/joda/time/chrono/OffsetDateTimeField.java     |  8 ++++----
 .../org/joda/time/chrono/PreciseDateTimeField.java    |  8 ++++----
 .../time/chrono/PreciseDurationDateTimeField.java     |  9 ++++-----
 .../org/joda/time/chrono/PreciseDurationField.java    |  4 ++--
 .../org/joda/time/chrono/RemainderDateTimeField.java  |  8 ++++----
 .../org/joda/time/chrono/ScaledDurationField.java     |  9 ++++-----
 .../java/org/joda/time/chrono/StrictChronology.java   |  8 ++++----
 .../org/joda/time/chrono/StrictDateTimeField.java     |  8 ++++----
 .../joda/time/chrono/UnsupportedDateTimeField.java    |  9 ++++-----
 .../joda/time/chrono/UnsupportedDurationField.java    |  9 ++++-----
 JodaTime/src/java/org/joda/time/chrono/Utils.java     |  8 ++++----
 .../java/org/joda/time/chrono/ZonedChronology.java    |  8 ++++----
 .../joda/time/chrono/buddhist/BuddhistChronology.java |  8 ++++----
 .../chrono/buddhist/BuddhistEraDateTimeField.java     |  8 ++++----
 .../org/joda/time/chrono/gj/CutoverChronology.java    |  8 ++++----
 .../org/joda/time/chrono/gj/GJCenturyChronology.java  |  9 ++++-----
 .../java/org/joda/time/chrono/gj/GJChronology.java    |  8 ++++----
 .../time/chrono/gj/GJDayOfMonthDateTimeField.java     |  8 ++++----
 .../joda/time/chrono/gj/GJDayOfWeekDateTimeField.java |  8 ++++----
 .../joda/time/chrono/gj/GJDayOfYearDateTimeField.java |  8 ++++----
 .../org/joda/time/chrono/gj/GJEraDateTimeField.java   |  8 ++++----
 .../java/org/joda/time/chrono/gj/GJLocaleSymbols.java |  9 ++++-----
 .../time/chrono/gj/GJMonthOfYearDateTimeField.java    |  9 ++++-----
 .../time/chrono/gj/GJWeekOfWeekyearDateTimeField.java |  8 ++++----
 .../joda/time/chrono/gj/GJWeekyearDateTimeField.java  |  8 ++++----
 .../org/joda/time/chrono/gj/GJYearDateTimeField.java  |  9 ++++-----
 .../joda/time/chrono/gj/GJYearOfEraDateTimeField.java |  9 ++++-----
 .../org/joda/time/chrono/gj/GJZonedChronology.java    |  8 ++++----
 .../org/joda/time/chrono/gj/GregorianChronology.java  |  8 ++++----
 .../org/joda/time/chrono/gj/JulianChronology.java     |  8 ++++----
 .../time/chrono/gj/JulianWithYearZeroChronology.java  |  8 ++++----
 .../org/joda/time/chrono/gj/ProlepticChronology.java  |  8 ++++----
 .../java/org/joda/time/chrono/iso/ISOChronology.java  |  8 ++++----
 .../java/org/joda/time/convert/AbstractConverter.java |  8 ++++----
 .../java/org/joda/time/convert/CalendarConverter.java |  8 ++++----
 .../src/java/org/joda/time/convert/Converter.java     |  8 ++++----
 .../java/org/joda/time/convert/ConverterManager.java  |  8 ++++----
 .../src/java/org/joda/time/convert/ConverterSet.java  |  8 ++++----
 .../src/java/org/joda/time/convert/DateConverter.java |  8 ++++----
 .../java/org/joda/time/convert/DurationConverter.java |  8 ++++----
 .../java/org/joda/time/convert/InstantConverter.java  |  8 ++++----
 .../java/org/joda/time/convert/IntervalConverter.java |  8 ++++----
 .../src/java/org/joda/time/convert/LongConverter.java |  8 ++++----
 .../joda/time/convert/PartialInstantConverter.java    |  8 ++++----
 .../joda/time/convert/ReadableDurationConverter.java  |  8 ++++----
 .../joda/time/convert/ReadableInstantConverter.java   |  8 ++++----
 .../joda/time/convert/ReadableIntervalConverter.java  |  8 ++++----
 .../java/org/joda/time/convert/StringConverter.java   |  8 ++++----
 .../joda/time/format/AbstractDateTimeFormatter.java   |  8 ++++----
 .../joda/time/format/AbstractDurationFormatter.java   | 10 +++++-----
 .../src/java/org/joda/time/format/DateTimeFormat.java |  8 ++++----
 .../java/org/joda/time/format/DateTimeFormatter.java  |  8 ++++----
 .../joda/time/format/DateTimeFormatterBuilder.java    |  8 ++++----
 .../src/java/org/joda/time/format/DateTimeParser.java |  8 ++++----
 .../org/joda/time/format/DateTimeParserBucket.java    |  8 ++++----
 .../java/org/joda/time/format/DateTimePrinter.java    |  8 ++++----
 .../src/java/org/joda/time/format/DurationFormat.java |  8 ++++----
 .../java/org/joda/time/format/DurationFormatter.java  |  8 ++++----
 .../joda/time/format/DurationFormatterBuilder.java    |  8 ++++----
 .../src/java/org/joda/time/format/DurationParser.java |  8 ++++----
 .../java/org/joda/time/format/DurationPrinter.java    |  8 ++++----
 .../src/java/org/joda/time/format/FormatUtils.java    |  9 ++++-----
 .../java/org/joda/time/format/ISODateTimeFormat.java  |  8 ++++----
 .../java/org/joda/time/format/ISODurationFormat.java  |  8 ++++----
 .../time/property/AbstractDateTimeFieldProperty.java  |  8 ++++----
 .../org/joda/time/property/DateOnlyFieldProperty.java |  8 ++++----
 .../org/joda/time/property/DateTimeFieldProperty.java |  8 ++++----
 .../time/property/MutableDateTimeFieldProperty.java   |  8 ++++----
 .../org/joda/time/property/TimeOnlyFieldProperty.java |  8 ++++----
 .../src/java/org/joda/time/tz/CachedDateTimeZone.java |  9 ++++-----
 .../java/org/joda/time/tz/DateTimeZoneBuilder.java    |  9 ++++-----
 .../java/org/joda/time/tz/DateTimeZonePermission.java |  9 ++++-----
 .../java/org/joda/time/tz/DefaultNameProvider.java    |  9 ++++-----
 .../src/java/org/joda/time/tz/FixedDateTimeZone.java  |  9 ++++-----
 JodaTime/src/java/org/joda/time/tz/NameProvider.java  |  9 ++++-----
 JodaTime/src/java/org/joda/time/tz/Provider.java      |  9 ++++-----
 JodaTime/src/java/org/joda/time/tz/UTCProvider.java   |  8 ++++----
 .../src/java/org/joda/time/tz/ZoneInfoCompiler.java   |  9 ++++-----
 .../src/java/org/joda/time/tz/ZoneInfoProvider.java   |  9 ++++-----
 .../joda/test/time/AbstractTestAbstractInstant.java   |  8 ++++----
 .../joda/test/time/AbstractTestDateTimeCommon.java    |  8 ++++----
 .../org/joda/test/time/AbstractTestDateTimeField.java |  8 ++++----
 .../joda/test/time/AbstractTestReadableInstant.java   |  8 ++++----
 .../src/test/org/joda/test/time/BulkMDTTests.java     |  8 ++++----
 JodaTime/src/test/org/joda/test/time/BulkTest.java    |  8 ++++----
 .../src/test/org/joda/test/time/ClassLoadTest.java    |  8 ++++----
 .../org/joda/test/time/TestBuddhistChronology.java    |  8 ++++----
 .../src/test/org/joda/test/time/TestConstructors.java |  8 ++++----
 .../org/joda/test/time/TestDateTimeComparator.java    |  8 ++++----
 .../test/org/joda/test/time/TestDateTimeCtors.java    |  8 ++++----
 JodaTime/src/test/org/joda/test/time/TestInstant.java |  8 ++++----
 JodaTime/src/test/org/joda/test/time/TestMDTAdd.java  |  8 ++++----
 .../test/org/joda/test/time/TestMDTAddWrapped.java    |  8 ++++----
 JodaTime/src/test/org/joda/test/time/TestMDTGet.java  |  8 ++++----
 JodaTime/src/test/org/joda/test/time/TestMDTSet.java  |  8 ++++----
 .../test/org/joda/test/time/TestMutableDateTime.java  |  8 ++++----
 .../org/joda/test/time/TestMutableDateTimeCtors.java  |  8 ++++----
 .../time/buddhist/TestBuddhistEraDateTimeField.java   |  8 ++++----
 .../src/test/org/joda/test/time/chrono/gj/Test.java   |  9 ++++-----
 .../joda/test/time/chrono/gj/TestGJChronology.java    |  9 ++++-----
 .../joda/test/time/chrono/gj/TestGJDateTimeField.java |  9 ++++-----
 .../test/time/chrono/gj/TestGJDayOfMonthField.java    |  9 ++++-----
 .../test/time/chrono/gj/TestGJDayOfWeekField.java     |  9 ++++-----
 .../test/time/chrono/gj/TestGJDayOfYearField.java     |  9 ++++-----
 .../test/time/chrono/gj/TestGJMonthOfYearField.java   |  9 ++++-----
 .../time/chrono/gj/TestGJWeekOfWeekyearField.java     |  9 ++++-----
 .../joda/test/time/chrono/gj/TestGJWeekyearField.java |  9 ++++-----
 .../org/joda/test/time/chrono/gj/TestGJYearField.java |  9 ++++-----
 .../test/time/chrono/gj/TestGregorianChronology.java  |  9 ++++-----
 .../test/time/chrono/gj/TestJulianChronology.java     |  9 ++++-----
 .../time/chrono/gj/TestJulianDayOfMonthField.java     |  9 ++++-----
 .../time/chrono/gj/TestJulianMonthOfYearField.java    |  9 ++++-----
 .../test/time/chrono/gj/TestJulianWeekyearField.java  |  9 ++++-----
 .../joda/test/time/chrono/gj/TestJulianYearField.java |  9 ++++-----
 .../test/time/gj/AbstractTestGJDateTimeField.java     |  8 ++++----
 .../time/gj/TestGJClockhourOfDayDateTimeField.java    |  8 ++++----
 .../gj/TestGJClockhourOfHalfdayDateTimeField.java     |  8 ++++----
 .../test/time/gj/TestGJDayOfMonthDateTimeField.java   |  8 ++++----
 .../test/time/gj/TestGJDayOfWeekDateTimeField.java    |  8 ++++----
 .../test/time/gj/TestGJDayOfYearDateTimeField.java    |  8 ++++----
 .../test/time/gj/TestGJHalfdayOfDayDateTimeField.java |  8 ++++----
 .../test/time/gj/TestGJHourOfDayDateTimeField.java    |  8 ++++----
 .../time/gj/TestGJHourOfHalfdayDateTimeField.java     |  8 ++++----
 .../test/time/gj/TestGJMillisOfDayDateTimeField.java  |  8 ++++----
 .../time/gj/TestGJMillisOfSecondDateTimeField.java    |  8 ++++----
 .../test/time/gj/TestGJMinuteOfDayDateTimeField.java  |  8 ++++----
 .../test/time/gj/TestGJMinuteOfHourDateTimeField.java |  8 ++++----
 .../test/time/gj/TestGJMonthOfYearDateTimeField.java  |  8 ++++----
 .../test/time/gj/TestGJSecondOfDayDateTimeField.java  |  8 ++++----
 .../time/gj/TestGJSecondOfMinuteDateTimeField.java    |  8 ++++----
 .../joda/test/time/gj/TestGJYearDateTimeField.java    |  8 ++++----
 .../time/gj/TestGJYearOfCenturyDateTimeField.java     |  8 ++++----
 .../test/time/gj/TestGJYearOfEraDateTimeField.java    |  8 ++++----
 .../src/test/org/joda/test/time/gj/TestSuiteGJ.java   |  8 ++++----
 .../time/iso/TestISOClockhourOfDayDateTimeField.java  |  8 ++++----
 .../iso/TestISOClockhourOfHalfdayDateTimeField.java   |  8 ++++----
 .../test/time/iso/TestISODayOfMonthDateTimeField.java |  8 ++++----
 .../test/time/iso/TestISODayOfWeekDateTimeField.java  |  8 ++++----
 .../test/time/iso/TestISODayOfYearDateTimeField.java  |  8 ++++----
 .../time/iso/TestISOHalfdayOfDayDateTimeField.java    |  8 ++++----
 .../test/time/iso/TestISOHourOfDayDateTimeField.java  |  8 ++++----
 .../time/iso/TestISOHourOfHalfdayDateTimeField.java   |  8 ++++----
 .../time/iso/TestISOMillisOfDayDateTimeField.java     |  8 ++++----
 .../time/iso/TestISOMillisOfSecondDateTimeField.java  |  8 ++++----
 .../time/iso/TestISOMinuteOfDayDateTimeField.java     |  8 ++++----
 .../time/iso/TestISOMinuteOfHourDateTimeField.java    |  8 ++++----
 .../time/iso/TestISOMonthOfYearDateTimeField.java     |  8 ++++----
 .../time/iso/TestISOSecondOfDayDateTimeField.java     |  8 ++++----
 .../time/iso/TestISOSecondOfMinuteDateTimeField.java  |  8 ++++----
 .../src/test/org/joda/test/time/iso/TestSuiteISO.java |  8 ++++----
 202 files changed, 789 insertions(+), 833 deletions(-)

diff --git a/JodaTime/LICENSE.txt b/JodaTime/LICENSE.txt
index 704859cbf..9d8e3a1a3 100644
--- a/JodaTime/LICENSE.txt
+++ b/JodaTime/LICENSE.txt
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.  
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/JodaTime/build.xml b/JodaTime/build.xml
index 99e3cee9a..240da8c56 100644
--- a/JodaTime/build.xml
+++ b/JodaTime/build.xml
@@ -218,7 +218,7 @@
                     use="yes"
                doctitle="&lt;h1&gt;${component.title}&lt;/h1&gt;"
             windowtitle="${component.title} (Version ${component.version})"
-                 bottom="Copyright (c) 2001-2003 - Joda.org">
+                 bottom="Copyright (c) 2001-2004 - Joda.org">
       <classpath refid="compile.classpath"/>
     </javadoc>
   </target>
diff --git a/JodaTime/src/example/org/joda/example/time/AgeCalculator.java b/JodaTime/src/example/org/joda/example/time/AgeCalculator.java
index 6e3bd3927..49829a3b5 100644
--- a/JodaTime/src/example/org/joda/example/time/AgeCalculator.java
+++ b/JodaTime/src/example/org/joda/example/time/AgeCalculator.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.example.time;
 
 import java.awt.Component;
diff --git a/JodaTime/src/example/org/joda/example/time/DateTimeBrowser.java b/JodaTime/src/example/org/joda/example/time/DateTimeBrowser.java
index 3597a4563..a06a5d82f 100644
--- a/JodaTime/src/example/org/joda/example/time/DateTimeBrowser.java
+++ b/JodaTime/src/example/org/joda/example/time/DateTimeBrowser.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,13 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-/*
- * Package statement.
- */
 package org.joda.example.time;
 /*
  * Import required Java packages.
diff --git a/JodaTime/src/example/org/joda/example/time/DateTimePerformance.java b/JodaTime/src/example/org/joda/example/time/DateTimePerformance.java
index 279a281d9..05305984c 100644
--- a/JodaTime/src/example/org/joda/example/time/DateTimePerformance.java
+++ b/JodaTime/src/example/org/joda/example/time/DateTimePerformance.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/AbstractDateTime.java b/JodaTime/src/java/org/joda/time/AbstractDateTime.java
index 445807fa6..e671a56a1 100644
--- a/JodaTime/src/java/org/joda/time/AbstractDateTime.java
+++ b/JodaTime/src/java/org/joda/time/AbstractDateTime.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/AbstractDuration.java b/JodaTime/src/java/org/joda/time/AbstractDuration.java
index 714460be1..d6bc4f420 100644
--- a/JodaTime/src/java/org/joda/time/AbstractDuration.java
+++ b/JodaTime/src/java/org/joda/time/AbstractDuration.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/AbstractInstant.java b/JodaTime/src/java/org/joda/time/AbstractInstant.java
index 221164949..3a4f40728 100644
--- a/JodaTime/src/java/org/joda/time/AbstractInstant.java
+++ b/JodaTime/src/java/org/joda/time/AbstractInstant.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/AbstractInterval.java b/JodaTime/src/java/org/joda/time/AbstractInterval.java
index 6339df744..a06bc39f5 100644
--- a/JodaTime/src/java/org/joda/time/AbstractInterval.java
+++ b/JodaTime/src/java/org/joda/time/AbstractInterval.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java b/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
index 20e188675..6f11a7fd7 100644
--- a/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
+++ b/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/Chronology.java b/JodaTime/src/java/org/joda/time/Chronology.java
index 917b294e7..1c5e7727b 100644
--- a/JodaTime/src/java/org/joda/time/Chronology.java
+++ b/JodaTime/src/java/org/joda/time/Chronology.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/DateOnly.java b/JodaTime/src/java/org/joda/time/DateOnly.java
index a46003e1f..0698f5062 100644
--- a/JodaTime/src/java/org/joda/time/DateOnly.java
+++ b/JodaTime/src/java/org/joda/time/DateOnly.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/DateTime.java b/JodaTime/src/java/org/joda/time/DateTime.java
index 6798b29cb..b45db504e 100644
--- a/JodaTime/src/java/org/joda/time/DateTime.java
+++ b/JodaTime/src/java/org/joda/time/DateTime.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/DateTimeComparator.java b/JodaTime/src/java/org/joda/time/DateTimeComparator.java
index ed897393d..93fd4d663 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeComparator.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeComparator.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/DateTimeConstants.java b/JodaTime/src/java/org/joda/time/DateTimeConstants.java
index ac8521d92..7dde2e92c 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeConstants.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeConstants.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/DateTimeField.java b/JodaTime/src/java/org/joda/time/DateTimeField.java
index 6adb3fd38..5e519e231 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/DateTimeZone.java b/JodaTime/src/java/org/joda/time/DateTimeZone.java
index 53b490e26..c7015fb34 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeZone.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeZone.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.time;
 
 import java.io.IOException;
diff --git a/JodaTime/src/java/org/joda/time/Duration.java b/JodaTime/src/java/org/joda/time/Duration.java
index b97b326e7..9d4326bdd 100644
--- a/JodaTime/src/java/org/joda/time/Duration.java
+++ b/JodaTime/src/java/org/joda/time/Duration.java
@@ -1,8 +1,8 @@
-/* 
+/*
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/JodaTime/src/java/org/joda/time/DurationField.java b/JodaTime/src/java/org/joda/time/DurationField.java
index 1b5ca051a..160e3905a 100644
--- a/JodaTime/src/java/org/joda/time/DurationField.java
+++ b/JodaTime/src/java/org/joda/time/DurationField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/DurationType.java b/JodaTime/src/java/org/joda/time/DurationType.java
index 5f207664d..837044d8c 100644
--- a/JodaTime/src/java/org/joda/time/DurationType.java
+++ b/JodaTime/src/java/org/joda/time/DurationType.java
@@ -1,8 +1,8 @@
-/* 
+/*
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/JodaTime/src/java/org/joda/time/Instant.java b/JodaTime/src/java/org/joda/time/Instant.java
index 4c12bfa48..6926b9218 100644
--- a/JodaTime/src/java/org/joda/time/Instant.java
+++ b/JodaTime/src/java/org/joda/time/Instant.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/Interval.java b/JodaTime/src/java/org/joda/time/Interval.java
index c60352db1..2e6fed7f1 100644
--- a/JodaTime/src/java/org/joda/time/Interval.java
+++ b/JodaTime/src/java/org/joda/time/Interval.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/MutableDateOnly.java b/JodaTime/src/java/org/joda/time/MutableDateOnly.java
index 38547916f..af4b71b6b 100644
--- a/JodaTime/src/java/org/joda/time/MutableDateOnly.java
+++ b/JodaTime/src/java/org/joda/time/MutableDateOnly.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-04 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/MutableDateTime.java b/JodaTime/src/java/org/joda/time/MutableDateTime.java
index 7dadac8a8..6d8ebc2bd 100644
--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java
+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.time;
 
 import java.io.Serializable;
diff --git a/JodaTime/src/java/org/joda/time/MutableDuration.java b/JodaTime/src/java/org/joda/time/MutableDuration.java
index 43a166e56..c1dd7a618 100644
--- a/JodaTime/src/java/org/joda/time/MutableDuration.java
+++ b/JodaTime/src/java/org/joda/time/MutableDuration.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/MutableInterval.java b/JodaTime/src/java/org/joda/time/MutableInterval.java
index 521a63bb3..a814eb5a1 100644
--- a/JodaTime/src/java/org/joda/time/MutableInterval.java
+++ b/JodaTime/src/java/org/joda/time/MutableInterval.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/MutableTimeOnly.java b/JodaTime/src/java/org/joda/time/MutableTimeOnly.java
index d848a5fe4..5a344067f 100644
--- a/JodaTime/src/java/org/joda/time/MutableTimeOnly.java
+++ b/JodaTime/src/java/org/joda/time/MutableTimeOnly.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-04 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/PartialInstant.java b/JodaTime/src/java/org/joda/time/PartialInstant.java
index 6aea954a8..99534a93c 100644
--- a/JodaTime/src/java/org/joda/time/PartialInstant.java
+++ b/JodaTime/src/java/org/joda/time/PartialInstant.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/ReadWritableDateTime.java b/JodaTime/src/java/org/joda/time/ReadWritableDateTime.java
index 0e3b134a0..fa4acd58d 100644
--- a/JodaTime/src/java/org/joda/time/ReadWritableDateTime.java
+++ b/JodaTime/src/java/org/joda/time/ReadWritableDateTime.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/ReadWritableDuration.java b/JodaTime/src/java/org/joda/time/ReadWritableDuration.java
index 1ce3dac8f..9ab1a4fab 100644
--- a/JodaTime/src/java/org/joda/time/ReadWritableDuration.java
+++ b/JodaTime/src/java/org/joda/time/ReadWritableDuration.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/ReadWritableInstant.java b/JodaTime/src/java/org/joda/time/ReadWritableInstant.java
index 509119d21..6b6d5225f 100644
--- a/JodaTime/src/java/org/joda/time/ReadWritableInstant.java
+++ b/JodaTime/src/java/org/joda/time/ReadWritableInstant.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/ReadWritableInterval.java b/JodaTime/src/java/org/joda/time/ReadWritableInterval.java
index 234313da9..fa311f7bb 100644
--- a/JodaTime/src/java/org/joda/time/ReadWritableInterval.java
+++ b/JodaTime/src/java/org/joda/time/ReadWritableInterval.java
@@ -1,8 +1,8 @@
-/* 
+/*
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/JodaTime/src/java/org/joda/time/ReadableDateTime.java b/JodaTime/src/java/org/joda/time/ReadableDateTime.java
index be344693f..8abbfb86e 100644
--- a/JodaTime/src/java/org/joda/time/ReadableDateTime.java
+++ b/JodaTime/src/java/org/joda/time/ReadableDateTime.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/ReadableDuration.java b/JodaTime/src/java/org/joda/time/ReadableDuration.java
index 9ca5a908f..79336d716 100644
--- a/JodaTime/src/java/org/joda/time/ReadableDuration.java
+++ b/JodaTime/src/java/org/joda/time/ReadableDuration.java
@@ -1,8 +1,8 @@
-/* 
+/*
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/JodaTime/src/java/org/joda/time/ReadableInstant.java b/JodaTime/src/java/org/joda/time/ReadableInstant.java
index b2c610355..304d7aa8f 100644
--- a/JodaTime/src/java/org/joda/time/ReadableInstant.java
+++ b/JodaTime/src/java/org/joda/time/ReadableInstant.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/ReadableInterval.java b/JodaTime/src/java/org/joda/time/ReadableInterval.java
index 90e0e10b7..8dda0e298 100644
--- a/JodaTime/src/java/org/joda/time/ReadableInterval.java
+++ b/JodaTime/src/java/org/joda/time/ReadableInterval.java
@@ -1,8 +1,8 @@
-/* 
+/*
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/JodaTime/src/java/org/joda/time/TimeOnly.java b/JodaTime/src/java/org/joda/time/TimeOnly.java
index 6aeff9596..b25009c3e 100644
--- a/JodaTime/src/java/org/joda/time/TimeOnly.java
+++ b/JodaTime/src/java/org/joda/time/TimeOnly.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/AbstractDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/AbstractDateTimeField.java
index 87bc5527e..d1514cc24 100644
--- a/JodaTime/src/java/org/joda/time/chrono/AbstractDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/AbstractDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/AbstractDurationField.java b/JodaTime/src/java/org/joda/time/chrono/AbstractDurationField.java
index e6b2faf84..27c8c49be 100644
--- a/JodaTime/src/java/org/joda/time/chrono/AbstractDurationField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/AbstractDurationField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/DecoratedChronology.java b/JodaTime/src/java/org/joda/time/chrono/DecoratedChronology.java
index 4c78ce60f..5c9b8928b 100644
--- a/JodaTime/src/java/org/joda/time/chrono/DecoratedChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/DecoratedChronology.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/DecoratedDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/DecoratedDateTimeField.java
index 518927101..2e99333b4 100644
--- a/JodaTime/src/java/org/joda/time/chrono/DecoratedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/DecoratedDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/DecoratedDurationField.java b/JodaTime/src/java/org/joda/time/chrono/DecoratedDurationField.java
index cd647eecd..85cd6871c 100644
--- a/JodaTime/src/java/org/joda/time/chrono/DecoratedDurationField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/DecoratedDurationField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.time.chrono;
 
 import org.joda.time.DurationField;
diff --git a/JodaTime/src/java/org/joda/time/chrono/DelegatedChronology.java b/JodaTime/src/java/org/joda/time/chrono/DelegatedChronology.java
index ecf56ae89..e4942054b 100644
--- a/JodaTime/src/java/org/joda/time/chrono/DelegatedChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/DelegatedChronology.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/DelegatedDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/DelegatedDateTimeField.java
index e3a6708f1..313fc304c 100644
--- a/JodaTime/src/java/org/joda/time/chrono/DelegatedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/DelegatedDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/DelegatedDurationField.java b/JodaTime/src/java/org/joda/time/chrono/DelegatedDurationField.java
index 85751bb04..2d191e751 100644
--- a/JodaTime/src/java/org/joda/time/chrono/DelegatedDurationField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/DelegatedDurationField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.time.chrono;
 
 import java.io.Serializable;
diff --git a/JodaTime/src/java/org/joda/time/chrono/DividedDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/DividedDateTimeField.java
index d44be737c..a8e9f419a 100644
--- a/JodaTime/src/java/org/joda/time/chrono/DividedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/DividedDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/ImpreciseDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/ImpreciseDateTimeField.java
index 1f0b7e346..ff7da042c 100644
--- a/JodaTime/src/java/org/joda/time/chrono/ImpreciseDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/ImpreciseDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.time.chrono;
 
 import org.joda.time.DurationField;
diff --git a/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java b/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java
index 9bf037050..c075cbd5d 100644
--- a/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/LenientDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/LenientDateTimeField.java
index 049b577a2..00f8de9f3 100644
--- a/JodaTime/src/java/org/joda/time/chrono/LenientDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/LenientDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java b/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java
index cc60446e0..41fdf2d78 100644
--- a/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/MillisDurationField.java b/JodaTime/src/java/org/joda/time/chrono/MillisDurationField.java
index 28a4b5de0..438c219ca 100644
--- a/JodaTime/src/java/org/joda/time/chrono/MillisDurationField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/MillisDurationField.java
@@ -1,8 +1,8 @@
-/* 
+/*
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/JodaTime/src/java/org/joda/time/chrono/NonZeroDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/NonZeroDateTimeField.java
index ba14ded77..f083bb9ce 100644
--- a/JodaTime/src/java/org/joda/time/chrono/NonZeroDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/NonZeroDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/OffsetDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/OffsetDateTimeField.java
index 80ab50a4e..adf65d49b 100644
--- a/JodaTime/src/java/org/joda/time/chrono/OffsetDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/OffsetDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/PreciseDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/PreciseDateTimeField.java
index d159c06e3..9b79a1af2 100644
--- a/JodaTime/src/java/org/joda/time/chrono/PreciseDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/PreciseDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/PreciseDurationDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/PreciseDurationDateTimeField.java
index f14598d3b..94935cf39 100644
--- a/JodaTime/src/java/org/joda/time/chrono/PreciseDurationDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/PreciseDurationDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.time.chrono;
 
 import org.joda.time.DurationField;
diff --git a/JodaTime/src/java/org/joda/time/chrono/PreciseDurationField.java b/JodaTime/src/java/org/joda/time/chrono/PreciseDurationField.java
index 4be09fa78..893537910 100644
--- a/JodaTime/src/java/org/joda/time/chrono/PreciseDurationField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/PreciseDurationField.java
@@ -1,8 +1,8 @@
-/* 
+/*
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/JodaTime/src/java/org/joda/time/chrono/RemainderDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/RemainderDateTimeField.java
index 8cdfbfc59..62d499ba6 100644
--- a/JodaTime/src/java/org/joda/time/chrono/RemainderDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/RemainderDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/ScaledDurationField.java b/JodaTime/src/java/org/joda/time/chrono/ScaledDurationField.java
index e7faada75..fc9f3628c 100644
--- a/JodaTime/src/java/org/joda/time/chrono/ScaledDurationField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/ScaledDurationField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.time.chrono;
 
 import org.joda.time.DurationField;
diff --git a/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java b/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java
index 3351b9f73..3eb0e5117 100644
--- a/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/StrictDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/StrictDateTimeField.java
index ed3dae75a..1047b0b9b 100644
--- a/JodaTime/src/java/org/joda/time/chrono/StrictDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/StrictDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/UnsupportedDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/UnsupportedDateTimeField.java
index 6d1ff23eb..b270d8149 100644
--- a/JodaTime/src/java/org/joda/time/chrono/UnsupportedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/UnsupportedDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.time.chrono;
 
 import java.io.Serializable;
diff --git a/JodaTime/src/java/org/joda/time/chrono/UnsupportedDurationField.java b/JodaTime/src/java/org/joda/time/chrono/UnsupportedDurationField.java
index c767e983e..0ba23788a 100644
--- a/JodaTime/src/java/org/joda/time/chrono/UnsupportedDurationField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/UnsupportedDurationField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.time.chrono;
 
 import java.io.Serializable;
diff --git a/JodaTime/src/java/org/joda/time/chrono/Utils.java b/JodaTime/src/java/org/joda/time/chrono/Utils.java
index 202ef09cc..63b966029 100644
--- a/JodaTime/src/java/org/joda/time/chrono/Utils.java
+++ b/JodaTime/src/java/org/joda/time/chrono/Utils.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java b/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
index 8707c9464..8ba2f180d 100644
--- a/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistChronology.java b/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistChronology.java
index 6a48b38ed..38c91827d 100644
--- a/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistChronology.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistEraDateTimeField.java
index ad683d9c2..ccd869bdd 100644
--- a/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistEraDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistEraDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/CutoverChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/CutoverChronology.java
index fb55edef8..b37bf8ae9 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/CutoverChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/CutoverChronology.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJCenturyChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJCenturyChronology.java
index 2dff47c04..4ea4d4601 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJCenturyChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJCenturyChronology.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.time.chrono.gj;
 
 import org.joda.time.Chronology;
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJChronology.java
index b5459255d..35aba9175 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJChronology.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfMonthDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfMonthDateTimeField.java
index 2dae10e26..d43be2fb1 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfMonthDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfMonthDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfWeekDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfWeekDateTimeField.java
index 98787aa5e..d3b05f070 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfWeekDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfWeekDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfYearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfYearDateTimeField.java
index cc8e502d3..92271e5fb 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfYearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfYearDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJEraDateTimeField.java
index 61c520b5b..4d9c234ef 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJEraDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJEraDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJLocaleSymbols.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJLocaleSymbols.java
index 77ff588a7..d8230d629 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJLocaleSymbols.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJLocaleSymbols.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.time.chrono.gj;
 
 import java.lang.ref.WeakReference;
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJMonthOfYearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJMonthOfYearDateTimeField.java
index 77b5f68c1..7e1c245ae 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJMonthOfYearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJMonthOfYearDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.time.chrono.gj;
 
 import java.util.Locale;
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekOfWeekyearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekOfWeekyearDateTimeField.java
index 56ee69d2e..0b17a8753 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekOfWeekyearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekOfWeekyearDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekyearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekyearDateTimeField.java
index 5004d9ad8..e906320ff 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekyearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekyearDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJYearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJYearDateTimeField.java
index 859d50382..db32b4686 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJYearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJYearDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.time.chrono.gj;
 
 import org.joda.time.DateTimeConstants;
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJYearOfEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJYearOfEraDateTimeField.java
index 216b1b279..245df7805 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJYearOfEraDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJYearOfEraDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.time.chrono.gj;
 
 import org.joda.time.DateTimeConstants;
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJZonedChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJZonedChronology.java
index adf28de3f..36ff452eb 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJZonedChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GJZonedChronology.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GregorianChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/GregorianChronology.java
index 3f2a81bd1..314afcf6c 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GregorianChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/GregorianChronology.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/JulianChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/JulianChronology.java
index 6fe2acada..df4c568db 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/JulianChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/JulianChronology.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/JulianWithYearZeroChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/JulianWithYearZeroChronology.java
index ca0bd68fb..56c3d4060 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/JulianWithYearZeroChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/JulianWithYearZeroChronology.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/ProlepticChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/ProlepticChronology.java
index 08b0eee9f..486737a61 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/ProlepticChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/ProlepticChronology.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/iso/ISOChronology.java b/JodaTime/src/java/org/joda/time/chrono/iso/ISOChronology.java
index 336ef8319..29878a0c4 100644
--- a/JodaTime/src/java/org/joda/time/chrono/iso/ISOChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/iso/ISOChronology.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java b/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java
index bdd3f8c0f..d3b60848d 100644
--- a/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/convert/CalendarConverter.java b/JodaTime/src/java/org/joda/time/convert/CalendarConverter.java
index 201f0c94a..58695e0e2 100644
--- a/JodaTime/src/java/org/joda/time/convert/CalendarConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/CalendarConverter.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/convert/Converter.java b/JodaTime/src/java/org/joda/time/convert/Converter.java
index ff7716f96..f1e3ffb81 100644
--- a/JodaTime/src/java/org/joda/time/convert/Converter.java
+++ b/JodaTime/src/java/org/joda/time/convert/Converter.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/convert/ConverterManager.java b/JodaTime/src/java/org/joda/time/convert/ConverterManager.java
index aa56c508f..b6de0a94f 100644
--- a/JodaTime/src/java/org/joda/time/convert/ConverterManager.java
+++ b/JodaTime/src/java/org/joda/time/convert/ConverterManager.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-2004 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/convert/ConverterSet.java b/JodaTime/src/java/org/joda/time/convert/ConverterSet.java
index fb4711599..9c5145ed6 100644
--- a/JodaTime/src/java/org/joda/time/convert/ConverterSet.java
+++ b/JodaTime/src/java/org/joda/time/convert/ConverterSet.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/convert/DateConverter.java b/JodaTime/src/java/org/joda/time/convert/DateConverter.java
index fae82f092..35e393d38 100644
--- a/JodaTime/src/java/org/joda/time/convert/DateConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/DateConverter.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/convert/DurationConverter.java b/JodaTime/src/java/org/joda/time/convert/DurationConverter.java
index 84447a113..2990d704c 100644
--- a/JodaTime/src/java/org/joda/time/convert/DurationConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/DurationConverter.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-2004 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/convert/InstantConverter.java b/JodaTime/src/java/org/joda/time/convert/InstantConverter.java
index f1fb34f61..2103119fc 100644
--- a/JodaTime/src/java/org/joda/time/convert/InstantConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/InstantConverter.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/convert/IntervalConverter.java b/JodaTime/src/java/org/joda/time/convert/IntervalConverter.java
index 94b9202b2..b99c68d39 100644
--- a/JodaTime/src/java/org/joda/time/convert/IntervalConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/IntervalConverter.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/convert/LongConverter.java b/JodaTime/src/java/org/joda/time/convert/LongConverter.java
index bfdcbfde2..ebedfc3dc 100644
--- a/JodaTime/src/java/org/joda/time/convert/LongConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/LongConverter.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java b/JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java
index 403bff81a..30b8c1d1b 100644
--- a/JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java b/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java
index 6480287de..28f8a752c 100644
--- a/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/ReadableDurationConverter.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/convert/ReadableInstantConverter.java b/JodaTime/src/java/org/joda/time/convert/ReadableInstantConverter.java
index f5a30348b..9b5b680e5 100644
--- a/JodaTime/src/java/org/joda/time/convert/ReadableInstantConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/ReadableInstantConverter.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java b/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java
index 7d178b157..1192e09c4 100644
--- a/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/ReadableIntervalConverter.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/convert/StringConverter.java b/JodaTime/src/java/org/joda/time/convert/StringConverter.java
index 94a8edae6..dc468e822 100644
--- a/JodaTime/src/java/org/joda/time/convert/StringConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/StringConverter.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-2004 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java b/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java
index 7f6e30977..ded726572 100644
--- a/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java
+++ b/JodaTime/src/java/org/joda/time/format/AbstractDateTimeFormatter.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/format/AbstractDurationFormatter.java b/JodaTime/src/java/org/joda/time/format/AbstractDurationFormatter.java
index 73fb429c4..5d7382a1b 100644
--- a/JodaTime/src/java/org/joda/time/format/AbstractDurationFormatter.java
+++ b/JodaTime/src/java/org/joda/time/format/AbstractDurationFormatter.java
@@ -1,8 +1,8 @@
-/**
+/*
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java b/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java
index f19d5725f..775777710 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java b/JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java
index 1cda3527a..72c1885ac 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatter.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
index 0a64bcd66..21191f532 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeParser.java b/JodaTime/src/java/org/joda/time/format/DateTimeParser.java
index 7a75653fd..03213c826 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeParser.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeParser.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java b/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java
index 7cc37ab98..30e3f4210 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java b/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java
index 31dd850be..d9efc6e96 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimePrinter.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/format/DurationFormat.java b/JodaTime/src/java/org/joda/time/format/DurationFormat.java
index fb0bae386..3900ee7bb 100644
--- a/JodaTime/src/java/org/joda/time/format/DurationFormat.java
+++ b/JodaTime/src/java/org/joda/time/format/DurationFormat.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/format/DurationFormatter.java b/JodaTime/src/java/org/joda/time/format/DurationFormatter.java
index 792494ab7..e060ebe31 100644
--- a/JodaTime/src/java/org/joda/time/format/DurationFormatter.java
+++ b/JodaTime/src/java/org/joda/time/format/DurationFormatter.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java b/JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java
index 495dd40a6..99a3fb9f6 100644
--- a/JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java
+++ b/JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/format/DurationParser.java b/JodaTime/src/java/org/joda/time/format/DurationParser.java
index 7fdc1128e..4c08ccd5a 100644
--- a/JodaTime/src/java/org/joda/time/format/DurationParser.java
+++ b/JodaTime/src/java/org/joda/time/format/DurationParser.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/format/DurationPrinter.java b/JodaTime/src/java/org/joda/time/format/DurationPrinter.java
index 691f758a7..37edf697b 100644
--- a/JodaTime/src/java/org/joda/time/format/DurationPrinter.java
+++ b/JodaTime/src/java/org/joda/time/format/DurationPrinter.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/format/FormatUtils.java b/JodaTime/src/java/org/joda/time/format/FormatUtils.java
index 5ca8238fb..9630331e8 100644
--- a/JodaTime/src/java/org/joda/time/format/FormatUtils.java
+++ b/JodaTime/src/java/org/joda/time/format/FormatUtils.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.time.format;
 
 import java.io.IOException;
diff --git a/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
index c8536c9e5..939345132 100644
--- a/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
+++ b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/format/ISODurationFormat.java b/JodaTime/src/java/org/joda/time/format/ISODurationFormat.java
index d3e1ea3f4..a5391db0c 100644
--- a/JodaTime/src/java/org/joda/time/format/ISODurationFormat.java
+++ b/JodaTime/src/java/org/joda/time/format/ISODurationFormat.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/property/AbstractDateTimeFieldProperty.java b/JodaTime/src/java/org/joda/time/property/AbstractDateTimeFieldProperty.java
index 76c7f4893..1796d1398 100644
--- a/JodaTime/src/java/org/joda/time/property/AbstractDateTimeFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/property/AbstractDateTimeFieldProperty.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java b/JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java
index 94518b294..04fda55f9 100644
--- a/JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-04 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java b/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java
index 3412607df..d8bd5ff91 100644
--- a/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/property/MutableDateTimeFieldProperty.java b/JodaTime/src/java/org/joda/time/property/MutableDateTimeFieldProperty.java
index 7bc47477d..0ca2991c2 100644
--- a/JodaTime/src/java/org/joda/time/property/MutableDateTimeFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/property/MutableDateTimeFieldProperty.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java b/JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java
index a6085e2b0..824807396 100644
--- a/JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-04 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/tz/CachedDateTimeZone.java b/JodaTime/src/java/org/joda/time/tz/CachedDateTimeZone.java
index 824703bc7..713853cc0 100644
--- a/JodaTime/src/java/org/joda/time/tz/CachedDateTimeZone.java
+++ b/JodaTime/src/java/org/joda/time/tz/CachedDateTimeZone.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.time.tz;
 
 import org.joda.time.DateTimeZone;
diff --git a/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java b/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java
index 1d61b2c5f..ec8cd1a47 100644
--- a/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java
+++ b/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.time.tz;
 
 import java.io.DataInput;
diff --git a/JodaTime/src/java/org/joda/time/tz/DateTimeZonePermission.java b/JodaTime/src/java/org/joda/time/tz/DateTimeZonePermission.java
index 9383164ac..f2f6d12f6 100644
--- a/JodaTime/src/java/org/joda/time/tz/DateTimeZonePermission.java
+++ b/JodaTime/src/java/org/joda/time/tz/DateTimeZonePermission.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.time.tz;
 
 /**
diff --git a/JodaTime/src/java/org/joda/time/tz/DefaultNameProvider.java b/JodaTime/src/java/org/joda/time/tz/DefaultNameProvider.java
index 655cd44d4..7f46d090c 100644
--- a/JodaTime/src/java/org/joda/time/tz/DefaultNameProvider.java
+++ b/JodaTime/src/java/org/joda/time/tz/DefaultNameProvider.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.time.tz;
 
 import java.text.DateFormatSymbols;
diff --git a/JodaTime/src/java/org/joda/time/tz/FixedDateTimeZone.java b/JodaTime/src/java/org/joda/time/tz/FixedDateTimeZone.java
index 16e954635..8fecd37da 100644
--- a/JodaTime/src/java/org/joda/time/tz/FixedDateTimeZone.java
+++ b/JodaTime/src/java/org/joda/time/tz/FixedDateTimeZone.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.time.tz;
 
 import org.joda.time.DateTimeZone;
diff --git a/JodaTime/src/java/org/joda/time/tz/NameProvider.java b/JodaTime/src/java/org/joda/time/tz/NameProvider.java
index 248f17e91..9e3d0ec22 100644
--- a/JodaTime/src/java/org/joda/time/tz/NameProvider.java
+++ b/JodaTime/src/java/org/joda/time/tz/NameProvider.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.time.tz;
 
 import java.util.Locale;
diff --git a/JodaTime/src/java/org/joda/time/tz/Provider.java b/JodaTime/src/java/org/joda/time/tz/Provider.java
index 7c3ffb5f1..c74b8d26a 100644
--- a/JodaTime/src/java/org/joda/time/tz/Provider.java
+++ b/JodaTime/src/java/org/joda/time/tz/Provider.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.time.tz;
 
 import java.util.Set;
diff --git a/JodaTime/src/java/org/joda/time/tz/UTCProvider.java b/JodaTime/src/java/org/joda/time/tz/UTCProvider.java
index f4a8235b8..cc2d7bb28 100644
--- a/JodaTime/src/java/org/joda/time/tz/UTCProvider.java
+++ b/JodaTime/src/java/org/joda/time/tz/UTCProvider.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java b/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java
index fe55a6f79..d824d90d4 100644
--- a/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java
+++ b/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.time.tz;
 
 import java.io.BufferedReader;
diff --git a/JodaTime/src/java/org/joda/time/tz/ZoneInfoProvider.java b/JodaTime/src/java/org/joda/time/tz/ZoneInfoProvider.java
index 978261b2c..ce65aa84c 100644
--- a/JodaTime/src/java/org/joda/time/tz/ZoneInfoProvider.java
+++ b/JodaTime/src/java/org/joda/time/tz/ZoneInfoProvider.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.time.tz;
 
 import java.io.DataInputStream;
diff --git a/JodaTime/src/test/org/joda/test/time/AbstractTestAbstractInstant.java b/JodaTime/src/test/org/joda/test/time/AbstractTestAbstractInstant.java
index dd3845d11..f0793a5d3 100644
--- a/JodaTime/src/test/org/joda/test/time/AbstractTestAbstractInstant.java
+++ b/JodaTime/src/test/org/joda/test/time/AbstractTestAbstractInstant.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeCommon.java b/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeCommon.java
index 0aa54bcc8..69c81e7f8 100644
--- a/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeCommon.java
+++ b/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeCommon.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeField.java b/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeField.java
index d5ef19c4f..f15d4b794 100644
--- a/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/AbstractTestReadableInstant.java b/JodaTime/src/test/org/joda/test/time/AbstractTestReadableInstant.java
index f6ab761a1..7b7e4b239 100644
--- a/JodaTime/src/test/org/joda/test/time/AbstractTestReadableInstant.java
+++ b/JodaTime/src/test/org/joda/test/time/AbstractTestReadableInstant.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/BulkMDTTests.java b/JodaTime/src/test/org/joda/test/time/BulkMDTTests.java
index 4f960d855..e3959aa63 100644
--- a/JodaTime/src/test/org/joda/test/time/BulkMDTTests.java
+++ b/JodaTime/src/test/org/joda/test/time/BulkMDTTests.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/BulkTest.java b/JodaTime/src/test/org/joda/test/time/BulkTest.java
index 425260987..0cdc56dcd 100644
--- a/JodaTime/src/test/org/joda/test/time/BulkTest.java
+++ b/JodaTime/src/test/org/joda/test/time/BulkTest.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/ClassLoadTest.java b/JodaTime/src/test/org/joda/test/time/ClassLoadTest.java
index 3ec99c699..0386534a1 100644
--- a/JodaTime/src/test/org/joda/test/time/ClassLoadTest.java
+++ b/JodaTime/src/test/org/joda/test/time/ClassLoadTest.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/TestBuddhistChronology.java b/JodaTime/src/test/org/joda/test/time/TestBuddhistChronology.java
index c2b7a1bec..6be12fb93 100644
--- a/JodaTime/src/test/org/joda/test/time/TestBuddhistChronology.java
+++ b/JodaTime/src/test/org/joda/test/time/TestBuddhistChronology.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/TestConstructors.java b/JodaTime/src/test/org/joda/test/time/TestConstructors.java
index 3d06f459f..baa3a83ae 100644
--- a/JodaTime/src/test/org/joda/test/time/TestConstructors.java
+++ b/JodaTime/src/test/org/joda/test/time/TestConstructors.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/TestDateTimeComparator.java b/JodaTime/src/test/org/joda/test/time/TestDateTimeComparator.java
index e26dd8f15..937c35dc4 100644
--- a/JodaTime/src/test/org/joda/test/time/TestDateTimeComparator.java
+++ b/JodaTime/src/test/org/joda/test/time/TestDateTimeComparator.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/TestDateTimeCtors.java b/JodaTime/src/test/org/joda/test/time/TestDateTimeCtors.java
index 6566c8e64..efac6a57c 100644
--- a/JodaTime/src/test/org/joda/test/time/TestDateTimeCtors.java
+++ b/JodaTime/src/test/org/joda/test/time/TestDateTimeCtors.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/TestInstant.java b/JodaTime/src/test/org/joda/test/time/TestInstant.java
index 7f6ba906a..8385c4b4f 100644
--- a/JodaTime/src/test/org/joda/test/time/TestInstant.java
+++ b/JodaTime/src/test/org/joda/test/time/TestInstant.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/TestMDTAdd.java b/JodaTime/src/test/org/joda/test/time/TestMDTAdd.java
index 9a558428e..850c50ba6 100644
--- a/JodaTime/src/test/org/joda/test/time/TestMDTAdd.java
+++ b/JodaTime/src/test/org/joda/test/time/TestMDTAdd.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/TestMDTAddWrapped.java b/JodaTime/src/test/org/joda/test/time/TestMDTAddWrapped.java
index dce56b5c8..694016cf1 100644
--- a/JodaTime/src/test/org/joda/test/time/TestMDTAddWrapped.java
+++ b/JodaTime/src/test/org/joda/test/time/TestMDTAddWrapped.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/TestMDTGet.java b/JodaTime/src/test/org/joda/test/time/TestMDTGet.java
index abfb0925e..8fe430b22 100644
--- a/JodaTime/src/test/org/joda/test/time/TestMDTGet.java
+++ b/JodaTime/src/test/org/joda/test/time/TestMDTGet.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/TestMDTSet.java b/JodaTime/src/test/org/joda/test/time/TestMDTSet.java
index 40a2eb909..a9873568a 100644
--- a/JodaTime/src/test/org/joda/test/time/TestMDTSet.java
+++ b/JodaTime/src/test/org/joda/test/time/TestMDTSet.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/TestMutableDateTime.java b/JodaTime/src/test/org/joda/test/time/TestMutableDateTime.java
index a11c1a8ab..cf0baf413 100644
--- a/JodaTime/src/test/org/joda/test/time/TestMutableDateTime.java
+++ b/JodaTime/src/test/org/joda/test/time/TestMutableDateTime.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/TestMutableDateTimeCtors.java b/JodaTime/src/test/org/joda/test/time/TestMutableDateTimeCtors.java
index 758c0f950..57c17194e 100644
--- a/JodaTime/src/test/org/joda/test/time/TestMutableDateTimeCtors.java
+++ b/JodaTime/src/test/org/joda/test/time/TestMutableDateTimeCtors.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/buddhist/TestBuddhistEraDateTimeField.java b/JodaTime/src/test/org/joda/test/time/buddhist/TestBuddhistEraDateTimeField.java
index 4293e9435..f08d3fbb4 100644
--- a/JodaTime/src/test/org/joda/test/time/buddhist/TestBuddhistEraDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/buddhist/TestBuddhistEraDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/Test.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/Test.java
index 6a6475c36..66b80175c 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/Test.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/Test.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.test.time.chrono.gj;
 
 import java.util.Random;
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java
index 5b0dfba03..a31f21972 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.test.time.chrono.gj;
 
 import org.joda.time.Chronology;
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDateTimeField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDateTimeField.java
index 830b077c1..a05509fdc 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.test.time.chrono.gj;
 
 import org.joda.time.chrono.ImpreciseDateTimeField;
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfMonthField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfMonthField.java
index ad440d07e..6fc31f622 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfMonthField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfMonthField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.test.time.chrono.gj;
 
 import org.joda.time.DurationField;
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfWeekField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfWeekField.java
index 834661d78..08f1025d2 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfWeekField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfWeekField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.test.time.chrono.gj;
 
 import org.joda.time.DurationField;
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfYearField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfYearField.java
index 4e39e1a73..efd4e4967 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfYearField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDayOfYearField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.test.time.chrono.gj;
 
 import org.joda.time.DurationField;
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJMonthOfYearField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJMonthOfYearField.java
index ea9c729c7..4f5e1f542 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJMonthOfYearField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJMonthOfYearField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.test.time.chrono.gj;
 
 import org.joda.time.DurationField;
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekOfWeekyearField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekOfWeekyearField.java
index 908b75639..a45f84e59 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekOfWeekyearField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekOfWeekyearField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.test.time.chrono.gj;
 
 import org.joda.time.DurationField;
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekyearField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekyearField.java
index 64990a3a8..7ea50de43 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekyearField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJWeekyearField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.test.time.chrono.gj;
 
 import org.joda.time.DurationField;
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJYearField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJYearField.java
index 333b02497..93e4c3809 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJYearField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJYearField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.test.time.chrono.gj;
 
 import org.joda.time.DurationField;
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGregorianChronology.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGregorianChronology.java
index c95faa343..bbaafc46a 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGregorianChronology.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGregorianChronology.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.test.time.chrono.gj;
 
 import org.joda.time.Chronology;
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianChronology.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianChronology.java
index 41a1021c5..a81eb712a 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianChronology.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianChronology.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.test.time.chrono.gj;
 
 import org.joda.time.Chronology;
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianDayOfMonthField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianDayOfMonthField.java
index 3de60550d..4c5a3181e 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianDayOfMonthField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianDayOfMonthField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.test.time.chrono.gj;
 
 /**
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianMonthOfYearField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianMonthOfYearField.java
index 5ce21a897..c154238d5 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianMonthOfYearField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianMonthOfYearField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.test.time.chrono.gj;
 
 /**
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianWeekyearField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianWeekyearField.java
index 6f3abcc8c..d7e7ecd8a 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianWeekyearField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianWeekyearField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.test.time.chrono.gj;
 
 import org.joda.time.chrono.Utils;
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianYearField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianYearField.java
index 9e4d3276e..4ce54b6b1 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianYearField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianYearField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,11 +47,10 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-
 package org.joda.test.time.chrono.gj;
 
 import org.joda.time.chrono.Utils;
diff --git a/JodaTime/src/test/org/joda/test/time/gj/AbstractTestGJDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/AbstractTestGJDateTimeField.java
index af42b4ba7..ed3ff04c8 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/AbstractTestGJDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/AbstractTestGJDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfDayDateTimeField.java
index 4afdacc9e..895fa4e78 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfDayDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfHalfdayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfHalfdayDateTimeField.java
index d9b1a70ee..2b097801b 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfHalfdayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfHalfdayDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfMonthDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfMonthDateTimeField.java
index e58316d4e..8de9c01be 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfMonthDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfMonthDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfWeekDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfWeekDateTimeField.java
index 02e1a211d..6d7f63426 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfWeekDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfWeekDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfYearDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfYearDateTimeField.java
index b076ce166..7482d8fd8 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfYearDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfYearDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJHalfdayOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJHalfdayOfDayDateTimeField.java
index e207ea9b5..debc0fa47 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJHalfdayOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJHalfdayOfDayDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfDayDateTimeField.java
index 5192ea4ab..21f275558 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfDayDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfHalfdayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfHalfdayDateTimeField.java
index ed12e8f8e..81de07d7b 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfHalfdayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfHalfdayDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfDayDateTimeField.java
index 81ce2e366..b6a51a385 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfDayDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfSecondDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfSecondDateTimeField.java
index 653091494..c2f6e4737 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfSecondDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfSecondDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfDayDateTimeField.java
index a1ee51207..5d29af9e8 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfDayDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfHourDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfHourDateTimeField.java
index a52552d2d..da1b35960 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfHourDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfHourDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJMonthOfYearDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJMonthOfYearDateTimeField.java
index 5b416fbec..9f9c5fb2e 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJMonthOfYearDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJMonthOfYearDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfDayDateTimeField.java
index 7273748ac..ef1922936 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfDayDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfMinuteDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfMinuteDateTimeField.java
index 3a363567e..c52dacc80 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfMinuteDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfMinuteDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJYearDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearDateTimeField.java
index aba6d1321..57f8ec27a 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJYearDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfCenturyDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfCenturyDateTimeField.java
index 59946fd39..1ca954b38 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfCenturyDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfCenturyDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfEraDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfEraDateTimeField.java
index 244cc2ff7..dba4aa6fb 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfEraDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfEraDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestSuiteGJ.java b/JodaTime/src/test/org/joda/test/time/gj/TestSuiteGJ.java
index 9dd5208b4..4d16bc0c7 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestSuiteGJ.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestSuiteGJ.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfDayDateTimeField.java
index ee35dea79..90dea9538 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfDayDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfHalfdayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfHalfdayDateTimeField.java
index 43793603e..29d3ac1a1 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfHalfdayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfHalfdayDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfMonthDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfMonthDateTimeField.java
index a8c35ebcd..6a957da19 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfMonthDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfMonthDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfWeekDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfWeekDateTimeField.java
index 20fd95fea..d1b5c4bd0 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfWeekDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfWeekDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfYearDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfYearDateTimeField.java
index f01862250..2cc2cf8e4 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfYearDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfYearDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOHalfdayOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOHalfdayOfDayDateTimeField.java
index 91b1db480..2dc55c679 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOHalfdayOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOHalfdayOfDayDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfDayDateTimeField.java
index a72f70f2d..a24e09e7e 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfDayDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfHalfdayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfHalfdayDateTimeField.java
index 4e4d342a9..4ef344ba7 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfHalfdayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfHalfdayDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfDayDateTimeField.java
index 29d010266..3228f438e 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfDayDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfSecondDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfSecondDateTimeField.java
index 469ab3982..45dd4abd1 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfSecondDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfSecondDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfDayDateTimeField.java
index f8999b5d8..7343ae898 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfDayDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfHourDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfHourDateTimeField.java
index d737bc8be..8ace19889 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfHourDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfHourDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOMonthOfYearDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOMonthOfYearDateTimeField.java
index 6e2caae74..000672de5 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOMonthOfYearDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOMonthOfYearDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfDayDateTimeField.java
index 54a0089e4..2088a6854 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfDayDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfMinuteDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfMinuteDateTimeField.java
index 290777388..fc8a02e12 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfMinuteDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfMinuteDateTimeField.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestSuiteISO.java b/JodaTime/src/test/org/joda/test/time/iso/TestSuiteISO.java
index e6778c163..c44c399cd 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestSuiteISO.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestSuiteISO.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-03 Stephen Colebourne.
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer. 
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
+ *    if any, must include the following acknowledgment:  
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,7 +47,7 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
+ * individuals on behalf of the Joda project and was originally 
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */

From c8bfdbcb0e6b79f6ad39bb6f00f47208a3b5e17c Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 3 Jan 2004 17:49:06 +0000
Subject: [PATCH 087/143] Override set with simpler implementation.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@92 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/time/chrono/PreciseDateTimeField.java  | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/JodaTime/src/java/org/joda/time/chrono/PreciseDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/PreciseDateTimeField.java
index 9b79a1af2..0b4c4c086 100644
--- a/JodaTime/src/java/org/joda/time/chrono/PreciseDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/PreciseDateTimeField.java
@@ -136,6 +136,19 @@ public long addWrapped(long instant, int amount) {
         return instant + (wrappedValue - thisValue) * getUnitMillis();
     }
 
+    /**
+     * Set the specified amount of units to the specified time instant.
+     * 
+     * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in
+     * @param value  value of units to set.
+     * @return the updated time instant.
+     * @throws IllegalArgumentException if value is too large or too small.
+     */
+    public long set(long instant, int value) {
+        Utils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValue());
+        return instant + (value - get(instant)) * iUnitMillis;
+    }
+
     /**
      * Returns the range duration of this field. For example, if this field
      * represents "minute of hour", then the range duration field is an hours.

From 5d24a3987aa732adab03ce9c6584b0d1f30620f3 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 3 Jan 2004 17:49:26 +0000
Subject: [PATCH 088/143] Simplify set implementation.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@93 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../time/chrono/PreciseDurationDateTimeField.java | 15 +++++----------
 1 file changed, 5 insertions(+), 10 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/chrono/PreciseDurationDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/PreciseDurationDateTimeField.java
index 94935cf39..aa9cbe4dc 100644
--- a/JodaTime/src/java/org/joda/time/chrono/PreciseDurationDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/PreciseDurationDateTimeField.java
@@ -68,7 +68,7 @@
     static final long serialVersionUID = 5004523158306266035L;
 
     /** The fractional unit in millis */
-    private final long iUnitMillis;
+    final long iUnitMillis;
 
     private final DurationField iUnitField;
 
@@ -143,13 +143,8 @@ public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
      * @throws IllegalArgumentException if value is too large or too small.
      */
     public long set(long instant, int value) {
-        int max;
-        if (getRangeDurationField().isPrecise()) {
-            max = getMaximumValue();
-        } else {
-            max = getMaximumValueForSet(instant, value);
-        }
-        Utils.verifyValueBounds(this, value, getMinimumValue(), max);
+        Utils.verifyValueBounds(this, value, getMinimumValue(),
+                                getMaximumValueForSet(instant, value));
         return instant + (value - get(instant)) * iUnitMillis;
     }
 
@@ -228,8 +223,8 @@ public final long getUnitMillis() {
     }
 
     /**
-     * Called by the set method if the range duration field is imprecise. By
-     * default, returns getMaximumValue(instant). Override to provide a faster
+     * Called by the set method to get the maximum allowed value. By default,
+     * returns getMaximumValue(instant). Override to provide a faster
      * implementation.
      */
     protected int getMaximumValueForSet(long instant, int value) {

From 4eebf636dd3f32f25f4f6335844ddffee631d131 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 3 Jan 2004 17:50:06 +0000
Subject: [PATCH 089/143] Improve fraction parsing accuracy.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@94 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../time/format/DateTimeFormatterBuilder.java | 59 ++++++++++---------
 1 file changed, 30 insertions(+), 29 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
index 21191f532..0a48dd9a4 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
@@ -1265,7 +1265,7 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
         private final int iMinDigits;
         private final int iMaxDigits;
 
-        private final long iScaler;
+        private final long iScalar;
 
         private transient DateTimeField iParseField;
 
@@ -1282,30 +1282,30 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
 
             iMinDigits = minDigits;
 
-            long scaler;
+            long scalar;
             while (true) {
                 switch (maxDigits) {
-                default: scaler = 1L; break;
-                case 1:  scaler = 10L; break;
-                case 2:  scaler = 100L; break;
-                case 3:  scaler = 1000L; break;
-                case 4:  scaler = 10000L; break;
-                case 5:  scaler = 100000L; break;
-                case 6:  scaler = 1000000L; break;
-                case 7:  scaler = 10000000L; break;
-                case 8:  scaler = 100000000L; break;
-                case 9:  scaler = 1000000000L; break;
-                case 10: scaler = 10000000000L; break;
-                case 11: scaler = 100000000000L; break;
-                case 12: scaler = 1000000000000L; break;
-                case 13: scaler = 10000000000000L; break;
-                case 14: scaler = 100000000000000L; break;
-                case 15: scaler = 1000000000000000L; break;
-                case 16: scaler = 10000000000000000L; break;
-                case 17: scaler = 100000000000000000L; break;
-                case 18: scaler = 1000000000000000000L; break;
+                default: scalar = 1L; break;
+                case 1:  scalar = 10L; break;
+                case 2:  scalar = 100L; break;
+                case 3:  scalar = 1000L; break;
+                case 4:  scalar = 10000L; break;
+                case 5:  scalar = 100000L; break;
+                case 6:  scalar = 1000000L; break;
+                case 7:  scalar = 10000000L; break;
+                case 8:  scalar = 100000000L; break;
+                case 9:  scalar = 1000000000L; break;
+                case 10: scalar = 10000000000L; break;
+                case 11: scalar = 100000000000L; break;
+                case 12: scalar = 1000000000000L; break;
+                case 13: scalar = 10000000000000L; break;
+                case 14: scalar = 100000000000000L; break;
+                case 15: scalar = 1000000000000000L; break;
+                case 16: scalar = 10000000000000000L; break;
+                case 17: scalar = 100000000000000000L; break;
+                case 18: scalar = 1000000000000000000L; break;
                 }
-                if (((iRangeMillis * scaler) / scaler) == iRangeMillis) {
+                if (((iRangeMillis * scalar) / scalar) == iRangeMillis) {
                     break;
                 }
                 // Overflowed: scale down.
@@ -1313,7 +1313,7 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
             }
 
             iMaxDigits = maxDigits;
-            iScaler = scaler;
+            iScalar = scalar;
         }
 
         public int estimatePrintedLength() {
@@ -1369,7 +1369,7 @@ private void printTo(StringBuffer buf, Writer out, long instantLocal)
             }
 
             String str;
-            long scaled = fraction * iScaler / iRangeMillis;
+            long scaled = fraction * iScalar / iRangeMillis;
             if ((scaled & 0x7fffffff) == scaled) {
                 str = Integer.toString((int)scaled);
             } else {
@@ -1427,7 +1427,7 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
             int limit = Math.min(iMaxDigits, text.length() - position);
 
             long value = 0;
-            long n = iRangeMillis;
+            long n = iRangeMillis * 10;
             int length = 0;
             while (length < limit) {
                 char c = text.charAt(position + length);
@@ -1435,12 +1435,13 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
                     break;
                 }
                 length++;
-                if (c != '0') {
-                    value += (c - '0') * n / 10;
-                }
-                n /= 10;
+                long nn = n / 10;
+                value += (c - '0') * nn;
+                n = nn;
             }
 
+            value /= 10;
+
             if (length == 0) {
                 return ~position;
             }

From d849be8e998ca54d4c888a5d228e5a9694e4009f Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 3 Jan 2004 17:50:36 +0000
Subject: [PATCH 090/143] Support parsing more fractional time elements.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@95 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../joda/time/format/ISODateTimeFormat.java   | 72 +++++++++++++++----
 1 file changed, 58 insertions(+), 14 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
index 939345132..2d2fd0880 100644
--- a/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
+++ b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
@@ -261,9 +261,12 @@ public DateTimeParser dateElementParser() {
      * Returns a generic ISO time parser. It accepts formats described by
      * the following syntax:
      * <pre>
-     * time         = ['T'] time-element [offset]
-     * time-element = HH [':' mm [':' ss ['.' SSS]]]
-     * offset       = 'Z' | (('+' | '-') HH ':' mm)
+     * time           = ['T'] time-element [offset]
+     * time-element   = HH [minute-element] | [fraction]
+     * minute-element = ':' mm [second-element] | [fraction]
+     * second-element = ':' ss [fraction]
+     * fraction       = ('.' | ',') digit+
+     * offset         = 'Z' | (('+' | '-') HH ':' mm)
      * </pre>
      */
     public DateTimeParser timeParser() {
@@ -284,22 +287,60 @@ public DateTimeParser timeParser() {
      * Returns a generic ISO time parser. It accepts formats described by
      * the following syntax:
      * <pre>
-     * time-element = HH [':' mm [':' ss ['.' SSS]]]
+     * time-element   = HH [minute-element] | [fraction]
+     * minute-element = ':' mm [second-element] | [fraction]
+     * second-element = ':' ss [fraction]
+     * fraction       = ('.' | ',') digit+
      * </pre>
      */
     public DateTimeParser timeElementParser() {
         if (tpe == null) {
+            // Decimal point can be either '.' or ','
+            DateTimeParser decimalPoint = new DateTimeFormatterBuilder(iChrono)
+                .append(null, new DateTimeParser[] {
+                    new DateTimeFormatterBuilder(iChrono)
+                    .appendLiteral('.')
+                    .toParser(),
+                    new DateTimeFormatterBuilder(iChrono)
+                    .appendLiteral(',')
+                    .toParser()
+                })
+                .toParser();
+
             tpe = new DateTimeFormatterBuilder(iChrono)
+                // time-element
                 .append(hourElement())
-                .appendOptional
-                (new DateTimeFormatterBuilder(iChrono)
-                 .append(minuteElement())
-                 .appendOptional
-                 (new DateTimeFormatterBuilder(iChrono)
-                  .append(secondElement())
-                  .appendOptional(fractionElement())
-                  .toParser())
-                 .toParser())
+                .append
+                (null, new DateTimeParser[] {
+                    new DateTimeFormatterBuilder(iChrono)
+                    // minute-element
+                    .append(minuteElement())
+                    .append
+                    (null, new DateTimeParser[] {
+                        new DateTimeFormatterBuilder(iChrono)
+                        // second-element
+                        .append(secondElement())
+                        // second fraction
+                        .appendOptional(new DateTimeFormatterBuilder(iChrono)
+                                        .append(decimalPoint)
+                                        .appendFractionOfSecond(1, 9)
+                                        .toParser())
+                        .toParser(),
+                        // minute fraction
+                        new DateTimeFormatterBuilder(iChrono)
+                        .append(decimalPoint)
+                        .appendFractionOfMinute(1, 9)
+                        .toParser(),
+                        null
+                    })
+                    .toParser(),
+                    // hour fraction
+                    new DateTimeFormatterBuilder(iChrono)
+                    .append(decimalPoint)
+                    .appendFractionOfHour(1, 9)
+                    .toParser(),
+                    null
+                })
                 .toParser();
         }
         return tpe;
@@ -313,7 +354,10 @@ public DateTimeParser timeElementParser() {
      * time              = 'T' time-element [offset]
      * date-element      = (yyyy ['-' MM ['-' dd]]) | week-date-element
      * week-date-element = xxxx '-W' ww ['-' e]
-     * time-element      = HH [':' mm [':' ss ['.' SSS]]]
+     * time-element      = HH [minute-element] | [fraction]
+     * minute-element    = ':' mm [second-element] | [fraction]
+     * second-element    = ':' ss [fraction]
+     * fraction          = ('.' | ',') digit+
      * offset            = 'Z' | (('+' | '-') HH ':' mm)
      * </pre>
      */

From fd68de5eed8630dec3635a0fb6d7d82d960efa1b Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 3 Jan 2004 23:20:57 +0000
Subject: [PATCH 091/143] Fix a bug in timezone obtaining

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@96 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/DateTimeZone.java | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/DateTimeZone.java b/JodaTime/src/java/org/joda/time/DateTimeZone.java
index c7015fb34..ed21befc6 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeZone.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeZone.java
@@ -143,10 +143,12 @@
         try {
             try {
                 cDefault = getInstance(System.getProperty("user.timezone"));
-            } catch (RuntimeException e) {
+            } catch (RuntimeException ignored) {
             }
-            cDefault = getInstance(java.util.TimeZone.getDefault());
-        } catch (IllegalArgumentException e) {
+            if (cDefault == null) {
+                cDefault = getInstance(java.util.TimeZone.getDefault());
+            }
+        } catch (IllegalArgumentException ignored) {
         }
 
         if (cDefault == null) {

From b9b9292a5101bf7d8aa667dac72b4042436f4b5e Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 3 Jan 2004 23:21:11 +0000
Subject: [PATCH 092/143] Handle ordinal dates

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@97 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../joda/time/format/ISODateTimeFormat.java   | 28 +++++++++++++++++--
 1 file changed, 25 insertions(+), 3 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
index 2d2fd0880..f0383ee0f 100644
--- a/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
+++ b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
@@ -147,6 +147,7 @@ public static synchronized ISODateTimeFormat getInstance(Chronology chrono) {
         we,  // weekyear element (xxxx)
         wwe, // weekOfWeekyear element (-ww)
         dwe, // dayOfWeek element (-ee)
+        dye, // dayOfYear element (-ooo)
         hde, // hourOfDay element (HH)
         mhe, // minuteOfHour element (:mm)
         sme, // secondOfMinute element (:ss)
@@ -207,7 +208,9 @@ private ISODateTimeFormat(final Chronology chrono) {
      * the following syntax:
      * <pre>
      * date              = date-element ['T' offset]
-     * date-element      = (yyyy ['-' MM ['-' dd]]) | week-date-element
+     * date-element      = std-date-element | ord-date-element | week-date-element
+     * std-date-element  = yyyy ['-' MM ['-' dd]]
+     * ord-date-element  = yyyy ['-' ddd]
      * week-date-element = xxxx '-W' ww ['-' e]
      * offset            = 'Z' | (('+' | '-') HH ':' mm)
      * </pre>
@@ -230,7 +233,9 @@ public DateTimeParser dateParser() {
      * Returns a generic ISO date parser. It accepts formats described by
      * the following syntax:
      * <pre>
-     * date-element      = (yyyy ['-' MM ['-' dd]]) | week-date-element
+     * date-element      = std-date-element | ord-date-element | week-date-element
+     * std-date-element  = yyyy ['-' MM ['-' dd]]
+     * ord-date-element  = yyyy ['-' ddd]
      * week-date-element = xxxx '-W' ww ['-' e]
      * </pre>
      */
@@ -250,6 +255,10 @@ public DateTimeParser dateElementParser() {
                     .append(weekyearElement())
                     .append(weekElement())
                     .appendOptional(dayOfWeekElement())
+                    .toParser(),
+                    new DateTimeFormatterBuilder(iChrono)
+                    .append(yearElement())
+                    .append(dayOfYearElement())
                     .toParser()
                 })
                 .toParser();
@@ -352,7 +361,9 @@ public DateTimeParser timeElementParser() {
      * <pre>
      * datetime          = time | (date-element [time | ('T' offset)])
      * time              = 'T' time-element [offset]
-     * date-element      = (yyyy ['-' MM ['-' dd]]) | week-date-element
+     * date-element      = std-date-element | ord-date-element | week-date-element
+     * std-date-element  = yyyy ['-' MM ['-' dd]]
+     * ord-date-element  = yyyy ['-' ddd]
      * week-date-element = xxxx '-W' ww ['-' e]
      * time-element      = HH [minute-element] | [fraction]
      * minute-element    = ':' mm [second-element] | [fraction]
@@ -780,6 +791,16 @@ private DateTimeFormatter dayOfWeekElement() {
         return dwe;
     }
 
+    private DateTimeFormatter dayOfYearElement() {
+        if (dye == null) {
+            dye = new DateTimeFormatterBuilder(iChrono)
+                .appendLiteral('-')
+                .appendDayOfYear(3)
+                .toFormatter();
+        }
+        return dye;
+    }
+
     private DateTimeFormatter hourElement() {
         if (hde == null) {
             hde = new DateTimeFormatterBuilder(iChrono)
@@ -829,4 +850,5 @@ private DateTimeFormatter offsetElement() {
         }
         return ze;
     }
+    
 }

From a8db2e4be27585dad5c3195937a88395f4cb0314 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 3 Jan 2004 23:21:29 +0000
Subject: [PATCH 093/143] Add test for parse formats

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@98 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../test/org/joda/test/time/TestParseISO.java | 442 ++++++++++++++++++
 1 file changed, 442 insertions(+)
 create mode 100644 JodaTime/src/test/org/joda/test/time/TestParseISO.java

diff --git a/JodaTime/src/test/org/joda/test/time/TestParseISO.java b/JodaTime/src/test/org/joda/test/time/TestParseISO.java
new file mode 100644
index 000000000..4d4447aba
--- /dev/null
+++ b/JodaTime/src/test/org/joda/test/time/TestParseISO.java
@@ -0,0 +1,442 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.test.time;
+
+import junit.framework.Assert;
+import junit.framework.TestSuite;
+
+import org.joda.time.DateTimeZone;
+import org.joda.time.MutableDateTime;
+import org.joda.time.format.DateTimeParser;
+import org.joda.time.format.ISODateTimeFormat;
+
+/**
+ * Unit test the parsing of ISO format datetimes
+ *
+ * @author Guy Allard
+ * @author Stephen Colebourne
+ */
+public class TestParseISO extends BulkTest {
+    
+    private static final int DEFAULT = 99999;
+
+    /**
+     * This is the main class for this test suite.
+     * @param args command line arguments.
+     */
+    public static void main(String[] args) {
+        junit.textui.TestRunner.run(suite());
+    }
+    
+    /**
+     * TestSuite suite() is a junit required method.
+     * @see org.joda.test.time.BulkTest
+     */
+    public static TestSuite suite() {
+        return BulkTest.makeSuite(TestParseISO.class);
+    }
+    
+    /**
+     * TestConstructors constructor.
+     * @param name
+     */
+    public TestParseISO(String name) {
+        super(name);
+    }
+
+    protected void setUp() throws Exception {
+        super.setUp();
+    }
+    
+    protected void tearDown() throws Exception {
+        super.tearDown();
+    }
+    
+    //-----------------------------------------------------------------------
+    // Dates
+    //-----------------------------------------------------------------------
+    public void testSpecCompleteDate() {
+        new DMatcher("5.2.1.1", "1999-10-20", "19991020",
+            19, 99, 10, 20, DEFAULT).run();
+    }        
+    //-----------------------------------------------------------------------
+    public void testSpecReducedPrecisionCYM() {
+        new DMatcher("5.2.1.2", "1999-10", "199910",
+            19, 99, 10, DEFAULT, DEFAULT).run();
+    }
+    public void testSpecReducedPrecisionCY() {
+        new DMatcher("5.2.1.2", "1999", "1999",
+            19, 99, DEFAULT, DEFAULT, DEFAULT).run();
+    }
+    public void testSpecReducedPrecisionC() {
+        new DMatcher("5.2.1.2", "20", "20",
+            20, DEFAULT, DEFAULT, DEFAULT, DEFAULT).run();
+        new DMatcher("5.2.1.2", "19", "19",
+            19, DEFAULT, DEFAULT, DEFAULT, DEFAULT).run();
+    }
+    //-----------------------------------------------------------------------
+    public void testSpecTruncatedYMD() {
+        new DMatcher("5.2.1.3", "85-04-11", "850411",
+            DEFAULT, 85, 4, 11, DEFAULT).run();
+    }
+    public void testSpecTruncatedYM() {
+        new DMatcher("5.2.1.3", "-85-04", "-8504",
+            DEFAULT, 85, 4, DEFAULT, DEFAULT).run();
+    }
+    public void testSpecTruncatedY() {
+        new DMatcher("5.2.1.3", "-85", "-85",
+            DEFAULT, 85, DEFAULT, DEFAULT, DEFAULT).run();
+    }
+    public void testSpecTruncatedMD() {
+        new DMatcher("5.2.1.3", "--04-11", "--0411",
+            DEFAULT, DEFAULT, 4, 11, DEFAULT).run();
+    }
+    public void testSpecTruncatedM() {
+        new DMatcher("5.2.1.3", "--04", "--04",
+            DEFAULT, DEFAULT, 4, DEFAULT, DEFAULT).run();
+    }
+    public void testSpecTruncatedD() {
+        new DMatcher("5.2.1.3", "---11", "---11",
+            DEFAULT, DEFAULT, DEFAULT, 11, DEFAULT).run();
+    }
+    //-----------------------------------------------------------------------
+    public void testSpecExpandedCYMD() {
+        new DMatcher("5.2.1.4", "+001985-04-11", "+0019850411",
+            19, 85, 4, 11, DEFAULT).run();
+    }
+    public void testSpecExpandedCYM() {
+        new DMatcher("5.2.1.4", "+001985-04", "+00198504",
+            19, 85, 4, DEFAULT, DEFAULT).run();
+    }
+    public void testSpecExpandedCY() {
+        new DMatcher("5.2.1.4", "+001985", "+001985",
+            19, 85, DEFAULT, DEFAULT, DEFAULT).run();
+    }
+    public void testSpecExpandedC() {
+        // Not supported - could only tell difference from CY if you knew
+        // number of digits representing year
+//        new DMatcher("5.2.1.4", "+0019", "+0019",
+//            19, DEFAULT, DEFAULT, DEFAULT, DEFAULT).assert();
+    }
+    
+    //-----------------------------------------------------------------------
+    // Ordinal based date
+    //-----------------------------------------------------------------------
+    public void testSpecOrdinalComplete() {
+        new DMatcher("5.2.2.1", "1985-101", "1985101",
+            19, 85, 4, 11, DEFAULT).run();
+        new DMatcher("5.2.2.1", "1985-021", "1985021",
+            19, 85, 1, 21, DEFAULT).run();
+        new DMatcher("5.2.2.1", "1985-006", "1985006",
+            19, 85, 1, 6, DEFAULT).run();
+    }
+    //-----------------------------------------------------------------------
+    public void testSpecOrdinalTruncatedYD() {
+        new DMatcher("5.2.2.2", "85-101", "85101",
+            DEFAULT, 85, 4, 11, DEFAULT).run();
+    }
+    public void testSpecOrdinalTruncatedD() {
+        new DMatcher("5.2.2.2", "-101", "-101",
+            DEFAULT, DEFAULT, 4, 11, DEFAULT).run();
+    }
+    //-----------------------------------------------------------------------
+    public void testSpecOrdinalExpandedYD() {
+        new DMatcher("5.2.2.3", "+001985-101", "+001985101",
+            19, 85, 4, 11, DEFAULT).run();
+    }
+    //-----------------------------------------------------------------------
+    // Week based date
+    //-----------------------------------------------------------------------
+    public void testSpecWeekComplete() {
+        new DMatcher("5.2.3.1", "1985-W15-1", "1985W151",
+            19, 85, 4, 8, DEFAULT).run();
+        new DMatcher("5.2.3.1", "1985-W15-2", "1985W152",
+            19, 85, 4, 9, DEFAULT).run();
+        new DMatcher("5.2.3.1", "1985-W15-3", "1985W153",
+            19, 85, 4, 10, DEFAULT).run();
+        new DMatcher("5.2.3.1", "1985-W15-4", "1985W154",
+            19, 85, 4, 11, DEFAULT).run();
+        new DMatcher("5.2.3.1", "1985-W15-5", "1985W155",
+            19, 85, 4, 12, DEFAULT).run();
+        new DMatcher("5.2.3.1", "1985-W15-6", "1985W156",
+            19, 85, 4, 13, DEFAULT).run();
+        new DMatcher("5.2.3.1", "1985-W15-7", "1985W157",
+            19, 85, 4, 14, DEFAULT).run();
+    }
+    //-----------------------------------------------------------------------
+    public void testSpecWeekReducedPrecision() {
+        // test date is Sunday, which should be left alone
+        new DMatcher("5.2.3.2", "1985-W15", "1985W15",
+            19, 85, 4, 14, DEFAULT).run();
+    }
+    //-----------------------------------------------------------------------
+    public void testSpecWeekTruncatedYWD() {
+        new DMatcher("5.2.3.2", "85-W154", "85W154",
+            DEFAULT, 85, 4, 11, DEFAULT).run();
+    }
+    public void testSpecWeekTruncatedYW() {
+        // test date is Sunday, which should be left alone
+        new DMatcher("5.2.3.2", "85-W15", "85W15",
+            DEFAULT, 85, 4, 14, DEFAULT).run();
+    }
+    public void testSpecWeekTruncatedDWD() {
+        // decade not supported
+    }
+    public void testSpecWeekTruncatedDW() {
+        // decade not supported
+    }
+    public void testSpecWeekTruncatedWD() {
+        new DMatcher("5.2.3.2", "-W154", "-W154",
+            DEFAULT, DEFAULT, 4, 11, DEFAULT).run();
+    }
+    public void testSpecWeekTruncatedW() {
+        // test date is Sunday, which should be left alone
+        new DMatcher("5.2.3.2", "-W15", "-W15",
+            DEFAULT, DEFAULT, 4, 14, DEFAULT).run();
+    }
+    public void testSpecWeekTruncatedD() {
+        // test date is Sunday 3rd Dec, thus relative Thursday is 30th Nov
+        new DMatcher("5.2.3.3", "-W-4", "-W-4",
+            DEFAULT, DEFAULT, 11, 30, DEFAULT).run();
+    }
+    public void testSpecWeekExpandedYWD() {
+        // test date is Sunday 3rd Dec, thus relative Thursday is 30th Nov
+        new DMatcher("5.2.3.4", "+001985-W15-4", "+001985W154",
+            19, 85, 4, 11, DEFAULT).run();
+    }
+
+    //-----------------------------------------------------------------------
+    // Times
+    //-----------------------------------------------------------------------
+    public void testSpecTimeComplete() {
+        new TMatcher("5.3.1.1", "23:20:50", "232050",
+            23, 20, 50, 0, DEFAULT).run();
+    }
+    //-----------------------------------------------------------------------
+    public void testSpecTimeReducedPrecisionHM() {
+        new TMatcher("5.3.1.2", "23:20", "2320",
+            23, 20, DEFAULT, DEFAULT, DEFAULT).run();
+    }
+    public void testSpecTimeReducedPrecisionH() {
+        new TMatcher("5.3.1.2", "23", "23",
+            23, DEFAULT, DEFAULT, DEFAULT, DEFAULT).run();
+    }
+    //-----------------------------------------------------------------------
+    public void testSpecTimeFractionalHMS() {
+        new TMatcher("5.3.1.3", "23:20:50.607", "232050.607",
+            23, 20, 50, 607, DEFAULT).run();
+        new TMatcher("5.3.1.3", "23:20:50,607", "232050,607",
+            23, 20, 50, 607, DEFAULT).run();
+    }
+    public void testSpecTimeFractionalHM() {
+        new TMatcher("5.3.1.3", "23:20.4", "2320.4",
+            23, 20, 24, 0, DEFAULT).run();
+        new TMatcher("5.3.1.3", "23:20,4", "2320,4",
+            23, 20, 24, 0, DEFAULT).run();
+    }
+    public void testSpecTimeFractionalH() {
+        new TMatcher("5.3.1.3", "23.25", "23.25",
+            23, 15, 0, 0, DEFAULT).run();
+        new TMatcher("5.3.1.3", "23.25", "23,25",
+            23, 15, 0, 0, DEFAULT).run();
+    }
+    //-----------------------------------------------------------------------
+    public void testSpecTimeTruncatedMS() {
+        new TMatcher("5.3.1.4", "-20:50", "-2050",
+            DEFAULT, 20, 50, 0, DEFAULT).run();
+    }
+    public void testSpecTimeTruncatedM() {
+        new TMatcher("5.3.1.4", "-20", "-20",
+            DEFAULT, 20, DEFAULT, DEFAULT, DEFAULT).run();
+    }
+    public void testSpecTimeTruncatedS() {
+        new TMatcher("5.3.1.4", "--50", "--50",
+            DEFAULT, DEFAULT, 50, 0, DEFAULT).run();
+    }
+    public void testSpecTimeTruncatedFractionMS() {
+        new TMatcher("5.3.1.4", "-20:50.607", "-2050.607",
+            DEFAULT, 20, 50, 607, DEFAULT).run();
+    }
+    public void testSpecTimeTruncatedFractionM() {
+        new TMatcher("5.3.1.4", "-20.4", "-20.4",
+            DEFAULT, 20, 24, 0, DEFAULT).run();
+    }
+    public void testSpecTimeTruncatedFractionS() {
+        new TMatcher("5.3.1.4", "--50.607", "--50.607",
+            DEFAULT, DEFAULT, 50, 607, DEFAULT).run();
+    }
+    
+    //-----------------------------------------------------------------------
+    //-----------------------------------------------------------------------
+    //-----------------------------------------------------------------------
+    /**
+     * Perform test.
+     */        
+    protected static abstract class Matcher extends Assert {
+        String spec, extended, basic;
+        int century, yearOfCentury, monthOfYear, dayOfMonth, hour, min, sec, milli, zone;
+        MutableDateTime dt;
+        
+        protected Matcher(String spec, String extended, String basic) {
+            this.spec = spec;
+            this.extended = extended;
+            this.basic = basic;
+        }
+        
+        protected abstract void run();
+        protected void assert() {
+            String msg = "\nSpec:   " + spec + "\nParsed: " + extended + "\nTo:     " + dt;
+            assertEquals(msg + "\nCentury: ", century, dt.getCenturyOfEra());
+            assertEquals(msg + "\nYear: ", yearOfCentury, dt.getYearOfCentury());
+            assertEquals(msg + "\nMonth: ", monthOfYear, dt.getMonthOfYear());
+            assertEquals(msg + "\nDay: ", dayOfMonth, dt.getDayOfMonth());
+            assertEquals(msg + "\nHour: ", hour, dt.getHourOfDay());
+            assertEquals(msg + "\nMinute: ", min, dt.getMinuteOfHour());
+            assertEquals(msg + "\nSecond: ", sec, dt.getSecondOfMinute());
+            assertEquals(msg + "\nMilli: ", milli, dt.getMillisOfSecond());
+            DateTimeZone z;
+            if (zone == DEFAULT) {
+                z = DateTimeZone.getDefault();
+            } else if (zone == 0) {
+                    z = DateTimeZone.UTC;
+            } else {
+                String str = "0" + Math.abs(zone) + ":00";
+                str = str.substring(str.length() - 4);
+                str = (zone < 0 ? "-" : "+") + str;
+                z = DateTimeZone.getInstance(str);
+            }
+            assertEquals(msg + "\nZone: ", z, dt.getDateTimeZone());
+        }
+        protected void parse(DateTimeParser p) {
+            int result = p.parseInto(dt, extended, 0);
+            assertTrue("\nSpec:   " + spec + "\nParsed: " + extended + "\nTo:     "
+                + dt + "\nParse failed at: " + ~result,
+                result >= 0);
+        }
+    }
+    protected static class DTMatcher extends Matcher {
+        protected DTMatcher(String spec, String extended, String basic,
+                int century, int yearOfCentury, int monthOfYear, int dayOfMonth,
+                int hour, int min, int sec, int milli, int zone) {
+            super(spec, extended, basic);
+            this.century = (century == DEFAULT ? 19 : century);
+            this.yearOfCentury = (yearOfCentury == DEFAULT ? 72 : yearOfCentury);
+            this.monthOfYear = (monthOfYear == DEFAULT ? 12 : monthOfYear);
+            this.dayOfMonth = (dayOfMonth == DEFAULT ? 3 : dayOfMonth);
+            this.hour = (hour == DEFAULT ? 10 : hour);
+            this.min = (min == DEFAULT ? 32 : min);
+            this.sec = (sec == DEFAULT ? 40 : sec);
+            this.milli = (milli == DEFAULT ? 205 : milli);
+            this.zone = zone;
+        }            
+        protected void run() {
+            dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);
+            parse(ISODateTimeFormat.getInstance().dateTimeParser());
+            super.assert();
+        }
+    }
+    protected static class DMatcher extends Matcher {
+        protected DMatcher(String spec, String extended, String basic,
+                int century, int yearOfCentury, int monthOfYear, int dayOfMonth, int zone) {
+            super(spec, extended, basic);
+            this.century = (century == DEFAULT ? 19 : century);
+            this.yearOfCentury = (yearOfCentury == DEFAULT ? 72 : yearOfCentury);
+            this.monthOfYear = (monthOfYear == DEFAULT ? 12 : monthOfYear);
+            this.dayOfMonth = (dayOfMonth == DEFAULT ? 3 : dayOfMonth);
+            this.hour = 10;
+            this.min = 32;
+            this.sec = 40;
+            this.milli = 205;
+            this.zone = zone;
+        }
+        protected void run() {
+            dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);
+            parse(ISODateTimeFormat.getInstance().dateParser());
+            super.assert();
+        
+            dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);
+            parse(ISODateTimeFormat.getInstance().dateTimeParser());
+            super.assert();
+        }
+    }
+    protected static class TMatcher extends Matcher {
+        protected TMatcher(String spec, String extended, String basic,
+                int hour, int min, int sec, int milli, int zone) {
+            super(spec, extended, basic);
+            this.century = 19;
+            this.yearOfCentury = 72;
+            this.monthOfYear = 12;
+            this.dayOfMonth = 3;
+            this.hour = (hour == DEFAULT ? 10 : hour);
+            this.min = (min == DEFAULT ? 32 : min);
+            this.sec = (sec == DEFAULT ? 40 : sec);
+            this.milli = (milli == DEFAULT ? 205 : milli);
+            this.zone = zone;
+        }
+        protected void run() {
+            dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);
+            parse(ISODateTimeFormat.getInstance().timeParser());
+            super.assert();
+            
+            extended = "T" + extended;
+            dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);
+            parse(ISODateTimeFormat.getInstance().timeParser());
+            super.assert();
+            
+            dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);
+            parse(ISODateTimeFormat.getInstance().dateTimeParser());
+            super.assert();
+        }
+    }
+}

From e5d945fd0d91cbd076e23c8ae90427ad7ef789a3 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 4 Jan 2004 00:29:06 +0000
Subject: [PATCH 094/143] Minor comment clarification.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@99 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/format/ISODateTimeFormat.java  | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
index f0383ee0f..4e5280fb1 100644
--- a/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
+++ b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
@@ -147,7 +147,7 @@ public static synchronized ISODateTimeFormat getInstance(Chronology chrono) {
         we,  // weekyear element (xxxx)
         wwe, // weekOfWeekyear element (-ww)
         dwe, // dayOfWeek element (-ee)
-        dye, // dayOfYear element (-ooo)
+        dye, // dayOfYear element (-DDD)
         hde, // hourOfDay element (HH)
         mhe, // minuteOfHour element (:mm)
         sme, // secondOfMinute element (:ss)
@@ -210,7 +210,7 @@ private ISODateTimeFormat(final Chronology chrono) {
      * date              = date-element ['T' offset]
      * date-element      = std-date-element | ord-date-element | week-date-element
      * std-date-element  = yyyy ['-' MM ['-' dd]]
-     * ord-date-element  = yyyy ['-' ddd]
+     * ord-date-element  = yyyy ['-' DDD]
      * week-date-element = xxxx '-W' ww ['-' e]
      * offset            = 'Z' | (('+' | '-') HH ':' mm)
      * </pre>
@@ -235,7 +235,7 @@ public DateTimeParser dateParser() {
      * <pre>
      * date-element      = std-date-element | ord-date-element | week-date-element
      * std-date-element  = yyyy ['-' MM ['-' dd]]
-     * ord-date-element  = yyyy ['-' ddd]
+     * ord-date-element  = yyyy ['-' DDD]
      * week-date-element = xxxx '-W' ww ['-' e]
      * </pre>
      */
@@ -363,7 +363,7 @@ public DateTimeParser timeElementParser() {
      * time              = 'T' time-element [offset]
      * date-element      = std-date-element | ord-date-element | week-date-element
      * std-date-element  = yyyy ['-' MM ['-' dd]]
-     * ord-date-element  = yyyy ['-' ddd]
+     * ord-date-element  = yyyy ['-' DDD]
      * week-date-element = xxxx '-W' ww ['-' e]
      * time-element      = HH [minute-element] | [fraction]
      * minute-element    = ':' mm [second-element] | [fraction]

From d7a7fcd6e2d7d8210bb37830857e110f7cdee6eb Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 4 Jan 2004 07:29:04 +0000
Subject: [PATCH 095/143] Bring back missing appendPattern method.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@100 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../joda/time/format/DateTimeFormatterBuilder.java  | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
index 0a48dd9a4..81f466292 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
@@ -864,6 +864,19 @@ public DateTimeFormatterBuilder appendTimeZoneOffset(
                        (iChrono, zeroOffsetText, showSeparators, minFields, maxFields));
     }
 
+    /**
+     * Calls upon {@link DateTimeFormat} to parse the pattern and append the
+     * results into this builder.
+     *
+     * @param pattern  pattern specification
+     * @throws IllegalArgumentException if the pattern is invalid
+     * @see DateTimeFormat#appendPatternTo(DateTimeFormatterBuilder,String)
+     */
+    public DateTimeFormatterBuilder appendPattern(String pattern) {
+        DateTimeFormat.appendPatternTo(this, pattern);
+        return this;
+    }
+
     private Object getFormatter() {
         Object f = iFormatter;
 

From a23eb4c8a802acd34aa2789be8a5a282decc6c1f Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 4 Jan 2004 07:29:59 +0000
Subject: [PATCH 096/143] Make class names follow consistent naming pattern.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@101 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 ...java => AbstractReadableInstantFieldProperty.java} | 11 ++++++-----
 .../org/joda/time/property/DateOnlyFieldProperty.java |  2 +-
 .../org/joda/time/property/DateTimeFieldProperty.java |  2 +-
 ...rty.java => ReadWritableInstantFieldProperty.java} | 11 ++++++-----
 .../org/joda/time/property/TimeOnlyFieldProperty.java |  2 +-
 5 files changed, 15 insertions(+), 13 deletions(-)
 rename JodaTime/src/java/org/joda/time/property/{AbstractDateTimeFieldProperty.java => AbstractReadableInstantFieldProperty.java} (96%)
 rename JodaTime/src/java/org/joda/time/property/{MutableDateTimeFieldProperty.java => ReadWritableInstantFieldProperty.java} (94%)

diff --git a/JodaTime/src/java/org/joda/time/property/AbstractDateTimeFieldProperty.java b/JodaTime/src/java/org/joda/time/property/AbstractReadableInstantFieldProperty.java
similarity index 96%
rename from JodaTime/src/java/org/joda/time/property/AbstractDateTimeFieldProperty.java
rename to JodaTime/src/java/org/joda/time/property/AbstractReadableInstantFieldProperty.java
index 1796d1398..83fa1a4a2 100644
--- a/JodaTime/src/java/org/joda/time/property/AbstractDateTimeFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/property/AbstractReadableInstantFieldProperty.java
@@ -60,27 +60,28 @@
 import org.joda.time.ReadableInstant;
 
 /**
- * AbstractDateTimeFieldProperty is a base class for binding a
+ * AbstractReadableInstantFieldProperty is a base class for binding a
  * ReadableInstant to a DateTimeField.
  * <p>
  * It allows the date and time manipulation code to be field based yet
  * still easy to use.
  * <p>
- * AbstractDateTimeFieldPropery itself is thread-safe and immutable, but the
- * ReadableInstant being operated on may be mutable and not thread-safe.
+ * AbstractReadableInstantFieldProperty itself is thread-safe and immutable,
+ * but the ReadableInstant being operated on may be mutable and not
+ * thread-safe.
  *
  * @author Stephen Colebourne
  * @author Brian S O'Neill
  * @since 1.0
  */
-public abstract class AbstractDateTimeFieldProperty implements Serializable {
+public abstract class AbstractReadableInstantFieldProperty implements Serializable {
     
     static final long serialVersionUID = 1971226328211649661L;
 
     /**
      * Constructor.
      */
-    public AbstractDateTimeFieldProperty() {
+    public AbstractReadableInstantFieldProperty() {
         super();
     }
 
diff --git a/JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java b/JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java
index 04fda55f9..d0cb80045 100644
--- a/JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java
@@ -87,7 +87,7 @@
  *
  * @author Brian S O'Neill
  */
-public class DateOnlyFieldProperty extends AbstractDateTimeFieldProperty {
+public class DateOnlyFieldProperty extends AbstractReadableInstantFieldProperty {
 
     static final long serialVersionUID = -7764886769525930067L;
 
diff --git a/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java b/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java
index d8bd5ff91..1e92dd482 100644
--- a/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java
@@ -89,7 +89,7 @@
  * @author Brian S O'Neill
  * @since 1.0
  */
-public class DateTimeFieldProperty extends AbstractDateTimeFieldProperty {
+public class DateTimeFieldProperty extends AbstractReadableInstantFieldProperty {
     
     static final long serialVersionUID = -6983323811635733510L;
 
diff --git a/JodaTime/src/java/org/joda/time/property/MutableDateTimeFieldProperty.java b/JodaTime/src/java/org/joda/time/property/ReadWritableInstantFieldProperty.java
similarity index 94%
rename from JodaTime/src/java/org/joda/time/property/MutableDateTimeFieldProperty.java
rename to JodaTime/src/java/org/joda/time/property/ReadWritableInstantFieldProperty.java
index 0ca2991c2..d43b2d1b9 100644
--- a/JodaTime/src/java/org/joda/time/property/MutableDateTimeFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/property/ReadWritableInstantFieldProperty.java
@@ -59,8 +59,9 @@
 import org.joda.time.ReadWritableInstant;
 
 /**
- * MutableDateTimeFieldProperty binds a ReadWritableInstant to a DateTimeField
- * allowing powerful datetime functionality to be easily accessed.
+ * ReadWritabelInstantFieldProperty binds a ReadWritableInstant to a
+ * DateTimeField allowing powerful datetime functionality to be easily
+ * accessed.
  * <p>
  * The example below shows how to use the property to change the value of a
  * MutableDateTime object.
@@ -71,14 +72,14 @@
  * dt.minute().set(10);
  * </pre>
  * <p>
- * MutableDateTimeFieldPropery itself is thread-safe and immutable, but the
+ * ReadWritableInstantFieldPropery itself is thread-safe and immutable, but the
  * ReadWritableInstant being operated on may not be thread-safe.
  *
  * @author Stephen Colebourne
  * @author Brian S O'Neill
  * @since 1.0
  */
-public class MutableDateTimeFieldProperty extends AbstractDateTimeFieldProperty {
+public class ReadWritableInstantFieldProperty extends AbstractReadableInstantFieldProperty {
 
     static final long serialVersionUID = -4481126543819298617L;
 
@@ -93,7 +94,7 @@
      * @param instant  the instant to set
      * @param field  the field to use
      */
-    public MutableDateTimeFieldProperty(ReadWritableInstant instant, DateTimeField field) {
+    public ReadWritableInstantFieldProperty(ReadWritableInstant instant, DateTimeField field) {
         super();
         iInstant = instant;
         iField = field;
diff --git a/JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java b/JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java
index 824807396..6a8940fed 100644
--- a/JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java
@@ -87,7 +87,7 @@
  *
  * @author Brian S O'Neill
  */
-public class TimeOnlyFieldProperty extends AbstractDateTimeFieldProperty {
+public class TimeOnlyFieldProperty extends AbstractReadableInstantFieldProperty {
 
     static final long serialVersionUID = 8826542069120527929L;
 

From e092621ffd2a52c2b334b63a9ace3e9e9757916e Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 4 Jan 2004 07:31:39 +0000
Subject: [PATCH 097/143] Reflect changes in property package class renames.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@102 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/MutableDateOnly.java   | 46 ++++++------
 .../java/org/joda/time/MutableDateTime.java   | 74 +++++++++----------
 .../java/org/joda/time/MutableTimeOnly.java   | 46 ++++++------
 3 files changed, 83 insertions(+), 83 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/MutableDateOnly.java b/JodaTime/src/java/org/joda/time/MutableDateOnly.java
index af4b71b6b..0633f4a5a 100644
--- a/JodaTime/src/java/org/joda/time/MutableDateOnly.java
+++ b/JodaTime/src/java/org/joda/time/MutableDateOnly.java
@@ -59,7 +59,7 @@
 import org.joda.time.convert.ConverterManager;
 import org.joda.time.convert.DurationConverter;
 import org.joda.time.format.ISODateTimeFormat;
-import org.joda.time.property.MutableDateTimeFieldProperty;
+import org.joda.time.property.ReadWritableInstantFieldProperty;
 
 /**
  * MutableDateOnly is the basic implementation of a modifiable date only class.
@@ -701,8 +701,8 @@ public void setDate(
      * 
      * @return the day of week property
      */
-    public final MutableDateTimeFieldProperty dayOfWeek() {
-        return new MutableDateTimeFieldProperty(this, getChronology().dayOfWeek());
+    public final ReadWritableInstantFieldProperty dayOfWeek() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().dayOfWeek());
     }
 
     /**
@@ -710,8 +710,8 @@ public final MutableDateTimeFieldProperty dayOfWeek() {
      * 
      * @return the day of month property
      */
-    public final MutableDateTimeFieldProperty dayOfMonth() {
-        return new MutableDateTimeFieldProperty(this, getChronology().dayOfMonth());
+    public final ReadWritableInstantFieldProperty dayOfMonth() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().dayOfMonth());
     }
 
     /**
@@ -719,8 +719,8 @@ public final MutableDateTimeFieldProperty dayOfMonth() {
      * 
      * @return the day of year property
      */
-    public final MutableDateTimeFieldProperty dayOfYear() {
-        return new MutableDateTimeFieldProperty(this, getChronology().dayOfYear());
+    public final ReadWritableInstantFieldProperty dayOfYear() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().dayOfYear());
     }
 
     /**
@@ -728,8 +728,8 @@ public final MutableDateTimeFieldProperty dayOfYear() {
      * 
      * @return the week of a week based year property
      */
-    public final MutableDateTimeFieldProperty weekOfWeekyear() {
-        return new MutableDateTimeFieldProperty(this, getChronology().weekOfWeekyear());
+    public final ReadWritableInstantFieldProperty weekOfWeekyear() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().weekOfWeekyear());
     }
 
     /**
@@ -737,8 +737,8 @@ public final MutableDateTimeFieldProperty weekOfWeekyear() {
      * 
      * @return the year of a week based year property
      */
-    public final MutableDateTimeFieldProperty weekyear() {
-        return new MutableDateTimeFieldProperty(this, getChronology().weekyear());
+    public final ReadWritableInstantFieldProperty weekyear() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().weekyear());
     }
 
     /**
@@ -746,8 +746,8 @@ public final MutableDateTimeFieldProperty weekyear() {
      * 
      * @return the month of year property
      */
-    public final MutableDateTimeFieldProperty monthOfYear() {
-        return new MutableDateTimeFieldProperty(this, getChronology().monthOfYear());
+    public final ReadWritableInstantFieldProperty monthOfYear() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().monthOfYear());
     }
 
     /**
@@ -755,8 +755,8 @@ public final MutableDateTimeFieldProperty monthOfYear() {
      * 
      * @return the year property
      */
-    public final MutableDateTimeFieldProperty year() {
-        return new MutableDateTimeFieldProperty(this, getChronology().year());
+    public final ReadWritableInstantFieldProperty year() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().year());
     }
 
     /**
@@ -764,8 +764,8 @@ public final MutableDateTimeFieldProperty year() {
      * 
      * @return the year of era property
      */
-    public final MutableDateTimeFieldProperty yearOfEra() {
-        return new MutableDateTimeFieldProperty(this, getChronology().yearOfEra());
+    public final ReadWritableInstantFieldProperty yearOfEra() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().yearOfEra());
     }
 
     /**
@@ -773,8 +773,8 @@ public final MutableDateTimeFieldProperty yearOfEra() {
      * 
      * @return the year of era property
      */
-    public final MutableDateTimeFieldProperty yearOfCentury() {
-        return new MutableDateTimeFieldProperty(this, getChronology().yearOfCentury());
+    public final ReadWritableInstantFieldProperty yearOfCentury() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().yearOfCentury());
     }
 
     /**
@@ -782,8 +782,8 @@ public final MutableDateTimeFieldProperty yearOfCentury() {
      * 
      * @return the year of era property
      */
-    public final MutableDateTimeFieldProperty centuryOfEra() {
-        return new MutableDateTimeFieldProperty(this, getChronology().centuryOfEra());
+    public final ReadWritableInstantFieldProperty centuryOfEra() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().centuryOfEra());
     }
 
     /**
@@ -791,8 +791,8 @@ public final MutableDateTimeFieldProperty centuryOfEra() {
      * 
      * @return the era property
      */
-    public final MutableDateTimeFieldProperty era() {
-        return new MutableDateTimeFieldProperty(this, getChronology().era());
+    public final ReadWritableInstantFieldProperty era() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().era());
     }
 
     // Misc
diff --git a/JodaTime/src/java/org/joda/time/MutableDateTime.java b/JodaTime/src/java/org/joda/time/MutableDateTime.java
index 6d8ebc2bd..daca91b91 100644
--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java
+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java
@@ -60,7 +60,7 @@
 import org.joda.time.convert.DurationConverter;
 import org.joda.time.convert.InstantConverter;
 import org.joda.time.format.ISODateTimeFormat;
-import org.joda.time.property.MutableDateTimeFieldProperty;
+import org.joda.time.property.ReadWritableInstantFieldProperty;
 
 /**
  * MutableDateTime is the standard implementation of a modifiable datetime class.
@@ -915,8 +915,8 @@ public void setDateTime(
      * 
      * @return the era property
      */
-    public MutableDateTimeFieldProperty era() {
-        return new MutableDateTimeFieldProperty(this, getChronology().era());
+    public ReadWritableInstantFieldProperty era() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().era());
     }
 
     /**
@@ -924,8 +924,8 @@ public MutableDateTimeFieldProperty era() {
      * 
      * @return the year of era property
      */
-    public MutableDateTimeFieldProperty centuryOfEra() {
-        return new MutableDateTimeFieldProperty(this, getChronology().centuryOfEra());
+    public ReadWritableInstantFieldProperty centuryOfEra() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().centuryOfEra());
     }
 
     /**
@@ -933,8 +933,8 @@ public MutableDateTimeFieldProperty centuryOfEra() {
      * 
      * @return the year of era property
      */
-    public MutableDateTimeFieldProperty yearOfCentury() {
-        return new MutableDateTimeFieldProperty(this, getChronology().yearOfCentury());
+    public ReadWritableInstantFieldProperty yearOfCentury() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().yearOfCentury());
     }
 
     /**
@@ -942,8 +942,8 @@ public MutableDateTimeFieldProperty yearOfCentury() {
      * 
      * @return the year of era property
      */
-    public MutableDateTimeFieldProperty yearOfEra() {
-        return new MutableDateTimeFieldProperty(this, getChronology().yearOfEra());
+    public ReadWritableInstantFieldProperty yearOfEra() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().yearOfEra());
     }
 
     /**
@@ -951,8 +951,8 @@ public MutableDateTimeFieldProperty yearOfEra() {
      * 
      * @return the year property
      */
-    public MutableDateTimeFieldProperty year() {
-        return new MutableDateTimeFieldProperty(this, getChronology().year());
+    public ReadWritableInstantFieldProperty year() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().year());
     }
 
     /**
@@ -960,8 +960,8 @@ public MutableDateTimeFieldProperty year() {
      * 
      * @return the year of a week based year property
      */
-    public MutableDateTimeFieldProperty weekyear() {
-        return new MutableDateTimeFieldProperty(this, getChronology().weekyear());
+    public ReadWritableInstantFieldProperty weekyear() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().weekyear());
     }
 
     /**
@@ -969,8 +969,8 @@ public MutableDateTimeFieldProperty weekyear() {
      * 
      * @return the month of year property
      */
-    public MutableDateTimeFieldProperty monthOfYear() {
-        return new MutableDateTimeFieldProperty(this, getChronology().monthOfYear());
+    public ReadWritableInstantFieldProperty monthOfYear() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().monthOfYear());
     }
 
     /**
@@ -978,8 +978,8 @@ public MutableDateTimeFieldProperty monthOfYear() {
      * 
      * @return the week of a week based year property
      */
-    public MutableDateTimeFieldProperty weekOfWeekyear() {
-        return new MutableDateTimeFieldProperty(this, getChronology().weekOfWeekyear());
+    public ReadWritableInstantFieldProperty weekOfWeekyear() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().weekOfWeekyear());
     }
 
     /**
@@ -987,8 +987,8 @@ public MutableDateTimeFieldProperty weekOfWeekyear() {
      * 
      * @return the day of year property
      */
-    public MutableDateTimeFieldProperty dayOfYear() {
-        return new MutableDateTimeFieldProperty(this, getChronology().dayOfYear());
+    public ReadWritableInstantFieldProperty dayOfYear() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().dayOfYear());
     }
 
     /**
@@ -998,8 +998,8 @@ public MutableDateTimeFieldProperty dayOfYear() {
      * 
      * @return the day of month property
      */
-    public MutableDateTimeFieldProperty dayOfMonth() {
-        return new MutableDateTimeFieldProperty(this, getChronology().dayOfMonth());
+    public ReadWritableInstantFieldProperty dayOfMonth() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().dayOfMonth());
     }
 
     /**
@@ -1009,8 +1009,8 @@ public MutableDateTimeFieldProperty dayOfMonth() {
      * 
      * @return the day of week property
      */
-    public MutableDateTimeFieldProperty dayOfWeek() {
-        return new MutableDateTimeFieldProperty(this, getChronology().dayOfWeek());
+    public ReadWritableInstantFieldProperty dayOfWeek() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().dayOfWeek());
     }
 
     // Time properties
@@ -1020,8 +1020,8 @@ public MutableDateTimeFieldProperty dayOfWeek() {
      * 
      * @return the hour of day property
      */
-    public MutableDateTimeFieldProperty hourOfDay() {
-        return new MutableDateTimeFieldProperty(this, getChronology().hourOfDay());
+    public ReadWritableInstantFieldProperty hourOfDay() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().hourOfDay());
     }
 
     /**
@@ -1029,8 +1029,8 @@ public MutableDateTimeFieldProperty hourOfDay() {
      * 
      * @return the minute of day property
      */
-    public MutableDateTimeFieldProperty minuteOfDay() {
-        return new MutableDateTimeFieldProperty(this, getChronology().minuteOfDay());
+    public ReadWritableInstantFieldProperty minuteOfDay() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().minuteOfDay());
     }
 
     /**
@@ -1038,8 +1038,8 @@ public MutableDateTimeFieldProperty minuteOfDay() {
      * 
      * @return the minute of hour property
      */
-    public MutableDateTimeFieldProperty minuteOfHour() {
-        return new MutableDateTimeFieldProperty(this, getChronology().minuteOfHour());
+    public ReadWritableInstantFieldProperty minuteOfHour() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().minuteOfHour());
     }
 
     /**
@@ -1047,8 +1047,8 @@ public MutableDateTimeFieldProperty minuteOfHour() {
      * 
      * @return the second of day property
      */
-    public MutableDateTimeFieldProperty secondOfDay() {
-        return new MutableDateTimeFieldProperty(this, getChronology().secondOfDay());
+    public ReadWritableInstantFieldProperty secondOfDay() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().secondOfDay());
     }
 
     /**
@@ -1056,8 +1056,8 @@ public MutableDateTimeFieldProperty secondOfDay() {
      * 
      * @return the second of minute property
      */
-    public MutableDateTimeFieldProperty secondOfMinute() {
-        return new MutableDateTimeFieldProperty(this, getChronology().secondOfMinute());
+    public ReadWritableInstantFieldProperty secondOfMinute() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().secondOfMinute());
     }
 
     /**
@@ -1065,8 +1065,8 @@ public MutableDateTimeFieldProperty secondOfMinute() {
      * 
      * @return the millis of day property
      */
-    public MutableDateTimeFieldProperty millisOfDay() {
-        return new MutableDateTimeFieldProperty(this, getChronology().millisOfDay());
+    public ReadWritableInstantFieldProperty millisOfDay() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().millisOfDay());
     }
 
     /**
@@ -1074,8 +1074,8 @@ public MutableDateTimeFieldProperty millisOfDay() {
      * 
      * @return the millis of second property
      */
-    public MutableDateTimeFieldProperty millisOfSecond() {
-        return new MutableDateTimeFieldProperty(this, getChronology().millisOfSecond());
+    public ReadWritableInstantFieldProperty millisOfSecond() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().millisOfSecond());
     }
 
     // Misc
diff --git a/JodaTime/src/java/org/joda/time/MutableTimeOnly.java b/JodaTime/src/java/org/joda/time/MutableTimeOnly.java
index 5a344067f..58d3831fd 100644
--- a/JodaTime/src/java/org/joda/time/MutableTimeOnly.java
+++ b/JodaTime/src/java/org/joda/time/MutableTimeOnly.java
@@ -59,7 +59,7 @@
 import org.joda.time.convert.ConverterManager;
 import org.joda.time.convert.DurationConverter;
 import org.joda.time.format.ISODateTimeFormat;
-import org.joda.time.property.MutableDateTimeFieldProperty;
+import org.joda.time.property.ReadWritableInstantFieldProperty;
 
 /**
  * MutableTimeOnly is the basic implementation of a modifiable time only class.
@@ -734,8 +734,8 @@ public void setTime(
      * 
      * @return the hour of day property
      */
-    public final MutableDateTimeFieldProperty hourOfDay() {
-        return new MutableDateTimeFieldProperty(this, getChronology().hourOfDay());
+    public final ReadWritableInstantFieldProperty hourOfDay() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().hourOfDay());
     }
 
     /**
@@ -743,8 +743,8 @@ public final MutableDateTimeFieldProperty hourOfDay() {
      * 
      * @return the clockhour of day property
      */
-    public final MutableDateTimeFieldProperty clockhourOfDay() {
-        return new MutableDateTimeFieldProperty(this, getChronology().clockhourOfDay());
+    public final ReadWritableInstantFieldProperty clockhourOfDay() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().clockhourOfDay());
     }
 
     /**
@@ -752,8 +752,8 @@ public final MutableDateTimeFieldProperty clockhourOfDay() {
      * 
      * @return the hour of halfday property
      */
-    public final MutableDateTimeFieldProperty hourOfHalfday() {
-        return new MutableDateTimeFieldProperty(this, getChronology().hourOfHalfday());
+    public final ReadWritableInstantFieldProperty hourOfHalfday() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().hourOfHalfday());
     }
 
     /**
@@ -761,8 +761,8 @@ public final MutableDateTimeFieldProperty hourOfHalfday() {
      * 
      * @return the clockhour of halfday property
      */
-    public final MutableDateTimeFieldProperty clockhourOfHalfday() {
-        return new MutableDateTimeFieldProperty(this, getChronology().clockhourOfHalfday());
+    public final ReadWritableInstantFieldProperty clockhourOfHalfday() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().clockhourOfHalfday());
     }
 
     /**
@@ -770,8 +770,8 @@ public final MutableDateTimeFieldProperty clockhourOfHalfday() {
      * 
      * @return the halfday of day property
      */
-    public final MutableDateTimeFieldProperty halfdayOfDay() {
-        return new MutableDateTimeFieldProperty(this, getChronology().halfdayOfDay());
+    public final ReadWritableInstantFieldProperty halfdayOfDay() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().halfdayOfDay());
     }
 
     /**
@@ -779,8 +779,8 @@ public final MutableDateTimeFieldProperty halfdayOfDay() {
      * 
      * @return the minute of day property
      */
-    public final MutableDateTimeFieldProperty minuteOfDay() {
-        return new MutableDateTimeFieldProperty(this, getChronology().minuteOfDay());
+    public final ReadWritableInstantFieldProperty minuteOfDay() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().minuteOfDay());
     }
 
     /**
@@ -788,8 +788,8 @@ public final MutableDateTimeFieldProperty minuteOfDay() {
      * 
      * @return the minute of hour property
      */
-    public final MutableDateTimeFieldProperty minuteOfHour() {
-        return new MutableDateTimeFieldProperty(this, getChronology().minuteOfHour());
+    public final ReadWritableInstantFieldProperty minuteOfHour() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().minuteOfHour());
     }
 
     /**
@@ -797,8 +797,8 @@ public final MutableDateTimeFieldProperty minuteOfHour() {
      * 
      * @return the second of day property
      */
-    public final MutableDateTimeFieldProperty secondOfDay() {
-        return new MutableDateTimeFieldProperty(this, getChronology().secondOfDay());
+    public final ReadWritableInstantFieldProperty secondOfDay() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().secondOfDay());
     }
 
     /**
@@ -806,8 +806,8 @@ public final MutableDateTimeFieldProperty secondOfDay() {
      * 
      * @return the second of minute property
      */
-    public final MutableDateTimeFieldProperty secondOfMinute() {
-        return new MutableDateTimeFieldProperty(this, getChronology().secondOfMinute());
+    public final ReadWritableInstantFieldProperty secondOfMinute() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().secondOfMinute());
     }
 
     /**
@@ -815,8 +815,8 @@ public final MutableDateTimeFieldProperty secondOfMinute() {
      * 
      * @return the millis of day property
      */
-    public final MutableDateTimeFieldProperty millisOfDay() {
-        return new MutableDateTimeFieldProperty(this, getChronology().millisOfDay());
+    public final ReadWritableInstantFieldProperty millisOfDay() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().millisOfDay());
     }
 
     /**
@@ -824,8 +824,8 @@ public final MutableDateTimeFieldProperty millisOfDay() {
      * 
      * @return the millis of second property
      */
-    public final MutableDateTimeFieldProperty millisOfSecond() {
-        return new MutableDateTimeFieldProperty(this, getChronology().millisOfSecond());
+    public final ReadWritableInstantFieldProperty millisOfSecond() {
+        return new ReadWritableInstantFieldProperty(this, getChronology().millisOfSecond());
     }
 
     // Misc

From 7f40c2c885cc3258933223397cc03d8704290120 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 4 Jan 2004 21:22:53 +0000
Subject: [PATCH 098/143] Bug fixes in set matching parse.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@103 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../time/format/DateTimeFormatterBuilder.java | 76 +++++++++----------
 1 file changed, 35 insertions(+), 41 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
index 81f466292..58e33b948 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
@@ -335,8 +335,10 @@ public DateTimeFormatterBuilder append(final DateTimePrinter printer,
         }
         int length = parsers.length;
         if (length == 1) {
-            // If the last element is null, an exception is still thrown.
-            return append(printer, parsers[0]);
+            if (parsers[0] == null) {
+                throw new IllegalArgumentException("No parser supplied");
+            }
+            return append0(printer, parsers[0]);
         }
 
         DateTimeParser[] copyOfParsers = new DateTimeParser[length];
@@ -1999,69 +2001,61 @@ public int estimateParsedLength() {
             return iParsedLengthEstimate;
         }
 
-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
+        public int parseInto(final DateTimeParserBucket bucket, final String text, final int position) {
             DateTimeParser[] parsers = iParsers;
             int length = parsers.length;
 
-            Object state = bucket.saveState();
-            
-            int bestInvalidPos = position;
-            int bestInvalidParser = 0;
+            final Object originalState = bucket.saveState();
+            boolean isOptional = false;
+
             int bestValidPos = position;
-            int bestValidParser = 0;
+            Object bestValidState = null;
 
-            for (int i=0; i<length; i++) {
-                if (i != 0) {
-                    bucket.undoChanges(state);
-                }
+            int bestInvalidPos = position;
 
+            for (int i=0; i<length; i++) {
                 DateTimeParser parser = parsers[i];
                 if (parser == null) {
                     // The empty parser wins only if nothing is better.
-                    if (bestValidPos > position) {
-                        break;
+                    if (bestValidPos <= position) {
+                        return position;
                     }
-                    return position;
+                    isOptional = true;
+                    break;
                 }
-
                 int parsePos = parser.parseInto(bucket, text, position);
                 if (parsePos >= position) {
-                    if (parsePos >= text.length()) {
-                        return parsePos;
-                    }
                     if (parsePos > bestValidPos) {
+                        if (parsePos >= text.length() ||
+                            (i + 1) >= length || parsers[i + 1] == null) {
+
+                            // Completely parsed text or no more parsers to
+                            // check. Skip the rest.
+                            return parsePos;
+                        }
                         bestValidPos = parsePos;
-                        bestValidParser = i;
+                        bestValidState = bucket.saveState();
                     }
                 } else {
-                    parsePos = ~parsePos;
-                    if (parsePos > bestInvalidPos) {
-                        bestInvalidPos = parsePos;
-                        bestInvalidParser = i;
+                    bucket.undoChanges(originalState);
+                    if (parsePos < 0) {
+                        parsePos = ~parsePos;
+                        if (parsePos > bestInvalidPos) {
+                            bestInvalidPos = parsePos;
+                        }
                     }
                 }
             }
 
-            if (bestValidPos > position) {
-                if (bestValidParser == length - 1) {
-                    // The best valid parser was the last one, so the bucket is
-                    // already in the best state.
-                    return bestValidPos;
+            if (bestValidPos > position || (bestValidPos == position && isOptional)) {
+                // Restore the state to the best valid parse.
+                if (bestValidState != null) {
+                    bucket.undoChanges(bestValidState);
                 }
-                bucket.undoChanges(state);
-                // Call best valid parser again to restore bucket state.
-                return parsers[bestValidParser].parseInto(bucket, text, position);
-            }
-
-            if (bestInvalidParser == length - 1) {
-                // The best invalid parser was the last one, so the bucket is
-                // already in the best state.
-                return ~bestInvalidPos;
+                return bestValidPos;
             }
 
-            bucket.undoChanges(state);
-            // Call best invalid parser again to restore bucket state.
-            return parsers[bestInvalidParser].parseInto(bucket, text, position);
+            return ~bestInvalidPos;
         }
     }
 }

From 8c56f7b1b1ffa684f0ef134559f6a15e9584e8c0 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 4 Jan 2004 21:28:37 +0000
Subject: [PATCH 099/143] Fix column name.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@104 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/example/org/joda/example/time/DateTimeBrowser.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/JodaTime/src/example/org/joda/example/time/DateTimeBrowser.java b/JodaTime/src/example/org/joda/example/time/DateTimeBrowser.java
index a06a5d82f..b62e7b792 100644
--- a/JodaTime/src/example/org/joda/example/time/DateTimeBrowser.java
+++ b/JodaTime/src/example/org/joda/example/time/DateTimeBrowser.java
@@ -653,7 +653,7 @@ private void validateFile(String fileName) {
                 "DayOfMon",
                 "DayOfYr",
                 "WeekOfWY",
-                "YearOfWY",
+                "Weekyear",
                 "MonOfYr",
                 "Year"
             };

From fa85e52f102ba75426ebf3bb49533009235ee3e0 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Mon, 5 Jan 2004 03:36:01 +0000
Subject: [PATCH 100/143] Reduced temporary object allocations during parse.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@105 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../time/format/DateTimeParserBucket.java     | 65 ++++++++++++++-----
 1 file changed, 48 insertions(+), 17 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java b/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java
index 30e3f4210..6f6a11056 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java
@@ -53,7 +53,6 @@
  */
 package org.joda.time.format;
 
-import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Locale;
 
@@ -76,7 +75,11 @@
     DateTimeZone iZone;
     int iOffset;
 
-    ArrayList iSavedFields = new ArrayList();
+    SavedField[] iSavedFields = new SavedField[8];
+    int iSavedFieldsCount;
+    boolean iSavedFieldsShared;
+
+    private Object iSavedState;
 
     /**
      * @param instantLocal the initial millis from 1970-01-01T00:00:00, local time
@@ -100,6 +103,7 @@ public DateTimeZone getDateTimeZone() {
      * @param zone the date time zone to operate in, or null if UTC
      */
     public void setDateTimeZone(DateTimeZone zone) {
+        iSavedState = null;
         iZone = zone == DateTimeZone.UTC ? null : zone;
         iOffset = 0;
     }
@@ -117,6 +121,7 @@ public int getOffset() {
      * overrides the time zone.
      */
     public void setOffset(int offset) {
+        iSavedState = null;
         iOffset = offset;
         iZone = null;
     }
@@ -125,14 +130,33 @@ public void setOffset(int offset) {
      * Saves a datetime field value.
      */
     public void saveField(DateTimeField field, int value) {
-        iSavedFields.add(new SavedField(field, value));
+        saveField(new SavedField(field, value));
     }
 
     /**
      * Saves a datetime field text value.
      */
     public void saveField(DateTimeField field, String text, Locale locale) {
-        iSavedFields.add(new SavedField(field, text, locale));
+        saveField(new SavedField(field, text, locale));
+    }
+
+    private void saveField(SavedField field) {
+        SavedField[] savedFields = iSavedFields;
+        int savedFieldsCount = iSavedFieldsCount;
+
+        if (savedFieldsCount == savedFields.length) {
+            SavedField[] newArray = new SavedField[savedFieldsCount * 2];
+            System.arraycopy(savedFields, 0, newArray, 0, savedFieldsCount);
+            iSavedFields = savedFields = newArray;
+            iSavedFieldsShared = false;
+        } else if (iSavedFieldsShared) {
+            iSavedFields = savedFields = (SavedField[])savedFields.clone();
+            iSavedFieldsShared = false;
+        }
+
+        iSavedState = null;
+        savedFields[savedFieldsCount] = field;
+        iSavedFieldsCount = savedFieldsCount + 1;
     }
 
     /**
@@ -143,9 +167,10 @@ public void saveField(DateTimeField field, String text, Locale locale) {
      * @return opaque saved state, which may be passed to undoChanges
      */
     public Object saveState() {
-        Object state = new SavedState();
-        iSavedFields = (ArrayList)iSavedFields.clone();
-        return state;
+        if (iSavedState == null) {
+            iSavedState = new SavedState();
+        }
+        return iSavedState;
     }
 
     /**
@@ -161,27 +186,28 @@ public Object saveState() {
      */
     public boolean undoChanges(Object savedState) {
         if (savedState instanceof SavedState) {
-            return ((SavedState)savedState).revertState(this);
+            if (((SavedState)savedState).revertState(this)) {
+                iSavedState = savedState;
+                return true;
+            }
         }
         return false;
     }
 
     /**
-     * Computes the parsed datetime by setting the saved fields.
-     * Calling this method does not affect the state of this object.
+     * Computes the parsed datetime by setting the saved fields. This method is
+     * idempotent, but it is not thread-safe.
      *
      * @return milliseconds since 1970-01-01T00:00:00Z
      * @throws IllegalArgumentException if any field is out of range
      */
     public long computeMillis() {
-        int length = iSavedFields.size();
-        SavedField[] savedFields = new SavedField[length];
-        iSavedFields.toArray(savedFields);
-
-        Arrays.sort(savedFields);
+        SavedField[] savedFields = iSavedFields;
+        int count = iSavedFieldsCount;
+        Arrays.sort(savedFields, 0, count);
 
         long millis = iMillis;
-        for (int i=0; i<length; i++) {
+        for (int i=0; i<count; i++) {
             millis = savedFields[i].set(millis);
         }
 
@@ -263,12 +289,15 @@ private int compareReverse(Comparable a, Comparable b) {
     private class SavedState {
         final DateTimeZone iZone;
         final int iOffset;
-        final ArrayList iSavedFields;
+        final SavedField[] iSavedFields;
+        final int iSavedFieldsCount;
 
         SavedState() {
             this.iZone = DateTimeParserBucket.this.iZone;
             this.iOffset = DateTimeParserBucket.this.iOffset;
             this.iSavedFields = DateTimeParserBucket.this.iSavedFields;
+            this.iSavedFieldsCount = DateTimeParserBucket.this.iSavedFieldsCount;
+            DateTimeParserBucket.this.iSavedFieldsShared = true;
         }
 
         boolean revertState(DateTimeParserBucket enclosing) {
@@ -278,6 +307,8 @@ boolean revertState(DateTimeParserBucket enclosing) {
             DateTimeParserBucket.this.iZone = this.iZone;
             DateTimeParserBucket.this.iOffset = this.iOffset;
             DateTimeParserBucket.this.iSavedFields = this.iSavedFields;
+            DateTimeParserBucket.this.iSavedFieldsCount = this.iSavedFieldsCount;
+            DateTimeParserBucket.this.iSavedFieldsShared = true;
             return true;
         }
     }

From 4d08164b8dcd0fd8cd02e6c6a64cfedf56636aee Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Mon, 5 Jan 2004 06:51:56 +0000
Subject: [PATCH 101/143] More performance improvements due to less object
 allocation.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@106 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../time/format/DateTimeParserBucket.java     | 60 +++++++++++++++----
 1 file changed, 48 insertions(+), 12 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java b/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java
index 6f6a11056..4bb75d789 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java
@@ -144,14 +144,13 @@ private void saveField(SavedField field) {
         SavedField[] savedFields = iSavedFields;
         int savedFieldsCount = iSavedFieldsCount;
 
-        if (savedFieldsCount == savedFields.length) {
-            SavedField[] newArray = new SavedField[savedFieldsCount * 2];
+        if (savedFieldsCount == savedFields.length || iSavedFieldsShared) {
+            // Expand capacity or merely copy if saved fields are shared.
+            SavedField[] newArray = new SavedField
+                [savedFieldsCount == savedFields.length ? savedFieldsCount * 2 : savedFields.length];
             System.arraycopy(savedFields, 0, newArray, 0, savedFieldsCount);
             iSavedFields = savedFields = newArray;
             iSavedFieldsShared = false;
-        } else if (iSavedFieldsShared) {
-            iSavedFields = savedFields = (SavedField[])savedFields.clone();
-            iSavedFieldsShared = false;
         }
 
         iSavedState = null;
@@ -204,7 +203,7 @@ public boolean undoChanges(Object savedState) {
     public long computeMillis() {
         SavedField[] savedFields = iSavedFields;
         int count = iSavedFieldsCount;
-        Arrays.sort(savedFields, 0, count);
+        sort(savedFields, count);
 
         long millis = iMillis;
         for (int i=0; i<count; i++) {
@@ -225,6 +224,38 @@ public long computeMillis() {
         return millis;
     }
 
+    /**
+     * Sorts elements [0,high). Calling java.util.Arrays isn't always the right
+     * choice since it always creates an internal copy of the array, even if it
+     * doesn't need to. If the array slice is small enough, an insertion sort
+     * is chosen instead, but it doesn't need a copy!
+     * <p>
+     * This method has a modified version of that insertion sort, except it
+     * doesn't create an unnecessary array copy. If high is over 10, then
+     * java.util.Arrays is called, which will perform a merge sort, which is
+     * faster than insertion sort on large lists.
+     * <p>
+     * The end result is much greater performace when computeMillis is called.
+     * Since the amount of saved fields is small, the insertion sort is a
+     * better choice. Additional performance is gained since there is no extra
+     * array allocation and copying. Also, the insertion sort here does not
+     * perform any casting operations. The version in java.util.Arrays performs
+     * casts within the insertion sort loop.
+     */
+    private static void sort(Comparable[] array, int high) {
+        if (high > 10) {
+            Arrays.sort(array, 0, high);
+        } else {
+            for (int i=0; i<high; i++) {
+                for (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {
+                    Comparable t = array[j];
+                    array[j] = array[j-1];
+                    array[j-1] = t;
+                }
+            }
+        }
+    }
+
     private static class SavedField implements Comparable {
         final DateTimeField iField;
         final int iValue;
@@ -297,18 +328,23 @@ private int compareReverse(Comparable a, Comparable b) {
             this.iOffset = DateTimeParserBucket.this.iOffset;
             this.iSavedFields = DateTimeParserBucket.this.iSavedFields;
             this.iSavedFieldsCount = DateTimeParserBucket.this.iSavedFieldsCount;
-            DateTimeParserBucket.this.iSavedFieldsShared = true;
         }
 
         boolean revertState(DateTimeParserBucket enclosing) {
             if (enclosing != DateTimeParserBucket.this) {
                 return false;
             }
-            DateTimeParserBucket.this.iZone = this.iZone;
-            DateTimeParserBucket.this.iOffset = this.iOffset;
-            DateTimeParserBucket.this.iSavedFields = this.iSavedFields;
-            DateTimeParserBucket.this.iSavedFieldsCount = this.iSavedFieldsCount;
-            DateTimeParserBucket.this.iSavedFieldsShared = true;
+            enclosing.iZone = this.iZone;
+            enclosing.iOffset = this.iOffset;
+            enclosing.iSavedFields = this.iSavedFields;
+            if (this.iSavedFieldsCount < enclosing.iSavedFieldsCount) {
+                // Since count is being restored to a lower count, the
+                // potential exists for new saved fields to destroy data being
+                // shared by another state. Set this flag such that the array
+                // of saved fields is cloned prior to modification.
+                enclosing.iSavedFieldsShared = true;
+            }
+            enclosing.iSavedFieldsCount = this.iSavedFieldsCount;
             return true;
         }
     }

From 38a5d1cc42eb1008792144823c1a44a9324a754c Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Mon, 5 Jan 2004 06:53:29 +0000
Subject: [PATCH 102/143] Fewer substrings created during integer parsing,
 resulting in performance improvements.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@107 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../time/format/DateTimeFormatterBuilder.java | 33 ++++++++---------
 .../time/format/DurationFormatterBuilder.java | 37 +++++++++----------
 2 files changed, 34 insertions(+), 36 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
index 58e33b948..b79e1f0c5 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
@@ -1095,29 +1095,28 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
             }
 
             int value;
-            if (length == 3 && negative) {
-                value = -FormatUtils.parseTwoDigits(text, position + 1);
-            } else if (length == 2) {
+            if (length >= 9) {
+                // Since value may exceed max, use stock parser which checks
+                // for this.
+                value = Integer.parseInt
+                    (text.substring(position, position += length));
+            } else {
+                int i = position;
                 if (negative) {
-                    value = text.charAt(position + 1) - '0';
-                    value = -value;
-                } else {
-                    value = FormatUtils.parseTwoDigits(text, position);
+                    i++;
                 }
-            } else if (length == 1 && !negative) {
-                value = text.charAt(position) - '0';
-            } else {
-                String sub = text.substring(position, position + length);
-                try {
-                    value = Integer.parseInt(sub);
-                } catch (NumberFormatException e) {
-                    return ~position;
+                value = text.charAt(i++) - '0';
+                position += length;
+                while (i < position) {
+                    value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';
+                }
+                if (negative) {
+                    value = -value;
                 }
             }
 
             bucket.saveField(iField, value);
-
-            return position + length;
+            return position;
         }
     }
 
diff --git a/JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java b/JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java
index 99a3fb9f6..9fe5eba3a 100644
--- a/JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java
+++ b/JodaTime/src/java/org/joda/time/format/DurationFormatterBuilder.java
@@ -1022,33 +1022,32 @@ public int parseInto(ReadWritableDuration duration,
             }
 
             int value;
-            if (length == 3 && negative) {
-                value = -FormatUtils.parseTwoDigits(text, position + 1);
-            } else if (length == 2) {
+            if (length >= 9) {
+                // Since value may exceed max, use stock parser which checks
+                // for this.
+                value = Integer.parseInt
+                    (text.substring(position, position += length));
+            } else {
+                int i = position;
                 if (negative) {
-                    value = text.charAt(position + 1) - '0';
-                    value = -value;
-                } else {
-                    value = FormatUtils.parseTwoDigits(text, position);
+                    i++;
                 }
-            } else if (length == 1 && !negative) {
-                value = text.charAt(position) - '0';
-            } else {
-                String sub = text.substring(position, position + length);
-                try {
-                    value = Integer.parseInt(sub);
-                } catch (NumberFormatException e) {
-                    return ~position;
+                value = text.charAt(i++) - '0';
+                position += length;
+                while (i < position) {
+                    value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';
+                }
+                if (negative) {
+                    value = -value;
                 }
             }
-
+            
             setFieldValue(duration, value);
-            position += length;
-
+                
             if (position >= 0 && iSuffix != null) {
                 position = iSuffix.parse(text, position);
             }
-
+                
             return position;
         }
 

From 3a68a02d6b0359e623858ab9391f84afdb17052a Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Tue, 6 Jan 2004 18:10:50 +0000
Subject: [PATCH 103/143] Expanded documentation.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@108 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../time/format/DateTimeParserBucket.java     | 24 ++++++++++++-------
 1 file changed, 16 insertions(+), 8 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java b/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java
index 4bb75d789..43c9c364d 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java
@@ -60,8 +60,19 @@
 import org.joda.time.DateTimeZone;
 
 /**
- * Allows fields to be saved in any order, but physically set in a consistent
- * order.
+ * Allows fields to be saved in any order, but be physically set in a
+ * consistent order. This is useful for parsing against formats that allow
+ * field values to contradict each other.
+ * <p>
+ * Field values are applied in an order where the "larger" fields are set
+ * first, making their value less likely to stick.  A field is larger than
+ * another when it's range duration is longer. If both ranges are the same,
+ * then the larger field has the longer duration. If it cannot be determined
+ * which field is larger, then the fields are set in the order they were saved.
+ * <p>
+ * For example, these fields were saved in this order: dayOfWeek, monthOfYear,
+ * dayOfMonth, dayOfYear. When computeMillis is called, the fields are set in
+ * this order: monthOfYear, dayOfYear, dayOfMonth, dayOfWeek.
  * <p>
  * DateTimeParserBucket is mutable and not thread-safe.
  *
@@ -285,12 +296,9 @@ long set(long millis) {
         }
 
         /**
-         * The field with the larger range is ordered first, where null is
-         * considered infinite. If the ranges match, then the field with the
-         * larger unit is ordered first. This ordering casues "smaller" fields
-         * to be set last, and thus their value sticks. For example, dayOfMonth
-         * takes precedence over monthOfYear, and dayOfWeek takes precedence
-         * over dayOfMonth.
+         * The field with the longer range duration is ordered first, where
+         * null is considered infinite. If the ranges match, then the field
+         * with the longer duration is ordered first.
          */
         public int compareTo(Object obj) {
             DateTimeField other = ((SavedField)obj).iField;

From 5f54fda829b4c96cf3d009f4e9a0b5f9659565d5 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Thu, 8 Jan 2004 06:23:16 +0000
Subject: [PATCH 104/143] Time zone offset parser supports fractional seconds
 leading with comma.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@109 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/format/DateTimeFormatterBuilder.java | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
index b79e1f0c5..8803f43e3 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
@@ -1096,8 +1096,8 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
 
             int value;
             if (length >= 9) {
-                // Since value may exceed max, use stock parser which checks
-                // for this.
+                // Since value may exceed integer limits, use stock parser
+                // which checks for this.
                 value = Integer.parseInt
                     (text.substring(position, position += length));
             } else {
@@ -1762,7 +1762,7 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
                 }
 
                 if (expectSeparators) {
-                    if (text.charAt(position) != '.') {
+                    if (text.charAt(position) != '.' && text.charAt(position) != ',') {
                         break parse;
                     }
                     limit--;

From 0facc1d24b002b04be706b8bc826b1423f5a78b1 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Thu, 8 Jan 2004 06:24:59 +0000
Subject: [PATCH 105/143] Extended time zone offset precision, ensuring that
 for Joda, all instants converted to strings can be parsed back into the exact
 same instant.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@110 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/format/ISODateTimeFormat.java  | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
index 4e5280fb1..d4ffffdde 100644
--- a/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
+++ b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
@@ -212,7 +212,7 @@ private ISODateTimeFormat(final Chronology chrono) {
      * std-date-element  = yyyy ['-' MM ['-' dd]]
      * ord-date-element  = yyyy ['-' DDD]
      * week-date-element = xxxx '-W' ww ['-' e]
-     * offset            = 'Z' | (('+' | '-') HH ':' mm)
+     * offset            = 'Z' | (('+' | '-') HH [':' mm [':' ss [('.' | ',') SSS]]])
      * </pre>
      */
     public DateTimeParser dateParser() {
@@ -275,7 +275,7 @@ public DateTimeParser dateElementParser() {
      * minute-element = ':' mm [second-element] | [fraction]
      * second-element = ':' ss [fraction]
      * fraction       = ('.' | ',') digit+
-     * offset         = 'Z' | (('+' | '-') HH ':' mm)
+     * offset         = 'Z' | (('+' | '-') HH [':' mm [':' ss [('.' | ',') SSS]]])
      * </pre>
      */
     public DateTimeParser timeParser() {
@@ -369,7 +369,7 @@ public DateTimeParser timeElementParser() {
      * minute-element    = ':' mm [second-element] | [fraction]
      * second-element    = ':' ss [fraction]
      * fraction          = ('.' | ',') digit+
-     * offset            = 'Z' | (('+' | '-') HH ':' mm)
+     * offset            = 'Z' | (('+' | '-') HH [':' mm [':' ss [('.' | ',') SSS]]])
      * </pre>
      */
     public DateTimeParser dateTimeParser() {
@@ -845,7 +845,7 @@ private DateTimeFormatter fractionElement() {
     private DateTimeFormatter offsetElement() {
         if (ze == null) {
             ze = new DateTimeFormatterBuilder(iChrono)
-                .appendTimeZoneOffset("Z", true, 2, 2)
+                .appendTimeZoneOffset("Z", true, 2, 4)
                 .toFormatter();
         }
         return ze;

From 548b2fb362bb0a240b89cb0d036c1068cd68b650 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Fri, 9 Jan 2004 05:20:35 +0000
Subject: [PATCH 106/143] Can't use strictfp, need jre1.2 compatibility.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@111 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/format/FormatUtils.java    | 15 +++++++--------
 1 file changed, 7 insertions(+), 8 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/format/FormatUtils.java b/JodaTime/src/java/org/joda/time/format/FormatUtils.java
index 9630331e8..196bfb478 100644
--- a/JodaTime/src/java/org/joda/time/format/FormatUtils.java
+++ b/JodaTime/src/java/org/joda/time/format/FormatUtils.java
@@ -63,9 +63,8 @@
  *
  * @author Brian S O'Neill
  */
-// Note: Use strictfp and StrictMath to ensure consistent results on all VMs.
-public strictfp class FormatUtils {
-    private static final double LOG_10 = StrictMath.log(10);
+public class FormatUtils {
+    private static final double LOG_10 = Math.log(10);
 
     private FormatUtils() {
     }
@@ -111,7 +110,7 @@ public static void appendPaddedInteger(StringBuffer buf, int value, int size) {
             } else if (value < 10000) {
                 digits = 4;
             } else {
-                digits = (int)(StrictMath.log(value) / LOG_10) + 1;
+                digits = (int)(Math.log(value) / LOG_10) + 1;
             }
             for (; size > digits; size--) {
                 buf.append('0');
@@ -149,7 +148,7 @@ public static void appendPaddedInteger(StringBuffer buf, long value, int size) {
                     return;
                 }
             }
-            int digits = (int)(StrictMath.log(value) / LOG_10) + 1;
+            int digits = (int)(Math.log(value) / LOG_10) + 1;
             for (; size > digits; size--) {
                 buf.append('0');
             }
@@ -200,7 +199,7 @@ public static void writePaddedInteger(Writer out, int value, int size)
             } else if (value < 10000) {
                 digits = 4;
             } else {
-                digits = (int)(StrictMath.log(value) / LOG_10) + 1;
+                digits = (int)(Math.log(value) / LOG_10) + 1;
             }
             for (; size > digits; size--) {
                 out.write('0');
@@ -240,7 +239,7 @@ public static void writePaddedInteger(Writer out, long value, int size)
                     return;
                 }
             }
-            int digits = (int)(StrictMath.log(value) / LOG_10) + 1;
+            int digits = (int)(Math.log(value) / LOG_10) + 1;
             for (; size > digits; size--) {
                 out.write('0');
             }
@@ -359,7 +358,7 @@ public static int calculateDigitCount(int value) {
              (value < 100 ? 2 :
               (value < 1000 ? 3 :
                (value < 10000 ? 4 :
-                ((int)(StrictMath.log(value) / LOG_10) + 1)))));
+                ((int)(Math.log(value) / LOG_10) + 1)))));
     }
 
     static int parseTwoDigits(String text, int position) {

From 265f5cc716414c87d9b0082caa91457b64550dcb Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 10 Jan 2004 03:47:19 +0000
Subject: [PATCH 107/143] Renamed toCopy methods.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@112 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/AbstractDuration.java  |  2 +-
 JodaTime/src/java/org/joda/time/DateOnly.java | 15 ++++++--------
 JodaTime/src/java/org/joda/time/DateTime.java |  8 ++------
 JodaTime/src/java/org/joda/time/Instant.java  | 15 ++++++++++++--
 .../java/org/joda/time/MutableDateOnly.java   | 10 ++++------
 .../java/org/joda/time/MutableDateTime.java   |  8 ++------
 .../java/org/joda/time/MutableTimeOnly.java   | 10 ++++------
 .../java/org/joda/time/ReadableInstant.java   | 17 +++++++++++++---
 JodaTime/src/java/org/joda/time/TimeOnly.java | 15 ++++++--------
 .../time/property/DateOnlyFieldProperty.java  | 20 +++++++++----------
 .../time/property/DateTimeFieldProperty.java  | 20 +++++++++----------
 .../time/property/TimeOnlyFieldProperty.java  | 20 +++++++++----------
 12 files changed, 82 insertions(+), 78 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/AbstractDuration.java b/JodaTime/src/java/org/joda/time/AbstractDuration.java
index d6bc4f420..160e7878b 100644
--- a/JodaTime/src/java/org/joda/time/AbstractDuration.java
+++ b/JodaTime/src/java/org/joda/time/AbstractDuration.java
@@ -496,7 +496,7 @@ private static int scaleValue(int value, int scalar) {
      * @throws ArithmeticException if the result of the calculation is too large
      */
     public final ReadableInstant addTo(ReadableInstant instant, int scalar) {
-        return instant.toCopy(addTo(instant.getMillis(), scalar));
+        return instant.withMillis(addTo(instant.getMillis(), scalar));
     }
 
     /**
diff --git a/JodaTime/src/java/org/joda/time/DateOnly.java b/JodaTime/src/java/org/joda/time/DateOnly.java
index 0698f5062..3f1feaa92 100644
--- a/JodaTime/src/java/org/joda/time/DateOnly.java
+++ b/JodaTime/src/java/org/joda/time/DateOnly.java
@@ -171,8 +171,8 @@ public DateOnly(Object instant) {
      * include ReadableInstant, String, Calendar and Date.
      *
      * @param instant  the datetime object, must not be null
-     * @param chronology  the chronology, must not be null
-     * @throws IllegalArgumentException if the date or chronology is null
+     * @param chronology  the chronology, null means ISOChronology
+     * @throws IllegalArgumentException if the chronology is null
      */
     public DateOnly(Object instant, Chronology chronology) {
         super(instant, chronology);
@@ -229,7 +229,7 @@ public DateOnly(
      * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
      * @return a copy of this instant with different millis
      */
-    public ReadableInstant toCopy(long newMillis) {
+    public ReadableInstant withMillis(long newMillis) {
         newMillis = resetUnsupportedFields(newMillis);
         return newMillis == getMillis() ? this : new DateOnly(newMillis, getChronology());
     }
@@ -243,13 +243,10 @@ public ReadableInstant toCopy(long newMillis) {
      *
      * @param newChronology  the new chronology
      * @return a copy of this instant with a different chronology
-     * @throws IllegalArgumentException if the chronology is null
      */
-    public ReadableInstant toCopy(Chronology newChronology) {
-        if (newChronology == null) {
-            throw new IllegalArgumentException("The Chronology must not be null");
-        }
-        newChronology = newChronology.withUTC();
+    public ReadableInstant withChronology(Chronology newChronology) {
+        newChronology = newChronology == null ? ISOChronology.getInstanceUTC()
+            : newChronology.withUTC();
         return newChronology == getChronology() ? this : new DateOnly(getMillis(), newChronology);
     }
 
diff --git a/JodaTime/src/java/org/joda/time/DateTime.java b/JodaTime/src/java/org/joda/time/DateTime.java
index b45db504e..c89b4a752 100644
--- a/JodaTime/src/java/org/joda/time/DateTime.java
+++ b/JodaTime/src/java/org/joda/time/DateTime.java
@@ -319,7 +319,7 @@ public DateTime(
      * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
      * @return a copy of this instant with different millis
      */
-    public ReadableInstant toCopy(long newMillis) {
+    public ReadableInstant withMillis(long newMillis) {
         return newMillis == getMillis() ? this : new DateTime(newMillis, getChronology());
     }
     
@@ -332,12 +332,8 @@ public ReadableInstant toCopy(long newMillis) {
      *
      * @param newChronology  the new chronology
      * @return a copy of this instant with a different chronology
-     * @throws IllegalArgumentException if the chronology is null
      */
-    public ReadableInstant toCopy(Chronology newChronology) {
-        if (newChronology == null) {
-            throw new IllegalArgumentException("The Chronology must not be null");
-        }
+    public ReadableInstant withChronology(Chronology newChronology) {
         return newChronology == getChronology() ? this : new DateTime(getMillis(), newChronology);
     }
     
diff --git a/JodaTime/src/java/org/joda/time/Instant.java b/JodaTime/src/java/org/joda/time/Instant.java
index 6926b9218..a61560983 100644
--- a/JodaTime/src/java/org/joda/time/Instant.java
+++ b/JodaTime/src/java/org/joda/time/Instant.java
@@ -135,7 +135,7 @@ public Instant(Object instant) {
      * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
      * @return a copy of this instant with different millis
      */
-    public ReadableInstant toCopy(long newMillis) {
+    public ReadableInstant withMillis(long newMillis) {
         return newMillis == iMillis ? this : new Instant(newMillis);
     }
     
@@ -146,10 +146,21 @@ public ReadableInstant toCopy(long newMillis) {
      * @param newChronology  ignored
      * @return this
      */
-    public ReadableInstant toCopy(Chronology newChronology) {
+    public ReadableInstant withChronology(Chronology newChronology) {
         return this;
     }
     
+    /**
+     * Since Instant does not support time zones, this method always returns
+     * <code>this</code>.
+     *
+     * @param newDateTimeZone  ignored
+     * @return this
+     */
+    public ReadableInstant withDateTimeZone(DateTimeZone newDateTimeZone) {
+        return this;
+    }
+
     // Accessors
     //-----------------------------------------------------------------------
     /**
diff --git a/JodaTime/src/java/org/joda/time/MutableDateOnly.java b/JodaTime/src/java/org/joda/time/MutableDateOnly.java
index 0633f4a5a..c368fab31 100644
--- a/JodaTime/src/java/org/joda/time/MutableDateOnly.java
+++ b/JodaTime/src/java/org/joda/time/MutableDateOnly.java
@@ -231,7 +231,7 @@ public MutableDateOnly(
      * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
      * @return a copy of this instant with different millis
      */
-    public ReadableInstant toCopy(long newMillis) {
+    public ReadableInstant withMillis(long newMillis) {
         return new MutableDateOnly(newMillis, getChronology());
     }
     
@@ -243,12 +243,10 @@ public ReadableInstant toCopy(long newMillis) {
      *
      * @param newChronology  the new chronology
      * @return a copy of this instant with a different chronology
-     * @throws IllegalArgumentException if the chronology is null
      */
-    public ReadableInstant toCopy(Chronology newChronology) {
-        if (newChronology == null) {
-            throw new IllegalArgumentException("The Chronology must not be null");
-        }
+    public ReadableInstant withChronology(Chronology newChronology) {
+        newChronology = newChronology == null ? ISOChronology.getInstanceUTC()
+            : newChronology.withUTC();
         return new MutableDateOnly(getMillis(), newChronology);
     }
 
diff --git a/JodaTime/src/java/org/joda/time/MutableDateTime.java b/JodaTime/src/java/org/joda/time/MutableDateTime.java
index daca91b91..a41db9535 100644
--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java
+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java
@@ -321,7 +321,7 @@ public MutableDateTime(
      * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
      * @return a copy of this instant with different millis
      */
-    public ReadableInstant toCopy(long newMillis) {
+    public ReadableInstant withMillis(long newMillis) {
         return new MutableDateTime(newMillis, getChronology());
     }
     
@@ -333,12 +333,8 @@ public ReadableInstant toCopy(long newMillis) {
      *
      * @param newChronology  the new chronology
      * @return a copy of this instant with a different chronology
-     * @throws IllegalArgumentException if the chronology is null
      */
-    public ReadableInstant toCopy(Chronology newChronology) {
-        if (newChronology == null) {
-            throw new IllegalArgumentException("The Chronology must not be null");
-        }
+    public ReadableInstant withChronology(Chronology newChronology) {
         return new MutableDateTime(getMillis(), newChronology);
     }
     
diff --git a/JodaTime/src/java/org/joda/time/MutableTimeOnly.java b/JodaTime/src/java/org/joda/time/MutableTimeOnly.java
index 58d3831fd..ae56ab37e 100644
--- a/JodaTime/src/java/org/joda/time/MutableTimeOnly.java
+++ b/JodaTime/src/java/org/joda/time/MutableTimeOnly.java
@@ -236,7 +236,7 @@ public MutableTimeOnly(
      * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
      * @return a copy of this instant with different millis
      */
-    public ReadableInstant toCopy(long newMillis) {
+    public ReadableInstant withMillis(long newMillis) {
         return new MutableTimeOnly(newMillis, getChronology());
     }
     
@@ -249,12 +249,10 @@ public ReadableInstant toCopy(long newMillis) {
      *
      * @param newChronology  the new chronology
      * @return a copy of this instant with a different chronology
-     * @throws IllegalArgumentException if the chronology is null
      */
-    public ReadableInstant toCopy(Chronology newChronology) {
-        if (newChronology == null) {
-            throw new IllegalArgumentException("The Chronology must not be null");
-        }
+    public ReadableInstant withChronology(Chronology newChronology) {
+        newChronology = newChronology == null ? ISOChronology.getInstanceUTC()
+            : newChronology.withUTC();
         return new MutableTimeOnly(getMillis(), newChronology);
     }
 
diff --git a/JodaTime/src/java/org/joda/time/ReadableInstant.java b/JodaTime/src/java/org/joda/time/ReadableInstant.java
index 304d7aa8f..a0bbea231 100644
--- a/JodaTime/src/java/org/joda/time/ReadableInstant.java
+++ b/JodaTime/src/java/org/joda/time/ReadableInstant.java
@@ -150,7 +150,7 @@
      * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
      * @return a copy of this instant with different millis
      */
-    ReadableInstant toCopy(long newMillis);
+    ReadableInstant withMillis(long newMillis);
     
     /**
      * Gets a copy of this instant with a different chronology.
@@ -161,10 +161,21 @@
      *
      * @param newChronology  the new chronology
      * @return a copy of this instant with a different chronology
-     * @throws IllegalArgumentException if the chronology is null
      */
-    ReadableInstant toCopy(Chronology newChronology);
+    ReadableInstant withChronology(Chronology newChronology);
     
+    /**
+     * Gets a copy of this instant with a different time zone.
+     * <p>
+     * The returned object will be a new instance of the same implementation
+     * type. Only the time zone of the chronology will change, the millis are
+     * kept. Immutable subclasses may return <code>this</code> if appropriate.
+     *
+     * @param newDateTimeZone  the new time zone
+     * @return a copy of this instant with a different time zone
+     */
+    ReadableInstant withDateTimeZone(DateTimeZone newDateTimeZone);
+
     //-----------------------------------------------------------------------
     /**
      * Get the value as a simple immutable <code>Instant</code> object.
diff --git a/JodaTime/src/java/org/joda/time/TimeOnly.java b/JodaTime/src/java/org/joda/time/TimeOnly.java
index b25009c3e..3253d00c2 100644
--- a/JodaTime/src/java/org/joda/time/TimeOnly.java
+++ b/JodaTime/src/java/org/joda/time/TimeOnly.java
@@ -171,8 +171,8 @@ public TimeOnly(Object instant) {
      * include ReadableInstant, String, Calendar and Date.
      *
      * @param instant  the datetime object, must not be null
-     * @param chronology  the chronology, must not be null
-     * @throws IllegalArgumentException if the date or chronology is null
+     * @param chronology  the chronology, null means ISOChronology
+     * @throws IllegalArgumentException if the date is null
      */
     public TimeOnly(Object instant, Chronology chronology) {
         super(instant, chronology);
@@ -233,7 +233,7 @@ public TimeOnly(
      * @param newMillis  the new millis, from 1970-01-01T00:00:00Z
      * @return a copy of this instant with different millis
      */
-    public ReadableInstant toCopy(long newMillis) {
+    public ReadableInstant withMillis(long newMillis) {
         newMillis = resetUnsupportedFields(newMillis);
         return newMillis == getMillis() ? this : new TimeOnly(newMillis, getChronology());
     }
@@ -247,13 +247,10 @@ public ReadableInstant toCopy(long newMillis) {
      *
      * @param newChronology  the new chronology
      * @return a copy of this instant with a different chronology
-     * @throws IllegalArgumentException if the chronology is null
      */
-    public ReadableInstant toCopy(Chronology newChronology) {
-        if (newChronology == null) {
-            throw new IllegalArgumentException("The Chronology must not be null");
-        }
-        newChronology = newChronology.withUTC();
+    public ReadableInstant withChronology(Chronology newChronology) {
+        newChronology = newChronology == null ? ISOChronology.getInstanceUTC()
+            : newChronology.withUTC();
         return newChronology == getChronology() ? this : new TimeOnly(getMillis(), newChronology);
     }
 
diff --git a/JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java b/JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java
index d0cb80045..284febf98 100644
--- a/JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/property/DateOnlyFieldProperty.java
@@ -151,7 +151,7 @@ public DateOnly getDateTime() {
      */
     public DateOnly addToCopy(int value) {
         DateOnly instant = iInstant;
-        return (DateOnly)instant.toCopy(iField.add(instant.getMillis(), value));
+        return (DateOnly)instant.withMillis(iField.add(instant.getMillis(), value));
     }
 
     /**
@@ -168,7 +168,7 @@ public DateOnly addToCopy(int value) {
      */
     public DateOnly addToCopy(long value) {
         DateOnly instant = iInstant;
-        return (DateOnly)instant.toCopy(iField.add(instant.getMillis(), value));
+        return (DateOnly)instant.withMillis(iField.add(instant.getMillis(), value));
     }
 
     /**
@@ -187,7 +187,7 @@ public DateOnly addToCopy(long value) {
      */
     public DateOnly addWrappedToCopy(int value) {
         DateOnly instant = iInstant;
-        return (DateOnly)instant.toCopy(iField.addWrapped(instant.getMillis(), value));
+        return (DateOnly)instant.withMillis(iField.addWrapped(instant.getMillis(), value));
     }
 
     //-----------------------------------------------------------------------
@@ -205,7 +205,7 @@ public DateOnly addWrappedToCopy(int value) {
      */
     public DateOnly setCopy(int value) {
         DateOnly instant = iInstant;
-        return (DateOnly)instant.toCopy(iField.set(instant.getMillis(), value));
+        return (DateOnly)instant.withMillis(iField.set(instant.getMillis(), value));
     }
     
     /**
@@ -223,7 +223,7 @@ public DateOnly setCopy(int value) {
      */
     public DateOnly setCopy(String text, Locale locale) {
         DateOnly instant = iInstant;
-        return (DateOnly)instant.toCopy(iField.set(instant.getMillis(), text, locale));
+        return (DateOnly)instant.withMillis(iField.set(instant.getMillis(), text, locale));
     }
 
     /**
@@ -250,7 +250,7 @@ public final DateOnly setCopy(String text) {
      */
     public DateOnly roundFloorCopy() {
         DateOnly instant = iInstant;
-        return (DateOnly)instant.toCopy(iField.roundFloor(instant.getMillis()));
+        return (DateOnly)instant.withMillis(iField.roundFloor(instant.getMillis()));
     }
 
     /**
@@ -260,7 +260,7 @@ public DateOnly roundFloorCopy() {
      */
     public DateOnly roundCeilingCopy() {
         DateOnly instant = iInstant;
-        return (DateOnly)instant.toCopy(iField.roundCeiling(instant.getMillis()));
+        return (DateOnly)instant.withMillis(iField.roundCeiling(instant.getMillis()));
     }
 
     /**
@@ -271,7 +271,7 @@ public DateOnly roundCeilingCopy() {
      */
     public DateOnly roundHalfFloorCopy() {
         DateOnly instant = iInstant;
-        return (DateOnly)instant.toCopy(iField.roundHalfFloor(instant.getMillis()));
+        return (DateOnly)instant.withMillis(iField.roundHalfFloor(instant.getMillis()));
     }
 
     /**
@@ -282,7 +282,7 @@ public DateOnly roundHalfFloorCopy() {
      */
     public DateOnly roundHalfCeilingCopy() {
         DateOnly instant = iInstant;
-        return (DateOnly)instant.toCopy(iField.roundHalfCeiling(instant.getMillis()));
+        return (DateOnly)instant.withMillis(iField.roundHalfCeiling(instant.getMillis()));
     }
 
     /**
@@ -293,7 +293,7 @@ public DateOnly roundHalfCeilingCopy() {
      */
     public DateOnly roundHalfEvenCopy() {
         DateOnly instant = iInstant;
-        return (DateOnly)instant.toCopy(iField.roundHalfEven(instant.getMillis()));
+        return (DateOnly)instant.withMillis(iField.roundHalfEven(instant.getMillis()));
     }
 
 }
diff --git a/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java b/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java
index 1e92dd482..aa29b8cab 100644
--- a/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/property/DateTimeFieldProperty.java
@@ -144,7 +144,7 @@ public ReadableInstant getInstant() {
      */
     public DateTime addToCopy(int value) {
         DateTime instant = iInstant;
-        return (DateTime)instant.toCopy(iField.add(instant.getMillis(), value));
+        return (DateTime)instant.withMillis(iField.add(instant.getMillis(), value));
     }
 
     /**
@@ -161,7 +161,7 @@ public DateTime addToCopy(int value) {
      */
     public DateTime addToCopy(long value) {
         DateTime instant = iInstant;
-        return (DateTime)instant.toCopy(iField.add(instant.getMillis(), value));
+        return (DateTime)instant.withMillis(iField.add(instant.getMillis(), value));
     }
 
     /**
@@ -180,7 +180,7 @@ public DateTime addToCopy(long value) {
      */
     public DateTime addWrappedToCopy(int value) {
         DateTime instant = iInstant;
-        return (DateTime)instant.toCopy(iField.addWrapped(instant.getMillis(), value));
+        return (DateTime)instant.withMillis(iField.addWrapped(instant.getMillis(), value));
     }
 
     //-----------------------------------------------------------------------
@@ -198,7 +198,7 @@ public DateTime addWrappedToCopy(int value) {
      */
     public DateTime setCopy(int value) {
         DateTime instant = iInstant;
-        return (DateTime)instant.toCopy(iField.set(instant.getMillis(), value));
+        return (DateTime)instant.withMillis(iField.set(instant.getMillis(), value));
     }
     
     /**
@@ -216,7 +216,7 @@ public DateTime setCopy(int value) {
      */
     public DateTime setCopy(String text, Locale locale) {
         DateTime instant = iInstant;
-        return (DateTime)instant.toCopy(iField.set(instant.getMillis(), text, locale));
+        return (DateTime)instant.withMillis(iField.set(instant.getMillis(), text, locale));
     }
 
     /**
@@ -243,7 +243,7 @@ public final DateTime setCopy(String text) {
      */
     public DateTime roundFloorCopy() {
         DateTime instant = iInstant;
-        return (DateTime)instant.toCopy(iField.roundFloor(instant.getMillis()));
+        return (DateTime)instant.withMillis(iField.roundFloor(instant.getMillis()));
     }
 
     /**
@@ -253,7 +253,7 @@ public DateTime roundFloorCopy() {
      */
     public DateTime roundCeilingCopy() {
         DateTime instant = iInstant;
-        return (DateTime)instant.toCopy(iField.roundCeiling(instant.getMillis()));
+        return (DateTime)instant.withMillis(iField.roundCeiling(instant.getMillis()));
     }
 
     /**
@@ -264,7 +264,7 @@ public DateTime roundCeilingCopy() {
      */
     public DateTime roundHalfFloorCopy() {
         DateTime instant = iInstant;
-        return (DateTime)instant.toCopy(iField.roundHalfFloor(instant.getMillis()));
+        return (DateTime)instant.withMillis(iField.roundHalfFloor(instant.getMillis()));
     }
 
     /**
@@ -275,7 +275,7 @@ public DateTime roundHalfFloorCopy() {
      */
     public DateTime roundHalfCeilingCopy() {
         DateTime instant = iInstant;
-        return (DateTime)instant.toCopy(iField.roundHalfCeiling(instant.getMillis()));
+        return (DateTime)instant.withMillis(iField.roundHalfCeiling(instant.getMillis()));
     }
 
     /**
@@ -286,7 +286,7 @@ public DateTime roundHalfCeilingCopy() {
      */
     public DateTime roundHalfEvenCopy() {
         DateTime instant = iInstant;
-        return (DateTime)instant.toCopy(iField.roundHalfEven(instant.getMillis()));
+        return (DateTime)instant.withMillis(iField.roundHalfEven(instant.getMillis()));
     }
 
 }
diff --git a/JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java b/JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java
index 6a8940fed..484b50576 100644
--- a/JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/property/TimeOnlyFieldProperty.java
@@ -151,7 +151,7 @@ public TimeOnly getDateTime() {
      */
     public TimeOnly addToCopy(int value) {
         TimeOnly instant = iInstant;
-        return (TimeOnly)instant.toCopy(iField.add(instant.getMillis(), value));
+        return (TimeOnly)instant.withMillis(iField.add(instant.getMillis(), value));
     }
 
     /**
@@ -168,7 +168,7 @@ public TimeOnly addToCopy(int value) {
      */
     public TimeOnly addToCopy(long value) {
         TimeOnly instant = iInstant;
-        return (TimeOnly)instant.toCopy(iField.add(instant.getMillis(), value));
+        return (TimeOnly)instant.withMillis(iField.add(instant.getMillis(), value));
     }
 
     /**
@@ -187,7 +187,7 @@ public TimeOnly addToCopy(long value) {
      */
     public TimeOnly addWrappedToCopy(int value) {
         TimeOnly instant = iInstant;
-        return (TimeOnly)instant.toCopy(iField.addWrapped(instant.getMillis(), value));
+        return (TimeOnly)instant.withMillis(iField.addWrapped(instant.getMillis(), value));
     }
 
     //-----------------------------------------------------------------------
@@ -205,7 +205,7 @@ public TimeOnly addWrappedToCopy(int value) {
      */
     public TimeOnly setCopy(int value) {
         TimeOnly instant = iInstant;
-        return (TimeOnly)instant.toCopy(iField.set(instant.getMillis(), value));
+        return (TimeOnly)instant.withMillis(iField.set(instant.getMillis(), value));
     }
     
     /**
@@ -223,7 +223,7 @@ public TimeOnly setCopy(int value) {
      */
     public TimeOnly setCopy(String text, Locale locale) {
         TimeOnly instant = iInstant;
-        return (TimeOnly)instant.toCopy(iField.set(instant.getMillis(), text, locale));
+        return (TimeOnly)instant.withMillis(iField.set(instant.getMillis(), text, locale));
     }
 
     /**
@@ -250,7 +250,7 @@ public final TimeOnly setCopy(String text) {
      */
     public TimeOnly roundFloorCopy() {
         TimeOnly instant = iInstant;
-        return (TimeOnly)instant.toCopy(iField.roundFloor(instant.getMillis()));
+        return (TimeOnly)instant.withMillis(iField.roundFloor(instant.getMillis()));
     }
 
     /**
@@ -260,7 +260,7 @@ public TimeOnly roundFloorCopy() {
      */
     public TimeOnly roundCeilingCopy() {
         TimeOnly instant = iInstant;
-        return (TimeOnly)instant.toCopy(iField.roundCeiling(instant.getMillis()));
+        return (TimeOnly)instant.withMillis(iField.roundCeiling(instant.getMillis()));
     }
 
     /**
@@ -271,7 +271,7 @@ public TimeOnly roundCeilingCopy() {
      */
     public TimeOnly roundHalfFloorCopy() {
         TimeOnly instant = iInstant;
-        return (TimeOnly)instant.toCopy(iField.roundHalfFloor(instant.getMillis()));
+        return (TimeOnly)instant.withMillis(iField.roundHalfFloor(instant.getMillis()));
     }
 
     /**
@@ -282,7 +282,7 @@ public TimeOnly roundHalfFloorCopy() {
      */
     public TimeOnly roundHalfCeilingCopy() {
         TimeOnly instant = iInstant;
-        return (TimeOnly)instant.toCopy(iField.roundHalfCeiling(instant.getMillis()));
+        return (TimeOnly)instant.withMillis(iField.roundHalfCeiling(instant.getMillis()));
     }
 
     /**
@@ -293,7 +293,7 @@ public TimeOnly roundHalfCeilingCopy() {
      */
     public TimeOnly roundHalfEvenCopy() {
         TimeOnly instant = iInstant;
-        return (TimeOnly)instant.toCopy(iField.roundHalfEven(instant.getMillis()));
+        return (TimeOnly)instant.withMillis(iField.roundHalfEven(instant.getMillis()));
     }
 
 }

From 6ad6d558d91d72cb3cb091c55887bde9ca93d829 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 10 Jan 2004 03:47:46 +0000
Subject: [PATCH 108/143] Added withDateTimeZone method.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@113 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/AbstractInstant.java | 17 +++++++++++++++++
 1 file changed, 17 insertions(+)

diff --git a/JodaTime/src/java/org/joda/time/AbstractInstant.java b/JodaTime/src/java/org/joda/time/AbstractInstant.java
index 3a4f40728..57d898287 100644
--- a/JodaTime/src/java/org/joda/time/AbstractInstant.java
+++ b/JodaTime/src/java/org/joda/time/AbstractInstant.java
@@ -118,6 +118,23 @@ public final int get(DateTimeField field) {
         return field.get(getMillis());
     }
 
+    /**
+     * Gets a copy of this instant with a different time zone.
+     * <p>
+     * The returned object will be a new instance of the same implementation
+     * type. Only the time zone of the chronology will change, the millis are
+     * kept. Immutable subclasses may return <code>this</code> if appropriate.
+     *
+     * @param newDateTimeZone  the new time zone
+     * @return a copy of this instant with a different time zone
+     */
+    public ReadableInstant withDateTimeZone(DateTimeZone newDateTimeZone) {
+        Chronology newChronology = getChronology();
+        newChronology = newChronology == null ? ISOChronology.getInstance(newDateTimeZone)
+            : newChronology.withDateTimeZone(newDateTimeZone);
+        return withChronology(newChronology);
+    }
+
     // Conversion
     //-----------------------------------------------------------------------
     /**

From 3b798c8b45a527781d5c6a014ea42b24018bf75b Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 10 Jan 2004 03:48:03 +0000
Subject: [PATCH 109/143] Comment correction.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@114 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/AbstractDateTime.java       | 2 +-
 JodaTime/src/java/org/joda/time/AbstractPartialInstant.java | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/AbstractDateTime.java b/JodaTime/src/java/org/joda/time/AbstractDateTime.java
index e671a56a1..e767880e8 100644
--- a/JodaTime/src/java/org/joda/time/AbstractDateTime.java
+++ b/JodaTime/src/java/org/joda/time/AbstractDateTime.java
@@ -84,7 +84,7 @@
      * Selects the correct chronology to use for the chronology based constructors
      * on subclasses.
      * 
-     * @param chrono  the chronology to use, must not be null
+     * @param chrono  the chronology to use
      * @return the passed in Chronology
      */
     private static Chronology selectChronology(Chronology chrono) {
diff --git a/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java b/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
index 6f11a7fd7..94ac6724d 100644
--- a/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
+++ b/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
@@ -199,7 +199,7 @@ protected AbstractPartialInstant(Object instant) {
      * include ReadableInstant, String, Calendar and Date.
      *
      * @param instant  the datetime object, must not be null
-     * @param chronology  the chronology, must not be null
+     * @param chronology  the chronology, null means ISOChronology
      * @throws IllegalArgumentException if the date or chronology is null
      */
     protected AbstractPartialInstant(Object instant, final Chronology chronology) {

From ce2c258738d315e3964f5d32047b2ae00f09fb84 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 10 Jan 2004 04:02:30 +0000
Subject: [PATCH 110/143] Split the javadoc index.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@115 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/build.xml | 1 +
 1 file changed, 1 insertion(+)

diff --git a/JodaTime/build.xml b/JodaTime/build.xml
index 240da8c56..13fb1155f 100644
--- a/JodaTime/build.xml
+++ b/JodaTime/build.xml
@@ -216,6 +216,7 @@
                 package="false"
                 version="true"
                     use="yes"
+              splitindex="yes"
                doctitle="&lt;h1&gt;${component.title}&lt;/h1&gt;"
             windowtitle="${component.title} (Version ${component.version})"
                  bottom="Copyright (c) 2001-2004 - Joda.org">

From f748871f5c52e95282d0f5f8717b59e1e43f25f4 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 10 Jan 2004 04:02:58 +0000
Subject: [PATCH 111/143] Update API consistency items.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@116 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/ToDo.txt | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/JodaTime/ToDo.txt b/JodaTime/ToDo.txt
index 6964b3615..12552fe81 100644
--- a/JodaTime/ToDo.txt
+++ b/JodaTime/ToDo.txt
@@ -16,9 +16,9 @@ Consistency:
  eg. withXxx() vs toXxx() vs asXxx vs toCopyXxx()
  
  Chronology: withUTC(), withDateTimeZone()
- AbstractInstant: toCopy()
+ DurationType: withChronology()
+ ReadableInstant: withChronology(), withDateTimeZone()
  DateTimeProperty: addToCopy(), setCopy(), ...
- DurationSupport: withChronology()
  
 
 Ideas longer term

From 940ea81828ccc569954c598be775e4890d10d101 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 10 Jan 2004 17:40:51 +0000
Subject: [PATCH 112/143] Comment typo.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@117 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../joda/time/property/ReadWritableInstantFieldProperty.java    | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/JodaTime/src/java/org/joda/time/property/ReadWritableInstantFieldProperty.java b/JodaTime/src/java/org/joda/time/property/ReadWritableInstantFieldProperty.java
index d43b2d1b9..c07e7e933 100644
--- a/JodaTime/src/java/org/joda/time/property/ReadWritableInstantFieldProperty.java
+++ b/JodaTime/src/java/org/joda/time/property/ReadWritableInstantFieldProperty.java
@@ -59,7 +59,7 @@
 import org.joda.time.ReadWritableInstant;
 
 /**
- * ReadWritabelInstantFieldProperty binds a ReadWritableInstant to a
+ * ReadWritableInstantFieldProperty binds a ReadWritableInstant to a
  * DateTimeField allowing powerful datetime functionality to be easily
  * accessed.
  * <p>

From a3c62f00a0c418e37f951bf72785712df7228f8c Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 10 Jan 2004 17:47:06 +0000
Subject: [PATCH 113/143] Comment fix.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@118 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/ReadWritableDateTime.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/JodaTime/src/java/org/joda/time/ReadWritableDateTime.java b/JodaTime/src/java/org/joda/time/ReadWritableDateTime.java
index fa4acd58d..d66d1de3c 100644
--- a/JodaTime/src/java/org/joda/time/ReadWritableDateTime.java
+++ b/JodaTime/src/java/org/joda/time/ReadWritableDateTime.java
@@ -89,7 +89,7 @@
 
     //-----------------------------------------------------------------------
     /**
-     * Set the week of the year to the specified value.
+     * Set the weekyear to the specified value.
      *
      * @param weekyear  the weekyear
      * @throws IllegalArgumentException if the value is invalid

From c7eeafa2d16f849903ea61ff70e2ac511a39748f Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 10 Jan 2004 17:50:42 +0000
Subject: [PATCH 114/143] Comment typo.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@119 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/MutableDateTime.java      | 4 ++--
 JodaTime/src/java/org/joda/time/ReadWritableDateTime.java | 4 ++--
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/MutableDateTime.java b/JodaTime/src/java/org/joda/time/MutableDateTime.java
index a41db9535..780f01bfd 100644
--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java
+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java
@@ -856,7 +856,7 @@ public void setTime(
     //-----------------------------------------------------------------------
     /**
      * Set the date and time from milliseconds.
-     * This method is a synonm for {@link #setMillis(long)}.
+     * This method is a synonym for {@link #setMillis(long)}.
      *
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z
      * @throws IllegalArgumentException if the value is invalid
@@ -867,7 +867,7 @@ public void setDateTime(final long instant) {
 
     /**
      * Set the date and time from an object representing an instant.
-     * This method is a synonm for {@link #setMillis(Object)}.
+     * This method is a synonym for {@link #setMillis(Object)}.
      * <p>
      * The recognised object types are defined in {@link ConverterManager} and
      * include ReadableInstant, String, Calendar and Date.
diff --git a/JodaTime/src/java/org/joda/time/ReadWritableDateTime.java b/JodaTime/src/java/org/joda/time/ReadWritableDateTime.java
index d66d1de3c..1a5d08e97 100644
--- a/JodaTime/src/java/org/joda/time/ReadWritableDateTime.java
+++ b/JodaTime/src/java/org/joda/time/ReadWritableDateTime.java
@@ -335,7 +335,7 @@
     //-----------------------------------------------------------------------
     /**
      * Set the date and time from milliseconds.
-     * This method is a synonm for {@link #setMillis(long)}.
+     * This method is a synonym for {@link #setMillis(long)}.
      *
      * @param instant  the milliseconds from 1970-01-01T00:00:00Z
      * @throws IllegalArgumentException if the value is invalid
@@ -344,7 +344,7 @@
 
     /**
      * Set the date and time from an object representing an instant.
-     * This method is a synonm for {@link #setMillis(Object)}.
+     * This method is a synonym for {@link #setMillis(Object)}.
      * <p>
      * The recognised object types are defined in {@link ConverterManager} and
      * include ReadableInstant, String, Calendar and Date.

From f6d1161f85a2bbef865d0a02af06edd9576616d0 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 10 Jan 2004 21:17:11 +0000
Subject: [PATCH 115/143] Fixed bug when weekyear changes cross cutover.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@120 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../time/chrono/gj/CutoverChronology.java     | 93 ++++++++++++++++---
 1 file changed, 82 insertions(+), 11 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/CutoverChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/CutoverChronology.java
index b37bf8ae9..c33049a6f 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/CutoverChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/gj/CutoverChronology.java
@@ -77,7 +77,7 @@
     /**
      * Convert a datetime from one chronology to another.
      */
-    private static long convert(long instant, Chronology from, Chronology to) {
+    private static long convertByYear(long instant, Chronology from, Chronology to) {
         return to.getDateTimeMillis
             (from.year().get(instant),
              from.monthOfYear().get(instant),
@@ -85,6 +85,18 @@ private static long convert(long instant, Chronology from, Chronology to) {
              from.millisOfDay().get(instant));
     }
 
+    /**
+     * Convert a datetime from one chronology to another.
+     */
+    private static long convertByWeekyear(final long instant, Chronology from, Chronology to) {
+        long newInstant;
+        newInstant = to.weekyear().set(0, from.weekyear().get(instant));
+        newInstant = to.weekOfWeekyear().set(newInstant, from.weekOfWeekyear().get(instant));
+        newInstant = to.dayOfWeek().set(newInstant, from.dayOfWeek().get(instant));
+        newInstant = to.millisOfDay().set(newInstant, from.millisOfDay().get(instant));
+        return newInstant;
+    }
+
     private static void checkUTC(Chronology chrono) {
         if (chrono.getDateTimeZone() != null &&
             chrono.getDateTimeZone() != DateTimeZone.UTC) {
@@ -119,7 +131,7 @@ private static void checkUTC(Chronology chrono) {
         iCutoverInstant = cutoverInstant;
 
         // Compute difference between the chronologies at the cutover instant
-        iGapDuration = cutoverInstant - julianToGregorian(cutoverInstant);
+        iGapDuration = cutoverInstant - julianToGregorianByYear(cutoverInstant);
 
         // Begin field definitions.
 
@@ -168,7 +180,7 @@ private static void checkUTC(Chronology chrono) {
         {
             long cutover = gregorian.weekyear().roundCeiling(iCutoverInstant);
             iWeekOfWeekyearField = new CutoverField
-                (julian.weekOfWeekyear(), gregorian.weekOfWeekyear(), cutover);
+                (julian.weekOfWeekyear(), gregorian.weekOfWeekyear(), cutover, true);
         }
 
         // These fields are special because they have imprecise durations. The
@@ -188,7 +200,7 @@ private static void checkUTC(Chronology chrono) {
             iMonthOfYearField = new ImpreciseCutoverField(julian.monthOfYear(), gregorian.monthOfYear());
             iMonthsField = iMonthOfYearField.getDurationField();
             
-            iWeekyearField = new ImpreciseCutoverField(julian.weekyear(), gregorian.weekyear());
+            iWeekyearField = new ImpreciseCutoverField(julian.weekyear(), gregorian.weekyear(), true);
             iWeekyearsField = iWeekyearField.getDurationField();
         }
     }
@@ -261,12 +273,20 @@ public final int getMinimumDaysInFirstWeek() {
         return iGregorianChronology.getMinimumDaysInFirstWeek();
     }
 
-    long julianToGregorian(long instant) {
-        return convert(instant, iJulianChronology, iGregorianChronology);
+    long julianToGregorianByYear(long instant) {
+        return convertByYear(instant, iJulianChronology, iGregorianChronology);
     }
 
-    long gregorianToJulian(long instant) {
-        return convert(instant, iGregorianChronology, iJulianChronology);
+    long gregorianToJulianByYear(long instant) {
+        return convertByYear(instant, iGregorianChronology, iJulianChronology);
+    }
+
+    long julianToGregorianByWeekyear(long instant) {
+        return convertByWeekyear(instant, iJulianChronology, iGregorianChronology);
+    }
+
+    long gregorianToJulianByWeekyear(long instant) {
+        return convertByWeekyear(instant, iGregorianChronology, iJulianChronology);
     }
 
     /**
@@ -279,6 +299,7 @@ long gregorianToJulian(long instant) {
         final DateTimeField iJulianField;
         final DateTimeField iGregorianField;
         final long iCutover;
+        final boolean iConvertByWeekyear;
 
         protected DurationField iDurationField;
 
@@ -287,14 +308,29 @@ long gregorianToJulian(long instant) {
          * @param gregorianField field from the chronology used at and after the cutover
          */
         CutoverField(DateTimeField julianField, DateTimeField gregorianField) {
-            this(julianField, gregorianField, iCutoverInstant);
+            this(julianField, gregorianField, iCutoverInstant, false);
+        }
+
+        /**
+         * @param julianField field from the chronology used before the cutover instant
+         * @param gregorianField field from the chronology used at and after the cutover
+         * @param convertByWeekyear
+         */
+        CutoverField(DateTimeField julianField, DateTimeField gregorianField, boolean convertByWeekyear) {
+            this(julianField, gregorianField, iCutoverInstant, convertByWeekyear);
         }
 
         CutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverInstant) {
+            this(julianField, gregorianField, cutoverInstant, false);
+        }
+
+        CutoverField(DateTimeField julianField, DateTimeField gregorianField,
+                     long cutoverInstant, boolean convertByWeekyear) {
             super(gregorianField.getName());
             iJulianField = julianField;
             iGregorianField = gregorianField;
             iCutover = cutoverInstant;
+            iConvertByWeekyear = convertByWeekyear;
             // Although average length of Julian and Gregorian years differ,
             // use the Gregorian duration field because it is more accurate.
             iDurationField = gregorianField.getDurationField();
@@ -516,6 +552,22 @@ public int getMaximumShortTextLength(Locale locale) {
             return Math.max(iJulianField.getMaximumShortTextLength(locale),
                             iGregorianField.getMaximumShortTextLength(locale));
         }
+
+        protected long julianToGregorian(long instant) {
+            if (iConvertByWeekyear) {
+                return julianToGregorianByWeekyear(instant);
+            } else {
+                return julianToGregorianByYear(instant);
+            }
+        }
+
+        protected long gregorianToJulian(long instant) {
+            if (iConvertByWeekyear) {
+                return gregorianToJulianByWeekyear(instant);
+            } else {
+                return gregorianToJulianByYear(instant);
+            }
+        }
     }
 
     /**
@@ -531,7 +583,15 @@ public int getMaximumShortTextLength(Locale locale) {
          * Creates a duration field that links back to this.
          */
         ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField) {
-            this(julianField, gregorianField, null);
+            this(julianField, gregorianField, null, false);
+        }
+
+        /**
+         * Creates a duration field that links back to this.
+         */
+        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,
+                              boolean convertByWeekyear) {
+            this(julianField, gregorianField, null, convertByWeekyear);
         }
 
         /**
@@ -542,7 +602,18 @@ public int getMaximumShortTextLength(Locale locale) {
         ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,
                               DurationField durationField)
         {
-            super(julianField, gregorianField);
+            this(julianField, gregorianField, durationField, false);
+        }
+
+        /**
+         * Uses a shared duration field rather than creating a new one.
+         *
+         * @param durationField shared duration field
+         */
+        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,
+                              DurationField durationField, boolean convertByWeekyear)
+        {
+            super(julianField, gregorianField, convertByWeekyear);
             if (durationField == null) {
                 durationField = new LinkedDurationField(iDurationField, this);
             }

From bf2500fde3b5108cdd5b18d847dff401c3636e43 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 10 Jan 2004 21:19:17 +0000
Subject: [PATCH 116/143] Fixed bug when constructing with non-ISO
 chronologies.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@121 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../java/org/joda/time/AbstractPartialInstant.java   | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java b/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
index 94ac6724d..2bb943b3d 100644
--- a/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
+++ b/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
@@ -185,10 +185,10 @@ protected AbstractPartialInstant(long instant, final Chronology chronology) {
      */
     protected AbstractPartialInstant(Object instant) {
         InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
-        final Chronology chronology = converter.getChronology(instant);
-        iChronology = selectChronologyUTC(chronology);
+        Chronology original = converter.getChronology(instant);
+        iChronology = selectChronologyUTC(original);
         iMillis = resetUnsupportedFields
-            (toLocalTime(converter.getInstantMillis(instant), chronology, iChronology));
+            (toLocalTime(converter.getInstantMillis(instant), original, iChronology));
     }
 
     /**
@@ -203,11 +203,11 @@ protected AbstractPartialInstant(Object instant) {
      * @throws IllegalArgumentException if the date or chronology is null
      */
     protected AbstractPartialInstant(Object instant, final Chronology chronology) {
-        iChronology = selectChronologyUTC(chronology);
         InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant);
+        Chronology original = converter.getChronology(instant, chronology);
+        iChronology = selectChronologyUTC(original);
         iMillis = resetUnsupportedFields
-            (toLocalTime(converter.getInstantMillis(instant),
-                         converter.getChronology(instant), iChronology));
+            (toLocalTime(converter.getInstantMillis(instant, chronology), original, iChronology));
     }
 
     /**

From ee1c58b83ee157b446d8a8218ea6c5e864094d1d Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 11 Jan 2004 00:03:19 +0000
Subject: [PATCH 117/143] Renamed undoChanges to restoreState; added safety
 code to computeMillis.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@122 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../time/format/DateTimeParserBucket.java     | 25 ++++++++++---------
 1 file changed, 13 insertions(+), 12 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java b/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java
index 43c9c364d..d44406cc2 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeParserBucket.java
@@ -171,10 +171,10 @@ private void saveField(SavedField field) {
 
     /**
      * Saves the state of this bucket, returning it in an opaque object. Call
-     * undoChanges to undo any changes that were made since the state was
+     * restoreState to undo any changes that were made since the state was
      * saved. Calls to saveState may be nested.
      *
-     * @return opaque saved state, which may be passed to undoChanges
+     * @return opaque saved state, which may be passed to restoreState
      */
     public Object saveState() {
         if (iSavedState == null) {
@@ -184,19 +184,16 @@ public Object saveState() {
     }
 
     /**
-     * Undos any changes that were made to this bucket since the given state
-     * was saved. Once the changes have been undone, they are lost. Any states
-     * that were saved after saving the previous state are also lost.
-     * <p>
-     * The state object passed into this method is not lost, and it can be used
-     * later to revert to that state again.
+     * Restores the state of this bucket from a previously saved state. The
+     * state object passed into this method is not consumed, and it can be used
+     * later to restore to that state again.
      *
      * @param savedState opaque saved state, returned from saveState
-     * @return true state object is valid and changes were undone
+     * @return true state object is valid and state restored
      */
-    public boolean undoChanges(Object savedState) {
+    public boolean restoreState(Object savedState) {
         if (savedState instanceof SavedState) {
-            if (((SavedState)savedState).revertState(this)) {
+            if (((SavedState)savedState).restoreState(this)) {
                 iSavedState = savedState;
                 return true;
             }
@@ -214,6 +211,10 @@ public boolean undoChanges(Object savedState) {
     public long computeMillis() {
         SavedField[] savedFields = iSavedFields;
         int count = iSavedFieldsCount;
+        if (iSavedFieldsShared) {
+            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();
+            iSavedFieldsShared = false;
+        }
         sort(savedFields, count);
 
         long millis = iMillis;
@@ -338,7 +339,7 @@ private int compareReverse(Comparable a, Comparable b) {
             this.iSavedFieldsCount = DateTimeParserBucket.this.iSavedFieldsCount;
         }
 
-        boolean revertState(DateTimeParserBucket enclosing) {
+        boolean restoreState(DateTimeParserBucket enclosing) {
             if (enclosing != DateTimeParserBucket.this) {
                 return false;
             }

From 70a6a3dcc6de219ae89b82e46fe39b190bf03306 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 11 Jan 2004 00:05:03 +0000
Subject: [PATCH 118/143] Support negative weekyears; fixed minor bug in
 matching parser.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@123 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/time/format/DateTimeFormatterBuilder.java     | 7 +++----
 1 file changed, 3 insertions(+), 4 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
index 8803f43e3..c087757d3 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
@@ -699,8 +699,7 @@ public DateTimeFormatterBuilder appendWeekOfWeekyear(final int minDigits) {
      * @return this DateTimeFormatterBuilder
      */
     public DateTimeFormatterBuilder appendWeekyear(final int minDigits, final int maxDigits) {
-        return appendDecimal
-            (iChronoUTC.weekyear(), minDigits, maxDigits);
+        return appendSignedDecimal(iChronoUTC.weekyear(), minDigits, maxDigits);
     }
 
     /**
@@ -2036,7 +2035,6 @@ public int parseInto(final DateTimeParserBucket bucket, final String text, final
                         bestValidState = bucket.saveState();
                     }
                 } else {
-                    bucket.undoChanges(originalState);
                     if (parsePos < 0) {
                         parsePos = ~parsePos;
                         if (parsePos > bestInvalidPos) {
@@ -2044,12 +2042,13 @@ public int parseInto(final DateTimeParserBucket bucket, final String text, final
                         }
                     }
                 }
+                bucket.restoreState(originalState);
             }
 
             if (bestValidPos > position || (bestValidPos == position && isOptional)) {
                 // Restore the state to the best valid parse.
                 if (bestValidState != null) {
-                    bucket.undoChanges(bestValidState);
+                    bucket.restoreState(bestValidState);
                 }
                 return bestValidPos;
             }

From 6f5522f58c1d2abdec37b5d22e5981716d4ec731 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 11 Jan 2004 17:39:55 +0000
Subject: [PATCH 119/143] Fix broken link.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@124 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/xdocs/userguide.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/JodaTime/xdocs/userguide.xml b/JodaTime/xdocs/userguide.xml
index 9f8cc48af..af6c34f9c 100644
--- a/JodaTime/xdocs/userguide.xml
+++ b/JodaTime/xdocs/userguide.xml
@@ -91,7 +91,7 @@ Interoperability is also made simple via the <code>toDate()</code>, <code>toCale
 The main API of DateTime has been kept small, limited to just get methods for each field.
 There is much more power available however through the use of <i>properties</i>.
 In addition to the <code>getDayOfYear()</code> method you will find <code>dayOfYear()</code>.
-This returns a <a href="apidocs/org/joda/time/DateTimeFieldProperty.html">property</a> with considerable functionality.
+This returns a <a href="apidocs/org/joda/time/property/DateTimeFieldProperty.html">property</a> with considerable functionality.
 </p>
 <p>
 The property has methods to:

From 14dcaf0e3931855913d79d0fbe8d1e6f1421b7a7 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Wed, 28 Jan 2004 07:12:30 +0000
Subject: [PATCH 120/143] Re-organized chronology package and created new field
 package.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@125 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/example/time/AgeCalculator.java  |   2 +-
 .../example/time/DateTimePerformance.java     |   2 +-
 .../java/org/joda/time/AbstractDateTime.java  |   2 +-
 .../java/org/joda/time/AbstractInstant.java   |   2 +-
 .../java/org/joda/time/AbstractInterval.java  |   2 +-
 .../org/joda/time/AbstractPartialInstant.java |   2 +-
 .../src/java/org/joda/time/Chronology.java    | 246 ++----
 JodaTime/src/java/org/joda/time/DateOnly.java |   2 +-
 .../src/java/org/joda/time/DurationType.java  |  10 +-
 .../java/org/joda/time/MutableDateOnly.java   |   2 +-
 .../java/org/joda/time/MutableDateTime.java   |   2 +-
 .../java/org/joda/time/MutableTimeOnly.java   |   2 +-
 JodaTime/src/java/org/joda/time/TimeOnly.java |   2 +-
 .../joda/time/chrono/AbstractChronology.java  | 600 +++++++++++++++
 ...onology.java => AbstractGJChronology.java} | 509 ++++++++++---
 .../joda/time/chrono/AssembledChronology.java | 617 +++++++++++++++
 .../joda/time/chrono/BuddhistChronology.java  | 227 ++++++
 .../BuddhistEraDateTimeField.java             |  12 +-
 .../joda/time/chrono/CopticChronology.java    | 286 +++++++
 .../chrono/CopticDayOfMonthDateTimeField.java | 108 +++
 .../time/chrono/CopticEraDateTimeField.java   | 195 +++++
 .../CopticMonthOfYearDateTimeField.java       | 113 +++
 .../joda/time/chrono/DecoratedChronology.java | 129 ----
 .../joda/time/chrono/DelegatedChronology.java | 494 ------------
 ...toverChronology.java => GJChronology.java} | 524 ++++++++++---
 .../{gj => }/GJDayOfMonthDateTimeField.java   |  11 +-
 .../{gj => }/GJDayOfWeekDateTimeField.java    |  24 +-
 .../{gj => }/GJDayOfYearDateTimeField.java    |  14 +-
 .../chrono/{gj => }/GJEraDateTimeField.java   |  24 +-
 .../time/chrono/{gj => }/GJLocaleSymbols.java |   4 +-
 .../{gj => }/GJMonthOfYearDateTimeField.java  |  38 +-
 .../GJWeekOfWeekyearDateTimeField.java        |  23 +-
 .../{gj => }/GJWeekyearDateTimeField.java     |  50 +-
 .../chrono/{gj => }/GJYearDateTimeField.java  | 121 +--
 .../{gj => }/GJYearOfEraDateTimeField.java    |  19 +-
 .../joda/time/chrono/GregorianChronology.java | 267 +++++++
 .../time/chrono/{iso => }/ISOChronology.java  |  46 +-
 .../joda/time/chrono/JulianChronology.java    | 334 ++++++++
 .../joda/time/chrono/LenientChronology.java   | 323 ++------
 .../org/joda/time/chrono/LimitChronology.java | 417 +++-------
 .../joda/time/chrono/StrictChronology.java    | 323 ++------
 .../org/joda/time/chrono/ZonedChronology.java | 400 +++-------
 .../chrono/buddhist/BuddhistChronology.java   | 575 --------------
 .../time/chrono/gj/GJCenturyChronology.java   | 157 ----
 .../org/joda/time/chrono/gj/GJChronology.java | 714 ------------------
 .../time/chrono/gj/GJZonedChronology.java     | 141 ----
 .../time/chrono/gj/GregorianChronology.java   | 128 ----
 .../joda/time/chrono/gj/JulianChronology.java | 200 -----
 .../gj/JulianWithYearZeroChronology.java      | 125 ---
 .../java/org/joda/time/chrono/gj/package.html |  74 --
 .../org/joda/time/chrono/iso/package.html     |  70 --
 .../java/org/joda/time/chrono/package.html    |   6 +-
 .../joda/time/convert/AbstractConverter.java  |   2 +-
 .../joda/time/convert/CalendarConverter.java  |  19 +-
 .../time/convert/PartialInstantConverter.java |   2 +-
 .../convert/ReadableInstantConverter.java     |   2 +-
 .../joda/time/convert/StringConverter.java    |   2 +-
 .../AbstractDateTimeField.java                |   4 +-
 .../AbstractDurationField.java                |   8 +-
 .../DecoratedDateTimeField.java               |   2 +-
 .../DecoratedDurationField.java               |   2 +-
 .../DelegatedDateTimeField.java               |   2 +-
 .../DelegatedDurationField.java               |   2 +-
 .../DividedDateTimeField.java                 |   6 +-
 .../Utils.java => field/FieldUtils.java}      |   6 +-
 .../ImpreciseDateTimeField.java               |   4 +-
 .../LenientDateTimeField.java                 |   3 +-
 .../org/joda/time/field/LimitDateTimeField.j  | 332 ++++++++
 .../MillisDurationField.java                  |   8 +-
 .../NonZeroDateTimeField.java                 |   4 +-
 .../OffsetDateTimeField.java                  |  10 +-
 .../PreciseDateTimeField.java                 |   6 +-
 .../PreciseDurationDateTimeField.java         |   8 +-
 .../PreciseDurationField.java                 |   2 +-
 .../RemainderDateTimeField.java               |   6 +-
 .../ScaledDurationField.java                  |   2 +-
 .../StrictDateTimeField.java                  |   5 +-
 .../UnsupportedDateTimeField.java             |   2 +-
 .../UnsupportedDurationField.java             |   2 +-
 .../{chrono/buddhist => field}/package.html   |  10 +-
 .../org/joda/time/format/DateTimeFormat.java  |   4 +-
 .../time/format/DateTimeFormatterBuilder.java |   6 +-
 .../joda/time/format/ISODateTimeFormat.java   |   2 +-
 .../org/joda/time/tz/DateTimeZoneBuilder.java |   2 +-
 .../org/joda/time/tz/ZoneInfoCompiler.java    |  27 +-
 .../test/time/AbstractTestDateTimeCommon.java |   4 +-
 .../time/AbstractTestReadableInstant.java     |   2 +-
 .../test/org/joda/test/time/BulkMDTTests.java |   2 +-
 .../src/test/org/joda/test/time/BulkTest.java |   2 +-
 .../test/time/TestBuddhistChronology.java     |   2 +-
 .../test/time/TestDateTimeComparator.java     |   2 +-
 .../org/joda/test/time/TestDateTimeCtors.java |   4 +-
 .../test/org/joda/test/time/TestMDTAdd.java   |   2 +-
 .../org/joda/test/time/TestMDTAddWrapped.java |   2 +-
 .../test/org/joda/test/time/TestMDTGet.java   |   2 +-
 .../test/org/joda/test/time/TestMDTSet.java   |   2 +-
 .../joda/test/time/TestMutableDateTime.java   |   2 +-
 .../test/time/TestMutableDateTimeCtors.java   |   4 +-
 .../TestBuddhistEraDateTimeField.java         |   2 +-
 .../org/joda/test/time/chrono/gj/Test.java    |   7 +-
 .../test/time/chrono/gj/TestGJChronology.java |   3 +-
 .../time/chrono/gj/TestGJDateTimeField.java   |   3 +-
 .../chrono/gj/TestJulianWeekyearField.java    |   6 +-
 .../time/chrono/gj/TestJulianYearField.java   |   6 +-
 .../time/gj/AbstractTestGJDateTimeField.java  |   4 +-
 .../gj/TestGJClockhourOfDayDateTimeField.java |   2 +-
 ...TestGJClockhourOfHalfdayDateTimeField.java |   2 +-
 .../gj/TestGJDayOfMonthDateTimeField.java     |   2 +-
 .../time/gj/TestGJDayOfWeekDateTimeField.java |   2 +-
 .../time/gj/TestGJDayOfYearDateTimeField.java |   2 +-
 .../gj/TestGJHalfdayOfDayDateTimeField.java   |   2 +-
 .../time/gj/TestGJHourOfDayDateTimeField.java |   2 +-
 .../gj/TestGJHourOfHalfdayDateTimeField.java  |   2 +-
 .../gj/TestGJMillisOfDayDateTimeField.java    |   2 +-
 .../gj/TestGJMillisOfSecondDateTimeField.java |   2 +-
 .../gj/TestGJMinuteOfDayDateTimeField.java    |   2 +-
 .../gj/TestGJMinuteOfHourDateTimeField.java   |   2 +-
 .../gj/TestGJMonthOfYearDateTimeField.java    |   2 +-
 .../gj/TestGJSecondOfDayDateTimeField.java    |   2 +-
 .../gj/TestGJSecondOfMinuteDateTimeField.java |   2 +-
 .../test/time/gj/TestGJYearDateTimeField.java |   2 +-
 .../gj/TestGJYearOfCenturyDateTimeField.java  |   2 +-
 .../time/gj/TestGJYearOfEraDateTimeField.java |   2 +-
 .../TestISOClockhourOfDayDateTimeField.java   |   2 +-
 ...estISOClockhourOfHalfdayDateTimeField.java |   2 +-
 .../iso/TestISODayOfMonthDateTimeField.java   |   2 +-
 .../iso/TestISODayOfWeekDateTimeField.java    |   2 +-
 .../iso/TestISODayOfYearDateTimeField.java    |   2 +-
 .../iso/TestISOHalfdayOfDayDateTimeField.java |   2 +-
 .../iso/TestISOHourOfDayDateTimeField.java    |   2 +-
 .../TestISOHourOfHalfdayDateTimeField.java    |   2 +-
 .../iso/TestISOMillisOfDayDateTimeField.java  |   2 +-
 .../TestISOMillisOfSecondDateTimeField.java   |   2 +-
 .../iso/TestISOMinuteOfDayDateTimeField.java  |   2 +-
 .../iso/TestISOMinuteOfHourDateTimeField.java |   2 +-
 .../iso/TestISOMonthOfYearDateTimeField.java  |   2 +-
 .../iso/TestISOSecondOfDayDateTimeField.java  |   2 +-
 .../TestISOSecondOfMinuteDateTimeField.java   |   2 +-
 138 files changed, 4576 insertions(+), 4777 deletions(-)
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/AbstractChronology.java
 rename JodaTime/src/java/org/joda/time/chrono/{gj/ProlepticChronology.java => AbstractGJChronology.java} (54%)
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java
 rename JodaTime/src/java/org/joda/time/chrono/{buddhist => }/BuddhistEraDateTimeField.java (94%)
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/CopticChronology.java
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/CopticMonthOfYearDateTimeField.java
 delete mode 100644 JodaTime/src/java/org/joda/time/chrono/DecoratedChronology.java
 delete mode 100644 JodaTime/src/java/org/joda/time/chrono/DelegatedChronology.java
 rename JodaTime/src/java/org/joda/time/chrono/{gj/CutoverChronology.java => GJChronology.java} (63%)
 rename JodaTime/src/java/org/joda/time/chrono/{gj => }/GJDayOfMonthDateTimeField.java (92%)
 rename JodaTime/src/java/org/joda/time/chrono/{gj => }/GJDayOfWeekDateTimeField.java (88%)
 rename JodaTime/src/java/org/joda/time/chrono/{gj => }/GJDayOfYearDateTimeField.java (89%)
 rename JodaTime/src/java/org/joda/time/chrono/{gj => }/GJEraDateTimeField.java (89%)
 rename JodaTime/src/java/org/joda/time/chrono/{gj => }/GJLocaleSymbols.java (98%)
 rename JodaTime/src/java/org/joda/time/chrono/{gj => }/GJMonthOfYearDateTimeField.java (92%)
 rename JodaTime/src/java/org/joda/time/chrono/{gj => }/GJWeekOfWeekyearDateTimeField.java (85%)
 rename JodaTime/src/java/org/joda/time/chrono/{gj => }/GJWeekyearDateTimeField.java (84%)
 rename JodaTime/src/java/org/joda/time/chrono/{gj => }/GJYearDateTimeField.java (65%)
 rename JodaTime/src/java/org/joda/time/chrono/{gj => }/GJYearOfEraDateTimeField.java (91%)
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java
 rename JodaTime/src/java/org/joda/time/chrono/{iso => }/ISOChronology.java (88%)
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/JulianChronology.java
 delete mode 100644 JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistChronology.java
 delete mode 100644 JodaTime/src/java/org/joda/time/chrono/gj/GJCenturyChronology.java
 delete mode 100644 JodaTime/src/java/org/joda/time/chrono/gj/GJChronology.java
 delete mode 100644 JodaTime/src/java/org/joda/time/chrono/gj/GJZonedChronology.java
 delete mode 100644 JodaTime/src/java/org/joda/time/chrono/gj/GregorianChronology.java
 delete mode 100644 JodaTime/src/java/org/joda/time/chrono/gj/JulianChronology.java
 delete mode 100644 JodaTime/src/java/org/joda/time/chrono/gj/JulianWithYearZeroChronology.java
 delete mode 100644 JodaTime/src/java/org/joda/time/chrono/gj/package.html
 delete mode 100644 JodaTime/src/java/org/joda/time/chrono/iso/package.html
 rename JodaTime/src/java/org/joda/time/{chrono => field}/AbstractDateTimeField.java (99%)
 rename JodaTime/src/java/org/joda/time/{chrono => field}/AbstractDurationField.java (96%)
 rename JodaTime/src/java/org/joda/time/{chrono => field}/DecoratedDateTimeField.java (99%)
 rename JodaTime/src/java/org/joda/time/{chrono => field}/DecoratedDurationField.java (99%)
 rename JodaTime/src/java/org/joda/time/{chrono => field}/DelegatedDateTimeField.java (99%)
 rename JodaTime/src/java/org/joda/time/{chrono => field}/DelegatedDurationField.java (99%)
 rename JodaTime/src/java/org/joda/time/{chrono => field}/DividedDateTimeField.java (98%)
 rename JodaTime/src/java/org/joda/time/{chrono/Utils.java => field/FieldUtils.java} (99%)
 rename JodaTime/src/java/org/joda/time/{chrono => field}/ImpreciseDateTimeField.java (98%)
 rename JodaTime/src/java/org/joda/time/{chrono => field}/LenientDateTimeField.java (98%)
 create mode 100644 JodaTime/src/java/org/joda/time/field/LimitDateTimeField.j
 rename JodaTime/src/java/org/joda/time/{chrono => field}/MillisDurationField.java (96%)
 rename JodaTime/src/java/org/joda/time/{chrono => field}/NonZeroDateTimeField.java (98%)
 rename JodaTime/src/java/org/joda/time/{chrono => field}/OffsetDateTimeField.java (96%)
 rename JodaTime/src/java/org/joda/time/{chrono => field}/PreciseDateTimeField.java (97%)
 rename JodaTime/src/java/org/joda/time/{chrono => field}/PreciseDurationDateTimeField.java (96%)
 rename JodaTime/src/java/org/joda/time/{chrono => field}/PreciseDurationField.java (99%)
 rename JodaTime/src/java/org/joda/time/{chrono => field}/RemainderDateTimeField.java (97%)
 rename JodaTime/src/java/org/joda/time/{chrono => field}/ScaledDurationField.java (99%)
 rename JodaTime/src/java/org/joda/time/{chrono => field}/StrictDateTimeField.java (97%)
 rename JodaTime/src/java/org/joda/time/{chrono => field}/UnsupportedDateTimeField.java (99%)
 rename JodaTime/src/java/org/joda/time/{chrono => field}/UnsupportedDurationField.java (99%)
 rename JodaTime/src/java/org/joda/time/{chrono/buddhist => field}/package.html (86%)

diff --git a/JodaTime/src/example/org/joda/example/time/AgeCalculator.java b/JodaTime/src/example/org/joda/example/time/AgeCalculator.java
index 49829a3b5..35b48e55e 100644
--- a/JodaTime/src/example/org/joda/example/time/AgeCalculator.java
+++ b/JodaTime/src/example/org/joda/example/time/AgeCalculator.java
@@ -82,7 +82,7 @@
 import org.joda.time.DateTime;
 import org.joda.time.DateTimeZone;
 import org.joda.time.DurationField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * AgeCalculator is a small Swing application that computes age from a specific
diff --git a/JodaTime/src/example/org/joda/example/time/DateTimePerformance.java b/JodaTime/src/example/org/joda/example/time/DateTimePerformance.java
index 05305984c..9431d604b 100644
--- a/JodaTime/src/example/org/joda/example/time/DateTimePerformance.java
+++ b/JodaTime/src/example/org/joda/example/time/DateTimePerformance.java
@@ -63,7 +63,7 @@
 
 import org.joda.time.DateTime;
 import org.joda.time.MutableDateTime;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 
 /**
  * DateTimePerformance provides various comparisons between the Java supplied
diff --git a/JodaTime/src/java/org/joda/time/AbstractDateTime.java b/JodaTime/src/java/org/joda/time/AbstractDateTime.java
index e767880e8..bc32ed491 100644
--- a/JodaTime/src/java/org/joda/time/AbstractDateTime.java
+++ b/JodaTime/src/java/org/joda/time/AbstractDateTime.java
@@ -56,7 +56,7 @@
 import java.io.Serializable;
 import java.util.Locale;
 
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 import org.joda.time.convert.InstantConverter;
 import org.joda.time.convert.ConverterManager;
 import org.joda.time.format.DateTimeFormat;
diff --git a/JodaTime/src/java/org/joda/time/AbstractInstant.java b/JodaTime/src/java/org/joda/time/AbstractInstant.java
index 57d898287..bb4b54075 100644
--- a/JodaTime/src/java/org/joda/time/AbstractInstant.java
+++ b/JodaTime/src/java/org/joda/time/AbstractInstant.java
@@ -57,7 +57,7 @@
 import java.util.Date;
 import java.util.GregorianCalendar;
 import java.util.Locale;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * AbstractInstant provides the common behaviour for instant classes.
diff --git a/JodaTime/src/java/org/joda/time/AbstractInterval.java b/JodaTime/src/java/org/joda/time/AbstractInterval.java
index a06bc39f5..05a155a98 100644
--- a/JodaTime/src/java/org/joda/time/AbstractInterval.java
+++ b/JodaTime/src/java/org/joda/time/AbstractInterval.java
@@ -53,7 +53,7 @@
  */
 package org.joda.time;
 
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 import org.joda.time.convert.ConverterManager;
 import org.joda.time.convert.IntervalConverter;
 import org.joda.time.format.DateTimePrinter;
diff --git a/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java b/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
index 2bb943b3d..9e67082f5 100644
--- a/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
+++ b/JodaTime/src/java/org/joda/time/AbstractPartialInstant.java
@@ -56,7 +56,7 @@
 import java.io.Serializable;
 import java.util.Locale;
 
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 import org.joda.time.convert.ConverterManager;
 import org.joda.time.convert.InstantConverter;
 import org.joda.time.format.DateTimeFormat;
diff --git a/JodaTime/src/java/org/joda/time/Chronology.java b/JodaTime/src/java/org/joda/time/Chronology.java
index 1c5e7727b..c97580e05 100644
--- a/JodaTime/src/java/org/joda/time/Chronology.java
+++ b/JodaTime/src/java/org/joda/time/Chronology.java
@@ -53,50 +53,38 @@
  */
 package org.joda.time;
 
-import java.io.Serializable;
-import org.joda.time.chrono.UnsupportedDateTimeField;
-import org.joda.time.chrono.UnsupportedDurationField;
-
 /**
- * Chronology provides access to the individual date time fields for
- * a chronological calendar system.
- * Various chronologies are supported by subclasses including ISO and 
- * GregorianJulian. 
+ * Chronology provides access to the individual date time fields for a
+ * chronological calendar system. Various chronologies are supported by
+ * subclasses including ISO and GregorianJulian.
  * <p>
  * This class defines a number of fields with names from the ISO8601 standard.
  * Chronology does not 'strongly' define these fields however, thus subclasses
  * are free to interpret the field names as they wish. For example, a week
  * could be defined as 10 days and a month as 40 days in a special
- * WeirdChronology subclass. Clearly the GJ and ISO implementations provided
- * use the field names as you would expect.
- * <p>
- * Chronology is thread-safe and immutable, and all subclasses must be as well.
+ * WeirdChronology implementation. Clearly the GJ and ISO implementations
+ * provided use the field names as you would expect.
  * 
- * @see org.joda.time.chrono.iso.ISOChronology
- * @see org.joda.time.chrono.gj.GJChronology
+ * @see org.joda.time.chrono.ISOChronology
+ * @see org.joda.time.chrono.GJChronology
+ * @see org.joda.time.chrono.GregorianChronology
+ * @see org.joda.time.chrono.JulianChronology
+ * @see org.joda.time.chrono.CopticChronology
+ * @see org.joda.time.chrono.BuddhistChronology
  *
  * @author Stephen Colebourne
  * @author Brian S O'Neill
  * @since 1.0
  */
-public abstract class Chronology implements Serializable {
+public interface Chronology {
     
-    static final long serialVersionUID = -7310865996721419676L;
-
-    /**
-     * Restricted constructor
-     */
-    protected Chronology() {
-        super();
-    }
-
     /**
      * Returns the DateTimeZone that this Chronology operates in, or null if
      * unspecified.
      *
      * @return DateTimeZone null if unspecified
      */
-    public abstract DateTimeZone getDateTimeZone();
+    DateTimeZone getDateTimeZone();
 
     /**
      * Returns an instance of this Chronology that operates in the UTC time
@@ -105,7 +93,7 @@ protected Chronology() {
      *
      * @return a version of this chronology that ignores time zones
      */
-    public abstract Chronology withUTC();
+    Chronology withUTC();
     
     /**
      * Returns an instance of this Chronology that operates in any time zone.
@@ -114,7 +102,7 @@ protected Chronology() {
      * @param zone to use, or default if null
      * @see org.joda.time.chrono.ZonedChronology
      */
-    public abstract Chronology withDateTimeZone(DateTimeZone zone);
+    Chronology withDateTimeZone(DateTimeZone zone);
 
     /**
      * Returns a date-only millisecond instant, by clearing the time fields
@@ -127,9 +115,7 @@ protected Chronology() {
      * @return millisecond instant from 1970-01-01T00:00:00Z with the time part
      * cleared
      */
-    public long getDateOnlyMillis(long instant) {
-        return dayOfYear().roundFloor(instant);
-    }
+    long getDateOnlyMillis(long instant);
 
     /**
      * Returns a date-only millisecond instant, formed from the given year,
@@ -145,11 +131,8 @@ public long getDateOnlyMillis(long instant) {
      * @return millisecond instant from 1970-01-01T00:00:00Z without any time
      * part
      */
-    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
-        throws IllegalArgumentException
-    {
-        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);
-    }
+    long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
+        throws IllegalArgumentException;
 
     /**
      * Returns a time-only millisecond instant, by clearing the date fields
@@ -162,9 +145,7 @@ public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
      * @return millisecond instant from 1970-01-01T00:00:00Z with the date part
      * cleared
      */
-    public long getTimeOnlyMillis(long instant) {
-        return dayOfYear().remainder(instant);
-    }
+    long getTimeOnlyMillis(long instant);
 
     /**
      * Returns a time-only millisecond instant, formed from the given hour,
@@ -182,15 +163,9 @@ public long getTimeOnlyMillis(long instant) {
      * @return millisecond instant from 1970-01-01T00:00:00Z without any date
      * part
      */
-    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        long instant = hourOfDay().set(0, hourOfDay);
-        instant = minuteOfHour().set(instant, minuteOfHour);
-        instant = secondOfMinute().set(instant, secondOfMinute);
-        return millisOfSecond().set(instant, millisOfSecond);
-    }
+    long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
+                           int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException;
 
     /**
      * Returns a datetime millisecond instant, formed from the given year,
@@ -207,15 +182,8 @@ public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
      * @param millisOfDay millisecond to use
      * @return millisecond instant from 1970-01-01T00:00:00Z
      */
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int millisOfDay)
-        throws IllegalArgumentException
-    {
-        long instant = year().set(0, year);
-        instant = monthOfYear().set(instant, monthOfYear);
-        instant = dayOfMonth().set(instant, dayOfMonth);
-        return millisOfDay().set(instant, millisOfDay);
-    }
+    long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay)
+        throws IllegalArgumentException;
 
     /**
      * Returns a datetime millisecond instant, from from the given instant,
@@ -234,16 +202,10 @@ public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
      * @param millisOfSecond millisecond to use
      * @return millisecond instant from 1970-01-01T00:00:00Z
      */
-    public long getDateTimeMillis(long instant,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        instant = hourOfDay().set(instant, hourOfDay);
-        instant = minuteOfHour().set(instant, minuteOfHour);
-        instant = secondOfMinute().set(instant, secondOfMinute);
-        return millisOfSecond().set(instant, millisOfSecond);
-    }
+    long getDateTimeMillis(long instant,
+                           int hourOfDay, int minuteOfHour,
+                           int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException;
 
     /**
      * Returns a datetime millisecond instant, formed from the given year,
@@ -264,19 +226,10 @@ public long getDateTimeMillis(long instant,
      * @param millisOfSecond millisecond to use
      * @return millisecond instant from 1970-01-01T00:00:00Z
      */
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        long instant = year().set(0, year);
-        instant = monthOfYear().set(instant, monthOfYear);
-        instant = dayOfMonth().set(instant, dayOfMonth);
-        instant = hourOfDay().set(instant, hourOfDay);
-        instant = minuteOfHour().set(instant, minuteOfHour);
-        instant = secondOfMinute().set(instant, secondOfMinute);
-        return millisOfSecond().set(instant, millisOfSecond);
-    }
+    long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                           int hourOfDay, int minuteOfHour,
+                           int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException;
 
     // Millis
     //-----------------------------------------------------------------------
@@ -285,27 +238,21 @@ public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
      * 
      * @return DurationField or UnsupportedDurationField if unsupported
      */
-    public DurationField millis() {
-        return UnsupportedDurationField.getInstance("millis");
-    }
+    DurationField millis();
 
     /**
      * Get the millis of second field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField millisOfSecond() {
-        return UnsupportedDateTimeField.getInstance("millisOfSecond", millis());
-    }
+    DateTimeField millisOfSecond();
 
     /**
      * Get the millis of day field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField millisOfDay() {
-        return UnsupportedDateTimeField.getInstance("millisOfDay", millis());
-    }
+    DateTimeField millisOfDay();
 
     // Second
     //-----------------------------------------------------------------------
@@ -314,27 +261,21 @@ public DateTimeField millisOfDay() {
      * 
      * @return DurationField or UnsupportedDurationField if unsupported
      */
-    public DurationField seconds() {
-        return UnsupportedDurationField.getInstance("seconds");
-    }
+    DurationField seconds();
 
     /**
      * Get the second of minute field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField secondOfMinute() {
-        return UnsupportedDateTimeField.getInstance("secondOfMinute", seconds());
-    }
+    DateTimeField secondOfMinute();
 
     /**
      * Get the second of day field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField secondOfDay() {
-        return UnsupportedDateTimeField.getInstance("secondOfDay", seconds());
-    }
+    DateTimeField secondOfDay();
 
     // Minute
     //-----------------------------------------------------------------------
@@ -343,27 +284,21 @@ public DateTimeField secondOfDay() {
      * 
      * @return DurationField or UnsupportedDurationField if unsupported
      */
-    public DurationField minutes() {
-        return UnsupportedDurationField.getInstance("minutes");
-    }
+    DurationField minutes();
 
     /**
      * Get the minute of hour field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField minuteOfHour() {
-        return UnsupportedDateTimeField.getInstance("minuteOfHour", minutes());
-    }
+    DateTimeField minuteOfHour();
 
     /**
      * Get the minute of day field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField minuteOfDay() {
-        return UnsupportedDateTimeField.getInstance("minuteOfDay", minutes());
-    }
+    DateTimeField minuteOfDay();
 
     // Hour
     //-----------------------------------------------------------------------
@@ -372,55 +307,42 @@ public DateTimeField minuteOfDay() {
      * 
      * @return DurationField or UnsupportedDurationField if unsupported
      */
-    public DurationField hours() {
-        return UnsupportedDurationField.getInstance("hours");
-    }
+    DurationField hours();
 
     /**
      * Get the hour of day (0-23) field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField hourOfDay() {
-        return UnsupportedDateTimeField.getInstance("hourOfDay", hours());
-    }
+    DateTimeField hourOfDay();
 
     /**
      * Get the hour of day (offset to 1-24) field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField clockhourOfDay() {
-        return UnsupportedDateTimeField.getInstance("clockhourOfDay", hours());
-    }
+    DateTimeField clockhourOfDay();
 
     /**
      * Get the hour of am/pm (0-11) field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField hourOfHalfday() {
-        return UnsupportedDateTimeField.getInstance("hourOfHalfday", hours());
-    }
+    DateTimeField hourOfHalfday();
 
     /**
      * Get the hour of am/pm (offset to 1-12) field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField clockhourOfHalfday() {
-        return UnsupportedDateTimeField.getInstance("clockhourOfHalfday", hours());
-    }
+    DateTimeField clockhourOfHalfday();
 
     /**
      * Get the AM(0) PM(1) field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField halfdayOfDay() {
-        return UnsupportedDateTimeField.getInstance
-            ("halfdayOfDay", UnsupportedDurationField.getInstance("halfdays"));
-    }
+    DateTimeField halfdayOfDay();
 
     // Day
     //-----------------------------------------------------------------------
@@ -429,9 +351,7 @@ public DateTimeField halfdayOfDay() {
      * 
      * @return DurationField or UnsupportedDurationField if unsupported
      */
-    public DurationField days() {
-        return UnsupportedDurationField.getInstance("days");
-    }
+    DurationField days();
 
     /**
      * Get the day of week field for this chronology.
@@ -441,27 +361,21 @@ public DurationField days() {
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField dayOfWeek() {
-        return UnsupportedDateTimeField.getInstance("dayOfWeek", days());
-    }
+    DateTimeField dayOfWeek();
 
     /**
      * Get the day of month field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField dayOfMonth() {
-        return UnsupportedDateTimeField.getInstance("dayOfMonth", days());
-    }
+    DateTimeField dayOfMonth();
 
     /**
      * Get the day of year field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField dayOfYear() {
-        return UnsupportedDateTimeField.getInstance("dayOfYear", days());
-    }
+    DateTimeField dayOfYear();
 
     // Week
     //-----------------------------------------------------------------------
@@ -470,36 +384,28 @@ public DateTimeField dayOfYear() {
      * 
      * @return DurationField or UnsupportedDurationField if unsupported
      */
-    public DurationField weeks() {
-        return UnsupportedDurationField.getInstance("weeks");
-    }
+    DurationField weeks();
 
     /**
      * Get the week of a week based year field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField weekOfWeekyear() {
-        return UnsupportedDateTimeField.getInstance("weekOfWeekyear", weeks());
-    }
+    DateTimeField weekOfWeekyear();
 
     /**
      * Get the weekyears duration field for this chronology.
      * 
      * @return DurationField or UnsupportedDurationField if unsupported
      */
-    public DurationField weekyears() {
-        return UnsupportedDurationField.getInstance("weekyears");
-    }
+    DurationField weekyears();
 
     /**
      * Get the year of a week based year field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField weekyear() {
-        return UnsupportedDateTimeField.getInstance("weekyear", weekyears());
-    }
+    DateTimeField weekyear();
 
     // Month
     //-----------------------------------------------------------------------
@@ -508,18 +414,14 @@ public DateTimeField weekyear() {
      * 
      * @return DurationField or UnsupportedDurationField if unsupported
      */
-    public DurationField months() {
-        return UnsupportedDurationField.getInstance("months");
-    }
+    DurationField months();
 
     /**
      * Get the month of year field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField monthOfYear() {
-        return UnsupportedDateTimeField.getInstance("monthOfYear", months());
-    }
+    DateTimeField monthOfYear();
 
     // Year
     //-----------------------------------------------------------------------
@@ -528,78 +430,62 @@ public DateTimeField monthOfYear() {
      * 
      * @return DurationField or UnsupportedDurationField if unsupported
      */
-    public DurationField years() {
-        return UnsupportedDurationField.getInstance("years");
-    }
+    DurationField years();
 
     /**
      * Get the year field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField year() {
-        return UnsupportedDateTimeField.getInstance("year", years());
-    }
+    DateTimeField year();
 
     /**
      * Get the year of era field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField yearOfEra() {
-        return UnsupportedDateTimeField.getInstance("yearOfEra", years());
-    }
+    DateTimeField yearOfEra();
 
     /**
      * Get the year of century field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField yearOfCentury() {
-        return UnsupportedDateTimeField.getInstance("yearOfCentury", years());
-    }
+    DateTimeField yearOfCentury();
 
     /**
      * Get the centuries duration field for this chronology.
      * 
      * @return DurationField or UnsupportedDurationField if unsupported
      */
-    public DurationField centuries() {
-        return UnsupportedDurationField.getInstance("centuries");
-    }
+    DurationField centuries();
 
     /**
      * Get the century of era field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField centuryOfEra() {
-        return UnsupportedDateTimeField.getInstance("centuryOfEra", centuries());
-    }
+    DateTimeField centuryOfEra();
 
     /**
      * Get the eras duration field for this chronology.
      * 
      * @return DurationField or UnsupportedDurationField if unsupported
      */
-    public DurationField eras() {
-        return UnsupportedDurationField.getInstance("eras");
-    }
+    DurationField eras();
 
     /**
      * Get the era field for this chronology.
      * 
      * @return DateTimeField or UnsupportedDateTimeField if unsupported
      */
-    public DateTimeField era() {
-        return UnsupportedDateTimeField.getInstance("era", eras());
-    }
+    DateTimeField era();
 
     /**
      * Gets a debugging toString.
      * 
      * @return a debugging string
      */
-    public abstract String toString();
+    String toString();
 
 }
diff --git a/JodaTime/src/java/org/joda/time/DateOnly.java b/JodaTime/src/java/org/joda/time/DateOnly.java
index 3f1feaa92..07a6647d2 100644
--- a/JodaTime/src/java/org/joda/time/DateOnly.java
+++ b/JodaTime/src/java/org/joda/time/DateOnly.java
@@ -55,7 +55,7 @@
 
 import java.io.Serializable;
 
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 // Import for @link support
 import org.joda.time.convert.ConverterManager;
 import org.joda.time.format.ISODateTimeFormat;
diff --git a/JodaTime/src/java/org/joda/time/DurationType.java b/JodaTime/src/java/org/joda/time/DurationType.java
index 837044d8c..81621fdb3 100644
--- a/JodaTime/src/java/org/joda/time/DurationType.java
+++ b/JodaTime/src/java/org/joda/time/DurationType.java
@@ -54,11 +54,11 @@
 package org.joda.time;
 
 import java.io.Serializable;
-import org.joda.time.chrono.MillisDurationField;
-import org.joda.time.chrono.PreciseDurationField;
-import org.joda.time.chrono.ScaledDurationField;
-import org.joda.time.chrono.UnsupportedDurationField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.field.MillisDurationField;
+import org.joda.time.field.PreciseDurationField;
+import org.joda.time.field.ScaledDurationField;
+import org.joda.time.field.UnsupportedDurationField;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * Controls a duration implementation by specifying which duration fields are to be used.
diff --git a/JodaTime/src/java/org/joda/time/MutableDateOnly.java b/JodaTime/src/java/org/joda/time/MutableDateOnly.java
index c368fab31..d09fae28a 100644
--- a/JodaTime/src/java/org/joda/time/MutableDateOnly.java
+++ b/JodaTime/src/java/org/joda/time/MutableDateOnly.java
@@ -55,7 +55,7 @@
 
 import java.io.Serializable;
 
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 import org.joda.time.convert.ConverterManager;
 import org.joda.time.convert.DurationConverter;
 import org.joda.time.format.ISODateTimeFormat;
diff --git a/JodaTime/src/java/org/joda/time/MutableDateTime.java b/JodaTime/src/java/org/joda/time/MutableDateTime.java
index 780f01bfd..40b486874 100644
--- a/JodaTime/src/java/org/joda/time/MutableDateTime.java
+++ b/JodaTime/src/java/org/joda/time/MutableDateTime.java
@@ -55,7 +55,7 @@
 
 import java.io.Serializable;
 
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 import org.joda.time.convert.ConverterManager;
 import org.joda.time.convert.DurationConverter;
 import org.joda.time.convert.InstantConverter;
diff --git a/JodaTime/src/java/org/joda/time/MutableTimeOnly.java b/JodaTime/src/java/org/joda/time/MutableTimeOnly.java
index ae56ab37e..79ede70c4 100644
--- a/JodaTime/src/java/org/joda/time/MutableTimeOnly.java
+++ b/JodaTime/src/java/org/joda/time/MutableTimeOnly.java
@@ -55,7 +55,7 @@
 
 import java.io.Serializable;
 
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 import org.joda.time.convert.ConverterManager;
 import org.joda.time.convert.DurationConverter;
 import org.joda.time.format.ISODateTimeFormat;
diff --git a/JodaTime/src/java/org/joda/time/TimeOnly.java b/JodaTime/src/java/org/joda/time/TimeOnly.java
index 3253d00c2..00cf0bf2b 100644
--- a/JodaTime/src/java/org/joda/time/TimeOnly.java
+++ b/JodaTime/src/java/org/joda/time/TimeOnly.java
@@ -55,7 +55,7 @@
 
 import java.io.Serializable;
 
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 // Import for @link support
 import org.joda.time.convert.ConverterManager;
 import org.joda.time.format.ISODateTimeFormat;
diff --git a/JodaTime/src/java/org/joda/time/chrono/AbstractChronology.java b/JodaTime/src/java/org/joda/time/chrono/AbstractChronology.java
new file mode 100644
index 000000000..46c378729
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/AbstractChronology.java
@@ -0,0 +1,600 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import java.io.Serializable;
+
+import org.joda.time.Chronology;
+// Import for @link support
+import org.joda.time.DateTimeConstants;
+import org.joda.time.DateTimeZone;
+import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+import org.joda.time.field.UnsupportedDateTimeField;
+import org.joda.time.field.UnsupportedDurationField;
+
+/**
+ * AbstractChronology provides a skeleton implementation for chronology
+ * classes. Many utility methods are defined, but all fields are unsupported.
+ * <p>
+ * AbstractChronology is thread-safe and immutable, and all subclasses must be
+ * as well.
+ *
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+public abstract class AbstractChronology implements Chronology, Serializable {
+    
+    static final long serialVersionUID = -7310865996721419676L;
+
+    /**
+     * Restricted constructor
+     */
+    protected AbstractChronology() {
+        super();
+    }
+
+    /**
+     * Returns the DateTimeZone that this Chronology operates in, or null if
+     * unspecified.
+     *
+     * @return DateTimeZone null if unspecified
+     */
+    public abstract DateTimeZone getDateTimeZone();
+
+    /**
+     * Returns an instance of this Chronology that operates in the UTC time
+     * zone. Chronologies that do not operate in a time zone or are already
+     * UTC must return themself.
+     *
+     * @return a version of this chronology that ignores time zones
+     */
+    public abstract Chronology withUTC();
+    
+    /**
+     * Returns an instance of this Chronology that operates in any time zone.
+     *
+     * @return a version of this chronology with a specific time zone
+     * @param zone to use, or default if null
+     * @see org.joda.time.chrono.ZonedChronology
+     */
+    public abstract Chronology withDateTimeZone(DateTimeZone zone);
+
+    /**
+     * Returns a date-only millisecond instant, by clearing the time fields
+     * from the given instant.
+     * <p>
+     * The default implementation simply returns
+     * <code>dayOfYear().roundFloor(instant)</code>.
+     * 
+     * @param instant the milliseconds from 1970-01-01T00:00:00Z
+     * @return millisecond instant from 1970-01-01T00:00:00Z with the time part
+     * cleared
+     */
+    public long getDateOnlyMillis(long instant) {
+        return dayOfYear().roundFloor(instant);
+    }
+
+    /**
+     * Returns a date-only millisecond instant, formed from the given year,
+     * month, and day values. The set of given values must refer to a valid
+     * date, or else an IllegalArgumentException is thrown.
+     * <p>
+     * The default implementation simply returns
+     * <code>getDateTimeMillis(year, monthOfYear, dayOfMonth, 0)</code>.
+     *
+     * @param year year to use
+     * @param monthOfYear month to use
+     * @param dayOfMonth day of month to use
+     * @return millisecond instant from 1970-01-01T00:00:00Z without any time
+     * part
+     */
+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
+        throws IllegalArgumentException
+    {
+        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);
+    }
+
+    /**
+     * Returns a time-only millisecond instant, by clearing the date fields
+     * from the given instant.
+     * <p>
+     * The default implementation simply returns
+     * <code>dayOfYear().remainder(instant)</code>.
+     * 
+     * @param instant the milliseconds from 1970-01-01T00:00:00Z
+     * @return millisecond instant from 1970-01-01T00:00:00Z with the date part
+     * cleared
+     */
+    public long getTimeOnlyMillis(long instant) {
+        return dayOfYear().remainder(instant);
+    }
+
+    /**
+     * Returns a time-only millisecond instant, formed from the given hour,
+     * minute, second, and millisecond values. The set of given values must
+     * refer to a valid time, or else an IllegalArgumentException is thrown.
+     * <p>
+     * The default implementation calls upon separate DateTimeFields to
+     * determine the result. Subclasses are encouraged to provide a more
+     * efficient implementation.
+     *
+     * @param hourOfDay hour to use
+     * @param minuteOfHour minute to use
+     * @param secondOfMinute second to use
+     * @param millisOfSecond millisecond to use
+     * @return millisecond instant from 1970-01-01T00:00:00Z without any date
+     * part
+     */
+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        long instant = hourOfDay().set(0, hourOfDay);
+        instant = minuteOfHour().set(instant, minuteOfHour);
+        instant = secondOfMinute().set(instant, secondOfMinute);
+        return millisOfSecond().set(instant, millisOfSecond);
+    }
+
+    /**
+     * Returns a datetime millisecond instant, formed from the given year,
+     * month, day, and millisecond values. The set of given values must refer
+     * to a valid datetime, or else an IllegalArgumentException is thrown.
+     * <p>
+     * The default implementation calls upon separate DateTimeFields to
+     * determine the result. Subclasses are encouraged to provide a more
+     * efficient implementation.
+     *
+     * @param year year to use
+     * @param monthOfYear month to use
+     * @param dayOfMonth day of month to use
+     * @param millisOfDay millisecond to use
+     * @return millisecond instant from 1970-01-01T00:00:00Z
+     */
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int millisOfDay)
+        throws IllegalArgumentException
+    {
+        long instant = year().set(0, year);
+        instant = monthOfYear().set(instant, monthOfYear);
+        instant = dayOfMonth().set(instant, dayOfMonth);
+        return millisOfDay().set(instant, millisOfDay);
+    }
+
+    /**
+     * Returns a datetime millisecond instant, from from the given instant,
+     * hour, minute, second, and millisecond values. The set of given values
+     * must refer to a valid datetime, or else an IllegalArgumentException is
+     * thrown.
+     * <p>
+     * The default implementation calls upon separate DateTimeFields to
+     * determine the result. Subclasses are encouraged to provide a more
+     * efficient implementation.
+     *
+     * @param instant instant to start from
+     * @param hourOfDay hour to use
+     * @param minuteOfHour minute to use
+     * @param secondOfMinute second to use
+     * @param millisOfSecond millisecond to use
+     * @return millisecond instant from 1970-01-01T00:00:00Z
+     */
+    public long getDateTimeMillis(long instant,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        instant = hourOfDay().set(instant, hourOfDay);
+        instant = minuteOfHour().set(instant, minuteOfHour);
+        instant = secondOfMinute().set(instant, secondOfMinute);
+        return millisOfSecond().set(instant, millisOfSecond);
+    }
+
+    /**
+     * Returns a datetime millisecond instant, formed from the given year,
+     * month, day, hour, minute, second, and millisecond values. The set of
+     * given values must refer to a valid datetime, or else an
+     * IllegalArgumentException is thrown.
+     * <p>
+     * The default implementation calls upon separate DateTimeFields to
+     * determine the result. Subclasses are encouraged to provide a more
+     * efficient implementation.
+     *
+     * @param year year to use
+     * @param monthOfYear month to use
+     * @param dayOfMonth day of month to use
+     * @param hourOfDay hour to use
+     * @param minuteOfHour minute to use
+     * @param secondOfMinute second to use
+     * @param millisOfSecond millisecond to use
+     * @return millisecond instant from 1970-01-01T00:00:00Z
+     */
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        long instant = year().set(0, year);
+        instant = monthOfYear().set(instant, monthOfYear);
+        instant = dayOfMonth().set(instant, dayOfMonth);
+        instant = hourOfDay().set(instant, hourOfDay);
+        instant = minuteOfHour().set(instant, minuteOfHour);
+        instant = secondOfMinute().set(instant, secondOfMinute);
+        return millisOfSecond().set(instant, millisOfSecond);
+    }
+
+    // Millis
+    //-----------------------------------------------------------------------
+    /**
+     * Get the millis duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField millis() {
+        return UnsupportedDurationField.getInstance("millis");
+    }
+
+    /**
+     * Get the millis of second field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField millisOfSecond() {
+        return UnsupportedDateTimeField.getInstance("millisOfSecond", millis());
+    }
+
+    /**
+     * Get the millis of day field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField millisOfDay() {
+        return UnsupportedDateTimeField.getInstance("millisOfDay", millis());
+    }
+
+    // Second
+    //-----------------------------------------------------------------------
+    /**
+     * Get the seconds duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField seconds() {
+        return UnsupportedDurationField.getInstance("seconds");
+    }
+
+    /**
+     * Get the second of minute field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField secondOfMinute() {
+        return UnsupportedDateTimeField.getInstance("secondOfMinute", seconds());
+    }
+
+    /**
+     * Get the second of day field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField secondOfDay() {
+        return UnsupportedDateTimeField.getInstance("secondOfDay", seconds());
+    }
+
+    // Minute
+    //-----------------------------------------------------------------------
+    /**
+     * Get the minutes duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField minutes() {
+        return UnsupportedDurationField.getInstance("minutes");
+    }
+
+    /**
+     * Get the minute of hour field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField minuteOfHour() {
+        return UnsupportedDateTimeField.getInstance("minuteOfHour", minutes());
+    }
+
+    /**
+     * Get the minute of day field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField minuteOfDay() {
+        return UnsupportedDateTimeField.getInstance("minuteOfDay", minutes());
+    }
+
+    // Hour
+    //-----------------------------------------------------------------------
+    /**
+     * Get the hours duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField hours() {
+        return UnsupportedDurationField.getInstance("hours");
+    }
+
+    /**
+     * Get the hour of day (0-23) field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField hourOfDay() {
+        return UnsupportedDateTimeField.getInstance("hourOfDay", hours());
+    }
+
+    /**
+     * Get the hour of day (offset to 1-24) field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField clockhourOfDay() {
+        return UnsupportedDateTimeField.getInstance("clockhourOfDay", hours());
+    }
+
+    /**
+     * Get the hour of am/pm (0-11) field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField hourOfHalfday() {
+        return UnsupportedDateTimeField.getInstance("hourOfHalfday", hours());
+    }
+
+    /**
+     * Get the hour of am/pm (offset to 1-12) field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField clockhourOfHalfday() {
+        return UnsupportedDateTimeField.getInstance("clockhourOfHalfday", hours());
+    }
+
+    /**
+     * Get the AM(0) PM(1) field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField halfdayOfDay() {
+        return UnsupportedDateTimeField.getInstance
+            ("halfdayOfDay", UnsupportedDurationField.getInstance("halfdays"));
+    }
+
+    // Day
+    //-----------------------------------------------------------------------
+    /**
+     * Get the days duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField days() {
+        return UnsupportedDurationField.getInstance("days");
+    }
+
+    /**
+     * Get the day of week field for this chronology.
+     *
+     * <p>DayOfWeek values are defined in {@link DateTimeConstants}.
+     * They use the ISO definitions, where 1 is Monday and 7 is Sunday.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField dayOfWeek() {
+        return UnsupportedDateTimeField.getInstance("dayOfWeek", days());
+    }
+
+    /**
+     * Get the day of month field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField dayOfMonth() {
+        return UnsupportedDateTimeField.getInstance("dayOfMonth", days());
+    }
+
+    /**
+     * Get the day of year field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField dayOfYear() {
+        return UnsupportedDateTimeField.getInstance("dayOfYear", days());
+    }
+
+    // Week
+    //-----------------------------------------------------------------------
+    /**
+     * Get the weeks duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField weeks() {
+        return UnsupportedDurationField.getInstance("weeks");
+    }
+
+    /**
+     * Get the week of a week based year field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField weekOfWeekyear() {
+        return UnsupportedDateTimeField.getInstance("weekOfWeekyear", weeks());
+    }
+
+    /**
+     * Get the weekyears duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField weekyears() {
+        return UnsupportedDurationField.getInstance("weekyears");
+    }
+
+    /**
+     * Get the year of a week based year field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField weekyear() {
+        return UnsupportedDateTimeField.getInstance("weekyear", weekyears());
+    }
+
+    // Month
+    //-----------------------------------------------------------------------
+    /**
+     * Get the months duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField months() {
+        return UnsupportedDurationField.getInstance("months");
+    }
+
+    /**
+     * Get the month of year field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField monthOfYear() {
+        return UnsupportedDateTimeField.getInstance("monthOfYear", months());
+    }
+
+    // Year
+    //-----------------------------------------------------------------------
+    /**
+     * Get the years duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField years() {
+        return UnsupportedDurationField.getInstance("years");
+    }
+
+    /**
+     * Get the year field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField year() {
+        return UnsupportedDateTimeField.getInstance("year", years());
+    }
+
+    /**
+     * Get the year of era field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField yearOfEra() {
+        return UnsupportedDateTimeField.getInstance("yearOfEra", years());
+    }
+
+    /**
+     * Get the year of century field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField yearOfCentury() {
+        return UnsupportedDateTimeField.getInstance("yearOfCentury", years());
+    }
+
+    /**
+     * Get the centuries duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField centuries() {
+        return UnsupportedDurationField.getInstance("centuries");
+    }
+
+    /**
+     * Get the century of era field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField centuryOfEra() {
+        return UnsupportedDateTimeField.getInstance("centuryOfEra", centuries());
+    }
+
+    /**
+     * Get the eras duration field for this chronology.
+     * 
+     * @return DurationField or UnsupportedDurationField if unsupported
+     */
+    public DurationField eras() {
+        return UnsupportedDurationField.getInstance("eras");
+    }
+
+    /**
+     * Get the era field for this chronology.
+     * 
+     * @return DateTimeField or UnsupportedDateTimeField if unsupported
+     */
+    public DateTimeField era() {
+        return UnsupportedDateTimeField.getInstance("era", eras());
+    }
+
+    /**
+     * Gets a debugging toString.
+     * 
+     * @return a debugging string
+     */
+    public abstract String toString();
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/ProlepticChronology.java b/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java
similarity index 54%
rename from JodaTime/src/java/org/joda/time/chrono/gj/ProlepticChronology.java
rename to JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java
index 486737a61..1936c111b 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/ProlepticChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * Copyright (c) 2001-2004 Stephen Colebourne.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
+ *    notice, this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
+ *    if any, must include the following acknowledgment:
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,37 +47,39 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
+ * individuals on behalf of the Joda project and was originally
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono.gj;
+package org.joda.time.chrono;
 
 import java.util.Locale;
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeZone;
 import org.joda.time.DurationField;
-import org.joda.time.chrono.DividedDateTimeField;
-import org.joda.time.chrono.MillisDurationField;
-import org.joda.time.chrono.NonZeroDateTimeField;
-import org.joda.time.chrono.RemainderDateTimeField;
-import org.joda.time.chrono.PreciseDateTimeField;
-import org.joda.time.chrono.PreciseDurationField;
-import org.joda.time.chrono.Utils;
+import org.joda.time.field.DividedDateTimeField;
+import org.joda.time.field.FieldUtils;
+import org.joda.time.field.MillisDurationField;
+import org.joda.time.field.NonZeroDateTimeField;
+import org.joda.time.field.OffsetDateTimeField;
+import org.joda.time.field.PreciseDateTimeField;
+import org.joda.time.field.PreciseDurationField;
+import org.joda.time.field.RemainderDateTimeField;
 
 /**
- * ProlepticChronology uses a consistent set of rules for all dates and
- * times. Year zero is included.
  *
- * @author Brian S O'Neill
+ *
  * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ * @author Guy Allard
  * @since 1.0
  */
-abstract class ProlepticChronology extends GJChronology {
+public abstract class AbstractGJChronology extends AssembledChronology {
 
-    static final long serialVersionUID = 541866437970475456L;
+    static final long serialVersionUID = 8283225332206808863L;
 
     static final long MILLIS_1970_TO_2000 = 946684800000L;
 
@@ -186,13 +188,19 @@
 
     private final int iMinDaysInFirstWeek;
 
-    ProlepticChronology(int minDaysInFirstWeek) {
-        super();
+    AbstractGJChronology(Chronology base, Object param, int minDaysInFirstWeek) {
+        super(base, param);
+
+        if (minDaysInFirstWeek < 1 || minDaysInFirstWeek > 7) {
+            throw new IllegalArgumentException
+                ("Invalid min days in first week: " + minDaysInFirstWeek);
+        }
+
         iMinDaysInFirstWeek = minDaysInFirstWeek;
 
         Integer i;
         try {
-            i = Integer.getInteger("org.joda.time.gj.ProlepticChronology.yearInfoCacheSize");
+            i = Integer.getInteger(getClass().getName().concat(".yearInfoCacheSize"));
         } catch (SecurityException e) {
             i = null;
         }
@@ -214,72 +222,28 @@
 
         iYearInfoCache = new YearInfo[cacheSize];
         iYearInfoCacheMask = cacheSize - 1;
-
-        // First copy fields that are the same for all Gregorian and Julian
-        // chronologies.
-
-        iMillisField = cMillisField;
-        iSecondsField = cSecondsField;
-        iMinutesField = cMinutesField;
-        iHoursField = cHoursField;
-        //iHalfdaysField = cHalfdaysField;  Doesn't exist in public interface
-        iDaysField = cDaysField;
-        iWeeksField = cWeeksField;
-
-        iMillisOfSecondField = cMillisOfSecondField;
-        iMillisOfDayField = cMillisOfDayField;
-        iSecondOfMinuteField = cSecondOfMinuteField;
-        iSecondOfDayField = cSecondOfDayField;
-        iMinuteOfHourField = cMinuteOfHourField;
-        iMinuteOfDayField = cMinuteOfDayField;
-        iHourOfDayField = cHourOfDayField;
-        iHourOfHalfdayField = cHourOfHalfdayField;
-        iClockhourOfDayField = cClockhourOfDayField;
-        iClockhourOfHalfdayField = cClockhourOfHalfdayField;
-        iHalfdayOfDayField = cHalfdayOfDayField;
-
-        // Now create fields that have unique behavior for Gregorian and Julian
-        // chronologies.
-
-        iYearField = new GJYearDateTimeField(this);
-        iYearOfEraField = new GJYearOfEraDateTimeField(iYearField, this);
-
-        iCenturyOfEraField = new DividedDateTimeField
-            (iYearOfEraField, "centuryOfEra", "centuries", 100);
-        iYearOfCenturyField = new RemainderDateTimeField
-            ((DividedDateTimeField)iCenturyOfEraField, "yearOfCentury");
-
-        iEraField = new GJEraDateTimeField(this);
-        iDayOfWeekField = new GJDayOfWeekDateTimeField(this, iDaysField);
-        iDayOfMonthField = new GJDayOfMonthDateTimeField(this, iDaysField);
-        iDayOfYearField = new GJDayOfYearDateTimeField(this, iDaysField);
-        iMonthOfYearField = new GJMonthOfYearDateTimeField(this);
-        iWeekyearField = new GJWeekyearDateTimeField(this);
-        iWeekOfWeekyearField = new GJWeekOfWeekyearDateTimeField(this, iWeeksField);
-
-        // The remaining (imprecise) durations are available from the newly
-        // created datetime fields.
-
-        iYearsField = iYearField.getDurationField();
-        iCenturiesField = iCenturyOfEraField.getDurationField();
-        iMonthsField = iMonthOfYearField.getDurationField();
-        iWeekyearsField = iWeekyearField.getDurationField();
     }
 
-    public Chronology withUTC() {
-        return this;
+    public DateTimeZone getDateTimeZone() {
+        Chronology base;
+        if ((base = getBase()) != null) {
+            return base.getDateTimeZone();
+        }
+        return DateTimeZone.UTC;
     }
 
-    /**
-     * Override the default implementation
-     */
-    public final long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
         throws IllegalArgumentException
     {
+        Chronology base;
+        if ((base = getBase()) != null) {
+            return base.getDateOnlyMillis(year, monthOfYear, dayOfMonth);
+        }
+
         boolean isLeap = isLeapYear(year);
 
-        Utils.verifyValueBounds("monthOfYear", monthOfYear, 1, 12);
-        Utils.verifyValueBounds("dayOfMonth", dayOfMonth, 1,
+        FieldUtils.verifyValueBounds("monthOfYear", monthOfYear, 1, 12);
+        FieldUtils.verifyValueBounds("dayOfMonth", dayOfMonth, 1,
                                 (isLeap ? MAX_DAYS_PER_MONTH_ARRAY : MIN_DAYS_PER_MONTH_ARRAY)
                                 [monthOfYear - 1]);
 
@@ -298,18 +262,19 @@ public final long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
         return instant;
     }
 
-    /**
-     * Override the default implementation
-     */
-    public final long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
-                                        int secondOfMinute, int millisOfSecond)
+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
         throws IllegalArgumentException
     {
+        Chronology base;
+        if ((base = getBase()) != null) {
+            return base.getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+        }
 
-        Utils.verifyValueBounds("hourOfDay", hourOfDay, 0, 23);
-        Utils.verifyValueBounds("minuteOfHour", minuteOfHour, 0, 59);
-        Utils.verifyValueBounds("secondOfMinute", secondOfMinute, 0, 59);
-        Utils.verifyValueBounds("millisOfSecond", millisOfSecond, 0, 999);
+        FieldUtils.verifyValueBounds("hourOfDay", hourOfDay, 0, 23);
+        FieldUtils.verifyValueBounds("minuteOfHour", minuteOfHour, 0, 59);
+        FieldUtils.verifyValueBounds("secondOfMinute", secondOfMinute, 0, 59);
+        FieldUtils.verifyValueBounds("millisOfSecond", millisOfSecond, 0, 999);
 
         return hourOfDay * DateTimeConstants.MILLIS_PER_HOUR
             + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE
@@ -317,59 +282,143 @@ public final long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
             + millisOfSecond;
     }
 
-    /**
-     * Override the default implementation
-     */
     public final long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
                                         int millisOfDay)
         throws IllegalArgumentException
     {
-        Utils.verifyValueBounds("millisOfDay", millisOfDay, 0, DateTimeConstants.MILLIS_PER_DAY);
+        Chronology base;
+        if ((base = getBase()) != null) {
+            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);
+        }
+        FieldUtils.verifyValueBounds("millisOfDay", millisOfDay, 0, DateTimeConstants.MILLIS_PER_DAY);
         return getDateOnlyMillis(year, monthOfYear, dayOfMonth) + millisOfDay;
     }
 
-    /**
-     * Override the default implementation
-     */
     public final long getDateTimeMillis(long instant,
                                         int hourOfDay, int minuteOfHour,
                                         int secondOfMinute, int millisOfSecond)
         throws IllegalArgumentException
     {
+        Chronology base;
+        if ((base = getBase()) != null) {
+            return base.getDateTimeMillis
+                (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+        }
         return getDateOnlyMillis(instant)
             + getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
     }
 
-    /**
-     * Override the default implementation
-     */
     public final long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
                                         int hourOfDay, int minuteOfHour,
                                         int secondOfMinute, int millisOfSecond)
         throws IllegalArgumentException
     {
+        Chronology base;
+        if ((base = getBase()) != null) {
+            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,
+                                          hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+        }
         return getDateOnlyMillis(year, monthOfYear, dayOfMonth)
             + getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
     }
 
-    public final boolean isCenturyISO() {
-        return true;
-    }
-
     public final int getMinimumDaysInFirstWeek() {
         return iMinDaysInFirstWeek;
     }
 
+    // Output
+    //-----------------------------------------------------------------------
+    /**
+     * Gets a debugging toString.
+     * 
+     * @return a debugging string
+     */
+    public String toString() {
+        StringBuffer sb = new StringBuffer(60);
+        String name = getClass().getName();
+        int index = name.lastIndexOf('.');
+        if (index >= 0) {
+            name = name.substring(index + 1);
+        }
+        sb.append(name);
+        sb.append('[');
+        DateTimeZone zone = getDateTimeZone();
+        if (zone != null) {
+            sb.append(zone.getID());
+            sb.append(", ");
+        }
+        sb.append("mdfw=");
+        sb.append(getMinimumDaysInFirstWeek());
+        sb.append(']');
+        return sb.toString();
+    }
+
+    protected void assemble(Fields fields) {
+        // First copy fields that are the same for all Gregorian and Julian
+        // chronologies.
+
+        fields.millis = cMillisField;
+        fields.seconds = cSecondsField;
+        fields.minutes = cMinutesField;
+        fields.hours = cHoursField;
+        //fields.halfdays = cHalfdaysField;  Doesn't exist in public interface
+        fields.days = cDaysField;
+        fields.weeks = cWeeksField;
+
+        fields.millisOfSecond = cMillisOfSecondField;
+        fields.millisOfDay = cMillisOfDayField;
+        fields.secondOfMinute = cSecondOfMinuteField;
+        fields.secondOfDay = cSecondOfDayField;
+        fields.minuteOfHour = cMinuteOfHourField;
+        fields.minuteOfDay = cMinuteOfDayField;
+        fields.hourOfDay = cHourOfDayField;
+        fields.hourOfHalfday = cHourOfHalfdayField;
+        fields.clockhourOfDay = cClockhourOfDayField;
+        fields.clockhourOfHalfday = cClockhourOfHalfdayField;
+        fields.halfdayOfDay = cHalfdayOfDayField;
+
+        // Now create fields that have unique behavior for Gregorian and Julian
+        // chronologies.
+
+        fields.year = new GJYearDateTimeField(this);
+        fields.yearOfEra = new GJYearOfEraDateTimeField(fields.year, this);
+
+        // Define one-based centuryOfEra and yearOfCentury.
+        DateTimeField field = new OffsetDateTimeField(fields.yearOfEra, "", 99);
+        fields.centuryOfEra = new DividedDateTimeField
+            (field, "centuryOfEra", "centuries", 100);
+        
+        field = new RemainderDateTimeField
+            ((DividedDateTimeField)fields.centuryOfEra, "");
+        fields.yearOfCentury = new OffsetDateTimeField(field, "yearOfCentury", 1);
+
+        fields.era = new GJEraDateTimeField(this);
+        fields.dayOfWeek = new GJDayOfWeekDateTimeField(this, fields.days);
+        fields.dayOfMonth = new GJDayOfMonthDateTimeField(this, fields.days);
+        fields.dayOfYear = new GJDayOfYearDateTimeField(this, fields.days);
+        fields.monthOfYear = new GJMonthOfYearDateTimeField(this);
+        fields.weekyear = new GJWeekyearDateTimeField(this);
+        fields.weekOfWeekyear = new GJWeekOfWeekyearDateTimeField(this, fields.weeks);
+
+        // The remaining (imprecise) durations are available from the newly
+        // created datetime fields.
+
+        fields.years = fields.year.getDurationField();
+        fields.centuries = fields.centuryOfEra.getDurationField();
+        fields.months = fields.monthOfYear.getDurationField();
+        fields.weekyears = fields.weekyear.getDurationField();
+    }
+
     /**
      * Get the number of days in the year.
      * @param year The year to use.
      * @return 366 if a leap year, otherwise 365.
      */
-    public final int getDaysInYear(int year) {
+    final int getDaysInYear(int year) {
         return isLeapYear(year) ? 366 : 365;
     }
 
-    public final int getDaysInYearMonth(int year, int month) {
+    final int getDaysInYearMonth(int year, int month) {
         if (isLeapYear(year)) {
             return MAX_DAYS_PER_MONTH_ARRAY[month - 1];
         } else {
@@ -381,7 +430,7 @@ public final int getDaysInYearMonth(int year, int month) {
      * Returns the total number of milliseconds elapsed in the year, by the end
      * of the month.
      */
-    public final long getTotalMillisByYearMonth(int year, int month) {
+    final long getTotalMillisByYearMonth(int year, int month) {
         if (isLeapYear(year)) {
             return MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];
         } else {
@@ -394,7 +443,7 @@ public final long getTotalMillisByYearMonth(int year, int month) {
      * @param year  the year to use.
      * @return number of weeks in the year.
      */
-    public final int getWeeksInYear(int year) {
+    final int getWeeksInYear(int year) {
         long firstWeekMillis1 = getFirstWeekOfYearMillis(year);
         long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1);
         return (int) ((firstWeekMillis2 - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK);
@@ -405,9 +454,9 @@ public final int getWeeksInYear(int year) {
      * @param year  the year to use.
      * @return millis
      */
-    public final long getFirstWeekOfYearMillis(int year) {
+    final long getFirstWeekOfYearMillis(int year) {
         long jan1millis = getYearMillis(year);
-        int jan1dayOfWeek = dayOfWeek().get(jan1millis);
+        int jan1dayOfWeek = getDayOfWeek(jan1millis);
         
         if (jan1dayOfWeek > (8 - iMinDaysInFirstWeek)) {
             // First week is end of previous year because it doesn't have enough days.
@@ -426,7 +475,7 @@ public final long getFirstWeekOfYearMillis(int year) {
      * @param year The year to use.
      * @return millis from 1970-01-01T00:00:00Z
      */
-    public final long getYearMillis(int year) {
+    final long getYearMillis(int year) {
         return getYearInfo(year).iFirstDayMillis;
         //return calculateFirstDayOfYearMillis(year);
     }
@@ -438,7 +487,7 @@ public final long getYearMillis(int year) {
      * @param month The month to use
      * @return millis from 1970-01-01T00:00:00Z
      */
-    public final long getYearMonthMillis(int year, int month) {
+    final long getYearMonthMillis(int year, int month) {
         long millis = getYearMillis(year);
         // month
         if (month > 1) {
@@ -455,7 +504,7 @@ public final long getYearMonthMillis(int year, int month) {
      * @param dayOfMonth The day of the month to use
      * @return millis from 1970-01-01T00:00:00Z
      */
-    public final long getYearMonthDayMillis(int year, int month, int dayOfMonth) {
+    final long getYearMonthDayMillis(int year, int month, int dayOfMonth) {
         long millis = getYearMillis(year);
         // month
         if (month > 1) {
@@ -465,18 +514,134 @@ public final long getYearMonthDayMillis(int year, int month, int dayOfMonth) {
         return millis + (dayOfMonth - 1) * (long)DateTimeConstants.MILLIS_PER_DAY;
     }
     
+    /**
+     * @param instant millis from 1970-01-01T00:00:00Z
+     */
+    final int getYear(long instant) {
+        // Get an initial estimate of the year, and the millis value that
+        // represents the start of that year. Then verify estimate and fix if
+        // necessary.
+
+        long unitMillis = getAverageMillisPerYear();
+        long i2 = instant + getApproxMillisAtEpoch();
+        if (i2 < 0) {
+            i2 = i2 - unitMillis + 1;
+        }
+        int year = (int) (i2 / unitMillis);
+
+        long yearStart = getYearMillis(year);
+        long diff = instant - yearStart;
+
+        if (diff < 0) {
+            if (diff < -DateTimeConstants.MILLIS_PER_DAY * 2L) {
+                // Too much error, assume operation overflowed.
+                return getYearOverflow(instant);
+            }
+            year--;
+        } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) {
+            if (diff >= DateTimeConstants.MILLIS_PER_DAY * 367L) {
+                // Too much error, assume operation overflowed.
+                return getYearOverflow(instant);
+            }
+            // One year may need to be added to fix estimate.
+            long oneYear;
+            if (isLeapYear(year)) {
+                oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L;
+            } else {
+                oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L;
+            }
+
+            yearStart += oneYear;
+
+            if ((yearStart ^ instant) < 0) {
+                // Sign mismatch, operation may have overflowed.
+                if ((yearStart <  0 && (yearStart - oneYear) >= 0) ||
+                    (yearStart >= 0 && (yearStart - oneYear) <  0)   ) {
+                    // It overflowed.
+                    return getYearOverflow(instant);
+                }
+            }
+
+            if (yearStart <= instant) {
+                // Didn't go too far, so actually add one year.
+                year++;
+            }
+        }
+
+        return year;
+    }
+
+    private final int getYearOverflow(long instant) {
+        if (instant > 0) {
+            int year = getMaxYear();
+            long yearStartMillis = getYearMillis(year);
+            if (isLeapYear(year)) {
+                yearStartMillis += DateTimeConstants.MILLIS_PER_DAY * 366L;
+            } else {
+                yearStartMillis += DateTimeConstants.MILLIS_PER_DAY * 365L;
+            }
+            long yearEndMillis = yearStartMillis - 1;
+
+            if (instant <= yearEndMillis) {
+                return year;
+            }
+
+            throw new IllegalArgumentException
+                ("Instant too large: " + instant + " > " + yearEndMillis);
+        } else {
+            int year = getMinYear();
+            long yearStartMillis = getYearMillis(year);
+            if (instant >= yearStartMillis) {
+                return year;
+            }
+
+            throw new IllegalArgumentException
+                ("Instant too small: " + instant + " < " + yearStartMillis);
+        }
+    }
+
+    /**
+     * @param instant millis from 1970-01-01T00:00:00Z
+     */
+    final long setYear(long instant, int year) {
+        int thisYear = getYear(instant);
+        int dayOfYear = getDayOfYear(instant, thisYear);
+        int millisOfDay = getMillisOfDay(instant);
+
+        if (dayOfYear > (31 + 28)) { // after Feb 28
+            if (isLeapYear(thisYear)) {
+                // Current date is Feb 29 or later.
+                if (!isLeapYear(year)) {
+                    // Moving to a non-leap year, Feb 29 does not exist.
+                    dayOfYear--;
+                }
+            } else {
+                // Current date is Mar 01 or later.
+                if (isLeapYear(year)) {
+                    // Moving to a leap year, account for Feb 29.
+                    dayOfYear++;
+                }
+            }
+        }
+
+        instant = getYearMonthDayMillis(year, 1, dayOfYear);
+        instant += millisOfDay;
+
+        return instant;
+    }
+
     /**
      * @param millis from 1970-01-01T00:00:00Z
      */
-    public final int getMonthOfYear(long millis) {
-        return getMonthOfYear(millis, year().get(millis));
+    final int getMonthOfYear(long millis) {
+        return getMonthOfYear(millis, getYear(millis));
     }
 
     /**
      * @param millis from 1970-01-01T00:00:00Z
      * @param year precalculated year of millis
      */
-    public final int getMonthOfYear(long millis, int year) {
+    final int getMonthOfYear(long millis, int year) {
         // Perform a binary search to get the month. To make it go even faster,
         // compare using ints instead of longs. The number of milliseconds per
         // year exceeds the limit of a 32-bit int's capacity, so divide by
@@ -511,8 +676,8 @@ public final int getMonthOfYear(long millis, int year) {
     /**
      * @param millis from 1970-01-01T00:00:00Z
      */
-    public final int getDayOfMonth(long millis) {
-        int year = year().get(millis);
+    final int getDayOfMonth(long millis) {
+        int year = getYear(millis);
         int month = getMonthOfYear(millis, year);
         return getDayOfMonth(millis, year, month);
     }
@@ -521,7 +686,7 @@ public final int getDayOfMonth(long millis) {
      * @param millis from 1970-01-01T00:00:00Z
      * @param year precalculated year of millis
      */
-    public final int getDayOfMonth(long millis, int year) {
+    final int getDayOfMonth(long millis, int year) {
         int month = getMonthOfYear(millis, year);
         return getDayOfMonth(millis, year, month);
     }
@@ -531,7 +696,7 @@ public final int getDayOfMonth(long millis, int year) {
      * @param year precalculated year of millis
      * @param month precalculated month of millis
      */
-    public final int getDayOfMonth(long millis, int year, int month) {
+    final int getDayOfMonth(long millis, int year, int month) {
         long dateMillis = getYearMillis(year);
         if (month > 1) {
             dateMillis += getTotalMillisByYearMonth(year, month - 1);
@@ -539,17 +704,114 @@ public final int getDayOfMonth(long millis, int year, int month) {
         return (int) ((millis - dateMillis) / DateTimeConstants.MILLIS_PER_DAY) + 1;
     }
 
-    public abstract boolean isLeapYear(int year);
+    /**
+     * @param instant millis from 1970-01-01T00:00:00Z
+     */
+    final int getDayOfYear(long instant) {
+        return getDayOfYear(instant, getYear(instant));
+    }
+
+    /**
+     * @param instant millis from 1970-01-01T00:00:00Z
+     * @param year precalculated year of millis
+     */
+    final int getDayOfYear(long instant, int year) {
+        long yearStart = getYearMillis(year);
+        return (int) ((instant - yearStart) / DateTimeConstants.MILLIS_PER_DAY) + 1;
+    }
+
+    /**
+     * @param instant millis from 1970-01-01T00:00:00Z
+     */
+    final int getWeekyear(long instant) {
+        int year = getYear(instant);
+        int week = getWeekOfWeekyear(instant, year);
+        if (week == 1) {
+            return getYear(instant + DateTimeConstants.MILLIS_PER_WEEK);
+        } else if (week > 51) {
+            return getYear(instant - (2 * DateTimeConstants.MILLIS_PER_WEEK));
+        } else {
+            return year;
+        }
+    }
+
+    /**
+     * @param instant millis from 1970-01-01T00:00:00Z
+     */
+    final int getWeekOfWeekyear(long instant) {
+        return getWeekOfWeekyear(instant, getYear(instant));
+    }
+
+    /**
+     * @param instant millis from 1970-01-01T00:00:00Z
+     * @param year precalculated year of millis
+     */
+    final int getWeekOfWeekyear(long instant, int year) {
+        long firstWeekMillis1 = getFirstWeekOfYearMillis(year);
+        if (instant < firstWeekMillis1) {
+            return getWeeksInYear(year - 1);
+        }
+        long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1);
+        if (instant >= firstWeekMillis2) {
+            return 1;
+        }
+        return (int) ((instant - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1;
+    }
+
+    /**
+     * @param instant millis from 1970-01-01T00:00:00Z
+     */
+    final int getDayOfWeek(long instant) {
+        // 1970-01-01 is day of week 4, Thursday.
+
+        long daysSince19700101;
+        if (instant >= 0) {
+            daysSince19700101 = instant / DateTimeConstants.MILLIS_PER_DAY;
+        } else {
+            daysSince19700101 = (instant - (DateTimeConstants.MILLIS_PER_DAY - 1))
+                / DateTimeConstants.MILLIS_PER_DAY;
+            if (daysSince19700101 < -3) {
+                return 7 + (int) ((daysSince19700101 + 4) % 7);
+            }
+        }
+
+        return 1 + (int) ((daysSince19700101 + 3) % 7);
+    }
+
+    /**
+     * @param instant millis from 1970-01-01T00:00:00Z
+     */
+    final int getMillisOfDay(long instant) {
+        if (instant >= 0) {
+            return (int) (instant % DateTimeConstants.MILLIS_PER_DAY);
+        } else {
+            return (DateTimeConstants.MILLIS_PER_DAY - 1)
+                + (int) ((instant + 1) % DateTimeConstants.MILLIS_PER_DAY);
+        }
+    }
+
+    abstract boolean isLeapYear(int year);
 
-    protected abstract long calculateFirstDayOfYearMillis(int year);
+    abstract long calculateFirstDayOfYearMillis(int year);
 
-    protected abstract int getMinYear();
+    abstract int getMinYear();
 
-    protected abstract int getMaxYear();
+    abstract int getMaxYear();
 
-    protected abstract long getRoughMillisPerYear();
+    abstract long getAverageMillisPerYear();
 
-    protected abstract long getRoughMillisPerMonth();
+    abstract long getAverageMillisPerMonth();
+
+    /**
+     * Returns a constant representing the approximate number of milliseconds
+     * elapsed from year 0 of this chronology. This constant <em>must</em> be
+     * defined as:
+     * <pre>
+     *    yearAtEpoch * averageMillisPerYear + millisOfYearAtEpoch
+     * <pre>
+     * where epoch is 1970-01-01 (Gregorian).
+     */
+    abstract long getApproxMillisAtEpoch();
 
     // Although accessed by multiple threads, this method doesn't need to be synchronized.
     private YearInfo getYearInfo(int year) {
@@ -592,4 +854,5 @@ public int getMaximumTextLength(Locale locale) {
             iFirstDayMillis = firstDayMillis;
         }
     }
+
 }
diff --git a/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java b/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java
new file mode 100644
index 000000000..27b8bb598
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java
@@ -0,0 +1,617 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import java.io.IOException;
+import java.io.ObjectInputStream;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeZone;
+import org.joda.time.DurationField;
+
+/**
+ * Allows chronologies to be assembled from a container of fields.
+ * <p>
+ * AssembledChronology is thread-safe and immutable.
+ *
+ * @author Brian S O'Neill
+ */
+public abstract class AssembledChronology extends AbstractChronology {
+
+    static final long serialVersionUID = -6728465968995518215L;
+
+    private final Chronology iBase;
+    private final Object iParam;
+
+    private transient DurationField iMillis;
+    private transient DurationField iSeconds;
+    private transient DurationField iMinutes;
+    private transient DurationField iHours;
+
+    private transient DurationField iDays;
+    private transient DurationField iWeeks;
+    private transient DurationField iWeekyears;
+    private transient DurationField iMonths;
+    private transient DurationField iYears;
+    private transient DurationField iCenturies;
+    private transient DurationField iEras;
+
+    private transient DateTimeField iMillisOfSecond;
+    private transient DateTimeField iMillisOfDay;
+    private transient DateTimeField iSecondOfMinute;
+    private transient DateTimeField iSecondOfDay;
+    private transient DateTimeField iMinuteOfHour;
+    private transient DateTimeField iMinuteOfDay;
+    private transient DateTimeField iHourOfDay;
+    private transient DateTimeField iClockhourOfDay;
+    private transient DateTimeField iHourOfHalfday;
+    private transient DateTimeField iClockhourOfHalfday;
+    private transient DateTimeField iHalfdayOfDay;
+
+    private transient DateTimeField iDayOfWeek;
+    private transient DateTimeField iDayOfMonth;
+    private transient DateTimeField iDayOfYear;
+    private transient DateTimeField iWeekOfWeekyear;
+    private transient DateTimeField iWeekyear;
+    private transient DateTimeField iMonthOfYear;
+    private transient DateTimeField iYear;
+    private transient DateTimeField iYearOfEra;
+    private transient DateTimeField iYearOfCentury;
+    private transient DateTimeField iCenturyOfEra;
+    private transient DateTimeField iEra;
+
+    // Bit set determines which base fields are used
+    // bit 1 set: hourOfDay, minuteOfHour, secondOfMinute, and millisOfSecond fields
+    // bit 2 set: millisOfDayField
+    // bit 3 set: year, monthOfYear, and dayOfMonth fields
+    private transient int iBaseFlags;
+
+    /**
+     * Constructor calls the assemble method, enabling subclasses to define its
+     * supported fields. If a base chronology is supplied, the field set
+     * initially contains references to each base chronlogy field.
+     * <p>
+     * Other methods in this class will delegate to the base chronology, if it
+     * can be determined that the base chronology will produce the same results
+     * as AbstractChronology.
+     *
+     * @param base optional base chronology to copy initial fields from
+     * @param param optional param object avalable for assemble method
+     */
+    protected AssembledChronology(Chronology base, Object param) {
+        iBase = base;
+        iParam = param;
+        setFields();
+    }
+
+    public DateTimeZone getDateTimeZone() {
+        Chronology base;
+        if ((base = iBase) != null) {
+            return base.getDateTimeZone();
+        }
+        return null;
+    }
+
+    public long getDateOnlyMillis(long instant) {
+        Chronology base;
+        if ((base = iBase) != null) {
+            return base.getDateOnlyMillis(instant);
+        }
+        return super.getDateOnlyMillis(instant);
+    }
+
+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
+        throws IllegalArgumentException
+    {
+        Chronology base;
+        if ((base = iBase) != null && (iBaseFlags & 4) == 4) {
+            // Only call specialized implementation if applicable fields are the same.
+            return base.getDateOnlyMillis(year, monthOfYear, dayOfMonth);
+        }
+        return super.getDateOnlyMillis(year, monthOfYear, dayOfMonth);
+    }
+
+    public long getTimeOnlyMillis(long instant) {
+        Chronology base;
+        if ((base = iBase) != null) {
+            return base.getTimeOnlyMillis(instant);
+        }
+        return super.getTimeOnlyMillis(instant);
+    }
+
+    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        Chronology base;
+        if ((base = iBase) != null && (iBaseFlags & 1) == 1) {
+            // Only call specialized implementation if applicable fields are the same.
+            return base.getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+        }
+        return super.getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+    }
+
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int millisOfDay)
+        throws IllegalArgumentException
+    {
+        Chronology base;
+        if ((base = iBase) != null && (iBaseFlags & 6) == 6) {
+            // Only call specialized implementation if applicable fields are the same.
+            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);
+        }
+        return super.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);
+    }
+
+    public long getDateTimeMillis(long instant,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        Chronology base;
+        if ((base = iBase) != null && (iBaseFlags & 1) == 1) {
+            // Only call specialized implementation if applicable fields are the same.
+            return base.getDateTimeMillis
+                (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+        }
+        return super.getDateTimeMillis
+            (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+    }
+
+    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
+                                  int hourOfDay, int minuteOfHour,
+                                  int secondOfMinute, int millisOfSecond)
+        throws IllegalArgumentException
+    {
+        Chronology base;
+        if ((base = iBase) != null && (iBaseFlags & 5) == 5) {
+            // Only call specialized implementation if applicable fields are the same.
+            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,
+                                          hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+        }
+        return super.getDateTimeMillis(year, monthOfYear, dayOfMonth,
+                                       hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+    }
+
+    public final DurationField millis() {
+        return iMillis;
+    }
+
+    public final DateTimeField millisOfSecond() {
+        return iMillisOfSecond;
+    }
+
+    public final DateTimeField millisOfDay() {
+        return iMillisOfDay;
+    }
+
+    public final DurationField seconds() {
+        return iSeconds;
+    }
+
+    public final DateTimeField secondOfMinute() {
+        return iSecondOfMinute;
+    }
+
+    public final DateTimeField secondOfDay() {
+        return iSecondOfDay;
+    }
+
+    public final DurationField minutes() {
+        return iMinutes;
+    }
+
+    public final DateTimeField minuteOfHour() {
+        return iMinuteOfHour;
+    }
+
+    public final DateTimeField minuteOfDay() {
+        return iMinuteOfDay;
+    }
+
+    public final DurationField hours() {
+        return iHours;
+    }
+
+    public final DateTimeField hourOfDay() {
+        return iHourOfDay;
+    }
+
+    public final DateTimeField clockhourOfDay() {
+        return iClockhourOfDay;
+    }
+
+    public final DateTimeField hourOfHalfday() {
+        return iHourOfHalfday;
+    }
+
+    public final DateTimeField clockhourOfHalfday() {
+        return iClockhourOfHalfday;
+    }
+
+    public final DateTimeField halfdayOfDay() {
+        return iHalfdayOfDay;
+    }
+
+    public final DurationField days() {
+        return iDays;
+    }
+
+    public final DateTimeField dayOfWeek() {
+        return iDayOfWeek;
+    }
+
+    public final DateTimeField dayOfMonth() {
+        return iDayOfMonth;
+    }
+
+    public final DateTimeField dayOfYear() {
+        return iDayOfYear;
+    }
+
+    public final DurationField weeks() {
+        return iWeeks;
+    }
+
+    public final DateTimeField weekOfWeekyear() {
+        return iWeekOfWeekyear;
+    }
+
+    public final DurationField weekyears() {
+        return iWeekyears;
+    }
+
+    public final DateTimeField weekyear() {
+        return iWeekyear;
+    }
+
+    public final DurationField months() {
+        return iMonths;
+    }
+
+    public final DateTimeField monthOfYear() {
+        return iMonthOfYear;
+    }
+
+    public final DurationField years() {
+        return iYears;
+    }
+
+    public final DateTimeField year() {
+        return iYear;
+    }
+
+    public final DateTimeField yearOfEra() {
+        return iYearOfEra;
+    }
+
+    public final DateTimeField yearOfCentury() {
+        return iYearOfCentury;
+    }
+
+    public final DurationField centuries() {
+        return iCenturies;
+    }
+
+    public final DateTimeField centuryOfEra() {
+        return iCenturyOfEra;
+    }
+
+    public final DurationField eras() {
+        return iEras;
+    }
+
+    public final DateTimeField era() {
+        return iEra;
+    }
+
+    /**
+     * Invoked by the constructor and after deserialization to allow subclasses
+     * to define all of its supported fields. All unset fields default to
+     * unsupported instances.
+     *
+     * @param fields container of fields
+     */
+    protected abstract void assemble(Fields fields);
+
+    /**
+     * Returns the same base chronology as passed into the constructor.
+     */
+    protected final Chronology getBase() {
+        return iBase;
+    }
+
+    /**
+     * Returns the same param object as passed into the constructor.
+     */
+    protected final Object getParam() {
+        return iParam;
+    }
+
+    private void setFields() {
+        Fields fields = new Fields();
+        if (iBase != null) {
+            fields.copyFieldsFrom(iBase);
+        }
+        assemble(fields);
+
+        {
+            DurationField f;
+            iMillis    = (f = fields.millis)    != null ? f : super.millis();
+            iSeconds   = (f = fields.seconds)   != null ? f : super.seconds();
+            iMinutes   = (f = fields.minutes)   != null ? f : super.minutes();
+            iHours     = (f = fields.hours)     != null ? f : super.hours();
+            iDays      = (f = fields.days)      != null ? f : super.days();
+            iWeeks     = (f = fields.weeks)     != null ? f : super.weeks();
+            iWeekyears = (f = fields.weekyears) != null ? f : super.weekyears();
+            iMonths    = (f = fields.months)    != null ? f : super.months();
+            iYears     = (f = fields.years)     != null ? f : super.years();
+            iCenturies = (f = fields.centuries) != null ? f : super.centuries();
+            iEras      = (f = fields.eras)      != null ? f : super.eras();
+        }
+
+        {
+            DateTimeField f;
+            iMillisOfSecond     = (f = fields.millisOfSecond)     != null ? f : super.millisOfSecond();
+            iMillisOfDay        = (f = fields.millisOfDay)        != null ? f : super.millisOfDay();
+            iSecondOfMinute     = (f = fields.secondOfMinute)     != null ? f : super.secondOfMinute();
+            iSecondOfDay        = (f = fields.secondOfDay)        != null ? f : super.secondOfDay();
+            iMinuteOfHour       = (f = fields.minuteOfHour)       != null ? f : super.minuteOfHour();
+            iMinuteOfDay        = (f = fields.minuteOfDay)        != null ? f : super.minuteOfDay();
+            iHourOfDay          = (f = fields.hourOfDay)          != null ? f : super.hourOfDay();
+            iClockhourOfDay     = (f = fields.clockhourOfDay)     != null ? f : super.clockhourOfDay();
+            iHourOfHalfday      = (f = fields.hourOfHalfday)      != null ? f : super.hourOfHalfday();
+            iClockhourOfHalfday = (f = fields.clockhourOfHalfday) != null ? f : super.clockhourOfHalfday();
+            iHalfdayOfDay       = (f = fields.halfdayOfDay)       != null ? f : super.halfdayOfDay();
+            iDayOfWeek          = (f = fields.dayOfWeek)          != null ? f : super.dayOfWeek();
+            iDayOfMonth         = (f = fields.dayOfMonth)         != null ? f : super.dayOfMonth();
+            iDayOfYear          = (f = fields.dayOfYear)          != null ? f : super.dayOfYear();
+            iWeekOfWeekyear     = (f = fields.weekOfWeekyear)     != null ? f : super.weekOfWeekyear();
+            iWeekyear           = (f = fields.weekyear)           != null ? f : super.weekyear();
+            iMonthOfYear        = (f = fields.monthOfYear)        != null ? f : super.monthOfYear();
+            iYear               = (f = fields.year)               != null ? f : super.year();
+            iYearOfEra          = (f = fields.yearOfEra)          != null ? f : super.yearOfEra();
+            iYearOfCentury      = (f = fields.yearOfCentury)      != null ? f : super.yearOfCentury();
+            iCenturyOfEra       = (f = fields.centuryOfEra)       != null ? f : super.centuryOfEra();
+            iEra                = (f = fields.era)                != null ? f : super.era();
+        }
+
+        int flags;
+        if (iBase == null) {
+            flags = 0;
+        } else {
+            flags = 
+                ((iHourOfDay      == iBase.hourOfDay()      &&
+                  iMinuteOfHour   == iBase.minuteOfHour()   &&
+                  iSecondOfMinute == iBase.secondOfMinute() &&
+                  iMillisOfSecond == iBase.millisOfSecond()   ) ? 1 : 0) |
+
+                ((iMillisOfDay == iBase.millisOfDay()) ? 2 : 0) |
+
+                ((iYear        == iBase.year()        &&
+                  iMonthOfYear == iBase.monthOfYear() &&
+                  iDayOfMonth  == iBase.dayOfMonth()    ) ? 4 : 0);
+        }
+
+        iBaseFlags = flags;
+    }
+
+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
+        in.defaultReadObject();
+        setFields();
+    }
+
+    public static final class Fields {
+        public DurationField millis;
+        public DurationField seconds;
+        public DurationField minutes;
+        public DurationField hours;
+    
+        public DurationField days;
+        public DurationField weeks;
+        public DurationField weekyears;
+        public DurationField months;
+        public DurationField years;
+        public DurationField centuries;
+        public DurationField eras;
+    
+        public DateTimeField millisOfSecond;
+        public DateTimeField millisOfDay;
+        public DateTimeField secondOfMinute;
+        public DateTimeField secondOfDay;
+        public DateTimeField minuteOfHour;
+        public DateTimeField minuteOfDay;
+        public DateTimeField hourOfDay;
+        public DateTimeField clockhourOfDay;
+        public DateTimeField hourOfHalfday;
+        public DateTimeField clockhourOfHalfday;
+        public DateTimeField halfdayOfDay;
+    
+        public DateTimeField dayOfWeek;
+        public DateTimeField dayOfMonth;
+        public DateTimeField dayOfYear;
+        public DateTimeField weekOfWeekyear;
+        public DateTimeField weekyear;
+        public DateTimeField monthOfYear;
+        public DateTimeField year;
+        public DateTimeField yearOfEra;
+        public DateTimeField yearOfCentury;
+        public DateTimeField centuryOfEra;
+        public DateTimeField era;
+
+        Fields() {
+        }
+
+        /**
+         * Copy the supported fields from a chronology into this container.
+         */
+        public void copyFieldsFrom(Chronology chrono) {
+            {
+                DurationField f;
+                if (isSupported(f = chrono.millis())) {
+                    millis = f;
+                }
+                if (isSupported(f = chrono.seconds())) {
+                    seconds = f;
+                }
+                if (isSupported(f = chrono.minutes())) {
+                    minutes = f;
+                }
+                if (isSupported(f = chrono.hours())) {
+                    hours = f;
+                }
+                if (isSupported(f = chrono.days())) {
+                    days = f;
+                }
+                if (isSupported(f = chrono.weeks())) {
+                    weeks = f;
+                }
+                if (isSupported(f = chrono.weekyears())) {
+                    weekyears = f;
+                }
+                if (isSupported(f = chrono.months())) {
+                    months = f;
+                }
+                if (isSupported(f = chrono.years())) {
+                    years = f;
+                }
+                if (isSupported(f = chrono.centuries())) {
+                    centuries = f;
+                }
+                if (isSupported(f = chrono.eras())) {
+                    eras = f;
+                }
+            }
+
+            {
+                DateTimeField f;
+                if (isSupported(f = chrono.millisOfSecond())) {
+                    millisOfSecond = f;
+                }
+                if (isSupported(f = chrono.millisOfDay())) {
+                    millisOfDay = f;
+                }
+                if (isSupported(f = chrono.secondOfMinute())) {
+                    secondOfMinute = f;
+                }
+                if (isSupported(f = chrono.secondOfDay())) {
+                    secondOfDay = f;
+                }
+                if (isSupported(f = chrono.minuteOfHour())) {
+                    minuteOfHour = f;
+                }
+                if (isSupported(f = chrono.minuteOfDay())) {
+                    minuteOfDay = f;
+                }
+                if (isSupported(f = chrono.hourOfDay())) {
+                    hourOfDay = f;
+                }
+                if (isSupported(f = chrono.clockhourOfDay())) {
+                    clockhourOfDay = f;
+                }
+                if (isSupported(f = chrono.hourOfHalfday())) {
+                    hourOfHalfday = f;
+                }
+                if (isSupported(f = chrono.clockhourOfHalfday())) {
+                    clockhourOfHalfday = f;
+                }
+                if (isSupported(f = chrono.halfdayOfDay())) {
+                    halfdayOfDay = f;
+                }
+                if (isSupported(f = chrono.dayOfWeek())) {
+                    dayOfWeek = f;
+                }
+                if (isSupported(f = chrono.dayOfMonth())) {
+                    dayOfMonth = f;
+                }
+                if (isSupported(f = chrono.dayOfYear())) {
+                    dayOfYear = f;
+                }
+                if (isSupported(f = chrono.weekOfWeekyear())) {
+                    weekOfWeekyear = f;
+                }
+                if (isSupported(f = chrono.weekyear())) {
+                    weekyear = f;
+                }
+                if (isSupported(f = chrono.monthOfYear())) {
+                    monthOfYear = f;
+                }
+                if (isSupported(f = chrono.year())) {
+                    year = f;
+                }
+                if (isSupported(f = chrono.yearOfEra())) {
+                    yearOfEra = f;
+                }
+                if (isSupported(f = chrono.yearOfCentury())) {
+                    yearOfCentury = f;
+                }
+                if (isSupported(f = chrono.centuryOfEra())) {
+                    centuryOfEra = f;
+                }
+                if (isSupported(f = chrono.era())) {
+                    era = f;
+                }
+            }
+        }
+
+        private static boolean isSupported(DurationField field) {
+            return field == null ? false : field.isSupported();
+        }
+
+        private static boolean isSupported(DateTimeField field) {
+            return field == null ? false : field.isSupported();
+        }
+    }
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java b/JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java
new file mode 100644
index 000000000..eff0211ff
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java
@@ -0,0 +1,227 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTime;
+import org.joda.time.DateTimeConstants;
+import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeZone;
+import org.joda.time.DurationField;
+import org.joda.time.field.DividedDateTimeField;
+import org.joda.time.field.OffsetDateTimeField;
+import org.joda.time.field.RemainderDateTimeField;
+
+/**
+ * <code>BuddhistChronology</code> provides access to the individual date
+ * time fields for the Buddhist chronological calendar system.
+ * <p>
+ * The Buddhist calendar differs from the GregorianJulian calendar only 
+ * in the year. This class is compatable with the BuddhistCalendar class 
+ * supplied by Sun.
+ * <p>
+ * BuddhistChronology is thread-safe and immutable.
+ *
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+public final class BuddhistChronology extends AssembledChronology {
+    
+    static final long serialVersionUID = -3474595157769370126L;
+
+    /**
+     * Constant value for 'Buddhist Era', equivalent to the value returned
+     * for AD/CE.
+     */
+    public static final int BE = DateTimeConstants.CE;
+
+    /** Number of years difference in calendars. */
+    private static final int BUDDHIST_OFFSET = 543;
+
+    /** Cache of zone to chronology */
+    private static final Map cCache = new HashMap();
+
+    /** UTC instance of the chronology */
+    private static final BuddhistChronology INSTANCE_UTC = getInstance(DateTimeZone.UTC);
+
+    /**
+     * Standard instance of a Buddhist Chronology, that matches
+     * Sun's BuddhistCalendar class. This means that it follows the
+     * GregorianJulian calendar rules with a cutover date.
+     * <p>
+     * The time zone of the returned instance is UTC.
+     */
+    public static BuddhistChronology getInstanceUTC() {
+        return INSTANCE_UTC;
+    }
+
+    /**
+     * Standard instance of a Buddhist Chronology, that matches
+     * Sun's BuddhistCalendar class. This means that it follows the
+     * GregorianJulian calendar rules with a cutover date.
+     */
+    public static BuddhistChronology getInstance() {
+        return getInstance(DateTimeZone.getDefault());
+    }
+
+    /**
+     * Standard instance of a Buddhist Chronology, that matches
+     * Sun's BuddhistCalendar class. This means that it follows the
+     * GregorianJulian calendar rules with a cutover date.
+     *
+     * @param zone  the time zone to use, null is default
+     */
+    public static synchronized BuddhistChronology getInstance(DateTimeZone zone) {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        BuddhistChronology chrono = (BuddhistChronology) cCache.get(zone);
+        if (chrono == null) {
+            // First create without a lower limit.
+            chrono = new BuddhistChronology(GJChronology.getInstance(zone, null), null);
+            // Impose lower limit and make another BuddhistChronology.
+            DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);
+            chrono = new BuddhistChronology(LimitChronology.getInstance(chrono, lowerLimit, null), "");
+            cCache.put(zone, chrono);
+        }
+        return chrono;
+    }
+
+    // Constructors and instance variables
+    //-----------------------------------------------------------------------
+    
+    /**
+     * Restricted constructor.
+     *
+     * @param param if non-null, then don't change the field set
+     */
+    private BuddhistChronology(Chronology base, Object param) {
+        super(base, param);
+    }
+
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return getInstance(getBase().getDateTimeZone());
+    }
+
+    // Conversion
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the Chronology in the UTC time zone.
+     * 
+     * @return the chronology in UTC
+     */
+    public Chronology withUTC() {
+        return INSTANCE_UTC;
+    }
+
+    /**
+     * Gets the Chronology in a specific time zone.
+     * 
+     * @param zone  the zone to get the chronology in, null is default
+     * @return the chronology
+     */
+    public Chronology withDateTimeZone(DateTimeZone zone) {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        if (zone == getDateTimeZone()) {
+            return this;
+        }
+        return getInstance(zone);
+    }
+
+    // Output
+    //-----------------------------------------------------------------------
+    /**
+     * Gets a debugging toString.
+     * 
+     * @return a debugging string
+     */
+    public String toString() {
+        String str = "BuddhistChronology";
+        DateTimeZone zone = getDateTimeZone();
+        if (zone != null) {
+            str = str + '[' + zone.getID() + ']';
+        }
+        return str;
+    }
+
+    protected void assemble(Fields fields) {
+        if (getParam() == null) {
+            DateTimeField field = fields.year;
+            fields.year = new OffsetDateTimeField(field, field.getName(), BUDDHIST_OFFSET);
+            fields.yearOfEra = fields.year;
+            
+            field = fields.weekyear;
+            fields.weekyear = new OffsetDateTimeField(field, field.getName(), BUDDHIST_OFFSET);
+            
+            field = new OffsetDateTimeField(fields.yearOfEra, "", 99);
+            fields.centuryOfEra = new DividedDateTimeField(field, "centuryOfEra", "centuries", 100);
+            
+            field = new RemainderDateTimeField
+                ((DividedDateTimeField)fields.centuryOfEra, "");
+            fields.yearOfCentury = new OffsetDateTimeField(field, "yearOfCentury", 1);
+            
+            fields.era = BuddhistEraDateTimeField.INSTANCE;
+        }
+    }
+   
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/BuddhistEraDateTimeField.java
similarity index 94%
rename from JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistEraDateTimeField.java
rename to JodaTime/src/java/org/joda/time/chrono/BuddhistEraDateTimeField.java
index ccd869bdd..95d653ba8 100644
--- a/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistEraDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/BuddhistEraDateTimeField.java
@@ -51,15 +51,15 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono.buddhist;
+package org.joda.time.chrono;
 
 import java.util.Locale;
 
 import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
-import org.joda.time.chrono.AbstractDateTimeField;
-import org.joda.time.chrono.UnsupportedDurationField;
-import org.joda.time.chrono.Utils;
+import org.joda.time.field.AbstractDateTimeField;
+import org.joda.time.field.UnsupportedDurationField;
+import org.joda.time.field.FieldUtils;
 
 /**
  * Provides time calculations for the buddhist era component of time.
@@ -73,7 +73,7 @@
     static final long serialVersionUID = -9175876774456816364L;
 
     /**
-     * Singleton instance of BuddhistYearDateTimeField
+     * Singleton instance
      */
     static final DateTimeField INSTANCE = new BuddhistEraDateTimeField();
 
@@ -114,7 +114,7 @@ public int get(long instant) {
      * @throws IllegalArgumentException  if era is invalid.
      */
     public long set(long instant, int era) {
-        Utils.verifyValueBounds(this, era, getMinimumValue(), getMaximumValue());
+        FieldUtils.verifyValueBounds(this, era, getMinimumValue(), getMaximumValue());
 
         return instant;
     }
diff --git a/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java
new file mode 100644
index 000000000..54cbd560a
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java
@@ -0,0 +1,286 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTime;
+import org.joda.time.DateTimeConstants;
+import org.joda.time.DateTimeZone;
+import org.joda.time.DurationField;
+import org.joda.time.field.PreciseDurationField;
+
+/**
+ * 
+ *
+ * @author Brian S O'Neill
+ */
+public final class CopticChronology extends AbstractGJChronology {
+
+    static final long serialVersionUID = -5972804258688333942L;
+
+    /**
+     * Constant value for 'Anno Martyrum' or 'Era of the Martyrs', equivalent
+     * to the value returned for AD/CE.
+     */
+    public static final int AM = DateTimeConstants.CE;
+
+    private static final long MILLIS_PER_YEAR =
+        (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY);
+
+    private static final long MILLIS_PER_MONTH =
+        (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY / 12);
+
+    private static final DurationField cMonthsField;
+
+    /** Singleton instance of a UTC CopticChronology */
+    private static final CopticChronology INSTANCE_UTC;
+
+    /** Cache of zone to chronology arrays */
+    private static final Map cCache = new HashMap();
+
+    static {
+        cMonthsField =  new PreciseDurationField
+            ("months", 30L * DateTimeConstants.MILLIS_PER_DAY);
+        INSTANCE_UTC = getInstance(DateTimeZone.UTC);
+    }
+
+    /**
+     * Gets an instance of the CopticChronology.
+     * The time zone of the returned instance is UTC.
+     * 
+     * @return a singleton UTC instance of the chronology
+     */
+    public static CopticChronology getInstanceUTC() {
+        return INSTANCE_UTC;
+    }
+
+    /**
+     * Gets an instance of the CopticChronology in the default time zone.
+     * 
+     * @return a chronology in the default time zone
+     */
+    public static CopticChronology getInstance() {
+        return getInstance(DateTimeZone.getDefault(), 4);
+    }
+
+    /**
+     * Gets an instance of the CopticChronology in the given time zone.
+     * 
+     * @param zone  the time zone to get the chronology in, null is default
+     * @return a chronology in the specified time zone
+     */
+    public static CopticChronology getInstance(DateTimeZone zone) {
+        return getInstance(zone, 4);
+    }
+
+    /**
+     * Gets an instance of the CopticChronology in the given time zone.
+     * 
+     * @param zone  the time zone to get the chronology in, null is default
+     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4
+     * @return a chronology in the specified time zone
+     */
+    public static CopticChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        CopticChronology chrono;
+        synchronized (cCache) {
+            CopticChronology[] chronos = (CopticChronology[]) cCache.get(zone);
+            if (chronos == null) {
+                chronos = new CopticChronology[7];
+                cCache.put(zone, chronos);
+            }
+            try {
+                chrono = chronos[minDaysInFirstWeek - 1];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                throw new IllegalArgumentException
+                    ("Invalid min days in first week: " + minDaysInFirstWeek);
+            }
+            if (chrono == null) {
+                if (zone == DateTimeZone.UTC) {
+                    // First create without a lower limit.
+                    chrono = new CopticChronology(null, null, minDaysInFirstWeek);
+                    // Impose lower limit and make another CopticChronology.
+                    DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);
+                    chrono = new CopticChronology
+                        (LimitChronology.getInstance(chrono, lowerLimit, null),
+                         null, minDaysInFirstWeek);
+                } else {
+                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);
+                    chrono = new CopticChronology
+                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);
+                }
+                chronos[minDaysInFirstWeek - 1] = chrono;
+            }
+        }
+        return chrono;
+    }
+
+    // Constructors and instance variables
+    //-----------------------------------------------------------------------
+
+    /**
+     * Restricted constructor
+     */
+    CopticChronology(Chronology base, Object param, int minDaysInFirstWeek) {
+        super(base, param, minDaysInFirstWeek);
+    }
+
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return getInstance(getBase().getDateTimeZone());
+    }
+
+    // Conversion
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the Chronology in the UTC time zone.
+     * 
+     * @return the chronology in UTC
+     */
+    public Chronology withUTC() {
+        return INSTANCE_UTC;
+    }
+
+    /**
+     * Gets the Chronology in a specific time zone.
+     * 
+     * @param zone  the zone to get the chronology in, null is default
+     * @return the chronology
+     */
+    public Chronology withDateTimeZone(DateTimeZone zone) {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        if (zone == getDateTimeZone()) {
+            return this;
+        }
+        return getInstance(zone);
+    }
+
+    boolean isLeapYear(int year) {
+        return (year & 3) == 3;
+    }
+
+    long calculateFirstDayOfYearMillis(int year) {
+        // Java epoch is 1970-01-01 Gregorian which is 1686-04-23 Coptic.
+        // Calculate relative to the nearest leap year and account for the
+        // difference later.
+
+        int relativeYear = year - 1687;
+        int leapYears;
+        if (relativeYear <= 0) {
+            // Add 3 before shifting right since /4 and >>2 behave differently
+            // on negative numbers.
+            leapYears = (relativeYear + 3) >> 2;
+        } else {
+            leapYears = relativeYear >> 2;
+            // For post 1687 an adjustment is needed as jan1st is before leap day
+            if (!isLeapYear(year)) {
+                leapYears++;
+            }
+        }
+        
+        long millis = (relativeYear * 365L + leapYears)
+            * (long)DateTimeConstants.MILLIS_PER_DAY;
+
+        // Adjust to account for difference between 1687-01-01 and 1686-04-23.
+
+        return millis + (365L - 112) * DateTimeConstants.MILLIS_PER_DAY;
+    }
+
+    int getMinYear() {
+        // The lowest year that can be fully supported.
+        return 1;
+    }
+
+    int getMaxYear() {
+        // The highest year that can be fully supported.
+        // TODO
+        return 292272992;
+    }
+
+    long getAverageMillisPerYear() {
+        return MILLIS_PER_YEAR;
+    }
+
+    long getAverageMillisPerMonth() {
+        return MILLIS_PER_MONTH;
+    }
+
+    long getApproxMillisAtEpoch() {
+        return 1686L * MILLIS_PER_YEAR + 112L * DateTimeConstants.MILLIS_PER_DAY;
+    }
+
+    protected void assemble(Fields fields) {
+        if (getBase() == null) {
+            super.assemble(fields);
+            // Coptic, like Julian, has no year zero.
+            fields.year = new JulianChronology.NoYearZeroField(this, fields.year);
+            fields.weekyear = new JulianChronology.NoWeekyearZeroField(this, fields.weekyear);
+            
+            fields.era = CopticEraDateTimeField.INSTANCE;
+            fields.months = cMonthsField;
+            fields.monthOfYear = new CopticMonthOfYearDateTimeField(this, cMonthsField);
+            fields.dayOfMonth = new CopticDayOfMonthDateTimeField(this, fields.days);
+        }
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java
new file mode 100644
index 000000000..ccc443c55
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/CopticDayOfMonthDateTimeField.java
@@ -0,0 +1,108 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import org.joda.time.DurationField;
+import org.joda.time.field.PreciseDurationDateTimeField;
+
+/**
+ * Provides time calculations for the day of the month component of time.
+ *
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+final class CopticDayOfMonthDateTimeField extends PreciseDurationDateTimeField {
+
+    static final long serialVersionUID = -5441610762799659434L;
+
+    private final AbstractGJChronology iChronology;
+
+    /**
+     * Restricted constructor.
+     */
+    CopticDayOfMonthDateTimeField(AbstractGJChronology chronology, DurationField days) {
+        super("dayOfMonth", days);
+        iChronology = chronology;
+    }
+
+    public int get(long instant) {
+        return (iChronology.getDayOfYear(instant) - 1) % 30 + 1;
+    }
+
+    public DurationField getRangeDurationField() {
+        return iChronology.months();
+    }
+
+    public int getMinimumValue() {
+        return 1;
+    }
+
+    public int getMaximumValue() {
+        return 30;
+    }
+
+    public int getMaximumValue(long instant) {
+		if (((iChronology.getDayOfYear(instant) - 1) / 30) < 12) {
+			return 30;
+		}
+		return iChronology.isLeapYear(iChronology.getYear(instant)) ? 6 : 5;
+    }
+
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return iChronology.dayOfMonth();
+    }
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java
new file mode 100644
index 000000000..b1adfd9c1
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/CopticEraDateTimeField.java
@@ -0,0 +1,195 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import java.util.Locale;
+
+import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+import org.joda.time.field.AbstractDateTimeField;
+import org.joda.time.field.UnsupportedDurationField;
+import org.joda.time.field.FieldUtils;
+
+/**
+ * Provides time calculations for the coptic era component of time.
+ *
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+final class CopticEraDateTimeField extends AbstractDateTimeField {
+    
+    static final long serialVersionUID = 4090856468123006167L;
+
+    /**
+     * Singleton instance
+     */
+    static final DateTimeField INSTANCE = new CopticEraDateTimeField();
+
+    /**
+     * Restricted constructor
+     */
+    private CopticEraDateTimeField() {
+        super("era");
+    }
+
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return INSTANCE;
+    }
+
+    public boolean isLenient() {
+        return false;
+    }
+
+    /**
+     * Get the Era component of the specified time instant.
+     * 
+     * @param millis  the time instant in millis to query.
+     * @return the era extracted from the input.
+     */
+    public int get(long instant) {
+        return CopticChronology.AM;
+    }
+
+    /**
+     * Set the Era component of the specified time instant.
+     * 
+     * @param millis  the time instant in millis to update.
+     * @param era  the era (CopticChronology.AM) to update the time to.
+     * @return the updated time instant.
+     * @throws IllegalArgumentException  if era is invalid.
+     */
+    public long set(long instant, int era) {
+        FieldUtils.verifyValueBounds(this, era, getMinimumValue(), getMaximumValue());
+
+        return instant;
+    }
+
+    /**
+     * @see org.joda.time.DateTimeField#set(long, String, Locale)
+     */
+    public long set(long instant, String text, Locale locale) {
+        if ("AM".equals(text) == false) {
+            throw new IllegalArgumentException("Invalid era text: " + text);
+        }
+        return instant;
+    }
+
+    public long roundFloor(long instant) {
+        return Long.MIN_VALUE;
+    }
+
+    public long roundCeiling(long instant) {
+        return Long.MAX_VALUE;
+    }
+
+    public long roundHalfFloor(long instant) {
+        return Long.MIN_VALUE;
+    }
+
+    public long roundHalfCeiling(long instant) {
+        return Long.MIN_VALUE;
+    }
+
+    public long roundHalfEven(long instant) {
+        return Long.MIN_VALUE;
+    }
+
+    public DurationField getDurationField() {
+        return UnsupportedDurationField.INSTANCE;
+    }
+
+    public DurationField getRangeDurationField() {
+        return null;
+    }
+
+    public int getMinimumValue() {
+        return CopticChronology.AM;
+    }
+
+    public int getMaximumValue() {
+        return CopticChronology.AM;
+    }
+    
+    /**
+     * @see org.joda.time.DateTimeField#getAsShortText(long, Locale)
+     */
+    public String getAsShortText(long instant, Locale locale) {
+        return "AM";
+    }
+    
+    /**
+     * @see org.joda.time.DateTimeField#getMaximumShortTextLength(Locale)
+     */
+    public int getMaximumShortTextLength(Locale locale) {
+        return 2;
+    }
+
+    /**
+     * @see org.joda.time.DateTimeField#getAsShortText(long, Locale)
+     */
+    public String getAsText(long instant, Locale locale) {
+        return "AM";
+    }
+
+    /**
+     * @see org.joda.time.DateTimeField#getMaximumShortTextLength(Locale)
+     */
+    public int getMaximumTextLength(Locale locale) {
+        return 2;
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/CopticMonthOfYearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/CopticMonthOfYearDateTimeField.java
new file mode 100644
index 000000000..b7a7f0649
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/CopticMonthOfYearDateTimeField.java
@@ -0,0 +1,113 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import org.joda.time.DurationField;
+import org.joda.time.field.PreciseDurationDateTimeField;
+
+/**
+ * 
+ *
+ * @author Brian S O'Neill
+ */
+final class CopticMonthOfYearDateTimeField extends PreciseDurationDateTimeField {
+
+    static final long serialVersionUID = 7741038885247700323L;
+
+    private final AbstractGJChronology iChronology;
+
+    /**
+     * Restricted constructor.
+     */
+    CopticMonthOfYearDateTimeField(AbstractGJChronology chronology, DurationField months) {
+        super("monthOfYear", months);
+        iChronology = chronology;
+    }
+
+    public int get(long instant) {
+        return (iChronology.getDayOfYear(instant) - 1) / 30 + 1;
+    }
+
+    public DurationField getRangeDurationField() {
+        return iChronology.years();
+    }
+
+    public boolean isLeap(long instant) {
+        return get(instant) > 12 && iChronology.isLeapYear(iChronology.getYear(instant));
+    }
+
+    public int getLeapAmount(long instant) {
+        return isLeap(instant) ? 1 : 0;
+    }
+
+    public DurationField getLeapDurationField() {
+        return iChronology.days();
+    }
+
+    public int getMinimumValue() {
+        return 1;
+    }
+
+    public int getMaximumValue() {
+        return 13;
+    }
+
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return iChronology.monthOfYear();
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/DecoratedChronology.java b/JodaTime/src/java/org/joda/time/chrono/DecoratedChronology.java
deleted file mode 100644
index 5c9b8928b..000000000
--- a/JodaTime/src/java/org/joda/time/chrono/DecoratedChronology.java
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono;
-
-import org.joda.time.Chronology;
-import org.joda.time.DateTimeZone;
-
-/**
- * <code>DecoratedChronology</code> extends {@link Chronology}, implementing
- * only the minimum required set of methods. These implemented methods delegate
- * to a wrapped field. The withUTC, withDateTimeZone, and toString methods are
- * exceptions, and are left abstract.
- * <p>
- * This design allows new Chronology types to be defined that piggyback on top
- * of another, inheriting all the safe method implementations from
- * Chronology. Should any method require pure delegation to the wrapped field,
- * simply override and use the provided getWrappedChronology method.
- * <p>
- * DecoratedChronology is thread-safe and immutable, and its subclasses must
- * be as well.
- *
- * @author Brian S O'Neill
- * @since 1.0
- * @see DelegatedChronology
- */
-public abstract class DecoratedChronology extends Chronology {
-
-    static final long serialVersionUID = 7094038875466049631L;
-
-    /** The Chronology being wrapped */
-    private final Chronology iChronology;
-    
-    /**
-     * Create a DecoratedChronology for any chronology.
-     *
-     * @param chrono the chronology
-     * @throws IllegalArgumentException if chronology is null
-     */
-    protected DecoratedChronology(Chronology chrono) {
-        if (chrono == null) {
-            throw new IllegalArgumentException("The Chronology must not be null");
-        }
-        iChronology = chrono;
-    }
-    
-    /**
-     * Gets the wrapped chronology.
-     * 
-     * @return the wrapped Chronology
-     */
-    protected Chronology getWrappedChronology() {
-        return iChronology;
-    }
-
-    /**
-     * Get the Chronology in the UTC time zone.
-     * 
-     * @return Chronology in UTC
-     */
-    public abstract Chronology withUTC();
-
-    /**
-     * Get the Chronology in the any time zone.
-     * 
-     * @return Chronology in ant time zone
-     */
-    public abstract Chronology withDateTimeZone(DateTimeZone zone);
-
-    /**
-     * Gets the time zone that this chronology is using.
-     * 
-     * @return the DateTimeZone
-     */
-    public DateTimeZone getDateTimeZone() {
-        return iChronology.getDateTimeZone();
-    }
-
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/DelegatedChronology.java b/JodaTime/src/java/org/joda/time/chrono/DelegatedChronology.java
deleted file mode 100644
index e4942054b..000000000
--- a/JodaTime/src/java/org/joda/time/chrono/DelegatedChronology.java
+++ /dev/null
@@ -1,494 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono;
-
-import org.joda.time.Chronology;
-import org.joda.time.DateTimeField;
-import org.joda.time.DateTimeZone;
-import org.joda.time.DurationField;
-
-/**
- * <code>DelegatedChronology</code> delegates each method call to the
- * chronology it wraps.
- * <p>
- * DelegatedChronology is thread-safe and immutable, and its subclasses must
- * be as well.
- *
- * @author Stephen Colebourne
- * @author Brian S O'Neill
- * @since 1.0
- * @see DecoratedChronology
- */
-public abstract class DelegatedChronology extends Chronology {
-    
-    static final long serialVersionUID = 216867504527676612L;
-
-    /** The Chronology being wrapped */
-    private final Chronology iChronology;
-    
-    /**
-     * Create a DelegatedChronology for any chronology.
-     *
-     * @param chrono the chronology
-     * @throws IllegalArgumentException if chronology is null
-     */
-    protected DelegatedChronology(Chronology chrono) {
-        if (chrono == null) {
-            throw new IllegalArgumentException("The Chronology must not be null");
-        }
-        iChronology = chrono;
-    }
-    
-    /**
-     * Gets the wrapped chronology.
-     * 
-     * @return the wrapped Chronology
-     */
-    protected Chronology getWrappedChronology() {
-        return iChronology;
-    }
-
-    /**
-     * Get the Chronology in the UTC time zone.
-     * 
-     * @return Chronology in UTC
-     */
-    public abstract Chronology withUTC();
-
-    /**
-     * Get the Chronology in the any time zone.
-     * 
-     * @return Chronology in ant time zone
-     */
-    public abstract Chronology withDateTimeZone(DateTimeZone zone);
-
-    /**
-     * Gets the time zone that this chronolog is using.
-     * 
-     * @return the DateTimeZone
-     */
-    public DateTimeZone getDateTimeZone() {
-        return iChronology.getDateTimeZone();
-    }
-
-    public long getDateOnlyMillis(long instant) {
-        return iChronology.getDateOnlyMillis(instant);
-    }
-
-    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
-        throws IllegalArgumentException
-    {
-        return iChronology.getDateOnlyMillis(year, monthOfYear, dayOfMonth);
-    }
-
-    public long getTimeOnlyMillis(long instant) {
-        return iChronology.getTimeOnlyMillis(instant);
-    }
-
-    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        return iChronology.getTimeOnlyMillis
-            (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-    }
-
-    public long getDateTimeMillis(long instant,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        return iChronology.getDateTimeMillis
-            (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-    }
-
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int millisOfDay)
-        throws IllegalArgumentException
-    {
-        return iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);
-    }
-
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        return iChronology.getDateTimeMillis
-            (year, monthOfYear, dayOfMonth,
-             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-    }
-
-    // Millis
-    //------------------------------------------------------------
-
-    /**
-     * Get the millis duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField millis() {
-        return iChronology.millis();
-    }
-
-    /**
-     * Get the millis of second field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField millisOfSecond() {
-        return iChronology.millisOfSecond();
-    }
-
-    /**
-     * Get the millis of day field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField millisOfDay() {
-        return iChronology.millisOfDay();
-    }
-
-    // Seconds
-    //------------------------------------------------------------
-
-    /**
-     * Get the seconds duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField seconds() {
-        return iChronology.seconds();
-    }
-
-    /**
-     * Get the second of minute field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField secondOfMinute() {
-        return iChronology.secondOfMinute();
-    }
-
-    /**
-     * Get the second of day field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField secondOfDay() {
-        return iChronology.secondOfDay();
-    }
-
-    // Minutes
-    //------------------------------------------------------------
-
-    /**
-     * Get the minutes duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField minutes() {
-        return iChronology.minutes();
-    }
-
-    /**
-     * Get the minute of hour field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField minuteOfHour() {
-        return iChronology.minuteOfHour();
-    }
-
-    /**
-     * Get the minute of day field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField minuteOfDay() {
-        return iChronology.minuteOfDay();
-    }
-
-    // Hours
-    //------------------------------------------------------------
-
-    /**
-     * Get the hours duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField hours() {
-        return iChronology.hours();
-    }
-
-    /**
-     * Get the hour of day (0-23) field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField hourOfDay() {
-        return iChronology.hourOfDay();
-    }
-
-    /**
-     * Get the hour of day (offset to 1-24) field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField clockhourOfDay() {
-        return iChronology.clockhourOfDay();
-    }
-
-    /**
-     * Get the hour of am/pm (0-11) field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField hourOfHalfday() {
-        return iChronology.hourOfHalfday();
-    }
-
-    /**
-     * Get the hour of am/pm (offset to 1-12) field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField clockhourOfHalfday() {
-        return iChronology.clockhourOfHalfday();
-    }
-
-    /**
-     * Get the AM(0) PM(1) field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField halfdayOfDay() {
-        return iChronology.halfdayOfDay();
-    }
-
-    // Day
-    //------------------------------------------------------------
-
-    /**
-     * Get the days duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField days() {
-        return iChronology.days();
-    }
-
-    /**
-     * Get the day of week field for this chronology.
-     *
-     * @return DateTimeField
-     */
-    public DateTimeField dayOfWeek() {
-        return iChronology.dayOfWeek();
-    }
-
-    /**
-     * Get the day of month field for this chronology.
-     *
-     * @return DateTimeField
-     */
-    public DateTimeField dayOfMonth() {
-        return iChronology.dayOfMonth();
-    }
-
-    /**
-     * Get the day of year field for this chronology.
-     *
-     * @return DateTimeField
-     */
-    public DateTimeField dayOfYear() {
-        return iChronology.dayOfYear();
-    }
-
-    // Week
-    //------------------------------------------------------------
-
-    /**
-     * Get the weeks duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField weeks() {
-        return iChronology.weeks();
-    }
-
-    /**
-     * Get the week of a week based year field for this chronology.
-     *
-     * @return DateTimeField
-     */
-    public DateTimeField weekOfWeekyear() {
-        return iChronology.weekOfWeekyear();
-    }
-
-    /**
-     * Get the weekyears duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField weekyears() {
-        return iChronology.weekyears();
-    }
-
-    /**
-     * Get the year of a week based year field for this chronology.
-     *
-     * @return DateTimeField
-     */
-    public DateTimeField weekyear() {
-        return iChronology.weekyear();
-    }
-
-    // Month
-    //------------------------------------------------------------
-
-    /**
-     * Get the months duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField months() {
-        return iChronology.months();
-    }
-
-    /**
-     * Get the month of year field for this chronology.
-     *
-     * @return DateTimeField
-     */
-    public DateTimeField monthOfYear() {
-        return iChronology.monthOfYear();
-    }
-
-    // Year
-    //------------------------------------------------------------
-
-    /**
-     * Get the years duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField years() {
-        return iChronology.years();
-    }
-
-    /**
-     * Get the year field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField year() {
-        return iChronology.year();
-    }
-
-    /**
-     * Get the year of era field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField yearOfEra() {
-        return iChronology.yearOfEra();
-    }
-
-    /**
-     * Get the year field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField yearOfCentury() {
-        return iChronology.yearOfCentury();
-    }
-
-    /**
-     * Get the centuries duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField centuries() {
-        return iChronology.centuries();
-    }
-
-    /**
-     * Get the century of era field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField centuryOfEra() {
-        return iChronology.centuryOfEra();
-    }
-
-    /**
-     * Get the eras duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField eras() {
-        return iChronology.eras();
-    }
-
-    /**
-     * Get the era field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField era() {
-        return iChronology.era();
-    }
-    
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/CutoverChronology.java b/JodaTime/src/java/org/joda/time/chrono/GJChronology.java
similarity index 63%
rename from JodaTime/src/java/org/joda/time/chrono/gj/CutoverChronology.java
rename to JodaTime/src/java/org/joda/time/chrono/GJChronology.java
index c33049a6f..34946b825 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/CutoverChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJChronology.java
@@ -2,7 +2,7 @@
  * Joda Software License, Version 1.0
  *
  *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * Copyright (c) 2001-2004 Stephen Colebourne.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -10,7 +10,7 @@
  * are met:
  *
  * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
+ *    notice, this list of conditions and the following disclaimer.
  *
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in
@@ -18,7 +18,7 @@
  *    distribution.
  *
  * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
+ *    if any, must include the following acknowledgment:
  *       "This product includes software developed by the
  *        Joda project (http://www.joda.org/)."
  *    Alternately, this acknowledgment may appear in the software itself,
@@ -47,30 +47,67 @@
  * ====================================================================
  *
  * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
+ * individuals on behalf of the Joda project and was originally
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono.gj;
+package org.joda.time.chrono;
 
+import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.Locale;
+import java.util.Map;
 
 import org.joda.time.Chronology;
+// Import for @link support
+import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeZone;
 import org.joda.time.DurationField;
-import org.joda.time.chrono.AbstractDateTimeField;
-import org.joda.time.chrono.DecoratedDurationField;
+import org.joda.time.Instant;
+import org.joda.time.ReadableInstant;
+import org.joda.time.field.AbstractDateTimeField;
+import org.joda.time.field.DecoratedDurationField;
+import org.joda.time.format.DateTimePrinter;
+import org.joda.time.format.ISODateTimeFormat;
 
 /**
- * Chronology for supporting the cutover from the Julian calendar to the
- * Gregorian calendar.
+ * GJChronology provides access to the individual date time fields for the
+ * Gregorian/Julian defined chronological calendar system.
+ * <p>
+ * The Gregorian calendar replaced the Julian calendar, and the point in time
+ * when this chronology switches can be controlled using the second parameter
+ * of the getInstance method. By default this cutover is set to the date the
+ * Gregorian calendar was first instituted, October 15, 1582.
+ * <p>
+ * Before this date, this chronology uses the proleptic Julian calendar
+ * (proleptic means extending indefinitely). The Julian calendar has leap 
+ * years every four years, whereas the Gregorian has special rules for 100 
+ * and 400 years. A meaningful result will thus be obtained for all input 
+ * values. However before March 1, 4 CE, Julian leap years were irregular,
+ * and before 45 BCE there was no Julian calendar.
+ * <p>
+ * This chronology differs from {@link java.util.GregorianCalendar
+ * java.util.GregorianCalendar} in that years in BCE are returned
+ * correctly. Thus year 1 BCE is returned as -1 instead of 1. The yearOfEra
+ * field produces results compatible with GregorianCalendar.
+ * <p>
+ * The Julian calendar does not have a year zero, and so year -1 is followed by
+ * year 1. If the Gregorian cutover date is specified at or before year -1
+ * (Julian), year zero is defined. In other words, the proleptic Gregorian
+ * chronology implemented by this class has a year zero.
+ * <p>
+ * To create a pure proleptic Julian chronology, use {@link JulianChronology},
+ * and to create a pure proleptic Gregorian chronology, use
+ * {@link GregorianChronology}.
+ * <p>
+ * GJChronology is thread-safe and immutable.
  * 
  * @author Brian S O'Neill
  * @author Stephen Colebourne
  * @since 1.0
  */
-final class CutoverChronology extends GJChronology {
+public final class GJChronology extends AssembledChronology {
 
     static final long serialVersionUID = -2545574827706931671L;
 
@@ -97,121 +134,229 @@ private static long convertByWeekyear(final long instant, Chronology from, Chron
         return newInstant;
     }
 
-    private static void checkUTC(Chronology chrono) {
-        if (chrono.getDateTimeZone() != null &&
-            chrono.getDateTimeZone() != DateTimeZone.UTC) {
-            throw new IllegalArgumentException();
-        }
-    }
+    /**
+     * The default GregorianJulian cutover point
+     */
+    static final Instant DEFAULT_CUTOVER = new Instant(-12219292800000L);
 
-    private final GJChronology iJulianChronology;
-    private final GJChronology iGregorianChronology;
+    /** Cache of zone to chronology list */
+    private static final Map cCache = new HashMap();
 
-    final long iCutoverInstant;
-    transient final long iGapDuration;
+    /**
+     * Factory method returns instances of the default GJ cutover
+     * chronology. This uses a cutover date of October 15, 1582 (Gregorian)
+     * 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by
+     * October 15, 1582 (Gregorian).
+     *
+     * <p>The first day of the week is designated to be
+     * {@link DateTimeConstants#MONDAY Monday}, and the minimum days in the
+     * first week of the year is 4.
+     *
+     * <p>The time zone of the returned instance is UTC.
+     */
+    public static GJChronology getInstanceUTC() {
+        return getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4);
+    }
 
     /**
-     * @param julian chronology used before the cutover instant
-     * @param gregorian chronology used at and after the cutover instant
-     * @param cutoverInstant instant when the gregorian chronology began
+     * Factory method returns instances of the default GJ cutover
+     * chronology. This uses a cutover date of October 15, 1582 (Gregorian)
+     * 00:00:00 UTC. For this value, October 4, 1582 (Julian) is followed by
+     * October 15, 1582 (Gregorian).
+     *
+     * <p>The first day of the week is designated to be
+     * {@link DateTimeConstants#MONDAY Monday}, and the minimum days in the
+     * first week of the year is 4.
+     *
+     * <p>The returned chronology is in the default time zone.
      */
-    CutoverChronology(JulianChronology julian, GregorianChronology gregorian, long cutoverInstant) {
-        checkUTC(julian);
-        checkUTC(gregorian);
+    public static GJChronology getInstance() {
+        return getInstance(DateTimeZone.getDefault(), DEFAULT_CUTOVER, 4);
+    }
 
-        if (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {
-            throw new IllegalArgumentException();
+    /**
+     * Factory method returns instances of the GJ cutover chronology. This uses
+     * a cutover date of October 15, 1582 (Gregorian) 00:00:00 UTC. For this
+     * value, October 4, 1582 (Julian) is followed by October 15, 1582
+     * (Gregorian).
+     *
+     * <p>The first day of the week is designated to be
+     * {@link DateTimeConstants#MONDAY Monday}, and the minimum days in the
+     * first week of the year is 4.
+     *
+     * @param zone  the time zone to use, null is default
+     */
+    public static GJChronology getInstance(DateTimeZone zone) {
+        return getInstance(zone, DEFAULT_CUTOVER, 4);
+    }
+
+    /**
+     * Factory method returns instances of the GJ cutover chronology. Any
+     * cutover date may be specified.
+     *
+     * <p>The first day of the week is designated to be
+     * {@link DateTimeConstants#MONDAY Monday}, and the minimum days in the
+     * first week of the year is 4.
+     *
+     * @param zone  the time zone to use, null is default
+     * @param gregorianCutover  the cutover to use, null means default
+     */
+    public static GJChronology getInstance(DateTimeZone zone,
+                                           ReadableInstant gregorianCutover) 
+    {
+        return getInstance(zone, gregorianCutover, 4);
+    }
+    
+    /**
+     * Factory method returns instances of the GJ cutover chronology. Any
+     * cutover date may be specified.
+     *
+     * @param zone  the time zone to use, null is default
+     * @param gregorianCutover  the cutover to use, null means default
+     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4
+     */
+    public static synchronized GJChronology getInstance(DateTimeZone zone,
+                                                        ReadableInstant gregorianCutover,
+                                                        int minDaysInFirstWeek)
+    {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
         }
-        if (julian.isCenturyISO() != gregorian.isCenturyISO()) {
-            throw new IllegalArgumentException();
+        Instant cutoverInstant;
+        if (gregorianCutover == null) {
+            cutoverInstant = DEFAULT_CUTOVER;
+        } else {
+            cutoverInstant = gregorianCutover.toInstant();
         }
 
-        iJulianChronology = julian;
-        iGregorianChronology = gregorian;
-        iCutoverInstant = cutoverInstant;
-
-        // Compute difference between the chronologies at the cutover instant
-        iGapDuration = cutoverInstant - julianToGregorianByYear(cutoverInstant);
+        GJChronology chrono;
+
+        ArrayList chronos = (ArrayList)cCache.get(zone);
+        if (chronos == null) {
+            chronos = new ArrayList(2);
+            cCache.put(zone, chronos);
+        } else {
+            for (int i=chronos.size(); --i>=0; ) {
+                chrono = (GJChronology)chronos.get(i);
+                if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&
+                    cutoverInstant.equals(chrono.getGregorianCutover())) {
+                    
+                    return chrono;
+                }
+            }
+        }
 
-        // Begin field definitions.
+        if (zone == DateTimeZone.UTC) {
+            chrono = new GJChronology
+                (JulianChronology.getInstance(zone, minDaysInFirstWeek),
+                 GregorianChronology.getInstance(zone, minDaysInFirstWeek),
+                 cutoverInstant);
+        } else {
+            chrono = getInstance(DateTimeZone.UTC, gregorianCutover, minDaysInFirstWeek);
+            chrono = new GJChronology(ZonedChronology.getInstance(chrono, zone));
+        }
 
-        // First just copy all the Gregorian fields and then override those
-        // that need special attention.
-        copyFields(gregorian);
-        
-        // Assuming cutover is at midnight, all time of day fields can be
-        // gregorian since they are unaffected by cutover.
+        chronos.add(chrono);
 
-        // Verify assumption.
-        if (gregorian.millisOfDay().get(cutoverInstant) == 0) {
-            // Cutover is sometime in the day, so cutover fields are required
-            // for time of day.
+        return chrono;
+    }
 
-            iMillisOfSecondField = new CutoverField(julian.millisOfSecond(), iMillisOfSecondField);
-            iMillisOfDayField = new CutoverField(julian.millisOfDay(), iMillisOfDayField);
-            iSecondOfMinuteField = new CutoverField(julian.secondOfMinute(), iSecondOfMinuteField);
-            iSecondOfDayField = new CutoverField(julian.secondOfDay(), iSecondOfDayField);
-            iMinuteOfHourField = new CutoverField(julian.minuteOfHour(), iMinuteOfHourField);
-            iMinuteOfDayField = new CutoverField(julian.minuteOfDay(), iMinuteOfDayField);
-            iHourOfDayField = new CutoverField(julian.hourOfDay(), iHourOfDayField);
-            iHourOfHalfdayField = new CutoverField(julian.hourOfHalfday(), iHourOfHalfdayField);
-            iClockhourOfDayField = new CutoverField(julian.clockhourOfDay(), iClockhourOfDayField);
-            iClockhourOfHalfdayField = new CutoverField(julian.clockhourOfHalfday(), iClockhourOfHalfdayField);
-            iHalfdayOfDayField = new CutoverField(julian.halfdayOfDay(), iHalfdayOfDayField);
+    /**
+     * Factory method returns instances of the GJ cutover chronology. Any
+     * cutover date may be specified.
+     *
+     * @param zone  the time zone to use, null is default
+     * @param gregorianCutover  the cutover to use
+     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4
+     */
+    public static synchronized GJChronology getInstance(DateTimeZone zone,
+                                                        long gregorianCutover,
+                                                        int minDaysInFirstWeek)
+    {
+        Instant cutoverInstant;
+        if (gregorianCutover == DEFAULT_CUTOVER.getMillis()) {
+            cutoverInstant = null;
+        } else {
+            cutoverInstant = new Instant(gregorianCutover);
         }
+        return getInstance(zone, cutoverInstant, minDaysInFirstWeek);
+    }
 
-        // These fields just require basic cutover support.
-        {
-            iEraField = new CutoverField(julian.era(), gregorian.era());
-            iDayOfMonthField = new CutoverField(julian.dayOfMonth(), gregorian.dayOfMonth());
-        }
+    private JulianChronology iJulianChronology;
+    private GregorianChronology iGregorianChronology;
+    private Instant iCutoverInstant;
 
-        // DayOfYear and weekOfWeekyear require special handling since cutover
-        // year has fewer days and weeks. Extend the cutover to the start of
-        // the next year or weekyear. This keeps the sequence unbroken during
-        // the cutover year.
+    long iCutoverMillis;
+    long iGapDuration;
 
-        {
-            long cutover = gregorian.year().roundCeiling(iCutoverInstant);
-            iDayOfYearField = new CutoverField
-                (julian.dayOfYear(), gregorian.dayOfYear(), cutover);
-        }
+    /**
+     * @param julian chronology used before the cutover instant
+     * @param gregorian chronology used at and after the cutover instant
+     * @param cutoverInstant instant when the gregorian chronology began
+     */
+    private GJChronology(JulianChronology julian,
+                         GregorianChronology gregorian,
+                         Instant cutoverInstant) {
+        super(null, new Object[] {julian, gregorian, cutoverInstant});
+    }
 
-        {
-            long cutover = gregorian.weekyear().roundCeiling(iCutoverInstant);
-            iWeekOfWeekyearField = new CutoverField
-                (julian.weekOfWeekyear(), gregorian.weekOfWeekyear(), cutover, true);
-        }
+    /**
+     * Called when applying a time zone.
+     */
+    private GJChronology(Chronology base) {
+        super(base, null);
+    }
 
-        // These fields are special because they have imprecise durations. The
-        // family of addition methods need special attention. Override affected
-        // duration fields as well.
-        {
-            iYearField = new ImpreciseCutoverField(julian.year(), gregorian.year());
-            iYearsField = iYearField.getDurationField();
-            iYearOfEraField = new ImpreciseCutoverField
-                (julian.yearOfEra(), gregorian.yearOfEra(), iYearsField);
-            iYearOfCenturyField = new ImpreciseCutoverField
-                (julian.yearOfCentury(), gregorian.yearOfCentury(), iYearsField);
-            
-            iCenturyOfEraField = new ImpreciseCutoverField(julian.centuryOfEra(), gregorian.centuryOfEra());
-            iCenturiesField = iCenturyOfEraField.getDurationField();
-            
-            iMonthOfYearField = new ImpreciseCutoverField(julian.monthOfYear(), gregorian.monthOfYear());
-            iMonthsField = iMonthOfYearField.getDurationField();
-            
-            iWeekyearField = new ImpreciseCutoverField(julian.weekyear(), gregorian.weekyear(), true);
-            iWeekyearsField = iWeekyearField.getDurationField();
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return getInstance(getDateTimeZone(), iCutoverInstant, getMinimumDaysInFirstWeek());
+    }
+
+    public DateTimeZone getDateTimeZone() {
+        Chronology base;
+        if ((base = getBase()) != null) {
+            return base.getDateTimeZone();
         }
+        return DateTimeZone.UTC;
     }
 
+    // Conversion
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the Chronology in the UTC time zone.
+     * 
+     * @return the chronology in UTC
+     */
     public Chronology withUTC() {
-        return this;
+        return withDateTimeZone(DateTimeZone.UTC);
+    }
+
+    /**
+     * Gets the Chronology in a specific time zone.
+     * 
+     * @param zone  the zone to get the chronology in, null is default
+     * @return the chronology
+     */
+    public Chronology withDateTimeZone(DateTimeZone zone) {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        if (zone == getDateTimeZone()) {
+            return this;
+        }
+        return getInstance(zone, iCutoverInstant, getMinimumDaysInFirstWeek());
     }
 
     public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
         throws IllegalArgumentException
     {
+        Chronology base;
+        if ((base = getBase()) != null) {
+            return base.getDateOnlyMillis(year, monthOfYear, dayOfMonth);
+        }
+
         return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);
     }
 
@@ -219,6 +364,11 @@ public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
                                   int secondOfMinute, int millisOfSecond)
         throws IllegalArgumentException
     {
+        Chronology base;
+        if ((base = getBase()) != null) {
+            return base.getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+        }
+
         // Time fields are same for Julian and Gregorian.
         return iGregorianChronology.getTimeOnlyMillis
             (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
@@ -228,14 +378,19 @@ public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
                                   int millisOfDay)
         throws IllegalArgumentException
     {
+        Chronology base;
+        if ((base = getBase()) != null) {
+            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);
+        }
+
         // Assume date is Gregorian.
         long instant = iGregorianChronology.getDateTimeMillis
             (year, monthOfYear, dayOfMonth, millisOfDay);
-        if (instant < iCutoverInstant) {
+        if (instant < iCutoverMillis) {
             // Maybe it's Julian.
             instant = iJulianChronology.getDateTimeMillis
                 (year, monthOfYear, dayOfMonth, millisOfDay);
-            if (instant >= iCutoverInstant) {
+            if (instant >= iCutoverMillis) {
                 // Okay, it's in the illegal cutover gap.
                 throw new IllegalArgumentException("Specified date does not exist");
             }
@@ -248,6 +403,12 @@ public long getDateTimeMillis(long instant,
                                   int secondOfMinute, int millisOfSecond)
         throws IllegalArgumentException
     {
+        Chronology base;
+        if ((base = getBase()) != null) {
+            return base.getDateTimeMillis
+                (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+        }
+
         return getDateOnlyMillis(instant)
             + getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
     }
@@ -257,22 +418,162 @@ public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
                                   int secondOfMinute, int millisOfSecond)
         throws IllegalArgumentException
     {
+        Chronology base;
+        if ((base = getBase()) != null) {
+            return base.getDateTimeMillis
+                (year, monthOfYear, dayOfMonth,
+                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+        }
+
         return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0)
             + getTimeOnlyMillis(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
     }
 
-    public long getGregorianJulianCutoverMillis() {
-        return iCutoverInstant;
-    }
-
-    public boolean isCenturyISO() {
-        return iGregorianChronology.isCenturyISO();
+    /**
+     * Gets the cutover instant between Gregorian and Julian chronologies.
+     * @return the cutover instant
+     */
+    public Instant getGregorianCutover() {
+        Instant cutover = iCutoverInstant;
+        if (cutover == null) {
+            iCutoverInstant = cutover = new Instant(iCutoverMillis);
+        }
+        return cutover;
     }
 
     public final int getMinimumDaysInFirstWeek() {
         return iGregorianChronology.getMinimumDaysInFirstWeek();
     }
 
+    // Output
+    //-----------------------------------------------------------------------
+    /**
+     * Gets a debugging toString.
+     * 
+     * @return a debugging string
+     */
+    public String toString() {
+        StringBuffer sb = new StringBuffer(60);
+        sb.append("GJCutoverChronology");
+        sb.append('[');
+        sb.append(getDateTimeZone().getID());
+        sb.append(", ");
+
+        sb.append("cutover=");
+        ISODateTimeFormat format = ISODateTimeFormat.getInstance(withUTC());
+        DateTimePrinter printer;
+        if (withUTC().getTimeOnlyMillis(iCutoverMillis) == 0) {
+            printer = format.date();
+        } else {
+            printer = format.dateTime();
+        }
+        printer.printTo(sb, iCutoverMillis);
+
+        sb.append(", mdfw=");
+        sb.append(getMinimumDaysInFirstWeek());
+        sb.append(']');
+
+        return sb.toString();
+    }
+
+    protected void assemble(Fields fields) {
+        if (getBase() != null) {
+            return;
+        }
+
+        Object[] params = (Object[])getParam();
+
+        JulianChronology julian = (JulianChronology)params[0];
+        GregorianChronology gregorian = (GregorianChronology)params[1];
+        Instant cutoverInstant = (Instant)params[2];
+        iCutoverMillis = cutoverInstant.getMillis();
+
+        if (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {
+            throw new IllegalArgumentException();
+        }
+
+        iJulianChronology = julian;
+        iGregorianChronology = gregorian;
+        iCutoverInstant = cutoverInstant;
+
+        // Compute difference between the chronologies at the cutover instant
+        iGapDuration = iCutoverMillis - julianToGregorianByYear(iCutoverMillis);
+
+        // Begin field definitions.
+
+        // First just copy all the Gregorian fields and then override those
+        // that need special attention.
+        fields.copyFieldsFrom(gregorian);
+        
+        // Assuming cutover is at midnight, all time of day fields can be
+        // gregorian since they are unaffected by cutover.
+
+        // Verify assumption.
+        if (gregorian.millisOfDay().get(iCutoverMillis) == 0) {
+            // Cutover is sometime in the day, so cutover fields are required
+            // for time of day.
+
+            fields.millisOfSecond = new CutoverField(julian.millisOfSecond(), fields.millisOfSecond);
+            fields.millisOfDay = new CutoverField(julian.millisOfDay(), fields.millisOfDay);
+            fields.secondOfMinute = new CutoverField(julian.secondOfMinute(), fields.secondOfMinute);
+            fields.secondOfDay = new CutoverField(julian.secondOfDay(), fields.secondOfDay);
+            fields.minuteOfHour = new CutoverField(julian.minuteOfHour(), fields.minuteOfHour);
+            fields.minuteOfDay = new CutoverField(julian.minuteOfDay(), fields.minuteOfDay);
+            fields.hourOfDay = new CutoverField(julian.hourOfDay(), fields.hourOfDay);
+            fields.hourOfHalfday = new CutoverField(julian.hourOfHalfday(), fields.hourOfHalfday);
+            fields.clockhourOfDay = new CutoverField(julian.clockhourOfDay(), fields.clockhourOfDay);
+            fields.clockhourOfHalfday = new CutoverField(julian.clockhourOfHalfday(),
+                                                         fields.clockhourOfHalfday);
+            fields.halfdayOfDay = new CutoverField(julian.halfdayOfDay(), fields.halfdayOfDay);
+        }
+
+        // These fields just require basic cutover support.
+        {
+            fields.era = new CutoverField(julian.era(), fields.era);
+            fields.dayOfMonth = new CutoverField(julian.dayOfMonth(), fields.dayOfMonth);
+        }
+
+        // DayOfYear and weekOfWeekyear require special handling since cutover
+        // year has fewer days and weeks. Extend the cutover to the start of
+        // the next year or weekyear. This keeps the sequence unbroken during
+        // the cutover year.
+
+        {
+            long cutover = gregorian.year().roundCeiling(iCutoverMillis);
+            fields.dayOfYear = new CutoverField
+                (julian.dayOfYear(), fields.dayOfYear, cutover);
+        }
+
+        {
+            long cutover = gregorian.weekyear().roundCeiling(iCutoverMillis);
+            fields.weekOfWeekyear = new CutoverField
+                (julian.weekOfWeekyear(), fields.weekOfWeekyear, cutover, true);
+        }
+
+        // These fields are special because they have imprecise durations. The
+        // family of addition methods need special attention. Override affected
+        // duration fields as well.
+        {
+            fields.year = new ImpreciseCutoverField(julian.year(), fields.year);
+            fields.years = fields.year.getDurationField();
+            fields.yearOfEra = new ImpreciseCutoverField
+                (julian.yearOfEra(), fields.yearOfEra, fields.years);
+            fields.yearOfCentury = new ImpreciseCutoverField
+                (julian.yearOfCentury(), fields.yearOfCentury, fields.years);
+            
+            fields.centuryOfEra = new ImpreciseCutoverField
+                (julian.centuryOfEra(), fields.centuryOfEra);
+            fields.centuries = fields.centuryOfEra.getDurationField();
+            
+            fields.monthOfYear = new ImpreciseCutoverField
+                (julian.monthOfYear(), fields.monthOfYear);
+            fields.months = fields.monthOfYear.getDurationField();
+            
+            fields.weekyear = new ImpreciseCutoverField(julian.weekyear(), fields.weekyear, true);
+            fields.weekyears = fields.weekyear.getDurationField();
+        }
+    }
+
     long julianToGregorianByYear(long instant) {
         return convertByYear(instant, iJulianChronology, iGregorianChronology);
     }
@@ -308,7 +609,7 @@ long gregorianToJulianByWeekyear(long instant) {
          * @param gregorianField field from the chronology used at and after the cutover
          */
         CutoverField(DateTimeField julianField, DateTimeField gregorianField) {
-            this(julianField, gregorianField, iCutoverInstant, false);
+            this(julianField, gregorianField, iCutoverMillis, false);
         }
 
         /**
@@ -317,19 +618,19 @@ long gregorianToJulianByWeekyear(long instant) {
          * @param convertByWeekyear
          */
         CutoverField(DateTimeField julianField, DateTimeField gregorianField, boolean convertByWeekyear) {
-            this(julianField, gregorianField, iCutoverInstant, convertByWeekyear);
+            this(julianField, gregorianField, iCutoverMillis, convertByWeekyear);
         }
 
-        CutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverInstant) {
-            this(julianField, gregorianField, cutoverInstant, false);
+        CutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {
+            this(julianField, gregorianField, cutoverMillis, false);
         }
 
         CutoverField(DateTimeField julianField, DateTimeField gregorianField,
-                     long cutoverInstant, boolean convertByWeekyear) {
+                     long cutoverMillis, boolean convertByWeekyear) {
             super(gregorianField.getName());
             iJulianField = julianField;
             iGregorianField = gregorianField;
-            iCutover = cutoverInstant;
+            iCutover = cutoverMillis;
             iConvertByWeekyear = convertByWeekyear;
             // Although average length of Julian and Gregorian years differ,
             // use the Gregorian duration field because it is more accurate.
@@ -758,4 +1059,5 @@ public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
             return iField.getDifferenceAsLong(minuendInstant, subtrahendInstant);
         }
     }
+
 }
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfMonthDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java
similarity index 92%
rename from JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfMonthDateTimeField.java
rename to JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java
index d43be2fb1..092424f09 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfMonthDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfMonthDateTimeField.java
@@ -51,11 +51,10 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono.gj;
+package org.joda.time.chrono;
 
 import org.joda.time.DurationField;
-import org.joda.time.chrono.PreciseDurationDateTimeField;
-import org.joda.time.chrono.Utils;
+import org.joda.time.field.PreciseDurationDateTimeField;
 
 /**
  * Provides time calculations for the day of the month component of time.
@@ -69,12 +68,12 @@
 
     static final long serialVersionUID = -4677223814028011723L;
 
-    private final ProlepticChronology iChronology;
+    private final AbstractGJChronology iChronology;
 
     /**
      * Restricted constructor.
      */
-    GJDayOfMonthDateTimeField(ProlepticChronology chronology, DurationField days) {
+    GJDayOfMonthDateTimeField(AbstractGJChronology chronology, DurationField days) {
         super("dayOfMonth", days);
         iChronology = chronology;
     }
@@ -102,7 +101,7 @@ public int getMaximumValue() {
     }
 
     public int getMaximumValue(long instant) {
-        int thisYear = iChronology.year().get(instant);
+        int thisYear = iChronology.getYear(instant);
         int thisMonth = iChronology.getMonthOfYear(instant, thisYear);
         return iChronology.getDaysInYearMonth(thisYear, thisMonth);
     }
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfWeekDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java
similarity index 88%
rename from JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfWeekDateTimeField.java
rename to JodaTime/src/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java
index d3b05f070..2b6ad26b3 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfWeekDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfWeekDateTimeField.java
@@ -51,14 +51,13 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono.gj;
+package org.joda.time.chrono;
 
 import java.util.Locale;
 
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DurationField;
-import org.joda.time.chrono.PreciseDurationDateTimeField;
-import org.joda.time.chrono.Utils;
+import org.joda.time.field.PreciseDurationDateTimeField;
 
 /**
  * GJDayOfWeekDateTimeField provides time calculations for the
@@ -73,12 +72,12 @@
     
     static final long serialVersionUID = -3857947176719041436L;
 
-    private final ProlepticChronology iChronology;
+    private final AbstractGJChronology iChronology;
 
     /**
      * Restricted constructor.
      */
-    GJDayOfWeekDateTimeField(ProlepticChronology chronology, DurationField days) {
+    GJDayOfWeekDateTimeField(AbstractGJChronology chronology, DurationField days) {
         super("dayOfWeek", days);
         iChronology = chronology;
     }
@@ -90,20 +89,7 @@
      * @return the day of the week extracted from the input
      */
     public int get(long instant) {
-        // 1970-01-01 is day of week 4, Thursday.
-
-        long daysSince19700101;
-        if (instant >= 0) {
-            daysSince19700101 = instant / DateTimeConstants.MILLIS_PER_DAY;
-        } else {
-            daysSince19700101 = (instant - (DateTimeConstants.MILLIS_PER_DAY - 1))
-                / DateTimeConstants.MILLIS_PER_DAY;
-            if (daysSince19700101 < -3) {
-                return 7 + (int) ((daysSince19700101 + 4) % 7);
-            }
-        }
-
-        return 1 + (int) ((daysSince19700101 + 3) % 7);
+        return iChronology.getDayOfWeek(instant);
     }
 
     /**
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfYearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java
similarity index 89%
rename from JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfYearDateTimeField.java
rename to JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java
index 92271e5fb..45ad5b696 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJDayOfYearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJDayOfYearDateTimeField.java
@@ -51,12 +51,11 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono.gj;
+package org.joda.time.chrono;
 
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DurationField;
-import org.joda.time.chrono.PreciseDurationDateTimeField;
-import org.joda.time.chrono.Utils;
+import org.joda.time.field.PreciseDurationDateTimeField;
 
 /**
  * Provides time calculations for the day of the year component of time.
@@ -70,12 +69,12 @@
 
     static final long serialVersionUID = -6821236822336841037L;
 
-    private final ProlepticChronology iChronology;
+    private final AbstractGJChronology iChronology;
 
     /**
      * Restricted constructor
      */
-    GJDayOfYearDateTimeField(ProlepticChronology chronology, DurationField days) {
+    GJDayOfYearDateTimeField(AbstractGJChronology chronology, DurationField days) {
         super("dayOfYear", days);
         iChronology = chronology;
     }
@@ -87,8 +86,7 @@
      * @return the day of the year extracted from the input.
      */
     public int get(long instant) {
-        long dateInstant = iChronology.year().roundFloor(instant);
-        return (int) ((instant - dateInstant) / DateTimeConstants.MILLIS_PER_DAY) + 1;
+        return iChronology.getDayOfYear(instant);
     }
 
     public DurationField getRangeDurationField() {
@@ -104,7 +102,7 @@ public int getMaximumValue() {
     }
 
     public int getMaximumValue(long instant) {
-        int thisYear = iChronology.year().get(instant);
+        int thisYear = iChronology.getYear(instant);
         return iChronology.getDaysInYear(thisYear);
     }
 
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java
similarity index 89%
rename from JodaTime/src/java/org/joda/time/chrono/gj/GJEraDateTimeField.java
rename to JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java
index 4d9c234ef..093764aa9 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJEraDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJEraDateTimeField.java
@@ -51,15 +51,15 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono.gj;
+package org.joda.time.chrono;
 
 import java.util.Locale;
 
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DurationField;
-import org.joda.time.chrono.AbstractDateTimeField;
-import org.joda.time.chrono.UnsupportedDurationField;
-import org.joda.time.chrono.Utils;
+import org.joda.time.field.AbstractDateTimeField;
+import org.joda.time.field.UnsupportedDurationField;
+import org.joda.time.field.FieldUtils;
 
 /**
  * Provides time calculations for the era component of time.
@@ -73,12 +73,12 @@
     
     static final long serialVersionUID = 4240986525305515528L;
 
-    private final ProlepticChronology iChronology;
+    private final AbstractGJChronology iChronology;
 
     /**
      * Restricted constructor
      */
-    GJEraDateTimeField(ProlepticChronology chronology) {
+    GJEraDateTimeField(AbstractGJChronology chronology) {
         super("era");
         iChronology = chronology;
     }
@@ -93,7 +93,7 @@ public boolean isLenient() {
      * @param instant  the time instant in millis to query.
      */
     public int get(long instant) {
-        if (iChronology.year().get(instant) <= 0) {
+        if (iChronology.getYear(instant) <= 0) {
             return DateTimeConstants.BCE;
         } else {
             return DateTimeConstants.CE;
@@ -113,12 +113,12 @@ public String getAsText(long instant, Locale locale) {
      * @throws IllegalArgumentException  if era is invalid.
      */
     public long set(long instant, int era) {
-        Utils.verifyValueBounds(this, era, DateTimeConstants.BCE, DateTimeConstants.CE);
+        FieldUtils.verifyValueBounds(this, era, DateTimeConstants.BCE, DateTimeConstants.CE);
             
         int oldEra = get(instant);
         if (oldEra != era) {
-            int year = iChronology.year().get(instant);
-            return iChronology.year().set(instant, -year);
+            int year = iChronology.getYear(instant);
+            return iChronology.setYear(instant, -year);
         } else {
             return instant;
         }
@@ -130,7 +130,7 @@ public long set(long instant, String text, Locale locale) {
 
     public long roundFloor(long instant) {
         if (get(instant) == DateTimeConstants.CE) {
-            return iChronology.year().set(0, 1);
+            return iChronology.setYear(0, 1);
         } else {
             return Long.MIN_VALUE;
         }
@@ -138,7 +138,7 @@ public long roundFloor(long instant) {
 
     public long roundCeiling(long instant) {
         if (get(instant) == DateTimeConstants.BCE) {
-            return iChronology.year().set(0, 1);
+            return iChronology.setYear(0, 1);
         } else {
             return Long.MAX_VALUE;
         }
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJLocaleSymbols.java b/JodaTime/src/java/org/joda/time/chrono/GJLocaleSymbols.java
similarity index 98%
rename from JodaTime/src/java/org/joda/time/chrono/gj/GJLocaleSymbols.java
rename to JodaTime/src/java/org/joda/time/chrono/GJLocaleSymbols.java
index d8230d629..cea800537 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJLocaleSymbols.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJLocaleSymbols.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono.gj;
+package org.joda.time.chrono;
 
 import java.lang.ref.WeakReference;
 import java.text.DateFormatSymbols;
@@ -59,7 +59,7 @@
 import java.util.Locale;
 
 /**
- * Utility class used by a few of the DateTimeFields.
+ * Utility class used by a few of the GJDateTimeFields.
  *
  * @author Brian S O'Neill
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJMonthOfYearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java
similarity index 92%
rename from JodaTime/src/java/org/joda/time/chrono/gj/GJMonthOfYearDateTimeField.java
rename to JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java
index 7e1c245ae..c453b3865 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJMonthOfYearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJMonthOfYearDateTimeField.java
@@ -51,15 +51,15 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono.gj;
+package org.joda.time.chrono;
 
 import java.util.Locale;
 
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
-import org.joda.time.chrono.ImpreciseDateTimeField;
-import org.joda.time.chrono.Utils;
+import org.joda.time.field.ImpreciseDateTimeField;
+import org.joda.time.field.FieldUtils;
 
 /**
  * Provides time calculations for the month of the year component of time.
@@ -77,13 +77,13 @@
     private static final int MIN = DateTimeConstants.JANUARY;
     private static final int MAX = DateTimeConstants.DECEMBER;
 
-    private final ProlepticChronology iChronology;
+    private final AbstractGJChronology iChronology;
 
     /**
      * Restricted constructor
      */
-    GJMonthOfYearDateTimeField(ProlepticChronology chronology) {
-        super("monthOfYear", "months", chronology.getRoughMillisPerMonth());
+    GJMonthOfYearDateTimeField(AbstractGJChronology chronology) {
+        super("monthOfYear", "months", chronology.getAverageMillisPerMonth());
         iChronology = chronology;
     }
 
@@ -133,12 +133,12 @@ public long add(long instant, int months) {
         //
         // Save time part first.
         //
-        long timePart = iChronology.millisOfDay().get(instant);
+        long timePart = iChronology.getMillisOfDay(instant);
         //
         //
         // Get this year and month.
         //
-        int thisYear = iChronology.year().get(instant);
+        int thisYear = iChronology.getYear(instant);
         int thisMonth = iChronology.getMonthOfYear(instant, thisYear);
         // ----------------------------------------------------------
         //
@@ -192,9 +192,9 @@ public long add(long instant, long months) {
 
         // Copied from add(long, int) and modified slightly:
 
-        long timePart = iChronology.millisOfDay().get(instant);
+        long timePart = iChronology.getMillisOfDay(instant);
 
-        int thisYear = iChronology.year().get(instant);
+        int thisYear = iChronology.getYear(instant);
         int thisMonth = iChronology.getMonthOfYear(instant, thisYear);
 
         long yearToUse;
@@ -247,7 +247,7 @@ public long add(long instant, long months) {
      * @return the updated time instant.
      */
     public long addWrapped(long instant, int months) {
-        return set(instant, Utils.getWrappedValue(get(instant), months, MIN, MAX));
+        return set(instant, FieldUtils.getWrappedValue(get(instant), months, MIN, MAX));
     }
 
     public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
@@ -255,10 +255,9 @@ public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
             return -getDifference(subtrahendInstant, minuendInstant);
         }
 
-        DateTimeField yearField = iChronology.year();
-        int minuendYear = yearField.get(minuendInstant);
+        int minuendYear = iChronology.getYear(minuendInstant);
         int minuendMonth = iChronology.getMonthOfYear(minuendInstant, minuendYear);
-        int subtrahendYear = yearField.get(subtrahendInstant);
+        int subtrahendYear = iChronology.getYear(subtrahendInstant);
         int subtrahendMonth = iChronology.getMonthOfYear(subtrahendInstant, subtrahendYear);
 
         long difference = (minuendYear - subtrahendYear) * 12L + minuendMonth - subtrahendMonth;
@@ -273,6 +272,7 @@ public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
                 (subtrahendInstant, subtrahendYear, subtrahendMonth);
             if (subtrahendDom > minuendDom) {
                 // ...and day of subtrahend month is larger.
+                // TODO: Don't depend on other fields
                 subtrahendInstant = iChronology.dayOfMonth().set(subtrahendInstant, minuendDom);
             }
         }
@@ -304,9 +304,9 @@ public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
      * @throws IllegalArgumentException  if month is invalid
      */
     public long set(long instant, int month) {
-        Utils.verifyValueBounds(this, month, MIN, MAX);
+        FieldUtils.verifyValueBounds(this, month, MIN, MAX);
         //
-        int thisYear = iChronology.year().get(instant);
+        int thisYear = iChronology.getYear(instant);
         //
         int thisDom = iChronology.getDayOfMonth(instant, thisYear);
         int maxDom = iChronology.getDaysInYearMonth(thisYear, month);
@@ -316,7 +316,7 @@ public long set(long instant, int month) {
         }
         // Return newly calculated millis value
         return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +
-            iChronology.millisOfDay().get(instant);
+            iChronology.getMillisOfDay(instant);
     }
 
     public long set(long instant, String text, Locale locale) {
@@ -328,7 +328,7 @@ public DurationField getRangeDurationField() {
     }
 
     public boolean isLeap(long instant) {
-        int thisYear = iChronology.year().get(instant);
+        int thisYear = iChronology.getYear(instant);
         int thisMonth = iChronology.getMonthOfYear(instant, thisYear);
         if (thisMonth != 2) {
             return false;
@@ -362,7 +362,7 @@ public int getMaximumShortTextLength(Locale locale) {
     }
 
     public long roundFloor(long instant) {
-        int year = iChronology.year().get(instant);
+        int year = iChronology.getYear(instant);
         int month = iChronology.getMonthOfYear(instant, year);
         return iChronology.getYearMonthMillis(year, month);
     }
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekOfWeekyearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java
similarity index 85%
rename from JodaTime/src/java/org/joda/time/chrono/gj/GJWeekOfWeekyearDateTimeField.java
rename to JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java
index 0b17a8753..074fb4031 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekOfWeekyearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJWeekOfWeekyearDateTimeField.java
@@ -51,13 +51,12 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono.gj;
+package org.joda.time.chrono;
 
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
-import org.joda.time.chrono.PreciseDurationDateTimeField;
-import org.joda.time.chrono.Utils;
+import org.joda.time.field.PreciseDurationDateTimeField;
 
 /**
  * Provides time calculations for the week of a week based year component of time.
@@ -72,12 +71,12 @@
 
     static final long serialVersionUID = -1587436826395135328L;
 
-    private final ProlepticChronology iChronology;
+    private final AbstractGJChronology iChronology;
 
     /**
      * Restricted constructor
      */
-    GJWeekOfWeekyearDateTimeField(ProlepticChronology chronology, DurationField weeks) {
+    GJWeekOfWeekyearDateTimeField(AbstractGJChronology chronology, DurationField weeks) {
         super("weekOfWeekyear", weeks);
         iChronology = chronology;
     }
@@ -90,17 +89,7 @@
      * @return the week of the year extracted from the input.
      */
     public int get(long instant) {
-        int year = iChronology.year().get(instant);
-        //
-        long firstWeekMillis1 = iChronology.getFirstWeekOfYearMillis(year);
-        if (instant < firstWeekMillis1) {
-            return iChronology.getWeeksInYear(year - 1);
-        }
-        long firstWeekMillis2 = iChronology.getFirstWeekOfYearMillis(year + 1);
-        if (instant >= firstWeekMillis2) {
-            return 1;
-        }
-        return (int) ((instant - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1;
+        return iChronology.getWeekOfWeekyear(instant);
     }
 
     public DurationField getRangeDurationField() {
@@ -133,7 +122,7 @@ public int getMaximumValue() {
     }
 
     public int getMaximumValue(long instant) {
-        int thisYear = iChronology.weekyear().get(instant);
+        int thisYear = iChronology.getWeekyear(instant);
         return iChronology.getWeeksInYear(thisYear);
     }
 
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekyearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJWeekyearDateTimeField.java
similarity index 84%
rename from JodaTime/src/java/org/joda/time/chrono/gj/GJWeekyearDateTimeField.java
rename to JodaTime/src/java/org/joda/time/chrono/GJWeekyearDateTimeField.java
index e906320ff..b7c1950e7 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJWeekyearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJWeekyearDateTimeField.java
@@ -51,13 +51,13 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono.gj;
+package org.joda.time.chrono;
 
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
-import org.joda.time.chrono.ImpreciseDateTimeField;
-import org.joda.time.chrono.Utils;
+import org.joda.time.field.ImpreciseDateTimeField;
+import org.joda.time.field.FieldUtils;
 
 /**
  * Provides time calculations for the week of the weekyear component of time.
@@ -75,13 +75,13 @@
 
     private static final long WEEK_53 = (53L - 1) * DateTimeConstants.MILLIS_PER_WEEK;
 
-    private final ProlepticChronology iChronology;
+    private final AbstractGJChronology iChronology;
 
     /**
      * Restricted constructor
      */
-    GJWeekyearDateTimeField(ProlepticChronology chronology) {
-        super("weekyear", "weekyears", chronology.getRoughMillisPerYear());
+    GJWeekyearDateTimeField(AbstractGJChronology chronology) {
+        super("weekyear", "weekyears", chronology.getAverageMillisPerYear());
         iChronology = chronology;
     }
 
@@ -97,14 +97,7 @@ public boolean isLenient() {
      * @return the year extracted from the input.
      */
     public int get(long instant) {
-        int week = iChronology.weekOfWeekyear().get(instant);
-        if (week == 1) {
-            return iChronology.year().get(instant + DateTimeConstants.MILLIS_PER_WEEK);
-        } else if (week > 51) {
-            return iChronology.year().get(instant - (2 * DateTimeConstants.MILLIS_PER_WEEK));
-        } else {
-            return iChronology.year().get(instant);
-        }
+        return iChronology.getWeekyear(instant);
     }
 
     /**
@@ -123,7 +116,7 @@ public long add(long instant, int years) {
     }
 
     public long add(long instant, long value) {
-        return add(instant, Utils.safeToInt(value));
+        return add(instant, FieldUtils.safeToInt(value));
     }
 
     /**
@@ -172,8 +165,8 @@ public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
      * @throws IllegalArgumentException  if year is invalid.
      */
     public long set(long instant, int year) {
-        Utils.verifyValueBounds(this, Math.abs(year),
-                                iChronology.getMinYear(), iChronology.getMaxYear());
+        FieldUtils.verifyValueBounds(this, Math.abs(year),
+                                     iChronology.getMinYear(), iChronology.getMaxYear());
         //
         // Do nothing if no real change is requested.
         //
@@ -184,7 +177,7 @@ public long set(long instant, int year) {
         //
         // Calculate the DayOfWeek (to be preserved).
         //
-        int thisDow = iChronology.dayOfWeek().get( instant );
+        int thisDow = iChronology.getDayOfWeek(instant);
         //
         // Calculate the maximum weeks in the target year.
         //
@@ -198,7 +191,7 @@ public long set(long instant, int year) {
         // for the target weekyear.  In that case it is adjusted
         // to the maximum possible.
         //
-        int setToWeek = iChronology.weekOfWeekyear().get( instant );
+        int setToWeek = iChronology.getWeekOfWeekyear(instant);
         if ( setToWeek > maxOutWeeks ) {
             setToWeek = maxOutWeeks;
         }
@@ -212,12 +205,12 @@ public long set(long instant, int year) {
         // Note - we cannot currently call ourself, so we just call
         // set for the year.  This at least gets us close.
         //
-        workInstant = iChronology.year().set( workInstant, year );
+        workInstant = iChronology.setYear( workInstant, year );
         //
         // Calculate the weekyear number for the get close to value
         // (which might not be equal to the year just set).
         //
-        int workWoyYear = iChronology.weekyear().get( workInstant );
+        int workWoyYear = get( workInstant );
 
         //
         // At most we are off by one year, which can be "fixed" by
@@ -233,7 +226,7 @@ public long set(long instant, int year) {
         //
 
         // BEGIN: possible set WeekOfWeekyear logic.
-        int currentWoyWeek = iChronology.weekOfWeekyear().get( workInstant );
+        int currentWoyWeek = iChronology.getWeekOfWeekyear(workInstant);
         // No range check required (we already know it is OK).
         workInstant = workInstant + (setToWeek - currentWoyWeek)
             * (long)DateTimeConstants.MILLIS_PER_WEEK;
@@ -242,6 +235,7 @@ public long set(long instant, int year) {
         //
         // Reset DayOfWeek to previous value.
         //
+        // TODO: Don't depend on other fields
         workInstant = iChronology.dayOfWeek().set( workInstant, thisDow );
         //
         // Return result.
@@ -254,11 +248,11 @@ public DurationField getRangeDurationField() {
     }
 
     public boolean isLeap(long instant) {
-        return iChronology.weekOfWeekyear().getMaximumValue(instant) > 52;
+        return iChronology.getWeeksInYear(iChronology.getWeekyear(instant)) > 52;
     }
 
     public int getLeapAmount(long instant) {
-        return iChronology.weekOfWeekyear().getMaximumValue(instant) - 52;
+        return iChronology.getWeeksInYear(iChronology.getWeekyear(instant)) - 52;
     }
 
     public DurationField getLeapDurationField() {
@@ -274,11 +268,11 @@ public int getMaximumValue() {
     }
 
     public long roundFloor(long instant) {
-        DateTimeField wowField = iChronology.weekOfWeekyear();
-        instant = wowField.roundFloor(instant);
-        int wow = wowField.get(instant);
+        // TODO: Don't depend on other fields
+        instant = iChronology.weekOfWeekyear().roundFloor(instant);
+        int wow = iChronology.getWeekOfWeekyear(instant);
         if (wow > 1) {
-            instant = wowField.add(instant, 1 - wow);
+            instant -= ((long) DateTimeConstants.MILLIS_PER_WEEK) * (wow - 1);
         }
         return instant;
     }
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJYearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJYearDateTimeField.java
similarity index 65%
rename from JodaTime/src/java/org/joda/time/chrono/gj/GJYearDateTimeField.java
rename to JodaTime/src/java/org/joda/time/chrono/GJYearDateTimeField.java
index db32b4686..c7312a863 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJYearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJYearDateTimeField.java
@@ -51,12 +51,12 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono.gj;
+package org.joda.time.chrono;
 
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DurationField;
-import org.joda.time.chrono.ImpreciseDateTimeField;
-import org.joda.time.chrono.Utils;
+import org.joda.time.field.ImpreciseDateTimeField;
+import org.joda.time.field.FieldUtils;
 
 /**
  * Provides time calculations for the year component of time.
@@ -72,13 +72,13 @@
 
     private static final long FEB_29 = (31L + 29 - 1) * DateTimeConstants.MILLIS_PER_DAY;
 
-    private final ProlepticChronology iChronology;
+    private final AbstractGJChronology iChronology;
 
     /**
      * Restricted constructor
      */
-    GJYearDateTimeField(ProlepticChronology chronology) {
-        super("year", "years", chronology.getRoughMillisPerYear());
+    GJYearDateTimeField(AbstractGJChronology chronology) {
+        super("year", "years", chronology.getAverageMillisPerYear());
         iChronology = chronology;
     }
 
@@ -93,81 +93,7 @@ public boolean isLenient() {
      * @return the year extracted from the input.
      */
     public int get(long instant) {
-        // Get an initial estimate of the year, and the millis value that
-        // represents the start of that year. Then verify estimate and fix if
-        // necessary.
-
-        int year;
-
-        long unitMillis = getDurationUnitMillis();
-        if (instant >= 0) {
-            year = 1970 + (int) (instant / unitMillis);
-        } else {
-            year = 1970 + (int) ((instant - unitMillis + 1) / unitMillis);
-        }
-
-        long yearStart = iChronology.getYearMillis(year);
-        if ((yearStart ^ instant) < 0) {
-            // Sign mismatch, operation overflowed.
-            return getOverflow(instant);
-        }
-
-        long diff = instant - yearStart;
-
-        if (diff < 0) {
-            // Subtract one year to fix estimate.
-            year--;
-        } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) {
-            // One year may need to be added to fix estimate.
-            long oneYear;
-            if (iChronology.isLeapYear(year)) {
-                oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L;
-            } else {
-                oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L;
-            }
-
-            yearStart += oneYear;
-            if ((yearStart ^ instant) < 0) {
-                // Sign mismatch, operation overflowed.
-                return getOverflow(instant);
-            }
-
-            if (yearStart <= instant) {
-                // Didn't go too far, so actually add one year.
-                year++;
-            }
-        }
-
-        return year;
-    }
-
-    private int getOverflow(long instant) {
-        if (instant > 0) {
-            int year = iChronology.getMaxYear();
-            long yearStartMillis = iChronology.getYearMillis(year);
-            if (iChronology.isLeapYear(year)) {
-                yearStartMillis += DateTimeConstants.MILLIS_PER_DAY * 366L;
-            } else {
-                yearStartMillis += DateTimeConstants.MILLIS_PER_DAY * 365L;
-            }
-            long yearEndMillis = yearStartMillis - 1;
-
-            if (instant <= yearEndMillis) {
-                return year;
-            }
-
-            throw new IllegalArgumentException
-                ("Instant too large: " + instant + " > " + yearEndMillis);
-        } else {
-            int year = iChronology.getMinYear();
-            long yearStartMillis = iChronology.getYearMillis(year);
-            if (instant >= yearStartMillis) {
-                return year;
-            }
-
-            throw new IllegalArgumentException
-                ("Instant too small: " + instant + " < " + yearStartMillis);
-        }
+        return iChronology.getYear(instant);
     }
 
     /**
@@ -188,7 +114,7 @@ public long add(long instant, int years) {
     }
 
     public long add(long instant, long years) {
-        return add(instant, Utils.safeToInt(years));
+        return add(instant, FieldUtils.safeToInt(years));
     }
 
     /**
@@ -204,8 +130,8 @@ public long addWrapped(long instant, int years) {
             return instant;
         }
         // Return newly calculated millis value
-        int thisYear = iChronology.year().get(instant);
-        int wrappedYear = Utils.getWrappedValue
+        int thisYear = iChronology.getYear(instant);
+        int wrappedYear = FieldUtils.getWrappedValue
             (thisYear, years, iChronology.getMinYear(), iChronology.getMaxYear());
         return set(instant, wrappedYear);
     }
@@ -249,32 +175,9 @@ public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
      * @throws IllegalArgumentException  if year is invalid.
      */
     public long set(long instant, int year) {
-        Utils.verifyValueBounds
+        FieldUtils.verifyValueBounds
             (this, year, iChronology.getMinYear(), iChronology.getMaxYear());
-
-        int dayOfYear = iChronology.dayOfYear().get(instant);
-        int millisOfDay = iChronology.millisOfDay().get(instant);
-
-        if (dayOfYear > (31 + 28)) { // after Feb 28
-            if (isLeap(instant)) {
-                // Old date is Feb 29 or later.
-                if (!iChronology.isLeapYear(year)) {
-                    // Moving to a non-leap year, Feb 29 does not exist.
-                    dayOfYear--;
-                }
-            } else {
-                // Old date is Mar 01 or later.
-                if (iChronology.isLeapYear(year)) {
-                    // Moving to a leap year, account for Feb 29.
-                    dayOfYear++;
-                }
-            }
-        }
-
-        instant = iChronology.getYearMonthDayMillis(year, 1, dayOfYear);
-        instant += millisOfDay;
-
-        return instant;
+        return iChronology.setYear(instant, year);
     }
 
     public DurationField getRangeDurationField() {
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJYearOfEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java
similarity index 91%
rename from JodaTime/src/java/org/joda/time/chrono/gj/GJYearOfEraDateTimeField.java
rename to JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java
index 245df7805..2a84c4f18 100644
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJYearOfEraDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java
@@ -51,12 +51,12 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono.gj;
+package org.joda.time.chrono;
 
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.DecoratedDateTimeField;
-import org.joda.time.chrono.Utils;
+import org.joda.time.field.DecoratedDateTimeField;
+import org.joda.time.field.FieldUtils;
 
 /**
  * Provides time calculations for the year of era component of time.
@@ -67,12 +67,12 @@
 
     static final long serialVersionUID = -5961050944769862059L;
 
-    private final ProlepticChronology iChronology;
+    private final AbstractGJChronology iChronology;
 
     /**
      * Restricted constructor.
      */
-    GJYearOfEraDateTimeField(DateTimeField yearField, ProlepticChronology chronology) {
+    GJYearOfEraDateTimeField(DateTimeField yearField, AbstractGJChronology chronology) {
         super(yearField, "yearOfEra");
         iChronology = chronology;
     }
@@ -136,12 +136,11 @@ public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
      * @throws IllegalArgumentException  if year is invalid.
      */
     public long set(long instant, int year) {
-        Utils.verifyValueBounds(this, year, 1, getMaximumValue());
-        if (iChronology.era().get(instant) == DateTimeConstants.BCE) {
-            return super.set(instant, 1 - year);
-        } else {
-            return super.set(instant, year);
+        FieldUtils.verifyValueBounds(this, year, 1, getMaximumValue());
+        if (iChronology.getYear(instant) <= 0) {
+            year = 1 - year;
         }
+        return super.set(instant, year);
     }
 
     public int getMinimumValue() {
diff --git a/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java b/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java
new file mode 100644
index 000000000..d7654d69e
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java
@@ -0,0 +1,267 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeConstants;
+import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeZone;
+import org.joda.time.field.DividedDateTimeField;
+import org.joda.time.field.OffsetDateTimeField;
+import org.joda.time.field.RemainderDateTimeField;
+
+/**
+ * 
+ * @author Guy Allard
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ */
+public final class GregorianChronology extends AbstractGJChronology {
+
+    static final long serialVersionUID = -861407383323710522L;
+
+    private static final long MILLIS_PER_YEAR =
+        (long) (365.2425 * DateTimeConstants.MILLIS_PER_DAY);
+
+    private static final long MILLIS_PER_MONTH =
+        (long) (365.2425 * DateTimeConstants.MILLIS_PER_DAY / 12);
+
+    /** Singleton instance of a UTC GregorianChronology */
+    private static final GregorianChronology INSTANCE_UTC;
+
+    /** Cache of zone to chronology arrays */
+    private static final Map cCache = new HashMap();
+
+    static {
+        INSTANCE_UTC = getInstance(DateTimeZone.UTC);
+    }
+
+    /**
+     * Gets an instance of the GregorianChronology.
+     * The time zone of the returned instance is UTC.
+     * 
+     * @return a singleton UTC instance of the chronology
+     */
+    public static GregorianChronology getInstanceUTC() {
+        return INSTANCE_UTC;
+    }
+
+    /**
+     * Gets an instance of the GregorianChronology in the default time zone.
+     * 
+     * @return a chronology in the default time zone
+     */
+    public static GregorianChronology getInstance() {
+        return getInstance(DateTimeZone.getDefault(), 4);
+    }
+
+    /**
+     * Gets an instance of the GregorianChronology in the given time zone.
+     * 
+     * @param zone  the time zone to get the chronology in, null is default
+     * @return a chronology in the specified time zone
+     */
+    public static GregorianChronology getInstance(DateTimeZone zone) {
+        return getInstance(zone, 4);
+    }
+
+    /**
+     * Gets an instance of the GregorianChronology in the given time zone.
+     * 
+     * @param zone  the time zone to get the chronology in, null is default
+     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4
+     * @return a chronology in the specified time zone
+     */
+    public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        GregorianChronology chrono;
+        synchronized (cCache) {
+            GregorianChronology[] chronos = (GregorianChronology[]) cCache.get(zone);
+            if (chronos == null) {
+                chronos = new GregorianChronology[7];
+                cCache.put(zone, chronos);
+            }
+            try {
+                chrono = chronos[minDaysInFirstWeek - 1];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                throw new IllegalArgumentException
+                    ("Invalid min days in first week: " + minDaysInFirstWeek);
+            }
+            if (chrono == null) {
+                if (zone == DateTimeZone.UTC) {
+                    chrono = new GregorianChronology(null, null, minDaysInFirstWeek);
+                } else {
+                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);
+                    chrono = new GregorianChronology
+                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);
+                }
+                chronos[minDaysInFirstWeek - 1] = chrono;
+            }
+        }
+        return chrono;
+    }
+
+    // Constructors and instance variables
+    //-----------------------------------------------------------------------
+
+    /**
+     * Restricted constructor
+     */
+    private GregorianChronology(Chronology base, Object param, int minDaysInFirstWeek) {
+        super(base, param, minDaysInFirstWeek);
+    }
+
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return getInstance(getBase().getDateTimeZone());
+    }
+
+    // Conversion
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the Chronology in the UTC time zone.
+     * 
+     * @return the chronology in UTC
+     */
+    public Chronology withUTC() {
+        return INSTANCE_UTC;
+    }
+
+    /**
+     * Gets the Chronology in a specific time zone.
+     * 
+     * @param zone  the zone to get the chronology in, null is default
+     * @return the chronology
+     */
+    public Chronology withDateTimeZone(DateTimeZone zone) {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        if (zone == getDateTimeZone()) {
+            return this;
+        }
+        return getInstance(zone);
+    }
+
+    protected void assemble(Fields fields) {
+        if (getBase() == null) {
+            super.assemble(fields);
+        }
+    }
+
+    boolean isLeapYear(int year) {
+        return ((year & 3) == 0) && ((year % 100) != 0 || (year % 400) == 0);
+    }
+
+    long calculateFirstDayOfYearMillis(int year) {
+        // Calculate relative to 2000 as that is on a 400 year boundary
+        // and that makes the sum easier
+        int relativeYear = year - 2000;
+        // Initial value is just temporary.
+        int leapYears = relativeYear / 100;
+        if (relativeYear <= 0) {
+            // Add 3 before shifting right since /4 and >>2 behave differently
+            // on negative numbers. When the expression is written as
+            // (relativeYear / 4) - (relativeYear / 100) + (relativeYear / 400),
+            // it works for both positive and negative values, except this optimization
+            // eliminates two divisions.
+            leapYears = ((relativeYear + 3) >> 2) - leapYears + ((leapYears + 3) >> 2);
+        } else {
+            leapYears = (relativeYear >> 2) - leapYears + (leapYears >> 2);
+            // For post 2000 an adjustment is needed as jan1st is before leap day
+            if (!isLeapYear(year)) {
+                leapYears++;
+            }
+        }
+        
+        long millis = (relativeYear * 365L + leapYears)
+            * (long)DateTimeConstants.MILLIS_PER_DAY;
+        
+        // Previous line was reduced from this to eliminate a multiplication.
+        // millis = ((relativeYear - leapYears) * 365L + leapYears * 366) * MILLIS_PER_DAY;
+        // (x - y)*c + y*(c + 1) => x*c - y*c + y*c + y => x*c + y
+        
+        return millis + MILLIS_1970_TO_2000;
+    }
+
+    int getMinYear() {
+        // The lowest year that can be fully supported.
+        return -292275054;
+    }
+
+    int getMaxYear() {
+        // The highest year that can be fully supported.
+        return 292278993;
+    }
+
+    long getAverageMillisPerYear() {
+        return MILLIS_PER_YEAR;
+    }
+
+    long getAverageMillisPerMonth() {
+        return MILLIS_PER_MONTH;
+    }
+
+    long getApproxMillisAtEpoch() {
+        return 1970L * MILLIS_PER_YEAR;
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/iso/ISOChronology.java b/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java
similarity index 88%
rename from JodaTime/src/java/org/joda/time/chrono/iso/ISOChronology.java
rename to JodaTime/src/java/org/joda/time/chrono/ISOChronology.java
index 29878a0c4..2eb9af376 100644
--- a/JodaTime/src/java/org/joda/time/chrono/iso/ISOChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono.iso;
+package org.joda.time.chrono;
 
 import java.io.IOException;
 import java.io.ObjectInputStream;
@@ -62,8 +62,8 @@
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeZone;
-import org.joda.time.chrono.DelegatedChronology;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.field.DividedDateTimeField;
+import org.joda.time.field.RemainderDateTimeField;
 
 /**
  * ISOChronology provides access to the individual date time fields 
@@ -77,13 +77,13 @@
  * @author Brian S O'Neill
  * @since 1.0
  */
-public final class ISOChronology extends DelegatedChronology {
+public final class ISOChronology extends AssembledChronology {
     
     static final long serialVersionUID = -6212696554273812441L;
 
     /** Singleton instance of a UTC ISOChronology */
     private static final ISOChronology INSTANCE_UTC =
-        new ISOChronology(GJChronology.getInstance(DateTimeZone.UTC, Long.MIN_VALUE, true));
+        new ISOChronology(GregorianChronology.getInstanceUTC());
         
     private static final int FAST_CACHE_SIZE = 64;
 
@@ -133,8 +133,7 @@ public static ISOChronology getInstance(DateTimeZone zone) {
         synchronized (cCache) {
             chrono = (ISOChronology) cCache.get(zone);
             if (chrono == null) {
-                chrono = new ISOChronology
-                    (GJChronology.getInstance(zone, Long.MIN_VALUE, true));
+                chrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));
                 cCache.put(zone, chrono);
             }
         }
@@ -144,19 +143,12 @@ public static ISOChronology getInstance(DateTimeZone zone) {
 
     // Constructors and instance variables
     //-----------------------------------------------------------------------
-    /**
-     * Restricted constructor
-     */
-    private ISOChronology(GJChronology gjChronology) {
-        super(gjChronology);
-    }
 
     /**
-     * Serialize ISOChronology instances using a small stub. This reduces the
-     * serialized size, and deserialized instances come from the cache.
+     * Restricted constructor
      */
-    private Object writeReplace() {
-        return new Stub(getDateTimeZone());
+    private ISOChronology(Chronology base) {
+        super(base, null);
     }
 
     // Conversion
@@ -202,6 +194,26 @@ public String toString() {
         return str;
     }
 
+    protected void assemble(Fields fields) {
+        if (getBase().getDateTimeZone() == DateTimeZone.UTC) {
+            // Use zero based century and year of century.
+            fields.centuryOfEra = new DividedDateTimeField
+                (fields.yearOfEra, "centuryOfEra", "centuries", 100);
+            fields.yearOfCentury = new RemainderDateTimeField
+                ((DividedDateTimeField)fields.centuryOfEra, "yearOfCentury");
+
+            fields.centuries = fields.centuryOfEra.getDurationField();
+        }
+    }
+
+    /**
+     * Serialize ISOChronology instances using a small stub. This reduces the
+     * serialized size, and deserialized instances come from the cache.
+     */
+    private Object writeReplace() {
+        return new Stub(getDateTimeZone());
+    }
+
     private static final class Stub implements Serializable {
         static final long serialVersionUID = -6212696554273812441L;
 
diff --git a/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java b/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java
new file mode 100644
index 000000000..1c0fc4f38
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java
@@ -0,0 +1,334 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeConstants;
+import org.joda.time.DateTimeField;
+import org.joda.time.DateTimeZone;
+import org.joda.time.field.DelegatedDateTimeField;
+import org.joda.time.field.FieldUtils;
+
+/**
+ *
+ * @author Guy Allard
+ * @author Brian S O'Neill
+ * @author Stephen Colebourne
+ */
+public final class JulianChronology extends AbstractGJChronology {
+
+    static final long serialVersionUID = -8731039522547897247L;
+
+    private static final long MILLIS_PER_YEAR =
+        (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY);
+
+    private static final long MILLIS_PER_MONTH =
+        (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY / 12);
+
+    /** Singleton instance of a UTC JulianChronology */
+    private static final JulianChronology INSTANCE_UTC;
+
+    /** Cache of zone to chronology arrays */
+    private static final Map cCache = new HashMap();
+
+    static {
+        INSTANCE_UTC = getInstance(DateTimeZone.UTC);
+    }
+
+    static int adjustYearForSet(int year) {
+        if (year <= 0) {
+            if (year == 0) {
+                throw new IllegalArgumentException("Invalid year: " + year);
+            }
+            year++;
+        }
+        return year;
+    }
+
+    /**
+     * Gets an instance of the JulianChronology.
+     * The time zone of the returned instance is UTC.
+     * 
+     * @return a singleton UTC instance of the chronology
+     */
+    public static JulianChronology getInstanceUTC() {
+        return INSTANCE_UTC;
+    }
+
+    /**
+     * Gets an instance of the JulianChronology in the default time zone.
+     * 
+     * @return a chronology in the default time zone
+     */
+    public static JulianChronology getInstance() {
+        return getInstance(DateTimeZone.getDefault(), 4);
+    }
+
+    /**
+     * Gets an instance of the JulianChronology in the given time zone.
+     * 
+     * @param zone  the time zone to get the chronology in, null is default
+     * @return a chronology in the specified time zone
+     */
+    public static JulianChronology getInstance(DateTimeZone zone) {
+        return getInstance(zone, 4);
+    }
+
+    /**
+     * Gets an instance of the JulianChronology in the given time zone.
+     * 
+     * @param zone  the time zone to get the chronology in, null is default
+     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4
+     * @return a chronology in the specified time zone
+     */
+    public static JulianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        JulianChronology chrono;
+        synchronized (cCache) {
+            JulianChronology[] chronos = (JulianChronology[]) cCache.get(zone);
+            if (chronos == null) {
+                chronos = new JulianChronology[7];
+                cCache.put(zone, chronos);
+            }
+            try {
+                chrono = chronos[minDaysInFirstWeek - 1];
+            } catch (ArrayIndexOutOfBoundsException e) {
+                throw new IllegalArgumentException
+                    ("Invalid min days in first week: " + minDaysInFirstWeek);
+            }
+            if (chrono == null) {
+                if (zone == DateTimeZone.UTC) {
+                    chrono = new JulianChronology(null, null, minDaysInFirstWeek);
+                } else {
+                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);
+                    chrono = new JulianChronology
+                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);
+                }
+                chronos[minDaysInFirstWeek - 1] = chrono;
+            }
+        }
+        return chrono;
+    }
+
+    // Constructors and instance variables
+    //-----------------------------------------------------------------------
+
+    /**
+     * Restricted constructor
+     */
+    JulianChronology(Chronology base, Object param, int minDaysInFirstWeek) {
+        super(base, param, minDaysInFirstWeek);
+    }
+
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return getInstance(getBase().getDateTimeZone());
+    }
+
+    // Conversion
+    //-----------------------------------------------------------------------
+    /**
+     * Gets the Chronology in the UTC time zone.
+     * 
+     * @return the chronology in UTC
+     */
+    public Chronology withUTC() {
+        return INSTANCE_UTC;
+    }
+
+    /**
+     * Gets the Chronology in a specific time zone.
+     * 
+     * @param zone  the zone to get the chronology in, null is default
+     * @return the chronology
+     */
+    public Chronology withDateTimeZone(DateTimeZone zone) {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
+        }
+        if (zone == getDateTimeZone()) {
+            return this;
+        }
+        return getInstance(zone);
+    }
+
+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
+        throws IllegalArgumentException
+    {
+        return super.getDateOnlyMillis(adjustYearForSet(year), monthOfYear, dayOfMonth);
+    }
+
+    boolean isLeapYear(int year) {
+        return (year & 3) == 0;
+    }
+
+    long calculateFirstDayOfYearMillis(int year) {
+        // Java epoch is 1970-01-01 Gregorian which is 1969-12-19 Julian.
+        // Calculate relative to the nearest leap year and account for the
+        // difference later.
+
+        int relativeYear = year - 1968;
+        int leapYears;
+        if (relativeYear <= 0) {
+            // Add 3 before shifting right since /4 and >>2 behave differently
+            // on negative numbers.
+            leapYears = (relativeYear + 3) >> 2;
+        } else {
+            leapYears = relativeYear >> 2;
+            // For post 1968 an adjustment is needed as jan1st is before leap day
+            if (!isLeapYear(year)) {
+                leapYears++;
+            }
+        }
+        
+        long millis = (relativeYear * 365L + leapYears)
+            * (long)DateTimeConstants.MILLIS_PER_DAY;
+
+        // Adjust to account for difference between 1968-01-01 and 1969-12-19.
+
+        return millis - (366L + 352) * DateTimeConstants.MILLIS_PER_DAY;
+    }
+
+    int getMinYear() {
+        // The lowest year that can be fully supported.
+        return -292269053;
+    }
+
+    int getMaxYear() {
+        // The highest year that can be fully supported.
+        return 292272992;
+    }
+
+    long getAverageMillisPerYear() {
+        return MILLIS_PER_YEAR;
+    }
+
+    long getAverageMillisPerMonth() {
+        return MILLIS_PER_MONTH;
+    }
+
+    long getApproxMillisAtEpoch() {
+        return 1969L * MILLIS_PER_YEAR + 352L * DateTimeConstants.MILLIS_PER_DAY;
+    }
+
+    protected void assemble(Fields fields) {
+        if (getBase() == null) {
+            super.assemble(fields);
+            // Julian chronology has no year zero.
+            fields.year = new NoYearZeroField(this, fields.year);
+            fields.weekyear = new NoWeekyearZeroField(this, fields.weekyear);
+        }
+    }
+
+    static class NoYearZeroField extends DelegatedDateTimeField {
+        static final long serialVersionUID = -8869148464118507846L;
+
+        final AbstractGJChronology iChronology;
+        private transient int iMinYear;
+
+        NoYearZeroField(AbstractGJChronology chronology, DateTimeField field) {
+            super(field);
+            iChronology = chronology;
+            int min = super.getMinimumValue();
+            if (min < 0) {
+                iMinYear = min - 1;
+            } else if (min == 0) {
+                iMinYear = 1;
+            } else {
+                iMinYear = min;
+            }
+        }
+        
+        public int get(long millis) {
+            int year = super.get(millis);
+            if (year <= 0) {
+                year--;
+            }
+            return year;
+        }
+
+        public long set(long millis, int year) {
+            FieldUtils.verifyValueBounds(this, year, iMinYear, getMaximumValue());
+            return super.set(millis, adjustYearForSet(year));
+        }
+
+        public int getMinimumValue() {
+            return iMinYear;
+        }
+
+        private Object readResolve() {
+            return iChronology.year();
+        }
+    }
+
+    static class NoWeekyearZeroField extends NoYearZeroField {
+        static final long serialVersionUID = -5013429014495501104L;
+
+        NoWeekyearZeroField(AbstractGJChronology chronology, DateTimeField field) {
+            super(chronology, field);
+        }
+        
+        private Object readResolve() {
+            return iChronology.weekyear();
+        }
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java b/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java
index c075cbd5d..1a8e1b2ae 100644
--- a/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java
@@ -56,6 +56,7 @@
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeZone;
+import org.joda.time.field.LenientDateTimeField;
 
 /**
  * Wraps another chronology, ensuring all the fields are lenient.
@@ -66,304 +67,90 @@
  * @see LenientDateTimeField
  * @see StrictChronology
  */
-public class LenientChronology extends DelegatedChronology {
+public final class LenientChronology extends AssembledChronology {
 
     static final long serialVersionUID = -3148237568046877177L;
 
-    private transient DateTimeField iYearField;
-    private transient DateTimeField iYearOfEraField;
-    private transient DateTimeField iYearOfCenturyField;
-    private transient DateTimeField iCenturyOfEraField;
-    private transient DateTimeField iEraField;
-    private transient DateTimeField iDayOfWeekField;
-    private transient DateTimeField iDayOfMonthField;
-    private transient DateTimeField iDayOfYearField;
-    private transient DateTimeField iMonthOfYearField;
-    private transient DateTimeField iWeekOfWeekyearField;
-    private transient DateTimeField iWeekyearField;
-
-    private transient DateTimeField iMillisOfSecondField;
-    private transient DateTimeField iMillisOfDayField;
-    private transient DateTimeField iSecondOfMinuteField;
-    private transient DateTimeField iSecondOfDayField;
-    private transient DateTimeField iMinuteOfHourField;
-    private transient DateTimeField iMinuteOfDayField;
-    private transient DateTimeField iHourOfDayField;
-    private transient DateTimeField iHourOfHalfdayField;
-    private transient DateTimeField iClockhourOfDayField;
-    private transient DateTimeField iClockhourOfHalfdayField;
-    private transient DateTimeField iHalfdayOfDayField;
-
-    private transient Chronology iWithUTC;
-
     /**
      * Create a LenientChronology for any chronology.
      *
-     * @param chrono the chronology
+     * @param base the chronology to wrap
      * @throws IllegalArgumentException if chronology is null
      */
-    public LenientChronology(Chronology chrono) {
-        super(chrono);
-    }
-
-    public Chronology withUTC() {
-        if (iWithUTC == null) {
-            iWithUTC = new LenientChronology(getWrappedChronology().withUTC());
+    public static LenientChronology getInstance(Chronology base) {
+        if (base == null) {
+            throw new IllegalArgumentException("Must supply a chronology");
         }
-        return iWithUTC;
-    }
-
-    public Chronology withDateTimeZone(DateTimeZone zone) {
-        return new LenientChronology(getWrappedChronology().withDateTimeZone(zone));
-    }
-
-    /**
-     * Overridden to ensure lenient fields are used.
-     */
-    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
-        throws IllegalArgumentException
-    {
-        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);
-    }
-
-    /**
-     * Overridden to ensure lenient fields are used.
-     */
-    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        long instant = hourOfDay().set(0, hourOfDay);
-        instant = minuteOfHour().set(instant, minuteOfHour);
-        instant = secondOfMinute().set(instant, secondOfMinute);
-        return millisOfSecond().set(instant, millisOfSecond);
-    }
-
-    /**
-     * Overridden to ensure lenient fields are used.
-     */
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int millisOfDay)
-        throws IllegalArgumentException
-    {
-        long instant = year().set(0, year);
-        instant = monthOfYear().set(instant, monthOfYear);
-        instant = dayOfMonth().set(instant, dayOfMonth);
-        return millisOfDay().set(instant, millisOfDay);
+        return new LenientChronology(base);
     }
 
-    /**
-     * Overridden to ensure lenient fields are used.
-     */
-    public long getDateTimeMillis(long instant,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        instant = hourOfDay().set(instant, hourOfDay);
-        instant = minuteOfHour().set(instant, minuteOfHour);
-        instant = secondOfMinute().set(instant, secondOfMinute);
-        return millisOfSecond().set(instant, millisOfSecond);
-    }
+    private transient Chronology iWithUTC;
 
     /**
-     * Overridden to ensure lenient fields are used.
+     * Create a LenientChronology for any chronology.
+     *
+     * @param base the chronology to wrap
      */
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        long instant = year().set(0, year);
-        instant = monthOfYear().set(instant, monthOfYear);
-        instant = dayOfMonth().set(instant, dayOfMonth);
-        instant = hourOfDay().set(instant, hourOfDay);
-        instant = minuteOfHour().set(instant, minuteOfHour);
-        instant = secondOfMinute().set(instant, secondOfMinute);
-        return millisOfSecond().set(instant, millisOfSecond);
-    }
-
-    // Milliseconds
-    //------------------------------------------------------------
-
-    public DateTimeField millisOfSecond() {
-        if (iMillisOfDayField == null) {
-            iMillisOfSecondField = LenientDateTimeField.getInstance(super.millisOfSecond());
-        }
-        return iMillisOfSecondField;
-    }
-
-    public DateTimeField millisOfDay() {
-        if (iMillisOfDayField == null) {
-            iMillisOfDayField = LenientDateTimeField.getInstance(super.millisOfDay());
-        }
-        return iMillisOfDayField;
-    }
-
-    // Seconds
-    //------------------------------------------------------------
-
-    public DateTimeField secondOfMinute() {
-        if (iSecondOfMinuteField == null) {
-            iSecondOfMinuteField = LenientDateTimeField.getInstance(super.secondOfMinute());
-        }
-        return iSecondOfMinuteField;
-    }
-
-    public DateTimeField secondOfDay() {
-        if (iSecondOfDayField == null) {
-            iSecondOfDayField = LenientDateTimeField.getInstance(super.secondOfDay());
-        }
-        return iSecondOfDayField;
-    }
-
-    // Minutes
-    //------------------------------------------------------------
-
-    public DateTimeField minuteOfHour() {
-        if (iMinuteOfHourField == null) {
-            iMinuteOfHourField = LenientDateTimeField.getInstance(super.minuteOfHour());
-        }
-        return iMinuteOfHourField;
+    private LenientChronology(Chronology base) {
+        super(base, null);
     }
 
-    public DateTimeField minuteOfDay() {
-        if (iMinuteOfDayField == null) {
-            iMinuteOfDayField = LenientDateTimeField.getInstance(super.minuteOfDay());
-        }
-        return iMinuteOfDayField;
-    }
-
-    // Hours
-    //------------------------------------------------------------
-
-    public DateTimeField hourOfDay() {
-        if (iHourOfDayField == null) {
-            iHourOfDayField = LenientDateTimeField.getInstance(super.hourOfDay());
-        }
-        return iHourOfDayField;
-    }
-
-    public DateTimeField clockhourOfDay() {
-        if (iClockhourOfDayField == null) {
-            iClockhourOfDayField = LenientDateTimeField.getInstance(super.clockhourOfDay());
-        }
-        return iClockhourOfDayField;
-    }
-
-    public DateTimeField hourOfHalfday() {
-        if (iHourOfHalfdayField == null) {
-            iHourOfHalfdayField = LenientDateTimeField.getInstance(super.hourOfHalfday());
-        }
-        return iHourOfHalfdayField;
-    }
-
-    public DateTimeField clockhourOfHalfday() {
-        if (iClockhourOfHalfdayField == null) {
-            iClockhourOfHalfdayField =
-                LenientDateTimeField.getInstance(super.clockhourOfHalfday());
-        }
-        return iClockhourOfHalfdayField;
-    }
-
-    public DateTimeField halfdayOfDay() {
-        if (iHalfdayOfDayField == null) {
-            iHalfdayOfDayField = LenientDateTimeField.getInstance(super.halfdayOfDay());
-        }
-        return iHalfdayOfDayField;
-    }
-
-    // Day
-    //------------------------------------------------------------
-
-    public DateTimeField dayOfWeek() {
-        if (iDayOfWeekField == null) {
-            iDayOfWeekField = LenientDateTimeField.getInstance(super.dayOfWeek());
-        }
-        return iDayOfWeekField;
-    }
-
-    public DateTimeField dayOfMonth() {
-        if (iDayOfMonthField == null) {
-            iDayOfMonthField = LenientDateTimeField.getInstance(super.dayOfMonth());
-        }
-        return iDayOfMonthField;
-    }
-
-    public DateTimeField dayOfYear() {
-        if (iDayOfYearField == null) {
-            iDayOfYearField = LenientDateTimeField.getInstance(super.dayOfYear());
-        }
-        return iDayOfYearField;
-    }
-
-    // Week
-    //------------------------------------------------------------
-
-    public DateTimeField weekOfWeekyear() {
-        if (iWeekOfWeekyearField == null) {
-            iWeekOfWeekyearField = LenientDateTimeField.getInstance(super.weekOfWeekyear());
-        }
-        return iWeekOfWeekyearField;
-    }
-
-    public DateTimeField weekyear() {
-        if (iWeekyearField == null) {
-            iWeekyearField = LenientDateTimeField.getInstance(super.weekyear());
+    public Chronology withUTC() {
+        if (iWithUTC == null) {
+            if (getDateTimeZone() == DateTimeZone.UTC) {
+                iWithUTC = this;
+            } else {
+                iWithUTC = LenientChronology.getInstance(getBase().withUTC());
+            }
         }
-        return iWeekyearField;
+        return iWithUTC;
     }
 
-    // Month
-    //------------------------------------------------------------
-
-    public DateTimeField monthOfYear() {
-        if (iMonthOfYearField == null) {
-            iMonthOfYearField = LenientDateTimeField.getInstance(super.monthOfYear());
+    public Chronology withDateTimeZone(DateTimeZone zone) {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
         }
-        return iMonthOfYearField;
-    }
-
-    // Year
-    //------------------------------------------------------------
-
-    public DateTimeField year() {
-        if (iYearField == null) {
-            iYearField = LenientDateTimeField.getInstance(super.year());
+        if (zone == DateTimeZone.UTC) {
+            return withUTC();
         }
-        return iYearField;
-    }
-
-    public DateTimeField yearOfEra() {
-        if (iYearOfEraField == null) {
-            iYearOfEraField = LenientDateTimeField.getInstance(super.yearOfEra());
+        if (zone == getDateTimeZone()) {
+            return this;
         }
-        return iYearOfEraField;
+        return LenientChronology.getInstance(getBase().withDateTimeZone(zone));
     }
 
-    public DateTimeField yearOfCentury() {
-        if (iYearOfCenturyField == null) {
-            iYearOfCenturyField = LenientDateTimeField.getInstance(super.yearOfCentury());
-        }
-        return iYearOfCenturyField;
-    }
+    protected void assemble(Fields fields) {
+        fields.year = convertField(fields.year);
+        fields.yearOfEra = convertField(fields.yearOfEra);
+        fields.yearOfCentury = convertField(fields.yearOfCentury);
+        fields.centuryOfEra = convertField(fields.centuryOfEra);
+        fields.era = convertField(fields.era);
+        fields.dayOfWeek = convertField(fields.dayOfWeek);
+        fields.dayOfMonth = convertField(fields.dayOfMonth);
+        fields.dayOfYear = convertField(fields.dayOfYear);
+        fields.monthOfYear = convertField(fields.monthOfYear);
+        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear);
+        fields.weekyear = convertField(fields.weekyear);
 
-    public DateTimeField centuryOfEra() {
-        if (iCenturyOfEraField == null) {
-            iCenturyOfEraField = LenientDateTimeField.getInstance(super.centuryOfEra());
-        }
-        return iCenturyOfEraField;
+        fields.millisOfSecond = convertField(fields.millisOfSecond);
+        fields.millisOfDay = convertField(fields.millisOfDay);
+        fields.secondOfMinute = convertField(fields.secondOfMinute);
+        fields.secondOfDay = convertField(fields.secondOfDay);
+        fields.minuteOfHour = convertField(fields.minuteOfHour);
+        fields.minuteOfDay = convertField(fields.minuteOfDay);
+        fields.hourOfDay = convertField(fields.hourOfDay);
+        fields.hourOfHalfday = convertField(fields.hourOfHalfday);
+        fields.clockhourOfDay = convertField(fields.clockhourOfDay);
+        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday);
+        fields.halfdayOfDay = convertField(fields.halfdayOfDay);
     }
 
-    public DateTimeField era() {
-        if (iEraField == null) {
-            iEraField = LenientDateTimeField.getInstance(super.era());
-        }
-        return iEraField;
+    private static final DateTimeField convertField(DateTimeField field) {
+        return LenientDateTimeField.getInstance(field);
     }
 
     public String toString() {
-        return "LenientChronology[" + getWrappedChronology().toString() + ']';
+        return "LenientChronology[" + getBase().toString() + ']';
     }
 
 }
diff --git a/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java b/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java
index 41fdf2d78..1963cc410 100644
--- a/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java
@@ -67,6 +67,8 @@
 import org.joda.time.DurationField;
 import org.joda.time.MutableDateTime;
 import org.joda.time.ReadableDateTime;
+import org.joda.time.field.DecoratedDateTimeField;
+import org.joda.time.field.DecoratedDurationField;
 import org.joda.time.format.DateTimePrinter;
 import org.joda.time.format.ISODateTimeFormat;
 
@@ -85,159 +87,59 @@
  * @author Stephen Colebourne
  * @since 1.0
  */
-public class LimitChronology extends Chronology {
+public final class LimitChronology extends AssembledChronology {
 
     static final long serialVersionUID = 7670866536893052522L;
 
-    private final Chronology iChronology;
-
-    final DateTime iLowerLimit;
-    final DateTime iUpperLimit;
-
-    private transient LimitChronology iWithUTC;
-
-    private transient DurationField iErasField;
-    private transient DurationField iCenturiesField;
-    private transient DurationField iYearsField;
-    private transient DurationField iMonthsField;
-    private transient DurationField iWeekyearsField;
-    private transient DurationField iWeeksField;
-    private transient DurationField iDaysField;
-
-    private transient DurationField iHoursField;
-    private transient DurationField iMinutesField;
-    private transient DurationField iSecondsField;
-    private transient DurationField iMillisField;
-
-    private transient DateTimeField iYearField;
-    private transient DateTimeField iYearOfEraField;
-    private transient DateTimeField iYearOfCenturyField;
-    private transient DateTimeField iCenturyOfEraField;
-    private transient DateTimeField iEraField;
-    private transient DateTimeField iDayOfWeekField;
-    private transient DateTimeField iDayOfMonthField;
-    private transient DateTimeField iDayOfYearField;
-    private transient DateTimeField iMonthOfYearField;
-    private transient DateTimeField iWeekOfWeekyearField;
-    private transient DateTimeField iWeekyearField;
-
-    private transient DateTimeField iMillisOfSecondField;
-    private transient DateTimeField iMillisOfDayField;
-    private transient DateTimeField iSecondOfMinuteField;
-    private transient DateTimeField iSecondOfDayField;
-    private transient DateTimeField iMinuteOfHourField;
-    private transient DateTimeField iMinuteOfDayField;
-    private transient DateTimeField iHourOfDayField;
-    private transient DateTimeField iHourOfHalfdayField;
-    private transient DateTimeField iClockhourOfDayField;
-    private transient DateTimeField iClockhourOfHalfdayField;
-    private transient DateTimeField iHalfdayOfDayField;
-
     /**
      * Wraps another chronology, with datetime limits. When withUTC or
      * withDateTimeZone is called, the returned LimitChronology instance has
      * the same limits, except they are time zone adjusted.
      *
+     * @param base base chronology to wrap
      * @param lowerLimit  inclusive lower limit, or null if none
      * @param upperLimit  exclusive upper limit, or null if none
      * @throws IllegalArgumentException if chronology is null or limits are invalid
      */
-    public LimitChronology(Chronology chrono,
-                           ReadableDateTime lowerLimit, ReadableDateTime upperLimit) {
-        if (chrono == null) {
+    public static LimitChronology getInstance(Chronology base,
+                                              ReadableDateTime lowerLimit,
+                                              ReadableDateTime upperLimit) {
+        if (base == null) {
             throw new IllegalArgumentException("Must supply a chronology");
         }
 
-        iChronology = chrono;
-
-        iLowerLimit = lowerLimit == null ? null : lowerLimit.toDateTime();
-        iUpperLimit = upperLimit == null ? null : upperLimit.toDateTime();
+        lowerLimit = lowerLimit == null ? null : lowerLimit.toDateTime();
+        upperLimit = upperLimit == null ? null : upperLimit.toDateTime();
 
-        if (iLowerLimit != null && iUpperLimit != null) {
-            if (!iLowerLimit.isBefore(iUpperLimit)) {
+        if (lowerLimit != null && upperLimit != null) {
+            if (!lowerLimit.isBefore(upperLimit)) {
                 throw new IllegalArgumentException
                     ("The lower limit must be come before than the upper limit");
             }
         }
 
-        setFields();
+        return new LimitChronology(base, (DateTime)lowerLimit, (DateTime)upperLimit);
     }
 
-    private void setFields() {
-        Chronology c = iChronology;
-
-        // Keep a local cache of converted fields so as not to create redundant
-        // objects.
-        HashMap converted = new HashMap();
-
-        // Convert duration fields...
-
-        iErasField = convertField(c.eras(), converted);
-        iCenturiesField = convertField(c.centuries(), converted);
-        iYearsField = convertField(c.years(), converted);
-        iMonthsField = convertField(c.months(), converted);
-        iWeekyearsField = convertField(c.weekyears(), converted);
-        iWeeksField = convertField(c.weeks(), converted);
-        iDaysField = convertField(c.days(), converted);
-
-        iHoursField = convertField(c.hours(), converted);
-        iMinutesField = convertField(c.minutes(), converted);
-        iSecondsField = convertField(c.seconds(), converted);
-        iMillisField = convertField(c.millis(), converted);
-
-        // Convert datetime fields...
-
-        iYearField = convertField(c.year(), converted);
-        iYearOfEraField = convertField(c.yearOfEra(), converted);
-        iYearOfCenturyField = convertField(c.yearOfCentury(), converted);
-        iCenturyOfEraField = convertField(c.centuryOfEra(), converted);
-        iEraField = convertField(c.era(), converted);
-        iDayOfWeekField = convertField(c.dayOfWeek(), converted);
-        iDayOfMonthField = convertField(c.dayOfMonth(), converted);
-        iDayOfYearField = convertField(c.dayOfYear(), converted);
-        iMonthOfYearField = convertField(c.monthOfYear(), converted);
-        iWeekOfWeekyearField = convertField(c.weekOfWeekyear(), converted);
-        iWeekyearField = convertField(c.weekyear(), converted);
-
-        iMillisOfSecondField = convertField(c.millisOfSecond(), converted);
-        iMillisOfDayField = convertField(c.millisOfDay(), converted);
-        iSecondOfMinuteField = convertField(c.secondOfMinute(), converted);
-        iSecondOfDayField = convertField(c.secondOfDay(), converted);
-        iMinuteOfHourField = convertField(c.minuteOfHour(), converted);
-        iMinuteOfDayField = convertField(c.minuteOfDay(), converted);
-        iHourOfDayField = convertField(c.hourOfDay(), converted);
-        iHourOfHalfdayField = convertField(c.hourOfHalfday(), converted);
-        iClockhourOfDayField = convertField(c.clockhourOfDay(), converted);
-        iClockhourOfHalfdayField = convertField(c.clockhourOfHalfday(), converted);
-        iHalfdayOfDayField = convertField(c.halfdayOfDay(), converted);
-    }
+    final DateTime iLowerLimit;
+    final DateTime iUpperLimit;
 
-    private DurationField convertField(DurationField field, HashMap converted) {
-        if (field == null || !field.isSupported()) {
-            return field;
-        }
-        if (converted.containsKey(field)) {
-            return (DurationField)converted.get(field);
-        }
-        LimitDurationField limitField = new LimitDurationField(field);
-        converted.put(field, limitField);
-        return limitField;
-    }
+    private transient LimitChronology iWithUTC;
 
-    private DateTimeField convertField(DateTimeField field, HashMap converted) {
-        if (field == null || !field.isSupported()) {
-            return field;
-        }
-        if (converted.containsKey(field)) {
-            return (DateTimeField)converted.get(field);
-        }
-        LimitDateTimeField limitField =
-            new LimitDateTimeField(field,
-                                   convertField(field.getDurationField(), converted),
-                                   convertField(field.getRangeDurationField(), converted),
-                                   convertField(field.getLeapDurationField(), converted));
-        converted.put(field, limitField);
-        return limitField;
+    /**
+     * Wraps another chronology, with datetime limits. When withUTC or
+     * withDateTimeZone is called, the returned LimitChronology instance has
+     * the same limits, except they are time zone adjusted.
+     *
+     * @param lowerLimit  inclusive lower limit, or null if none
+     * @param upperLimit  exclusive upper limit, or null if none
+     */
+    private LimitChronology(Chronology base,
+                            DateTime lowerLimit, DateTime upperLimit) {
+        super(base, null);
+        // These can be set after assembly.
+        iLowerLimit = lowerLimit;
+        iUpperLimit = upperLimit;
     }
 
     /**
@@ -254,19 +156,10 @@ public DateTime getLowerLimit() {
      * 
      * @return upper limit
      */
-    public DateTime getUpperBound() {
+    public DateTime getUpperLimit() {
         return iUpperLimit;
     }
 
-    /**
-     * Gets the wrapped chronology.
-     * 
-     * @return the wrapped Chronology
-     */
-    protected Chronology getWrappedChronology() {
-        return iChronology;
-    }
-
     /**
      * If this LimitChronology is already UTC, then this is
      * returned. Otherwise, a new instance is returned, with the limits
@@ -307,8 +200,8 @@ public Chronology withDateTimeZone(DateTimeZone zone) {
             upperLimit = mdt.toDateTime();
         }
         
-        LimitChronology chrono = new LimitChronology
-            (iChronology.withDateTimeZone(zone), lowerLimit, upperLimit);
+        LimitChronology chrono = getInstance
+            (getBase().withDateTimeZone(zone), lowerLimit, upperLimit);
 
         if (zone == DateTimeZone.UTC) {
             iWithUTC = chrono;
@@ -317,13 +210,9 @@ public Chronology withDateTimeZone(DateTimeZone zone) {
         return chrono;
     }
 
-    public DateTimeZone getDateTimeZone() {
-        return iChronology.getDateTimeZone();
-    }
-
     public long getDateOnlyMillis(long instant) {
         checkLimits(instant, null);
-        instant = iChronology.getDateOnlyMillis(instant);
+        instant = getBase().getDateOnlyMillis(instant);
         checkLimits(instant, "resulting");
         return instant;
     }
@@ -331,14 +220,14 @@ public long getDateOnlyMillis(long instant) {
     public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
         throws IllegalArgumentException
     {
-        long instant = iChronology.getDateOnlyMillis(year, monthOfYear, dayOfMonth);
+        long instant = getBase().getDateOnlyMillis(year, monthOfYear, dayOfMonth);
         checkLimits(instant, "resulting");
         return instant;
     }
 
     public long getTimeOnlyMillis(long instant) {
         checkLimits(instant, null);
-        instant = iChronology.getTimeOnlyMillis(instant);
+        instant = getBase().getTimeOnlyMillis(instant);
         checkLimits(instant, "resulting");
         return instant;
     }
@@ -347,7 +236,7 @@ public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
                                   int secondOfMinute, int millisOfSecond)
         throws IllegalArgumentException
     {
-        long instant = iChronology.getTimeOnlyMillis
+        long instant = getBase().getTimeOnlyMillis
             (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
         checkLimits(instant, "resulting");
         return instant;
@@ -357,7 +246,7 @@ public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
                                   int millisOfDay)
         throws IllegalArgumentException
     {
-        long instant = iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);
+        long instant = getBase().getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);
         checkLimits(instant, "resulting");
         return instant;
     }
@@ -368,7 +257,7 @@ public long getDateTimeMillis(long instant,
         throws IllegalArgumentException
     {
         checkLimits(instant, null);
-        instant = iChronology.getDateTimeMillis
+        instant = getBase().getDateTimeMillis
             (instant, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
         checkLimits(instant, "resulting");
         return instant;
@@ -379,178 +268,90 @@ public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
                                   int secondOfMinute, int millisOfSecond)
         throws IllegalArgumentException
     {
-        long instant = iChronology.getDateTimeMillis
+        long instant = getBase().getDateTimeMillis
             (year, monthOfYear, dayOfMonth,
              hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
         checkLimits(instant, "resulting");
         return instant;
     }
 
-    // Milliseconds
-    //------------------------------------------------------------
-
-    public DurationField millis() {
-        return iMillisField;
-    }
-
-    public DateTimeField millisOfSecond() {
-        return iMillisOfSecondField;
-    }
-
-    public DateTimeField millisOfDay() {
-        return iMillisOfDayField;
-    }
-
-    // Seconds
-    //------------------------------------------------------------
-
-    public DurationField seconds() {
-        return iSecondsField;
-    }
-
-    public DateTimeField secondOfMinute() {
-        return iSecondOfMinuteField;
-    }
-
-    public DateTimeField secondOfDay() {
-        return iSecondOfDayField;
-    }
-
-    // Minutes
-    //------------------------------------------------------------
-
-    public DurationField minutes() {
-        return iMinutesField;
-    }
-
-    public DateTimeField minuteOfHour() {
-        return iMinuteOfHourField;
-    }
-
-    public DateTimeField minuteOfDay() {
-        return iMinuteOfDayField;
-    }
-
-    // Hours
-    //------------------------------------------------------------
-
-    public DurationField hours() {
-        return iHoursField;
-    }
-
-    public DateTimeField hourOfDay() {
-        return iHourOfDayField;
-    }
-
-    public DateTimeField clockhourOfDay() {
-        return iClockhourOfDayField;
-    }
-
-    public DateTimeField hourOfHalfday() {
-        return iHourOfHalfdayField;
-    }
-
-    public DateTimeField clockhourOfHalfday() {
-        return iClockhourOfHalfdayField;
-    }
-
-    public DateTimeField halfdayOfDay() {
-        return iHalfdayOfDayField;
-    }
-
-    // Day
-    //------------------------------------------------------------
-
-    public DurationField days() {
-        return iDaysField;
-    }
-
-    public DateTimeField dayOfWeek() {
-        return iDayOfWeekField;
-    }
-
-    public DateTimeField dayOfMonth() {
-        return iDayOfMonthField;
-    }
-
-    public DateTimeField dayOfYear() {
-        return iDayOfYearField;
-    }
-
-    // Week
-    //------------------------------------------------------------
-
-    public DurationField weeks() {
-        return iWeeksField;
-    }
-
-    public DateTimeField weekOfWeekyear() {
-        return iWeekOfWeekyearField;
-    }
-
-    public DurationField weekyears() {
-        return iWeekyearsField;
-    }
-
-    public DateTimeField weekyear() {
-        return iWeekyearField;
-    }
-
-    // Month
-    //------------------------------------------------------------
-
-    public DurationField months() {
-        return iMonthsField;
-    }
-
-    public DateTimeField monthOfYear() {
-        return iMonthOfYearField;
-    }
-
-    // Year
-    //------------------------------------------------------------
-
-    public DurationField years() {
-        return iYearsField;
-    }
+    protected void assemble(Fields fields) {
+        // Keep a local cache of converted fields so as not to create redundant
+        // objects.
+        HashMap converted = new HashMap();
 
-    public DateTimeField year() {
-        return iYearField;
-    }
+        // Convert duration fields...
 
-    public DateTimeField yearOfEra() {
-        return iYearOfEraField;
-    }
+        fields.eras = convertField(fields.eras, converted);
+        fields.centuries = convertField(fields.centuries, converted);
+        fields.years = convertField(fields.years, converted);
+        fields.months = convertField(fields.months, converted);
+        fields.weekyears = convertField(fields.weekyears, converted);
+        fields.weeks = convertField(fields.weeks, converted);
+        fields.days = convertField(fields.days, converted);
 
-    public DateTimeField yearOfCentury() {
-        return iYearOfCenturyField;
-    }
+        fields.hours = convertField(fields.hours, converted);
+        fields.minutes = convertField(fields.minutes, converted);
+        fields.seconds = convertField(fields.seconds, converted);
+        fields.millis = convertField(fields.millis, converted);
 
-    public DurationField centuries() {
-        return iCenturiesField;
-    }
+        // Convert datetime fields...
 
-    public DateTimeField centuryOfEra() {
-        return iCenturyOfEraField;
+        fields.year = convertField(fields.year, converted);
+        fields.yearOfEra = convertField(fields.yearOfEra, converted);
+        fields.yearOfCentury = convertField(fields.yearOfCentury, converted);
+        fields.centuryOfEra = convertField(fields.centuryOfEra, converted);
+        fields.era = convertField(fields.era, converted);
+        fields.dayOfWeek = convertField(fields.dayOfWeek, converted);
+        fields.dayOfMonth = convertField(fields.dayOfMonth, converted);
+        fields.dayOfYear = convertField(fields.dayOfYear, converted);
+        fields.monthOfYear = convertField(fields.monthOfYear, converted);
+        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted);
+        fields.weekyear = convertField(fields.weekyear, converted);
+
+        fields.millisOfSecond = convertField(fields.millisOfSecond, converted);
+        fields.millisOfDay = convertField(fields.millisOfDay, converted);
+        fields.secondOfMinute = convertField(fields.secondOfMinute, converted);
+        fields.secondOfDay = convertField(fields.secondOfDay, converted);
+        fields.minuteOfHour = convertField(fields.minuteOfHour, converted);
+        fields.minuteOfDay = convertField(fields.minuteOfDay, converted);
+        fields.hourOfDay = convertField(fields.hourOfDay, converted);
+        fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted);
+        fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted);
+        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted);
+        fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted);
     }
 
-    public DurationField eras() {
-        return iErasField;
+    private DurationField convertField(DurationField field, HashMap converted) {
+        if (field == null || !field.isSupported()) {
+            return field;
+        }
+        if (converted.containsKey(field)) {
+            return (DurationField)converted.get(field);
+        }
+        LimitDurationField limitField = new LimitDurationField(field);
+        converted.put(field, limitField);
+        return limitField;
     }
 
-    public DateTimeField era() {
-        return iEraField;
+    private DateTimeField convertField(DateTimeField field, HashMap converted) {
+        if (field == null || !field.isSupported()) {
+            return field;
+        }
+        if (converted.containsKey(field)) {
+            return (DateTimeField)converted.get(field);
+        }
+        LimitDateTimeField limitField =
+            new LimitDateTimeField(field,
+                                   convertField(field.getDurationField(), converted),
+                                   convertField(field.getRangeDurationField(), converted),
+                                   convertField(field.getLeapDurationField(), converted));
+        converted.put(field, limitField);
+        return limitField;
     }
 
     public String toString() {
-        return iChronology.toString();
-    }
-
-    private void readObject(ObjectInputStream in)
-        throws IOException, ClassNotFoundException
-    {
-        in.defaultReadObject();
-        setFields();
+        return getBase().toString();
     }
 
     void checkLimits(long instant, String desc) {
@@ -587,18 +388,18 @@ public String getMessage() {
             }
             buf.append(" instant is ");
 
-            DateTimePrinter p = ISODateTimeFormat.getInstance(getWrappedChronology()).dateTime();
+            DateTimePrinter p = ISODateTimeFormat.getInstance(getBase()).dateTime();
 
             if (iIsLow) {
                 buf.append("below the supported minimum of ");
-                p.printTo(buf, iLowerLimit);
+                p.printTo(buf, getLowerLimit());
             } else {
                 buf.append("above the supported maximum of ");
-                p.printTo(buf, iUpperLimit);
+                p.printTo(buf, getUpperLimit());
             }
             
             buf.append(" (");
-            buf.append(getWrappedChronology());
+            buf.append(getBase());
             buf.append(')');
 
             return buf.toString();
diff --git a/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java b/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java
index 3eb0e5117..9ed16c7d9 100644
--- a/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java
@@ -56,6 +56,7 @@
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeZone;
+import org.joda.time.field.StrictDateTimeField;
 
 /**
  * Wraps another chronology, ensuring all the fields are strict.
@@ -66,304 +67,90 @@
  * @see StrictDateTimeField
  * @see LenientChronology
  */
-public class StrictChronology extends DelegatedChronology {
+public final class StrictChronology extends AssembledChronology {
 
     static final long serialVersionUID = 6633006628097111960L;
 
-    private transient DateTimeField iYearField;
-    private transient DateTimeField iYearOfEraField;
-    private transient DateTimeField iYearOfCenturyField;
-    private transient DateTimeField iCenturyOfEraField;
-    private transient DateTimeField iEraField;
-    private transient DateTimeField iDayOfWeekField;
-    private transient DateTimeField iDayOfMonthField;
-    private transient DateTimeField iDayOfYearField;
-    private transient DateTimeField iMonthOfYearField;
-    private transient DateTimeField iWeekOfWeekyearField;
-    private transient DateTimeField iWeekyearField;
-
-    private transient DateTimeField iMillisOfSecondField;
-    private transient DateTimeField iMillisOfDayField;
-    private transient DateTimeField iSecondOfMinuteField;
-    private transient DateTimeField iSecondOfDayField;
-    private transient DateTimeField iMinuteOfHourField;
-    private transient DateTimeField iMinuteOfDayField;
-    private transient DateTimeField iHourOfDayField;
-    private transient DateTimeField iHourOfHalfdayField;
-    private transient DateTimeField iClockhourOfDayField;
-    private transient DateTimeField iClockhourOfHalfdayField;
-    private transient DateTimeField iHalfdayOfDayField;
-
-    private transient Chronology iWithUTC;
-
     /**
      * Create a StrictChronology for any chronology.
      *
-     * @param chrono the chronology
+     * @param base the chronology to wrap
      * @throws IllegalArgumentException if chronology is null
      */
-    public StrictChronology(Chronology chrono) {
-        super(chrono);
-    }
-
-    public Chronology withUTC() {
-        if (iWithUTC == null) {
-            iWithUTC = new StrictChronology(getWrappedChronology().withUTC());
+    public static StrictChronology getInstance(Chronology base) {
+        if (base == null) {
+            throw new IllegalArgumentException("Must supply a chronology");
         }
-        return iWithUTC;
-    }
-
-    public Chronology withDateTimeZone(DateTimeZone zone) {
-        return new StrictChronology(getWrappedChronology().withDateTimeZone(zone));
-    }
-
-    /**
-     * Overridden to ensure strict fields are used.
-     */
-    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
-        throws IllegalArgumentException
-    {
-        return getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);
-    }
-
-    /**
-     * Overridden to ensure strict fields are used.
-     */
-    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        long instant = hourOfDay().set(0, hourOfDay);
-        instant = minuteOfHour().set(instant, minuteOfHour);
-        instant = secondOfMinute().set(instant, secondOfMinute);
-        return millisOfSecond().set(instant, millisOfSecond);
-    }
-
-    /**
-     * Overridden to ensure strict fields are used.
-     */
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int millisOfDay)
-        throws IllegalArgumentException
-    {
-        long instant = year().set(0, year);
-        instant = monthOfYear().set(instant, monthOfYear);
-        instant = dayOfMonth().set(instant, dayOfMonth);
-        return millisOfDay().set(instant, millisOfDay);
+        return new StrictChronology(base);
     }
 
-    /**
-     * Overridden to ensure strict fields are used.
-     */
-    public long getDateTimeMillis(long instant,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        instant = hourOfDay().set(instant, hourOfDay);
-        instant = minuteOfHour().set(instant, minuteOfHour);
-        instant = secondOfMinute().set(instant, secondOfMinute);
-        return millisOfSecond().set(instant, millisOfSecond);
-    }
+    private transient Chronology iWithUTC;
 
     /**
-     * Overridden to ensure strict fields are used.
+     * Create a StrictChronology for any chronology.
+     *
+     * @param base the chronology to wrap
      */
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        long instant = year().set(0, year);
-        instant = monthOfYear().set(instant, monthOfYear);
-        instant = dayOfMonth().set(instant, dayOfMonth);
-        instant = hourOfDay().set(instant, hourOfDay);
-        instant = minuteOfHour().set(instant, minuteOfHour);
-        instant = secondOfMinute().set(instant, secondOfMinute);
-        return millisOfSecond().set(instant, millisOfSecond);
-    }
-
-    // Milliseconds
-    //------------------------------------------------------------
-
-    public DateTimeField millisOfSecond() {
-        if (iMillisOfDayField == null) {
-            iMillisOfSecondField = StrictDateTimeField.getInstance(super.millisOfSecond());
-        }
-        return iMillisOfSecondField;
-    }
-
-    public DateTimeField millisOfDay() {
-        if (iMillisOfDayField == null) {
-            iMillisOfDayField = StrictDateTimeField.getInstance(super.millisOfDay());
-        }
-        return iMillisOfDayField;
-    }
-
-    // Seconds
-    //------------------------------------------------------------
-
-    public DateTimeField secondOfMinute() {
-        if (iSecondOfMinuteField == null) {
-            iSecondOfMinuteField = StrictDateTimeField.getInstance(super.secondOfMinute());
-        }
-        return iSecondOfMinuteField;
-    }
-
-    public DateTimeField secondOfDay() {
-        if (iSecondOfDayField == null) {
-            iSecondOfDayField = StrictDateTimeField.getInstance(super.secondOfDay());
-        }
-        return iSecondOfDayField;
-    }
-
-    // Minutes
-    //------------------------------------------------------------
-
-    public DateTimeField minuteOfHour() {
-        if (iMinuteOfHourField == null) {
-            iMinuteOfHourField = StrictDateTimeField.getInstance(super.minuteOfHour());
-        }
-        return iMinuteOfHourField;
+    private StrictChronology(Chronology base) {
+        super(base, null);
     }
 
-    public DateTimeField minuteOfDay() {
-        if (iMinuteOfDayField == null) {
-            iMinuteOfDayField = StrictDateTimeField.getInstance(super.minuteOfDay());
-        }
-        return iMinuteOfDayField;
-    }
-
-    // Hours
-    //------------------------------------------------------------
-
-    public DateTimeField hourOfDay() {
-        if (iHourOfDayField == null) {
-            iHourOfDayField = StrictDateTimeField.getInstance(super.hourOfDay());
-        }
-        return iHourOfDayField;
-    }
-
-    public DateTimeField clockhourOfDay() {
-        if (iClockhourOfDayField == null) {
-            iClockhourOfDayField = StrictDateTimeField.getInstance(super.clockhourOfDay());
-        }
-        return iClockhourOfDayField;
-    }
-
-    public DateTimeField hourOfHalfday() {
-        if (iHourOfHalfdayField == null) {
-            iHourOfHalfdayField = StrictDateTimeField.getInstance(super.hourOfHalfday());
-        }
-        return iHourOfHalfdayField;
-    }
-
-    public DateTimeField clockhourOfHalfday() {
-        if (iClockhourOfHalfdayField == null) {
-            iClockhourOfHalfdayField =
-                StrictDateTimeField.getInstance(super.clockhourOfHalfday());
-        }
-        return iClockhourOfHalfdayField;
-    }
-
-    public DateTimeField halfdayOfDay() {
-        if (iHalfdayOfDayField == null) {
-            iHalfdayOfDayField = StrictDateTimeField.getInstance(super.halfdayOfDay());
-        }
-        return iHalfdayOfDayField;
-    }
-
-    // Day
-    //------------------------------------------------------------
-
-    public DateTimeField dayOfWeek() {
-        if (iDayOfWeekField == null) {
-            iDayOfWeekField = StrictDateTimeField.getInstance(super.dayOfWeek());
-        }
-        return iDayOfWeekField;
-    }
-
-    public DateTimeField dayOfMonth() {
-        if (iDayOfMonthField == null) {
-            iDayOfMonthField = StrictDateTimeField.getInstance(super.dayOfMonth());
-        }
-        return iDayOfMonthField;
-    }
-
-    public DateTimeField dayOfYear() {
-        if (iDayOfYearField == null) {
-            iDayOfYearField = StrictDateTimeField.getInstance(super.dayOfYear());
-        }
-        return iDayOfYearField;
-    }
-
-    // Week
-    //------------------------------------------------------------
-
-    public DateTimeField weekOfWeekyear() {
-        if (iWeekOfWeekyearField == null) {
-            iWeekOfWeekyearField = StrictDateTimeField.getInstance(super.weekOfWeekyear());
-        }
-        return iWeekOfWeekyearField;
-    }
-
-    public DateTimeField weekyear() {
-        if (iWeekyearField == null) {
-            iWeekyearField = StrictDateTimeField.getInstance(super.weekyear());
+    public Chronology withUTC() {
+        if (iWithUTC == null) {
+            if (getDateTimeZone() == DateTimeZone.UTC) {
+                iWithUTC = this;
+            } else {
+                iWithUTC = StrictChronology.getInstance(getBase().withUTC());
+            }
         }
-        return iWeekyearField;
+        return iWithUTC;
     }
 
-    // Month
-    //------------------------------------------------------------
-
-    public DateTimeField monthOfYear() {
-        if (iMonthOfYearField == null) {
-            iMonthOfYearField = StrictDateTimeField.getInstance(super.monthOfYear());
+    public Chronology withDateTimeZone(DateTimeZone zone) {
+        if (zone == null) {
+            zone = DateTimeZone.getDefault();
         }
-        return iMonthOfYearField;
-    }
-
-    // Year
-    //------------------------------------------------------------
-
-    public DateTimeField year() {
-        if (iYearField == null) {
-            iYearField = StrictDateTimeField.getInstance(super.year());
+        if (zone == DateTimeZone.UTC) {
+            return withUTC();
         }
-        return iYearField;
-    }
-
-    public DateTimeField yearOfEra() {
-        if (iYearOfEraField == null) {
-            iYearOfEraField = StrictDateTimeField.getInstance(super.yearOfEra());
+        if (zone == getDateTimeZone()) {
+            return this;
         }
-        return iYearOfEraField;
+        return StrictChronology.getInstance(getBase().withDateTimeZone(zone));
     }
 
-    public DateTimeField yearOfCentury() {
-        if (iYearOfCenturyField == null) {
-            iYearOfCenturyField = StrictDateTimeField.getInstance(super.yearOfCentury());
-        }
-        return iYearOfCenturyField;
-    }
+    protected void assemble(Fields fields) {
+        fields.year = convertField(fields.year);
+        fields.yearOfEra = convertField(fields.yearOfEra);
+        fields.yearOfCentury = convertField(fields.yearOfCentury);
+        fields.centuryOfEra = convertField(fields.centuryOfEra);
+        fields.era = convertField(fields.era);
+        fields.dayOfWeek = convertField(fields.dayOfWeek);
+        fields.dayOfMonth = convertField(fields.dayOfMonth);
+        fields.dayOfYear = convertField(fields.dayOfYear);
+        fields.monthOfYear = convertField(fields.monthOfYear);
+        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear);
+        fields.weekyear = convertField(fields.weekyear);
 
-    public DateTimeField centuryOfEra() {
-        if (iCenturyOfEraField == null) {
-            iCenturyOfEraField = StrictDateTimeField.getInstance(super.centuryOfEra());
-        }
-        return iCenturyOfEraField;
+        fields.millisOfSecond = convertField(fields.millisOfSecond);
+        fields.millisOfDay = convertField(fields.millisOfDay);
+        fields.secondOfMinute = convertField(fields.secondOfMinute);
+        fields.secondOfDay = convertField(fields.secondOfDay);
+        fields.minuteOfHour = convertField(fields.minuteOfHour);
+        fields.minuteOfDay = convertField(fields.minuteOfDay);
+        fields.hourOfDay = convertField(fields.hourOfDay);
+        fields.hourOfHalfday = convertField(fields.hourOfHalfday);
+        fields.clockhourOfDay = convertField(fields.clockhourOfDay);
+        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday);
+        fields.halfdayOfDay = convertField(fields.halfdayOfDay);
     }
 
-    public DateTimeField era() {
-        if (iEraField == null) {
-            iEraField = StrictDateTimeField.getInstance(super.era());
-        }
-        return iEraField;
+    private static final DateTimeField convertField(DateTimeField field) {
+        return StrictDateTimeField.getInstance(field);
     }
 
     public String toString() {
-        return "StrictChronology[" + getWrappedChronology().toString() + ']';
+        return "StrictChronology[" + getBase().toString() + ']';
     }
 
 }
diff --git a/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java b/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
index 8ba2f180d..1efb30776 100644
--- a/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
@@ -53,9 +53,6 @@
  */
 package org.joda.time.chrono;
 
-import java.io.IOException;
-import java.io.ObjectInputStream;
-
 import java.util.HashMap;
 import java.util.Locale;
 
@@ -64,6 +61,8 @@
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeZone;
 import org.joda.time.DurationField;
+import org.joda.time.field.AbstractDateTimeField;
+import org.joda.time.field.AbstractDurationField;
 
 /**
  * Wraps another Chronology for supporting time zones.
@@ -74,183 +73,73 @@
  * @author Stephen Colebourne
  * @since 1.0
  */
-public class ZonedChronology extends Chronology {
-
-    static final long serialVersionUID = -1079258847191166848L;
-
-    static boolean useTimeArithmetic(DurationField field) {
-        // Use time of day arithmetic rules for unit durations less than
-        // typical time zone offsets.
-        return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12;
-    }
-
-    private final Chronology iChronology;
-    private final DateTimeZone iZone;
-
-    private transient DurationField iErasField;
-    private transient DurationField iCenturiesField;
-    private transient DurationField iYearsField;
-    private transient DurationField iMonthsField;
-    private transient DurationField iWeekyearsField;
-    private transient DurationField iWeeksField;
-    private transient DurationField iDaysField;
-
-    private transient DurationField iHoursField;
-    private transient DurationField iMinutesField;
-    private transient DurationField iSecondsField;
-    private transient DurationField iMillisField;
-
-    private transient DateTimeField iYearField;
-    private transient DateTimeField iYearOfEraField;
-    private transient DateTimeField iYearOfCenturyField;
-    private transient DateTimeField iCenturyOfEraField;
-    private transient DateTimeField iEraField;
-    private transient DateTimeField iDayOfWeekField;
-    private transient DateTimeField iDayOfMonthField;
-    private transient DateTimeField iDayOfYearField;
-    private transient DateTimeField iMonthOfYearField;
-    private transient DateTimeField iWeekOfWeekyearField;
-    private transient DateTimeField iWeekyearField;
-
-    private transient DateTimeField iMillisOfSecondField;
-    private transient DateTimeField iMillisOfDayField;
-    private transient DateTimeField iSecondOfMinuteField;
-    private transient DateTimeField iSecondOfDayField;
-    private transient DateTimeField iMinuteOfHourField;
-    private transient DateTimeField iMinuteOfDayField;
-    private transient DateTimeField iHourOfDayField;
-    private transient DateTimeField iHourOfHalfdayField;
-    private transient DateTimeField iClockhourOfDayField;
-    private transient DateTimeField iClockhourOfHalfdayField;
-    private transient DateTimeField iHalfdayOfDayField;
+public final class ZonedChronology extends AssembledChronology {
 
     /**
      * Create a ZonedChronology for any chronology, overriding any time zone it
      * may already have.
      *
-     * @param chrono the chronology
+     * @param base base chronology to wrap
      * @param zone the time zone
      * @throws IllegalArgumentException if chronology or time zone is null
      */
-    public ZonedChronology(Chronology chrono, DateTimeZone zone) {
-        if (chrono == null) {
+    public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {
+        if (base == null) {
             throw new IllegalArgumentException("Must supply a chronology");
         }
-        chrono = chrono.withUTC();
-        if (chrono == null) {
+        base = base.withUTC();
+        if (base == null) {
             throw new IllegalArgumentException("UTC chronology must not be null");
         }
         if (zone == null) {
             throw new IllegalArgumentException("DateTimeZone must not be null");
         }
-
-        iChronology = chrono;
-        iZone = zone;
-        setFields();
+        return new ZonedChronology(base, zone);
     }
 
-    private void setFields() {
-        Chronology c = iChronology;
-
-        // Keep a local cache of converted fields so as not to create redundant
-        // objects.
-        HashMap converted = new HashMap();
-
-        // Convert duration fields...
-
-        iErasField = convertField(c.eras(), converted);
-        iCenturiesField = convertField(c.centuries(), converted);
-        iYearsField = convertField(c.years(), converted);
-        iMonthsField = convertField(c.months(), converted);
-        iWeekyearsField = convertField(c.weekyears(), converted);
-        iWeeksField = convertField(c.weeks(), converted);
-        iDaysField = convertField(c.days(), converted);
-
-        iHoursField = convertField(c.hours(), converted);
-        iMinutesField = convertField(c.minutes(), converted);
-        iSecondsField = convertField(c.seconds(), converted);
-        iMillisField = convertField(c.millis(), converted);
-
-        // Convert datetime fields...
-
-        iYearField = convertField(c.year(), converted);
-        iYearOfEraField = convertField(c.yearOfEra(), converted);
-        iYearOfCenturyField = convertField(c.yearOfCentury(), converted);
-        iCenturyOfEraField = convertField(c.centuryOfEra(), converted);
-        iEraField = convertField(c.era(), converted);
-        iDayOfWeekField = convertField(c.dayOfWeek(), converted);
-        iDayOfMonthField = convertField(c.dayOfMonth(), converted);
-        iDayOfYearField = convertField(c.dayOfYear(), converted);
-        iMonthOfYearField = convertField(c.monthOfYear(), converted);
-        iWeekOfWeekyearField = convertField(c.weekOfWeekyear(), converted);
-        iWeekyearField = convertField(c.weekyear(), converted);
-
-        iMillisOfSecondField = convertField(c.millisOfSecond(), converted);
-        iMillisOfDayField = convertField(c.millisOfDay(), converted);
-        iSecondOfMinuteField = convertField(c.secondOfMinute(), converted);
-        iSecondOfDayField = convertField(c.secondOfDay(), converted);
-        iMinuteOfHourField = convertField(c.minuteOfHour(), converted);
-        iMinuteOfDayField = convertField(c.minuteOfDay(), converted);
-        iHourOfDayField = convertField(c.hourOfDay(), converted);
-        iHourOfHalfdayField = convertField(c.hourOfHalfday(), converted);
-        iClockhourOfDayField = convertField(c.clockhourOfDay(), converted);
-        iClockhourOfHalfdayField = convertField(c.clockhourOfHalfday(), converted);
-        iHalfdayOfDayField = convertField(c.halfdayOfDay(), converted);
-    }
+    static final long serialVersionUID = -1079258847191166848L;
 
-    private DurationField convertField(DurationField field, HashMap converted) {
-        if (field == null || !field.isSupported()) {
-            return field;
-        }
-        if (converted.containsKey(field)) {
-            return (DurationField)converted.get(field);
-        }
-        ZonedDurationField zonedField = new ZonedDurationField(field, iZone);
-        converted.put(field, zonedField);
-        return zonedField;
+    static boolean useTimeArithmetic(DurationField field) {
+        // Use time of day arithmetic rules for unit durations less than
+        // typical time zone offsets.
+        return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12;
     }
 
-    private DateTimeField convertField(DateTimeField field, HashMap converted) {
-        if (field == null || !field.isSupported()) {
-            return field;
-        }
-        if (converted.containsKey(field)) {
-            return (DateTimeField)converted.get(field);
-        }
-        ZonedDateTimeField zonedField =
-            new ZonedDateTimeField(field, iZone,
-                                   convertField(field.getDurationField(), converted),
-                                   convertField(field.getRangeDurationField(), converted),
-                                   convertField(field.getLeapDurationField(), converted));
-        converted.put(field, zonedField);
-        return zonedField;
+    /**
+     * Restricted constructor
+     *
+     * @param base base chronology to wrap
+     * @param zone the time zone
+     */
+    private ZonedChronology(Chronology base, DateTimeZone zone) {
+        super(base, zone);
     }
 
     public DateTimeZone getDateTimeZone() {
-        return iZone;
+        return (DateTimeZone)getParam();
     }
 
     public Chronology withUTC() {
-        return iChronology;
+        return getBase();
     }
 
     public Chronology withDateTimeZone(DateTimeZone zone) {
         if (zone == null) {
             zone = DateTimeZone.getDefault();
         }
-        if (zone == iZone) {
+        if (zone == getParam()) {
             return this;
         }
         if (zone == DateTimeZone.UTC) {
-            return iChronology;
+            return getBase();
         }
-        return new ZonedChronology(iChronology, zone);
+        return new ZonedChronology(getBase(), zone);
     }
 
     public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
         throws IllegalArgumentException
     {
-        return localToUTC(iChronology.getDateOnlyMillis
+        return localToUTC(getBase().getDateOnlyMillis
                           (year, monthOfYear, dayOfMonth));
     }
 
@@ -258,7 +147,7 @@ public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
                                   int secondOfMinute, int millisOfSecond)
         throws IllegalArgumentException
     {
-        return localToUTC(iChronology.getTimeOnlyMillis
+        return localToUTC(getBase().getTimeOnlyMillis
                           (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));
     }
 
@@ -266,7 +155,7 @@ public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
                                   int millisOfDay)
         throws IllegalArgumentException
     {
-        return localToUTC(iChronology.getDateTimeMillis
+        return localToUTC(getBase().getDateTimeMillis
                           (year, monthOfYear, dayOfMonth, millisOfDay));
     }
 
@@ -275,8 +164,8 @@ public long getDateTimeMillis(long instant,
                                   int secondOfMinute, int millisOfSecond)
         throws IllegalArgumentException
     {
-        return localToUTC(iChronology.getDateTimeMillis
-                          (instant + iZone.getOffset(instant),
+        return localToUTC(getBase().getDateTimeMillis
+                          (instant + getDateTimeZone().getOffset(instant),
                            hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));
     }
 
@@ -285,7 +174,7 @@ public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
                                   int secondOfMinute, int millisOfSecond)
         throws IllegalArgumentException
     {
-        return localToUTC(iChronology.getDateTimeMillis
+        return localToUTC(getBase().getDateTimeMillis
                           (year, monthOfYear, dayOfMonth, 
                            hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));
     }
@@ -294,180 +183,93 @@ public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
      * @param instant instant from 1970-01-01T00:00:00 local time
      */
     private long localToUTC(long instant) {
-        int offset = iZone.getOffsetFromLocal(instant);
+        DateTimeZone zone = getDateTimeZone();
+        int offset = zone.getOffsetFromLocal(instant);
         instant -= offset;
-        if (offset != iZone.getOffset(instant)) {
+        if (offset != zone.getOffset(instant)) {
             throw new IllegalArgumentException
                 ("Illegal instant due to time zone offset transition");
         }
         return instant;
     }
 
-    // Milliseconds
-    //------------------------------------------------------------
-
-    public DurationField millis() {
-        return iMillisField;
-    }
-
-    public DateTimeField millisOfSecond() {
-        return iMillisOfSecondField;
-    }
-
-    public DateTimeField millisOfDay() {
-        return iMillisOfDayField;
-    }
-
-    // Seconds
-    //------------------------------------------------------------
-
-    public DurationField seconds() {
-        return iSecondsField;
-    }
-
-    public DateTimeField secondOfMinute() {
-        return iSecondOfMinuteField;
-    }
-
-    public DateTimeField secondOfDay() {
-        return iSecondOfDayField;
-    }
-
-    // Minutes
-    //------------------------------------------------------------
-
-    public DurationField minutes() {
-        return iMinutesField;
-    }
-
-    public DateTimeField minuteOfHour() {
-        return iMinuteOfHourField;
-    }
-
-    public DateTimeField minuteOfDay() {
-        return iMinuteOfDayField;
-    }
-
-    // Hours
-    //------------------------------------------------------------
-
-    public DurationField hours() {
-        return iHoursField;
-    }
-
-    public DateTimeField hourOfDay() {
-        return iHourOfDayField;
-    }
-
-    public DateTimeField clockhourOfDay() {
-        return iClockhourOfDayField;
-    }
-
-    public DateTimeField hourOfHalfday() {
-        return iHourOfHalfdayField;
-    }
-
-    public DateTimeField clockhourOfHalfday() {
-        return iClockhourOfHalfdayField;
-    }
-
-    public DateTimeField halfdayOfDay() {
-        return iHalfdayOfDayField;
-    }
-
-    // Day
-    //------------------------------------------------------------
-
-    public DurationField days() {
-        return iDaysField;
-    }
-
-    public DateTimeField dayOfWeek() {
-        return iDayOfWeekField;
-    }
-
-    public DateTimeField dayOfMonth() {
-        return iDayOfMonthField;
-    }
-
-    public DateTimeField dayOfYear() {
-        return iDayOfYearField;
-    }
-
-    // Week
-    //------------------------------------------------------------
-
-    public DurationField weeks() {
-        return iWeeksField;
-    }
-
-    public DateTimeField weekOfWeekyear() {
-        return iWeekOfWeekyearField;
-    }
-
-    public DurationField weekyears() {
-        return iWeekyearsField;
-    }
-
-    public DateTimeField weekyear() {
-        return iWeekyearField;
-    }
-
-    // Month
-    //------------------------------------------------------------
-
-    public DurationField months() {
-        return iMonthsField;
-    }
-
-    public DateTimeField monthOfYear() {
-        return iMonthOfYearField;
-    }
-
-    // Year
-    //------------------------------------------------------------
-
-    public DurationField years() {
-        return iYearsField;
-    }
+    protected void assemble(Fields fields) {
+        // Keep a local cache of converted fields so as not to create redundant
+        // objects.
+        HashMap converted = new HashMap();
 
-    public DateTimeField year() {
-        return iYearField;
-    }
+        // Convert duration fields...
 
-    public DateTimeField yearOfEra() {
-        return iYearOfEraField;
-    }
+        fields.eras = convertField(fields.eras, converted);
+        fields.centuries = convertField(fields.centuries, converted);
+        fields.years = convertField(fields.years, converted);
+        fields.months = convertField(fields.months, converted);
+        fields.weekyears = convertField(fields.weekyears, converted);
+        fields.weeks = convertField(fields.weeks, converted);
+        fields.days = convertField(fields.days, converted);
 
-    public DateTimeField yearOfCentury() {
-        return iYearOfCenturyField;
-    }
+        fields.hours = convertField(fields.hours, converted);
+        fields.minutes = convertField(fields.minutes, converted);
+        fields.seconds = convertField(fields.seconds, converted);
+        fields.millis = convertField(fields.millis, converted);
 
-    public DurationField centuries() {
-        return iCenturiesField;
-    }
+        // Convert datetime fields...
 
-    public DateTimeField centuryOfEra() {
-        return iCenturyOfEraField;
+        fields.year = convertField(fields.year, converted);
+        fields.yearOfEra = convertField(fields.yearOfEra, converted);
+        fields.yearOfCentury = convertField(fields.yearOfCentury, converted);
+        fields.centuryOfEra = convertField(fields.centuryOfEra, converted);
+        fields.era = convertField(fields.era, converted);
+        fields.dayOfWeek = convertField(fields.dayOfWeek, converted);
+        fields.dayOfMonth = convertField(fields.dayOfMonth, converted);
+        fields.dayOfYear = convertField(fields.dayOfYear, converted);
+        fields.monthOfYear = convertField(fields.monthOfYear, converted);
+        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted);
+        fields.weekyear = convertField(fields.weekyear, converted);
+
+        fields.millisOfSecond = convertField(fields.millisOfSecond, converted);
+        fields.millisOfDay = convertField(fields.millisOfDay, converted);
+        fields.secondOfMinute = convertField(fields.secondOfMinute, converted);
+        fields.secondOfDay = convertField(fields.secondOfDay, converted);
+        fields.minuteOfHour = convertField(fields.minuteOfHour, converted);
+        fields.minuteOfDay = convertField(fields.minuteOfDay, converted);
+        fields.hourOfDay = convertField(fields.hourOfDay, converted);
+        fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted);
+        fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted);
+        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted);
+        fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted);
     }
 
-    public DurationField eras() {
-        return iErasField;
+    private DurationField convertField(DurationField field, HashMap converted) {
+        if (field == null || !field.isSupported()) {
+            return field;
+        }
+        if (converted.containsKey(field)) {
+            return (DurationField)converted.get(field);
+        }
+        ZonedDurationField zonedField = new ZonedDurationField(field, getDateTimeZone());
+        converted.put(field, zonedField);
+        return zonedField;
     }
 
-    public DateTimeField era() {
-        return iEraField;
+    private DateTimeField convertField(DateTimeField field, HashMap converted) {
+        if (field == null || !field.isSupported()) {
+            return field;
+        }
+        if (converted.containsKey(field)) {
+            return (DateTimeField)converted.get(field);
+        }
+        ZonedDateTimeField zonedField =
+            new ZonedDateTimeField(field, getDateTimeZone(),
+                                   convertField(field.getDurationField(), converted),
+                                   convertField(field.getRangeDurationField(), converted),
+                                   convertField(field.getLeapDurationField(), converted));
+        converted.put(field, zonedField);
+        return zonedField;
     }
 
     public String toString() {
-        return iChronology.toString();
-    }
-
-    private void readObject(ObjectInputStream in)
-        throws IOException, ClassNotFoundException
-    {
-        in.defaultReadObject();
-        setFields();
+        return "ZonedChronology[" + getBase() + ", " + getDateTimeZone().getID() + ']';
     }
 
     /*
diff --git a/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistChronology.java b/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistChronology.java
deleted file mode 100644
index 38c91827d..000000000
--- a/JodaTime/src/java/org/joda/time/chrono/buddhist/BuddhistChronology.java
+++ /dev/null
@@ -1,575 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono.buddhist;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import org.joda.time.Chronology;
-import org.joda.time.DateTime;
-import org.joda.time.DateTimeConstants;
-import org.joda.time.DateTimeField;
-import org.joda.time.DateTimeZone;
-import org.joda.time.DurationField;
-import org.joda.time.chrono.DecoratedChronology;
-import org.joda.time.chrono.DividedDateTimeField;
-import org.joda.time.chrono.LimitChronology;
-import org.joda.time.chrono.OffsetDateTimeField;
-import org.joda.time.chrono.RemainderDateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
-
-/**
- * <code>BuddhistChronology</code> provides access to the individual date
- * time fields for the Buddhist chronological calendar system.
- * <p>
- * The Buddhist calendar differs from the GregorianJulian calendar only 
- * in the year. This class is compatable with the BuddhistCalendar class 
- * supplied by Sun.
- * <p>
- * BuddhistChronology is thread-safe and immutable.
- *
- * @author Stephen Colebourne
- * @author Brian S O'Neill
- * @since 1.0
- */
-public final class BuddhistChronology extends DecoratedChronology {
-    
-    static final long serialVersionUID = -3474595157769370126L;
-
-    /**
-     * Constant value for 'Buddhist Era', equivalent to the value returned
-     * for AD/CE.
-     */
-    public static final int BE = DateTimeConstants.CE;
-
-    /** Number of years difference in calendars. */
-    private static final int BUDDHIST_OFFSET = 543;
-
-    /** Cache of zone to chronology */
-    private static final Map cCache = new HashMap();
-
-    /** UTC instance of the chronology */
-    private static final BuddhistChronology INSTANCE_UTC = getInstance(DateTimeZone.UTC);
-
-    /**
-     * Standard instance of a Buddhist Chronology, that matches
-     * Sun's BuddhistCalendar class. This means that it follows the
-     * GregorianJulian calendar rules with a cutover date.
-     * <p>
-     * The time zone of the returned instance is UTC.
-     */
-    public static BuddhistChronology getInstanceUTC() {
-        return INSTANCE_UTC;
-    }
-
-    /**
-     * Standard instance of a Buddhist Chronology, that matches
-     * Sun's BuddhistCalendar class. This means that it follows the
-     * GregorianJulian calendar rules with a cutover date.
-     */
-    public static BuddhistChronology getInstance() {
-        return getInstance(DateTimeZone.getDefault());
-    }
-
-    /**
-     * Standard instance of a Buddhist Chronology, that matches
-     * Sun's BuddhistCalendar class. This means that it follows the
-     * GregorianJulian calendar rules with a cutover date.
-     *
-     * @param zone  the time zone to use, null is default
-     */
-    public static synchronized BuddhistChronology getInstance(DateTimeZone zone) {
-        if (zone == null) {
-            zone = DateTimeZone.getDefault();
-        }
-        BuddhistChronology chrono = (BuddhistChronology) cCache.get(zone);
-        if (chrono == null) {
-            chrono = new BuddhistChronology(GJChronology.getInstance(zone, null, false));
-            cCache.put(zone, chrono);
-        }
-        return chrono;
-    }
-
-    // Constructors and instance variables
-    //-----------------------------------------------------------------------
-    // Fields are transient because readResolve will always return a cached instance.
-    private transient DateTimeField iYearField;
-    private transient DateTimeField iWeekyearField;
-    private transient DateTimeField iYearOfCenturyField;
-    private transient DateTimeField iCenturyOfEraField;
-    
-    /**
-     * Restricted constructor.
-     */
-    private BuddhistChronology(Chronology chronology) {
-        this(chronology, false);
-    }
-
-    /**
-     * Restricted constructor.
-     */
-    private BuddhistChronology(Chronology chronology, boolean unlimited) {
-        // BuddhistChronology is constructed in three magic steps:
-        //
-        // 1. Wrap a BuddhistChronology with proper offset, but no range limits
-        // 2. Wrap a LimitChronology, which will copy and wrap all the fields
-        // 3. Wrap a BuddhistChronology which purely delegates to LimitChronology
-        //
-        // Why is it done this way? So that the LimitChronology error message
-        // shows the limit printed using BuddhistChronology fields. This extra
-        // wrapping does not impose any additional overhead when accessing
-        // fields because LimitChronology copies them.
-        //
-        // Is this a good design? No.
-
-        super(unlimited ? chronology : limitChronology(chronology));
-
-        DateTimeField field = getWrappedChronology().year();
-        if (unlimited) {
-            field = new OffsetDateTimeField(field, field.getName(), BUDDHIST_OFFSET);
-        }
-        iYearField = field;
-            
-        field = getWrappedChronology().weekyear();
-        if (unlimited) {
-            field = new OffsetDateTimeField(field, field.getName(), BUDDHIST_OFFSET);
-        }
-        iWeekyearField = field;
-
-        // All other fields delegated to GJ
-    }
-
-    /**
-     * Returns a LimitChronology that wraps an unlimited BuddhistChronology
-     * that wraps the given Chronology.
-     */    
-    private static Chronology limitChronology(Chronology chrono) {
-        chrono = new BuddhistChronology(chrono, true);
-        DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);
-        return new LimitChronology(chrono, lowerLimit, null);
-    }
-    
-    /**
-     * Serialization singleton
-     */
-    private Object readResolve() {
-        return getInstance(getWrappedChronology().getDateTimeZone());
-    }
-
-    // Conversion
-    //-----------------------------------------------------------------------
-    /**
-     * Gets the Chronology in the UTC time zone.
-     * 
-     * @return the chronology in UTC
-     */
-    public Chronology withUTC() {
-        return INSTANCE_UTC;
-    }
-
-    /**
-     * Gets the Chronology in a specific time zone.
-     * 
-     * @param zone  the zone to get the chronology in, null is default
-     * @return the chronology
-     */
-    public Chronology withDateTimeZone(DateTimeZone zone) {
-        if (zone == null) {
-            zone = DateTimeZone.getDefault();
-        }
-        if (zone == getDateTimeZone()) {
-            return this;
-        }
-        return getInstance(zone);
-    }
-
-    // Millis
-    //------------------------------------------------------------
-
-    /**
-     * Get the millis duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField millis() {
-        return getWrappedChronology().millis();
-    }
-
-    /**
-     * Get the millis of second field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField millisOfSecond() {
-        return getWrappedChronology().millisOfSecond();
-    }
-
-    /**
-     * Get the millis of day field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField millisOfDay() {
-        return getWrappedChronology().millisOfDay();
-    }
-
-    // Seconds
-    //------------------------------------------------------------
-
-    /**
-     * Get the seconds duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField seconds() {
-        return getWrappedChronology().seconds();
-    }
-
-    /**
-     * Get the second of minute field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField secondOfMinute() {
-        return getWrappedChronology().secondOfMinute();
-    }
-
-    /**
-     * Get the second of day field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField secondOfDay() {
-        return getWrappedChronology().secondOfDay();
-    }
-
-    // Minutes
-    //------------------------------------------------------------
-
-    /**
-     * Get the minutes duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField minutes() {
-        return getWrappedChronology().minutes();
-    }
-
-    /**
-     * Get the minute of hour field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField minuteOfHour() {
-        return getWrappedChronology().minuteOfHour();
-    }
-
-    /**
-     * Get the minute of day field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField minuteOfDay() {
-        return getWrappedChronology().minuteOfDay();
-    }
-
-    // Hours
-    //------------------------------------------------------------
-
-    /**
-     * Get the hours duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField hours() {
-        return getWrappedChronology().hours();
-    }
-
-    /**
-     * Get the hour of day (0-23) field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField hourOfDay() {
-        return getWrappedChronology().hourOfDay();
-    }
-
-    /**
-     * Get the hour of day (offset to 1-24) field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField clockhourOfDay() {
-        return getWrappedChronology().clockhourOfDay();
-    }
-
-    /**
-     * Get the hour of am/pm (0-11) field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField hourOfHalfday() {
-        return getWrappedChronology().hourOfHalfday();
-    }
-
-    /**
-     * Get the hour of am/pm (offset to 1-12) field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField clockhourOfHalfday() {
-        return getWrappedChronology().clockhourOfHalfday();
-    }
-
-    /**
-     * Get the AM(0) PM(1) field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField halfdayOfDay() {
-        return getWrappedChronology().halfdayOfDay();
-    }
-
-    // Day
-    //------------------------------------------------------------
-
-    /**
-     * Get the days duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField days() {
-        return getWrappedChronology().days();
-    }
-
-    /**
-     * Get the day of week field for this chronology.
-     *
-     * @return DateTimeField
-     */
-    public DateTimeField dayOfWeek() {
-        return getWrappedChronology().dayOfWeek();
-    }
-
-    /**
-     * Get the day of month field for this chronology.
-     *
-     * @return DateTimeField
-     */
-    public DateTimeField dayOfMonth() {
-        return getWrappedChronology().dayOfMonth();
-    }
-
-    /**
-     * Get the day of year field for this chronology.
-     *
-     * @return DateTimeField
-     */
-    public DateTimeField dayOfYear() {
-        return getWrappedChronology().dayOfYear();
-    }
-
-    // Week
-    //------------------------------------------------------------
-
-    /**
-     * Get the weeks duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField weeks() {
-        return getWrappedChronology().weeks();
-    }
-
-    /**
-     * Get the week of a week based year field for this chronology.
-     *
-     * @return DateTimeField
-     */
-    public DateTimeField weekOfWeekyear() {
-        return getWrappedChronology().weekOfWeekyear();
-    }
-
-    /**
-     * Get the weekyears duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField weekyears() {
-        return getWrappedChronology().weekyears();
-    }
-
-    /**
-     * Get the year of a week based year field for this chronology.
-     *
-     * @return DateTimeField
-     */
-    public DateTimeField weekyear() {
-        return iWeekyearField;
-    }
-
-    // Month
-    //------------------------------------------------------------
-
-    /**
-     * Get the months duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField months() {
-        return getWrappedChronology().months();
-    }
-
-    /**
-     * Get the month of year field for this chronology.
-     *
-     * @return DateTimeField
-     */
-    public DateTimeField monthOfYear() {
-        return getWrappedChronology().monthOfYear();
-    }
-
-    // Year
-    //------------------------------------------------------------
-
-    /**
-     * Get the years duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField years() {
-        return getWrappedChronology().years();
-    }
-
-    /**
-     * Get the year field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField year() {
-        return iYearField;
-    }
-
-    /**
-     * Get the year of era field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField yearOfEra() {
-        return iYearField;
-    }
-
-    /**
-     * Get the year of century field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField yearOfCentury() {
-        if (iYearOfCenturyField == null) {
-            DateTimeField tempField = new RemainderDateTimeField
-                ((DividedDateTimeField)centuryOfEra(), "");
-            iYearOfCenturyField = new OffsetDateTimeField(tempField, "yearOfCentury", 1);
-        }
-        return iYearOfCenturyField;
-    }
-
-    /**
-     * Get the centuries duration field for this chronology.
-     * 
-     * @return DurationField
-     */
-    public DurationField centuries() {
-        return getWrappedChronology().centuries();
-    }
-
-    /**
-     * Get the century of era field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField centuryOfEra() {
-        if (iCenturyOfEraField == null) {
-            DateTimeField tempField = new OffsetDateTimeField(yearOfEra(), "", 99);
-            iCenturyOfEraField = new DividedDateTimeField
-                (tempField, "centuryOfEra", "centuries", 100);
-        }
-        return iCenturyOfEraField;
-    }
-
-    /**
-     * Get the era field for this chronology.
-     * 
-     * @return DateTimeField
-     */
-    public DateTimeField era() {
-        return BuddhistEraDateTimeField.INSTANCE;
-    }
-
-    // Output
-    //-----------------------------------------------------------------------
-    /**
-     * Gets a debugging toString.
-     * 
-     * @return a debugging string
-     */
-    public String toString() {
-        String str = "BuddhistChronology";
-        DateTimeZone zone = getDateTimeZone();
-        if (zone != null) {
-            str = str + '[' + zone.getID() + ']';
-        }
-        return str;
-    }
-   
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJCenturyChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJCenturyChronology.java
deleted file mode 100644
index 4ea4d4601..000000000
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJCenturyChronology.java
+++ /dev/null
@@ -1,157 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono.gj;
-
-import org.joda.time.Chronology;
-import org.joda.time.DateTimeField;
-import org.joda.time.DateTimeZone;
-import org.joda.time.chrono.OffsetDateTimeField;
-import org.joda.time.chrono.DividedDateTimeField;
-import org.joda.time.chrono.RemainderDateTimeField;
-
-/**
- * Chronology for supporting GJ style centuries. Century 1 begin on year 1, and
- * year of century ranges from 1 to 100.
- *
- * @author Brian S O'Neill
- * @author Stephen Colebourne
- * @since 1.0
- */
-class GJCenturyChronology extends GJChronology {
-
-    static final long serialVersionUID = -8572000567534692411L;
-
-    private final GJChronology iChronology;
-
-    /**
-     * @param chrono wrapped chronology
-     */
-    public GJCenturyChronology(GJChronology chrono) {
-        if (chrono.getDateTimeZone() != null &&
-            chrono.getDateTimeZone() != DateTimeZone.UTC) {
-            throw new IllegalArgumentException();
-        }
-        if (!chrono.isCenturyISO()) {
-            throw new IllegalArgumentException();
-        }
-
-        iChronology = chrono;
-        copyFields(chrono);
-
-        DateTimeField tempField = new OffsetDateTimeField(iYearOfEraField, "", 99);
-        iCenturyOfEraField = new DividedDateTimeField
-            (tempField, "centuryOfEra", "centuries", 100);
-
-        tempField = new RemainderDateTimeField
-            ((DividedDateTimeField)iCenturyOfEraField, "");
-        iYearOfCenturyField = new OffsetDateTimeField(tempField, "yearOfCentury", 1);
-    }
-
-    public Chronology withUTC() {
-        return this;
-    }
-
-    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
-        throws IllegalArgumentException
-    {
-        return iChronology.getDateOnlyMillis(year, monthOfYear, dayOfMonth);
-    }
-
-    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        return iChronology.getTimeOnlyMillis
-            (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-    }
-
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int millisOfDay)
-        throws IllegalArgumentException
-    {
-        return iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);
-    }
-
-    public long getDateTimeMillis(long instant,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        return iChronology.getDateTimeMillis
-            (instant,
-             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-    }
-
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        return iChronology.getDateTimeMillis
-            (year, monthOfYear, dayOfMonth,
-             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-    }
-
-    public long getGregorianJulianCutoverMillis() {
-        return iChronology.getGregorianJulianCutoverMillis();
-    }
-    
-    public boolean isCenturyISO() {
-        return false;
-    }
-
-    public final int getMinimumDaysInFirstWeek() {
-        return iChronology.getMinimumDaysInFirstWeek();
-    }
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJChronology.java
deleted file mode 100644
index 35aba9175..000000000
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJChronology.java
+++ /dev/null
@@ -1,714 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono.gj;
-
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.Serializable;
-import java.lang.ref.SoftReference;
-import java.util.ArrayList;
-import java.util.HashMap;
-
-import org.joda.time.Chronology;
-// Import for @link support
-import org.joda.time.DateTimeConstants;
-import org.joda.time.DateTimeField;
-import org.joda.time.DateTimeZone;
-import org.joda.time.DurationField;
-import org.joda.time.Instant;
-import org.joda.time.ReadableInstant;
-import org.joda.time.format.DateTimePrinter;
-import org.joda.time.format.ISODateTimeFormat;
-
-/**
- * GJChronology provides access to the individual date time fields 
- * for the Gregorian/Julian defined chronological calendar system.
- * <p>
- * The Gregorian calendar replaced the Julian calendar, and the point in time
- * when this chronology switches can be controlled using the second parameter
- * of the getInstance method. By default this cutover is set to the date the
- * Gregorian calendar was first instituted, October 15, 1582.
- * <p>
- * Before this date, this chronology uses the proleptic Julian calendar
- * (proleptic means extending indefinitely). The Julian calendar has leap 
- * years every four years, whereas the Gregorian has special rules for 100 
- * and 400 years. A meaningful result will thus be obtained for all input 
- * values. However before March 1, 4 CE, Julian leap years were irregular,
- * and before 45 BCE there was no Julian calendar.
- * <p>
- * This chronology differs from {@link java.util.GregorianCalendar
- * java.util.GregorianCalendar} in that years in BCE are returned
- * correctly. Thus year 1 BCE is returned as -1 instead of 1. The yearOfEra
- * field produces results compatible with GregorianCalendar.
- * <p>
- * The Julian calendar does not have a year zero, and so year -1 is followed by
- * year 1. If the Gregorian cutover date is specified at or before year -1
- * (Julian), year zero is defined. In other words, the proleptic Gregorian
- * chronology implemented by this class has a year zero.
- * <p>
- * A pure proleptic Gregorian chronology is obtained by specifying a cutover of
- * Long.MIN_VALUE. Likewise, a pure Julian chronology is obtained with a
- * cutover of Long.MAX_VALUE.
- * <p>
- * GJChronology is thread-safe and immutable.
- *
- * @author Stephen Colebourne
- * @author Brian S O'Neill
- * @since 1.0
- */
-public abstract class GJChronology extends Chronology {
-
-    static final long serialVersionUID = 3258844765135550418L;
-
-    /**
-     * The default GregorianJulian cutover point
-     */
-    static final long DEFAULT_CUTOVER = -12219292800000L;
-
-    // Cache that maps DateTimeZones to Factory instances.
-    private static HashMap cZonesToFactories = new HashMap();
-
-    transient DurationField iYearsField;
-    transient DurationField iCenturiesField;
-    transient DurationField iMonthsField;
-    transient DurationField iWeekyearsField;
-
-    transient DurationField iMillisField;
-    transient DurationField iSecondsField;
-    transient DurationField iMinutesField;
-    transient DurationField iHoursField;
-    transient DurationField iDaysField;
-    transient DurationField iWeeksField;
-
-    transient DateTimeField iYearField;
-    transient DateTimeField iYearOfEraField;
-    transient DateTimeField iYearOfCenturyField;
-    transient DateTimeField iCenturyOfEraField;
-    transient DateTimeField iEraField;
-    transient DateTimeField iDayOfWeekField;
-    transient DateTimeField iDayOfMonthField;
-    transient DateTimeField iDayOfYearField;
-    transient DateTimeField iMonthOfYearField;
-    transient DateTimeField iWeekOfWeekyearField;
-    transient DateTimeField iWeekyearField;
-
-    transient DateTimeField iMillisOfSecondField;
-    transient DateTimeField iMillisOfDayField;
-    transient DateTimeField iSecondOfMinuteField;
-    transient DateTimeField iSecondOfDayField;
-    transient DateTimeField iMinuteOfHourField;
-    transient DateTimeField iMinuteOfDayField;
-    transient DateTimeField iHourOfDayField;
-    transient DateTimeField iHourOfHalfdayField;
-    transient DateTimeField iClockhourOfDayField;
-    transient DateTimeField iClockhourOfHalfdayField;
-    transient DateTimeField iHalfdayOfDayField;
-
-    /**
-     * Factory method returns instances of the default GJ chronology. This uses
-     * a cutover date of October 15, 1582 (Gregorian) 00:00:00 UTC. For this
-     * value, October 4, 1582 (Julian) is followed by October 15, 1582
-     * (Gregorian).
-     *
-     * <p>The first day of the week is designated to be
-     * {@link DateTimeConstants#MONDAY Monday}, and the minimum days in the
-     * first week of the year is 4.
-     *
-     * <p>The time zone of the returned instance is UTC.
-     */
-    public static GJChronology getInstanceUTC() {
-        return getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, false);
-    }
-
-    /**
-     * Factory method returns instances of the default GJ chronology. This uses
-     * a cutover date of October 15, 1582 (Gregorian) 00:00:00 UTC. For this
-     * value, October 4, 1582 (Julian) is followed by October 15, 1582
-     * (Gregorian).
-     *
-     * <p>The first day of the week is designated to be
-     * {@link DateTimeConstants#MONDAY Monday}, and the minimum days in the
-     * first week of the year is 4.
-     *
-     * <p>The returned chronology is in the default time zone.
-     */
-    public static GJChronology getInstance() {
-        return getInstance(DateTimeZone.getDefault(), DEFAULT_CUTOVER, false);
-    }
-
-    /**
-     * Factory method returns instances of the default GJ chronology. This uses
-     * a cutover date of October 15, 1582 (Gregorian) 00:00:00 UTC. For this
-     * value, October 4, 1582 (Julian) is followed by October 15, 1582
-     * (Gregorian).
-     *
-     * <p>The first day of the week is designated to be
-     * {@link DateTimeConstants#MONDAY Monday}, and the minimum days in the
-     * first week of the year is 4.
-     *
-     * @param zone  the time zone to use, null is default
-     */
-    public static GJChronology getInstance(DateTimeZone zone) {
-        return getInstance(zone, DEFAULT_CUTOVER, false);
-    }
-
-    /**
-     * Factory method allowing the Gregorian cutover point and year zero
-     * handling to be set. If the cutover millis is Long.MIN_VALUE, a proleptic
-     * Gregorian calendar is returned. If the cutover millis is Long.MAX_VALUE,
-     * a proleptic Julian calendar is returned.
-     *
-     * <p>The first day of the week is designated to be
-     * {@link DateTimeConstants#MONDAY Monday}, and the minimum days in the
-     * first week of the year is 4.
-     *
-     * @param zone  the time zone to use, null is default
-     * @param gregorianCutover  the cutover as a ReadableInstant, null means default
-     * @param centuryISO  when true, century related fields follow ISO rules
-     */
-    public static GJChronology getInstance(DateTimeZone zone,
-                                           ReadableInstant gregorianCutover,
-                                           boolean centuryISO)
-    {
-        return getInstance(zone, gregorianCutover, centuryISO, 4);
-    }
-    
-    /**
-     * Factory method allowing the Gregorian cutover point and year zero
-     * handling to be set.  If the cutover is Long.MIN_VALUE, a proleptic
-     * Gregorian calendar is returned. If the cutover is Long.MAX_VALUE, a
-     * proleptic Julian calendar is returned.
-     *
-     * <p>The first day of the week is designated to be
-     * {@link DateTimeConstants#MONDAY Monday}, and the minimum days in the
-     * first week of the year is 4.
-     *
-     * @param zone  the time zone to use, null is default
-     * @param gregorianCutover  the cutover as milliseconds from 1970-01-01T00:00:00Z
-     * @param centuryISO  when true, century related fields follow ISO rules
-     */
-    public static synchronized GJChronology getInstance(DateTimeZone zone,
-                                                        long gregorianCutover,
-                                                        boolean centuryISO)
-    {
-        return getInstance(zone, gregorianCutover, centuryISO, 4);
-    }
-
-    /**
-     * Factory method allowing the Gregorian cutover point and year zero
-     * handling to be set.  If the cutover is Long.MIN_VALUE, a proleptic
-     * Gregorian calendar is returned. If the cutover is Long.MAX_VALUE, a
-     * proleptic Julian calendar is returned.
-     *
-     * @param zone  the time zone to use, null is default
-     * @param gregorianCutover  the cutover as a ReadableInstant, null means default
-     * @param centuryISO  when true, century related fields follow ISO rules
-     * @param minDaysInFirstWeek  minimum number of days in first week of the year; ISO is 4
-     */
-    public static synchronized GJChronology getInstance(DateTimeZone zone,
-                                                        ReadableInstant gregorianCutover,
-                                                        boolean centuryISO,
-                                                        int minDaysInFirstWeek)
-    {
-        long cutover;
-        if (gregorianCutover != null) {
-            cutover = gregorianCutover.getMillis();
-        } else {
-            cutover = DEFAULT_CUTOVER;
-        }
-        return getInstance(zone, cutover, centuryISO, minDaysInFirstWeek);
-    }
-
-    /**
-     * Factory method allowing the Gregorian cutover point and year zero
-     * handling to be set.  If the cutover is Long.MIN_VALUE, a proleptic
-     * Gregorian calendar is returned. If the cutover is Long.MAX_VALUE, a
-     * proleptic Julian calendar is returned.
-     *
-     * @param zone  the time zone to use, null is default
-     * @param gregorianCutover  the cutover as milliseconds from 1970-01-01T00:00:00Z
-     * @param centuryISO  when true, century related fields follow ISO rules
-     * @param minDaysInFirstWeek  minimum number of days in first week of the year; ISO is 4
-     */
-    public static synchronized GJChronology getInstance(DateTimeZone zone,
-                                                        long gregorianCutover,
-                                                        boolean centuryISO,
-                                                        int minDaysInFirstWeek)
-    {
-        if (zone == null) {
-            zone = DateTimeZone.getDefault();
-        }
-
-        if (minDaysInFirstWeek < 1 || minDaysInFirstWeek > 7) {
-            throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek);
-        }
-
-        Factory factory;
-        getFactory: {
-            SoftReference ref = (SoftReference)cZonesToFactories.get(zone);
-            if (ref != null) {
-                factory = (Factory)ref.get();
-                if (factory != null) {
-                    break getFactory;
-                }
-            }
-            factory = new Factory(zone);
-            cZonesToFactories.put(zone, new SoftReference(factory));
-        }
-
-        return factory.getInstance(gregorianCutover, centuryISO, minDaysInFirstWeek);
-    }
-
-    GJChronology() {
-        super();
-    }
-
-    public Chronology withDateTimeZone(DateTimeZone zone) {
-        if (zone == null) {
-            zone = DateTimeZone.getDefault();
-        }
-        if (zone == getDateTimeZone()) {
-            return this;
-        }
-        if (zone == DateTimeZone.UTC) {
-            return withUTC();
-        }
-        return getInstance(zone, getGregorianJulianCutoverMillis(),
-                           isCenturyISO(), getMinimumDaysInFirstWeek());
-    }
-
-    // This method is overridden by GJZonedChronology.
-    public DateTimeZone getDateTimeZone() {
-        return DateTimeZone.UTC;
-    }
-
-    /**
-     * Gets the cutover instant between Gregorian and Julian chronologies.
-     * @return the cutover instant
-     */
-    public Instant getGregorianJulianCutover() {
-        return new Instant(getGregorianJulianCutoverMillis());
-    }
-    
-    /**
-     * Gets the cutover millis between Gregorian and Julian chronologies.
-     * @return the cutover millis
-     */
-    public abstract long getGregorianJulianCutoverMillis();
-    
-    /**
-     * Returns true when century fields follow ISO rules. In ISO rules, the
-     * century is simply the year divided by 100, and the year of century is
-     * the remainder.
-     * <p>
-     * When false is returned, the first century is defined to start on year
-     * one, and the year of century can range from 1 to 100.
-     */
-    public abstract boolean isCenturyISO();
-
-    public abstract int getMinimumDaysInFirstWeek();
-    
-    // Milliseconds
-    //------------------------------------------------------------
-
-    public DurationField millis() {
-        return iMillisField;
-    }
-
-    public DateTimeField millisOfSecond() {
-        return iMillisOfSecondField;
-    }
-
-    public DateTimeField millisOfDay() {
-        return iMillisOfDayField;
-    }
-
-    // Seconds
-    //------------------------------------------------------------
-
-    public DurationField seconds() {
-        return iSecondsField;
-    }
-
-    public DateTimeField secondOfMinute() {
-        return iSecondOfMinuteField;
-    }
-
-    public DateTimeField secondOfDay() {
-        return iSecondOfDayField;
-    }
-
-    // Minutes
-    //------------------------------------------------------------
-
-    public DurationField minutes() {
-        return iMinutesField;
-    }
-
-    public DateTimeField minuteOfHour() {
-        return iMinuteOfHourField;
-    }
-
-    public DateTimeField minuteOfDay() {
-        return iMinuteOfDayField;
-    }
-
-    // Hours
-    //------------------------------------------------------------
-
-    public DurationField hours() {
-        return iHoursField;
-    }
-
-    public DateTimeField hourOfDay() {
-        return iHourOfDayField;
-    }
-
-    public DateTimeField clockhourOfDay() {
-        return iClockhourOfDayField;
-    }
-
-    public DateTimeField hourOfHalfday() {
-        return iHourOfHalfdayField;
-    }
-
-    public DateTimeField clockhourOfHalfday() {
-        return iClockhourOfHalfdayField;
-    }
-
-    public DateTimeField halfdayOfDay() {
-        return iHalfdayOfDayField;
-    }
-
-    // Day
-    //------------------------------------------------------------
-    
-    public DurationField days() {
-        return iDaysField;
-    }
-
-    public DateTimeField dayOfWeek() {
-        return iDayOfWeekField;
-    }
-
-    public DateTimeField dayOfMonth() {
-        return iDayOfMonthField;
-    }
-
-    public DateTimeField dayOfYear() {
-        return iDayOfYearField;
-    }
-
-    // Week
-    //------------------------------------------------------------
-    
-    public DurationField weeks() {
-        return iWeeksField;
-    }
-
-    public DateTimeField weekOfWeekyear() {
-        return iWeekOfWeekyearField;
-    }
-
-    public DurationField weekyears() {
-        return iWeekyearsField;
-    }
-
-    public DateTimeField weekyear() {
-        return iWeekyearField;
-    }
-
-    // Month
-    //------------------------------------------------------------
-    
-    public DurationField months() {
-        return iMonthsField;
-    }
-
-    public DateTimeField monthOfYear() {
-        return iMonthOfYearField;
-    }
-
-    // Year
-    //------------------------------------------------------------
-    
-    public DurationField years() {
-        return iYearsField;
-    }
-
-    public DateTimeField year() {
-        return iYearField;
-    }
-
-    public DateTimeField yearOfEra() {
-        return iYearOfEraField;
-    }
-
-    public DateTimeField yearOfCentury() {
-        return iYearOfCenturyField;
-    }
-
-    public DurationField centuries() {
-        return iCenturiesField;
-    }
-
-    public DateTimeField centuryOfEra() {
-        return iCenturyOfEraField;
-    }
-
-    public DateTimeField era() {
-        return iEraField;
-    }
-
-    // Output
-    //-----------------------------------------------------------------------
-    /**
-     * Gets a debugging toString.
-     * 
-     * @return a debugging string
-     */
-    public String toString() {
-        StringBuffer sb = new StringBuffer(50);
-        sb.append("GJChronology");
-        sb.append('[');
-        sb.append(getDateTimeZone().getID());
-        sb.append(", ");
-
-        long cutover = getGregorianJulianCutoverMillis();
-        if (cutover == Long.MAX_VALUE) {
-            sb.append("julian");
-        } else if (cutover == Long.MIN_VALUE) {
-            sb.append("gregorian");
-        } else {
-            sb.append("cutover=");
-            ISODateTimeFormat format = ISODateTimeFormat.getInstance(withUTC());
-            DateTimePrinter printer;
-            if (withUTC().getTimeOnlyMillis(cutover) == 0) {
-                printer = format.date();
-            } else {
-                printer = format.dateTime();
-            }
-            printer.printTo(sb, cutover);
-        }
-
-        sb.append(", century=");
-        sb.append(isCenturyISO() ? "iso" : "gj");
-
-        sb.append(", mdfw=");
-        sb.append(getMinimumDaysInFirstWeek());
-        sb.append(']');
-
-        return sb.toString();
-    }
-
-    /**
-     * Serialize GJChronology instances using a small stub. This reduces the
-     * serialized size, and deserialized instances come from the cache.
-     *
-     * <p>This method is intentionally package-private in order for sub-classes
-     * to inherit this method.
-     */
-    Object writeReplace() {
-        return new Stub(getDateTimeZone(),
-                        getGregorianJulianCutoverMillis(),
-                        isCenturyISO(),
-                        getMinimumDaysInFirstWeek());
-    }
-
-    /**
-     * Used by subclass constructors to copy all the fields of another
-     * chronology into this one.
-     */
-    void copyFields(Chronology chrono) {
-        iYearsField = chrono.years();
-        iCenturiesField = chrono.centuries();
-        iMonthsField = chrono.months();
-        iWeekyearsField = chrono.weekyears();
-
-        iMillisField = chrono.millis();
-        iSecondsField = chrono.seconds();
-        iMinutesField = chrono.minutes();
-        iHoursField = chrono.hours();
-        iDaysField = chrono.days();
-        iWeeksField = chrono.weeks();
-
-        iYearField = chrono.year();
-        iYearOfEraField = chrono.yearOfEra();
-        iYearOfCenturyField = chrono.yearOfCentury();
-        iCenturyOfEraField = chrono.centuryOfEra();
-        iEraField = chrono.era();
-        iDayOfWeekField = chrono.dayOfWeek();
-        iDayOfMonthField = chrono.dayOfMonth();
-        iDayOfYearField = chrono.dayOfYear();
-        iMonthOfYearField = chrono.monthOfYear();
-        iWeekOfWeekyearField = chrono.weekOfWeekyear();
-        iWeekyearField = chrono.weekyear();
-
-        iMillisOfSecondField = chrono.millisOfSecond();
-        iMillisOfDayField = chrono.millisOfDay();
-        iSecondOfMinuteField = chrono.secondOfMinute();
-        iSecondOfDayField = chrono.secondOfDay();
-        iMinuteOfHourField = chrono.minuteOfHour();
-        iMinuteOfDayField = chrono.minuteOfDay();
-        iHourOfDayField = chrono.hourOfDay();
-        iHourOfHalfdayField = chrono.hourOfHalfday();
-        iClockhourOfDayField = chrono.clockhourOfDay();
-        iClockhourOfHalfdayField = chrono.clockhourOfHalfday();
-        iHalfdayOfDayField = chrono.halfdayOfDay();
-    }
-
-    private static final class Stub implements Serializable {
-        static final long serialVersionUID = -1220272966668670015L;
-
-        private transient DateTimeZone iZone;
-        private transient long iCutover;
-        private transient boolean iCenturyISO;
-        private transient byte iMinDaysInFirstWeek;
-
-        Stub(DateTimeZone zone, long gregorianCutover,
-             boolean centuryISO, int minDaysInFirstWeek)
-        {
-            iZone = zone;
-            iCutover = gregorianCutover;
-            iCenturyISO = centuryISO;
-            iMinDaysInFirstWeek = (byte)minDaysInFirstWeek;
-        }
-
-        Object readResolve() {
-            return GJChronology.getInstance(iZone,
-                                            iCutover,
-                                            iCenturyISO,
-                                            iMinDaysInFirstWeek);
-        }
-
-        private void writeObject(ObjectOutputStream out) throws IOException {
-            out.writeBoolean(iCenturyISO);
-            out.writeObject(iZone);
-            out.writeLong(iCutover);
-            out.writeByte(iMinDaysInFirstWeek);
-        }
-
-        private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
-            iCenturyISO = in.readBoolean();
-            iZone = (DateTimeZone)in.readObject();
-            iCutover = in.readLong();
-            iMinDaysInFirstWeek = in.readByte();
-        }
-    }
-
-    /**
-     * Creates instances for a specific time zone.
-     */
-    private static final class Factory {
-        private final DateTimeZone iZone;
-
-        // A simple cache that performs in O(n) time.
-        private ArrayList iCache;
-
-        Factory(DateTimeZone zone) {
-            iZone = zone;
-            iCache = new ArrayList();
-        }
-
-        public synchronized GJChronology getInstance(long gregorianCutover,
-                                                     boolean centuryISO,
-                                                     int minDaysInFirstWeek)
-        {
-            GJChronology chrono;
-            ArrayList cache = iCache;
-            
-            for (int i=cache.size(); --i>=0; ) {
-                chrono = (GJChronology)((SoftReference)cache.get(i)).get();
-                if (chrono == null) {
-                    cache.remove(i);
-                    continue;
-                }
-                
-                if (chrono.getGregorianJulianCutoverMillis() == gregorianCutover &&
-                    chrono.isCenturyISO() == centuryISO &&
-                    chrono.getMinimumDaysInFirstWeek() == minDaysInFirstWeek) {
-                    
-                    return chrono;
-                }
-            }
-
-            if (iZone != DateTimeZone.UTC) {
-                chrono = GJChronology.getInstance
-                    (DateTimeZone.UTC, gregorianCutover, centuryISO, minDaysInFirstWeek);
-                chrono = new GJZonedChronology(chrono, iZone);
-            } else {
-                if (gregorianCutover == Long.MAX_VALUE) {
-                    chrono = new JulianChronology(minDaysInFirstWeek);
-                } else if (gregorianCutover == Long.MIN_VALUE) {
-                    chrono = new GregorianChronology(minDaysInFirstWeek);
-                } else {
-                    JulianChronology julian_utc = (JulianChronology)GJChronology.getInstance
-                        (DateTimeZone.UTC, Long.MAX_VALUE, true, minDaysInFirstWeek);
-                    GregorianChronology gregorian_utc = (GregorianChronology)GJChronology.getInstance
-                        (DateTimeZone.UTC, Long.MIN_VALUE, true, minDaysInFirstWeek);
-                    
-                    chrono = new CutoverChronology(julian_utc, gregorian_utc, gregorianCutover);
-                }
-
-                if (!centuryISO) {
-                    chrono = new GJCenturyChronology(chrono);
-                }
-            }
-            
-            cache.add(new SoftReference(chrono));
-            return chrono;
-        }
-    }
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GJZonedChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/GJZonedChronology.java
deleted file mode 100644
index 36ff452eb..000000000
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GJZonedChronology.java
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono.gj;
-
-import org.joda.time.Chronology;
-import org.joda.time.DateTimeZone;
-import org.joda.time.chrono.ZonedChronology;
-
-/**
- * A special zoned chronology for the GJ chronology.
- * 
- * @author Brian S O'Neill
- * @author Stephen Colebourne
- * @since 1.0
- */
-final class GJZonedChronology extends GJChronology {
-
-    static final long serialVersionUID = -4148749408058922172L;
-
-    private final GJChronology iChronology;
-    private final DateTimeZone iZone;
-    private final ZonedChronology iZonedChronology;
-
-    GJZonedChronology(GJChronology chrono, DateTimeZone zone) {
-        iChronology = chrono;
-        iZone = zone;
-        copyFields(iZonedChronology = new ZonedChronology(chrono, zone));
-    }
-
-    public DateTimeZone getDateTimeZone() {
-        return iZone;
-    }
-
-    public Chronology withUTC() {
-        return iChronology;
-    }
-
-    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
-        throws IllegalArgumentException
-    {
-        return iZonedChronology.getDateOnlyMillis(year, monthOfYear, dayOfMonth);
-    }
-
-    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
-                                        int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        return iZonedChronology.getTimeOnlyMillis
-            (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-    }
-
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                        int millisOfDay)
-        throws IllegalArgumentException
-    {
-        return iZonedChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);
-    }
-
-    public long getDateTimeMillis(long instant,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        return iZonedChronology.getDateTimeMillis
-            (instant,
-             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-    }
-
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        return iZonedChronology.getDateTimeMillis
-            (year, monthOfYear, dayOfMonth,
-             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-    }
-
-    public long getGregorianJulianCutoverMillis() {
-        return iChronology.getGregorianJulianCutoverMillis();
-    }
-
-    public boolean isCenturyISO() {
-        return iChronology.isCenturyISO();
-    }
-
-    public int getMinimumDaysInFirstWeek() {
-        return iChronology.getMinimumDaysInFirstWeek();
-    }
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/GregorianChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/GregorianChronology.java
deleted file mode 100644
index 314afcf6c..000000000
--- a/JodaTime/src/java/org/joda/time/chrono/gj/GregorianChronology.java
+++ /dev/null
@@ -1,128 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono.gj;
-
-import org.joda.time.DateTimeConstants;
-
-/**
- * 
- * @author Guy Allard
- * @author Stephen Colebourne
- * @author Brian S O'Neill
- */
-final class GregorianChronology extends ProlepticChronology {
-
-    static final long serialVersionUID = 3691407383323710523L;
-
-    GregorianChronology(int minDaysInFirstWeek) {
-        super(minDaysInFirstWeek);
-    }
-
-    public long getGregorianJulianCutoverMillis() {
-        return Long.MIN_VALUE;
-    }
-    
-    public boolean isLeapYear(int year) {
-        return ((year & 3) == 0) && ((year % 100) != 0 || (year % 400) == 0);
-    }
-
-    protected long calculateFirstDayOfYearMillis(int year) {
-        // Calculate relative to 2000 as that is on a 400 year boundary
-        // and that makes the sum easier
-        int relativeYear = year - 2000;
-        // Initial value is just temporary.
-        int leapYears = relativeYear / 100;
-        if (relativeYear <= 0) {
-            // Add 3 before shifting right since /4 and >>2 behave differently
-            // on negative numbers. When the expression is written as
-            // (relativeYear / 4) - (relativeYear / 100) + (relativeYear / 400),
-            // it works for both positive and negative values, except this optimization
-            // eliminates two divisions.
-            leapYears = ((relativeYear + 3) >> 2) - leapYears + ((leapYears + 3) >> 2);
-        } else {
-            leapYears = (relativeYear >> 2) - leapYears + (leapYears >> 2);
-            // For post 2000 an adjustment is needed as jan1st is before leap day
-            if (!isLeapYear(year)) {
-                leapYears++;
-            }
-        }
-        
-        long millis = (relativeYear * 365L + leapYears)
-            * (long)DateTimeConstants.MILLIS_PER_DAY;
-        
-        // Previous line was reduced from this to eliminate a multiplication.
-        // millis = ((relativeYear - leapYears) * 365L + leapYears * 366) * MILLIS_PER_DAY;
-        // (x - y)*c + y*(c + 1) => x*c - y*c + y*c + y => x*c + y
-        
-        return millis + MILLIS_1970_TO_2000;
-    }
-
-    protected int getMinYear() {
-        // The lowest year that can be fully supported.
-        return -292275054;
-    }
-
-    protected int getMaxYear() {
-        // The highest year that can be fully supported.
-        return 292278993;
-    }
-
-    protected long getRoughMillisPerYear() {
-        return (long) (365.2425 * DateTimeConstants.MILLIS_PER_DAY);
-    }
-
-    protected long getRoughMillisPerMonth() {
-        return (long) (365.2425 * DateTimeConstants.MILLIS_PER_DAY / 12);
-    }
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/JulianChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/JulianChronology.java
deleted file mode 100644
index df4c568db..000000000
--- a/JodaTime/src/java/org/joda/time/chrono/gj/JulianChronology.java
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono.gj;
-
-import org.joda.time.Chronology;
-import org.joda.time.DateTimeField;
-import org.joda.time.chrono.DelegatedDateTimeField;
-import org.joda.time.chrono.Utils;
-
-/**
- * Year zero is dropped from the year and weekyear fields.
- *
- * @author Brian S O'Neill
- */
-final class JulianChronology extends GJChronology {
-
-    static final long serialVersionUID = -8731039522547897247L;
-
-    private final JulianWithYearZeroChronology iChronology;
-
-    /**
-     * @param chrono wrapped chronology
-     */
-    JulianChronology(int minDaysInFirstWeek) {
-        JulianWithYearZeroChronology chrono =
-            new JulianWithYearZeroChronology(minDaysInFirstWeek);
-        iChronology = chrono;
-        copyFields(chrono);
-
-        // Override only the fields that differ.
-
-        iYearField = new NoYearZeroField(chrono.year());
-        iWeekyearField = new NoWeekyearZeroField(chrono.weekyear());
-    }
-
-    public Chronology withUTC() {
-        return this;
-    }
-
-    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
-        throws IllegalArgumentException
-    {
-        year = adjustYearForSet(year);
-        return iChronology.getDateOnlyMillis(year, monthOfYear, dayOfMonth);
-    }
-
-    public long getTimeOnlyMillis(int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        return iChronology.getTimeOnlyMillis
-            (hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-    }
-
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int millisOfDay)
-        throws IllegalArgumentException
-    {
-        year = adjustYearForSet(year);
-        return iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);
-    }
-
-    public long getDateTimeMillis(long instant,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        return iChronology.getDateTimeMillis
-            (instant,
-             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-    }
-
-    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
-                                  int hourOfDay, int minuteOfHour,
-                                  int secondOfMinute, int millisOfSecond)
-        throws IllegalArgumentException
-    {
-        year = adjustYearForSet(year);
-        return iChronology.getDateTimeMillis
-            (year, monthOfYear, dayOfMonth,
-             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
-    }
-
-    public long getGregorianJulianCutoverMillis() {
-        return iChronology.getGregorianJulianCutoverMillis();
-    }
-
-    public boolean isCenturyISO() {
-        return iChronology.isCenturyISO();
-    }
-
-    public int getMinimumDaysInFirstWeek() {
-        return iChronology.getMinimumDaysInFirstWeek();
-    }
-
-    int adjustYearForSet(int year) {
-        if (year <= 0) {
-            if (year == 0) {
-                throw new IllegalArgumentException("Invalid year: " + year);
-            }
-            year++;
-        }
-        return year;
-    }
-
-    private class NoYearZeroField extends DelegatedDateTimeField {
-        static final long serialVersionUID = -8869148464118507846L;
-
-        private transient int iMinYear;
-
-        NoYearZeroField(DateTimeField field) {
-            super(field);
-            iMinYear = super.getMinimumValue() - 1;
-        }
-        
-        public int get(long millis) {
-            int year = super.get(millis);
-            if (year <= 0) {
-                year--;
-            }
-            return year;
-        }
-
-        public long set(long millis, int year) {
-            Utils.verifyValueBounds(this, year, iMinYear, getMaximumValue());
-            return super.set(millis, adjustYearForSet(year));
-        }
-
-        public int getMinimumValue() {
-            return iMinYear;
-        }
-
-        private Object readResolve() {
-            return JulianChronology.this.year();
-        }
-    }
-
-    private final class NoWeekyearZeroField extends NoYearZeroField {
-        static final long serialVersionUID = -5013429014495501104L;
-
-        NoWeekyearZeroField(DateTimeField field) {
-            super(field);
-        }
-        
-        private Object readResolve() {
-            return JulianChronology.this.weekyear();
-        }
-    }
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/JulianWithYearZeroChronology.java b/JodaTime/src/java/org/joda/time/chrono/gj/JulianWithYearZeroChronology.java
deleted file mode 100644
index 56c3d4060..000000000
--- a/JodaTime/src/java/org/joda/time/chrono/gj/JulianWithYearZeroChronology.java
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-2004 Stephen Colebourne.  
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:  
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally 
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono.gj;
-
-import org.joda.time.DateTimeConstants;
-
-/**
- * JulianWithZeroChronology includes year zero to simplify implementation.
- * 
- * @author Guy Allard
- * @author Brian S O'Neill
- * @author Stephen Colebourne
- */
-final class JulianWithYearZeroChronology extends ProlepticChronology {
-
-    static final long serialVersionUID = 9044685826106463217L;
-
-    JulianWithYearZeroChronology(int minDaysInFirstWeek) {
-        super(minDaysInFirstWeek);
-    }
-
-    public long getGregorianJulianCutoverMillis() {
-        return Long.MAX_VALUE;
-    }
-
-    public boolean isLeapYear(int year) {
-        return (year & 3) == 0;
-    }
-
-    protected long calculateFirstDayOfYearMillis(int year) {
-        // Java epoch is 1970-01-01 Gregorian which is 1969-12-19 Julian.
-        // Calculate relative to the nearest leap year and account for the
-        // difference later.
-
-        int relativeYear = year - 1968;
-        int leapYears;
-        if (relativeYear <= 0) {
-            // Add 3 before shifting right since /4 and >>2 behave differently
-            // on negative numbers.
-            leapYears = (relativeYear + 3) >> 2;
-        } else {
-            leapYears = relativeYear >> 2;
-            // For post 1968 an adjustment is needed as jan1st is before leap day
-            if (!isLeapYear(year)) {
-                leapYears++;
-            }
-        }
-        
-        long millis = (relativeYear * 365L + leapYears)
-            * (long)DateTimeConstants.MILLIS_PER_DAY;
-
-        // Adjust to account for difference between 1968-01-01 and 1969-12-19.
-
-        return millis - (366L + 365 - 13) * DateTimeConstants.MILLIS_PER_DAY;
-    }
-
-    protected int getMinYear() {
-        // The lowest year that can be fully supported.
-        return -292269053;
-    }
-
-    protected int getMaxYear() {
-        // The highest year that can be fully supported.
-        return 292272992;
-    }
-
-    protected long getRoughMillisPerYear() {
-        return (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY);
-    }
-
-    protected long getRoughMillisPerMonth() {
-        return (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY / 12);
-    }
-}
diff --git a/JodaTime/src/java/org/joda/time/chrono/gj/package.html b/JodaTime/src/java/org/joda/time/chrono/gj/package.html
deleted file mode 100644
index 13ad62c8c..000000000
--- a/JodaTime/src/java/org/joda/time/chrono/gj/package.html
+++ /dev/null
@@ -1,74 +0,0 @@
-<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
-<html>
-<head>
-<title>org.joda.time.chrono.gj package</title>
-<!--
-
-   Joda Software License, Version 1.0
-  
-  
-   Copyright (c) 2001-03 Stephen Colebourne.
-   All rights reserved.
-  
-   Redistribution and use in source and binary forms, with or without
-   modification, are permitted provided that the following conditions
-   are met:
-  
-   1. Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-  
-   2. Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-  
-   3. The end-user documentation included with the redistribution,
-      if any, must include the following acknowledgment:
-         "This product includes software developed by the
-          Joda project (http://www.joda.org/)."
-      Alternately, this acknowledgment may appear in the software itself,
-      if and wherever such third-party acknowledgments normally appear.
-  
-   4. The name "Joda" must not be used to endorse or promote products
-      derived from this software without prior written permission. For
-      written permission, please contact licence@joda.org.
-  
-   5. Products derived from this software may not be called "Joda",
-      nor may "Joda" appear in their name, without prior written
-      permission of the Joda project.
-  
-   THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
-   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-   DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
-   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
-   USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
-   OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
-   SUCH DAMAGE.
-   ====================================================================
-  
-   This software consists of voluntary contributions made by many
-   individuals on behalf of the Joda project and was originally
-   created by Stephen Colebourne <scolebourne@joda.org>. For more
-   information on the Joda project, please see <http://www.joda.org/>.
-
--->
-</head>
-<body>
-<p>
-Provides a Gregorian/Julian Chronology implementation. The Gregorian/Julian
-calendar system (shortened to GJ) is the most commonly used system on the
-planet. The Julian system defined a leap year once every 4 years, whereas the
-Gregorian calendar has additional special rules for every 100 and 400 years.
-</p>
-<p>
-This package provides the classes necessary to support the GJ calendar system,
-including different cutover dates, the presence or absence of a year zero, a
-pure Gregorian calendar, or a pure Julian calendar.
-</p>
-</body>
-</html>
diff --git a/JodaTime/src/java/org/joda/time/chrono/iso/package.html b/JodaTime/src/java/org/joda/time/chrono/iso/package.html
deleted file mode 100644
index 03787f818..000000000
--- a/JodaTime/src/java/org/joda/time/chrono/iso/package.html
+++ /dev/null
@@ -1,70 +0,0 @@
-<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
-<html>
-<head>
-<title>org.joda.time.chrono.iso package</title>
-<!--
-
-   Joda Software License, Version 1.0
-  
-  
-   Copyright (c) 2001-03 Stephen Colebourne.
-   All rights reserved.
-  
-   Redistribution and use in source and binary forms, with or without
-   modification, are permitted provided that the following conditions
-   are met:
-  
-   1. Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-  
-   2. Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in
-      the documentation and/or other materials provided with the
-      distribution.
-  
-   3. The end-user documentation included with the redistribution,
-      if any, must include the following acknowledgment:
-         "This product includes software developed by the
-          Joda project (http://www.joda.org/)."
-      Alternately, this acknowledgment may appear in the software itself,
-      if and wherever such third-party acknowledgments normally appear.
-  
-   4. The name "Joda" must not be used to endorse or promote products
-      derived from this software without prior written permission. For
-      written permission, please contact licence@joda.org.
-  
-   5. Products derived from this software may not be called "Joda",
-      nor may "Joda" appear in their name, without prior written
-      permission of the Joda project.
-  
-   THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
-   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-   DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
-   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
-   USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
-   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
-   OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
-   SUCH DAMAGE.
-   ====================================================================
-  
-   This software consists of voluntary contributions made by many
-   individuals on behalf of the Joda project and was originally
-   created by Stephen Colebourne <scolebourne@joda.org>. For more
-   information on the Joda project, please see <http://www.joda.org/>.
-
--->
-</head>
-<body>
-<p>
-Provides an ISO Chronology implementation. The ISO calendar system is defined
-by the ISO8601 standard, which is in fact a special case of the Gregorian
-calendar system. It is defined as Gregorian over all time (proleptic) and
-includes the year 0 (which never actually occurred). All XML date and time
-transfers are recommended to use the ISO8601 standard.
-</p>
-</body>
-</html>
diff --git a/JodaTime/src/java/org/joda/time/chrono/package.html b/JodaTime/src/java/org/joda/time/chrono/package.html
index 1d411cd6a..194471a43 100644
--- a/JodaTime/src/java/org/joda/time/chrono/package.html
+++ b/JodaTime/src/java/org/joda/time/chrono/package.html
@@ -7,7 +7,7 @@
    Joda Software License, Version 1.0
   
   
-   Copyright (c) 2001-03 Stephen Colebourne.
+   Copyright (c) 2001-2004 Stephen Colebourne.
    All rights reserved.
   
    Redistribution and use in source and binary forms, with or without
@@ -60,9 +60,7 @@
 </head>
 <body>
 <p>
-Provides Chronology implementaions and support. The base package contains
-classes that aid in making new chronologies and fields, and the sub-packages
-contain complete implementations.
+Provides Chronology implementaions and support.
 </p>
 </body>
 </html>
diff --git a/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java b/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java
index d3b60848d..a988194a2 100644
--- a/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/AbstractConverter.java
@@ -55,7 +55,7 @@
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeZone;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * AbstractConverter simplifies the process of implementing a converter.
diff --git a/JodaTime/src/java/org/joda/time/convert/CalendarConverter.java b/JodaTime/src/java/org/joda/time/convert/CalendarConverter.java
index 58695e0e2..0a9e442e7 100644
--- a/JodaTime/src/java/org/joda/time/convert/CalendarConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/CalendarConverter.java
@@ -58,9 +58,11 @@
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeZone;
-import org.joda.time.chrono.buddhist.BuddhistChronology;
-import org.joda.time.chrono.gj.GJChronology;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.BuddhistChronology;
+import org.joda.time.chrono.GJChronology;
+import org.joda.time.chrono.GregorianChronology;
+import org.joda.time.chrono.JulianChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * CalendarConverter converts a java util Calendar to milliseconds in the
@@ -126,11 +128,16 @@ public Chronology getChronology(Object object) {
     public Chronology getChronology(Object object, DateTimeZone zone) {
         if (object instanceof GregorianCalendar) {
             GregorianCalendar gc = (GregorianCalendar) object;
-            return GJChronology.getInstance(zone, gc.getGregorianChange().getTime(), false);
-            
+            long cutover = gc.getGregorianChange().getTime();
+            if (cutover == Long.MIN_VALUE) {
+                return GregorianChronology.getInstance(zone);
+            } else if (cutover == Long.MAX_VALUE) {
+                return JulianChronology.getInstance(zone);
+            } else {
+                return GJChronology.getInstance(zone, cutover, 4);
+            }
         } else if (object.getClass().getName().endsWith(".BuddhistCalendar")) {
             return BuddhistChronology.getInstance(zone);
-            
         } else {
             return ISOChronology.getInstance(zone);
         }
diff --git a/JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java b/JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java
index 30b8c1d1b..aab0d2634 100644
--- a/JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/PartialInstantConverter.java
@@ -56,7 +56,7 @@
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeZone;
 import org.joda.time.PartialInstant;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * PartialInstantConverter extracts milliseconds and chronology from a
diff --git a/JodaTime/src/java/org/joda/time/convert/ReadableInstantConverter.java b/JodaTime/src/java/org/joda/time/convert/ReadableInstantConverter.java
index 9b5b680e5..6036bbd7d 100644
--- a/JodaTime/src/java/org/joda/time/convert/ReadableInstantConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/ReadableInstantConverter.java
@@ -56,7 +56,7 @@
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeZone;
 import org.joda.time.ReadableInstant;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * ReadableInstantConverter extracts milliseconds and chronology from a ReadableInstant.
diff --git a/JodaTime/src/java/org/joda/time/convert/StringConverter.java b/JodaTime/src/java/org/joda/time/convert/StringConverter.java
index dc468e822..0585ba01b 100644
--- a/JodaTime/src/java/org/joda/time/convert/StringConverter.java
+++ b/JodaTime/src/java/org/joda/time/convert/StringConverter.java
@@ -59,7 +59,7 @@
 import org.joda.time.ReadWritableDuration;
 import org.joda.time.ReadWritableInterval;
 import org.joda.time.ReadableDuration;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 import org.joda.time.format.DateTimeParser;
 import org.joda.time.format.DurationParser;
 import org.joda.time.format.ISODateTimeFormat;
diff --git a/JodaTime/src/java/org/joda/time/chrono/AbstractDateTimeField.java b/JodaTime/src/java/org/joda/time/field/AbstractDateTimeField.java
similarity index 99%
rename from JodaTime/src/java/org/joda/time/chrono/AbstractDateTimeField.java
rename to JodaTime/src/java/org/joda/time/field/AbstractDateTimeField.java
index d1514cc24..ae41151af 100644
--- a/JodaTime/src/java/org/joda/time/chrono/AbstractDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/AbstractDateTimeField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono;
+package org.joda.time.field;
 
 import java.io.Serializable;
 import java.util.Locale;
@@ -236,7 +236,7 @@ public long add(long instant, long value) {
      */
     public long addWrapped(long instant, int value) {
         int current = get(instant);
-        int wrapped = Utils.getWrappedValue
+        int wrapped = FieldUtils.getWrappedValue
             (current, value, getMinimumValue(instant), getMaximumValue(instant));
         return set(instant, wrapped);
     }
diff --git a/JodaTime/src/java/org/joda/time/chrono/AbstractDurationField.java b/JodaTime/src/java/org/joda/time/field/AbstractDurationField.java
similarity index 96%
rename from JodaTime/src/java/org/joda/time/chrono/AbstractDurationField.java
rename to JodaTime/src/java/org/joda/time/field/AbstractDurationField.java
index 27c8c49be..06e82bdee 100644
--- a/JodaTime/src/java/org/joda/time/chrono/AbstractDurationField.java
+++ b/JodaTime/src/java/org/joda/time/field/AbstractDurationField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono;
+package org.joda.time.field;
 
 import java.io.Serializable;
 import org.joda.time.DurationField;
@@ -106,7 +106,7 @@ public final boolean isSupported() {
      * negative
      */
     public int getValue(long duration) {
-        return Utils.safeToInt(getValueAsLong(duration));
+        return FieldUtils.safeToInt(getValueAsLong(duration));
     }
 
     /**
@@ -138,7 +138,7 @@ public long getValueAsLong(long duration) {
      * negative
      */
     public int getValue(long duration, long instant) {
-        return Utils.safeToInt(getValueAsLong(duration, instant));
+        return FieldUtils.safeToInt(getValueAsLong(duration, instant));
     }
 
     /**
@@ -168,7 +168,7 @@ public long getMillis(long value) {
     // Calculation API
     //------------------------------------------------------------------------
     public int getDifference(long minuendInstant, long subtrahendInstant) {
-        return Utils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));
+        return FieldUtils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));
     }
 
     //------------------------------------------------------------------------
diff --git a/JodaTime/src/java/org/joda/time/chrono/DecoratedDateTimeField.java b/JodaTime/src/java/org/joda/time/field/DecoratedDateTimeField.java
similarity index 99%
rename from JodaTime/src/java/org/joda/time/chrono/DecoratedDateTimeField.java
rename to JodaTime/src/java/org/joda/time/field/DecoratedDateTimeField.java
index 2e99333b4..c415876ef 100644
--- a/JodaTime/src/java/org/joda/time/chrono/DecoratedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/DecoratedDateTimeField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono;
+package org.joda.time.field;
 
 import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
diff --git a/JodaTime/src/java/org/joda/time/chrono/DecoratedDurationField.java b/JodaTime/src/java/org/joda/time/field/DecoratedDurationField.java
similarity index 99%
rename from JodaTime/src/java/org/joda/time/chrono/DecoratedDurationField.java
rename to JodaTime/src/java/org/joda/time/field/DecoratedDurationField.java
index 85cd6871c..be255e298 100644
--- a/JodaTime/src/java/org/joda/time/chrono/DecoratedDurationField.java
+++ b/JodaTime/src/java/org/joda/time/field/DecoratedDurationField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono;
+package org.joda.time.field;
 
 import org.joda.time.DurationField;
 
diff --git a/JodaTime/src/java/org/joda/time/chrono/DelegatedDateTimeField.java b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
similarity index 99%
rename from JodaTime/src/java/org/joda/time/chrono/DelegatedDateTimeField.java
rename to JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
index 313fc304c..d7748ba36 100644
--- a/JodaTime/src/java/org/joda/time/chrono/DelegatedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/DelegatedDateTimeField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono;
+package org.joda.time.field;
 
 import java.io.Serializable;
 import java.util.Locale;
diff --git a/JodaTime/src/java/org/joda/time/chrono/DelegatedDurationField.java b/JodaTime/src/java/org/joda/time/field/DelegatedDurationField.java
similarity index 99%
rename from JodaTime/src/java/org/joda/time/chrono/DelegatedDurationField.java
rename to JodaTime/src/java/org/joda/time/field/DelegatedDurationField.java
index 2d191e751..21d9c6d08 100644
--- a/JodaTime/src/java/org/joda/time/chrono/DelegatedDurationField.java
+++ b/JodaTime/src/java/org/joda/time/field/DelegatedDurationField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono;
+package org.joda.time.field;
 
 import java.io.Serializable;
 import org.joda.time.DurationField;
diff --git a/JodaTime/src/java/org/joda/time/chrono/DividedDateTimeField.java b/JodaTime/src/java/org/joda/time/field/DividedDateTimeField.java
similarity index 98%
rename from JodaTime/src/java/org/joda/time/chrono/DividedDateTimeField.java
rename to JodaTime/src/java/org/joda/time/field/DividedDateTimeField.java
index a8e9f419a..81e5cd8dc 100644
--- a/JodaTime/src/java/org/joda/time/chrono/DividedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/DividedDateTimeField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono;
+package org.joda.time.field;
 
 import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
@@ -187,7 +187,7 @@ public long add(long instant, long amount) {
      * @return the updated time instant.
      */
     public long addWrapped(long instant, int amount) {
-        return set(instant, Utils.getWrappedValue(get(instant), amount, iMin, iMax));
+        return set(instant, FieldUtils.getWrappedValue(get(instant), amount, iMin, iMax));
     }
 
     public int getDifference(long minuendInstant, long subtrahendInstant) {
@@ -207,7 +207,7 @@ public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
      * @throws IllegalArgumentException if value is too large or too small.
      */
     public long set(long instant, int value) {
-        Utils.verifyValueBounds(this, value, iMin, iMax);
+        FieldUtils.verifyValueBounds(this, value, iMin, iMax);
         int remainder = getRemainder(getWrappedField().get(instant));
         return getWrappedField().set(instant, value * iDivisor + remainder);
     }
diff --git a/JodaTime/src/java/org/joda/time/chrono/Utils.java b/JodaTime/src/java/org/joda/time/field/FieldUtils.java
similarity index 99%
rename from JodaTime/src/java/org/joda/time/chrono/Utils.java
rename to JodaTime/src/java/org/joda/time/field/FieldUtils.java
index 63b966029..da3bdc75e 100644
--- a/JodaTime/src/java/org/joda/time/chrono/Utils.java
+++ b/JodaTime/src/java/org/joda/time/field/FieldUtils.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono;
+package org.joda.time.field;
 
 import org.joda.time.DateTimeField;
 
@@ -63,12 +63,12 @@
  * @author Stephen Colebourne
  * @since 1.0
  */
-public class Utils {
+public class FieldUtils {
 
     /**
      * Restricted constructor.
      */
-    private Utils() {
+    private FieldUtils() {
         super();
     }
     
diff --git a/JodaTime/src/java/org/joda/time/chrono/ImpreciseDateTimeField.java b/JodaTime/src/java/org/joda/time/field/ImpreciseDateTimeField.java
similarity index 98%
rename from JodaTime/src/java/org/joda/time/chrono/ImpreciseDateTimeField.java
rename to JodaTime/src/java/org/joda/time/field/ImpreciseDateTimeField.java
index ff7da042c..d57c3127b 100644
--- a/JodaTime/src/java/org/joda/time/chrono/ImpreciseDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/ImpreciseDateTimeField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono;
+package org.joda.time.field;
 
 import org.joda.time.DurationField;
 
@@ -124,7 +124,7 @@ public ImpreciseDateTimeField(String name, String durationName, long unitMillis)
      * @return the difference in the units of this field
      */
     public int getDifference(long minuendInstant, long subtrahendInstant) {
-        return Utils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));
+        return FieldUtils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));
     }
 
     /**
diff --git a/JodaTime/src/java/org/joda/time/chrono/LenientDateTimeField.java b/JodaTime/src/java/org/joda/time/field/LenientDateTimeField.java
similarity index 98%
rename from JodaTime/src/java/org/joda/time/chrono/LenientDateTimeField.java
rename to JodaTime/src/java/org/joda/time/field/LenientDateTimeField.java
index 00f8de9f3..9a9275e85 100644
--- a/JodaTime/src/java/org/joda/time/chrono/LenientDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/LenientDateTimeField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono;
+package org.joda.time.field;
 
 import org.joda.time.DateTimeField;
 
@@ -62,6 +62,7 @@
  * LenientDateTimeField is thread-safe and immutable.
  *
  * @author Brian S O'Neill
+ * @see org.joda.time.chrono.LenientChronology
  * @see StrictDateTimeField
  */
 public class LenientDateTimeField extends DelegatedDateTimeField {
diff --git a/JodaTime/src/java/org/joda/time/field/LimitDateTimeField.j b/JodaTime/src/java/org/joda/time/field/LimitDateTimeField.j
new file mode 100644
index 000000000..7f5828dbc
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/field/LimitDateTimeField.j
@@ -0,0 +1,332 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-03 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import java.util.Locale;
+
+import org.joda.time.DateTimeField;
+import org.joda.time.DurationField;
+
+/**
+ * Generic limiting datetime field.
+ * <p>
+ * This DateTimeField allows specific millisecond boundaries to be applied 
+ * to DateTimeFields.
+ * <p>
+ * LimitDateTimeField is thread-safe and immutable.
+ *
+ * @author Stephen Colebourne
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+// TODO: Move delete this
+// TODO: Also consider ShiftedChronology, for supporting Coptic.
+public class LimitDateTimeField extends DecoratedDateTimeField {
+
+    static final long serialVersionUID = -4969295623151287856L;
+
+    /** The lower boundary in millis */
+    private final long iLowerBound;
+    /** The upper boundary in millis */
+    private final long iUpperBound;
+
+    /**
+     * Constructor
+     * 
+     * @param lowerBound  milliseconds to form the lower boundary inclusive
+     * @param upperBound  milliseconds to form the upper boundary inclusive
+     * @throws IllegalArgumentException if field is null or boundary is invalid
+     */
+    public LimitDateTimeField(DateTimeField field,
+                              long lowerBound, long upperBound) {
+        this(field, field.getName(), lowerBound, upperBound);
+    }
+
+    /**
+     * Constructor
+     * 
+     * @param name  short, descriptive name, like "secondOfMinute".
+     * @param lowerBound  milliseconds to form the lower boundary inclusive
+     * @param upperBound  milliseconds to form the upper boundary inclusive
+     * @throws IllegalArgumentException if field is null or boundary is invalid
+     */
+    public LimitDateTimeField(DateTimeField field, String name,
+                              long lowerBound, long upperBound) {
+        super(field, name);
+                
+        if (lowerBound >= upperBound) {
+            throw new IllegalArgumentException("The lowerBound must be less than the upperBound");
+        }
+        iLowerBound = lowerBound;
+        iUpperBound = upperBound;
+    }
+
+    /**
+     * Get the amount of fractional units from the specified time instant.
+     * 
+     * @param instant  the time instant in millis to query.
+     * @return the amount of fractional units extracted from the input.
+     */
+    public int get(long instant) {
+        checkBounds(instant, null);
+        return getWrappedField().get(instant);
+    }
+
+    public String getAsText(long instant, Locale locale) {
+        checkBounds(instant, null);
+        return getWrappedField().getAsText(instant, locale);
+    }
+
+    public String getAsShortText(long instant, Locale locale) {
+        checkBounds(instant, null);
+        return getWrappedField().getAsShortText(instant, locale);
+    }
+
+    /**
+     * Add the specified amount of fractional units to the specified time
+     * instant. The amount added may be negative.
+     * 
+     * @param instant  the time instant in millis to update.
+     * @param amount  the amount of fractional units to add (can be negative).
+     * @return the updated time instant.
+     */
+    public long add(long instant, int amount) {
+        checkBounds(instant, null);
+        long result = getWrappedField().add(instant, amount);
+        checkBounds(result, "resulting");
+        return result;
+    }
+
+    /**
+     * Add the specified amount of fractional units to the specified time
+     * instant. The amount added may be negative.
+     * 
+     * @param instant  the time instant in millis to update.
+     * @param amount  the amount of fractional units to add (can be negative).
+     * @return the updated time instant.
+     */
+    public long add(long instant, long amount) {
+        checkBounds(instant, null);
+        long result = getWrappedField().add(instant, amount);
+        System.out.println(result);
+        System.out.println(iLowerBound);
+        checkBounds(result, "resulting");
+        return result;
+    }
+
+    /**
+     * Add to the fractional component of the specified time instant,
+     * wrapping around within that component if necessary.
+     * 
+     * @param instant  the time instant in millis to update.
+     * @param amount  the amount of fractional units to add (can be negative).
+     * @return the updated time instant.
+     */
+    public long addWrapped(long instant, int amount) {
+        checkBounds(instant, null);
+        long result = getWrappedField().addWrapped(instant, amount);
+        checkBounds(result, "resulting");
+        return result;
+    }
+
+    public int getDifference(long minuendInstant, long subtrahendInstant) {
+        checkBounds(minuendInstant, "minuend");
+        checkBounds(subtrahendInstant, "subtrahend");
+        return getWrappedField().getDifference(minuendInstant, subtrahendInstant);
+    }
+
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        checkBounds(minuendInstant, "minuend");
+        checkBounds(subtrahendInstant, "subtrahend");
+        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant);
+    }
+
+    /**
+     * Set the specified amount of fractional units to the specified time instant.
+     * 
+     * @param instant  the time instant in millis to update.
+     * @param value  value of fractional units to set.
+     * @return the updated time instant.
+     * @throws IllegalArgumentException if value is too large or too small.
+     */
+    public long set(long instant, int value) {
+        checkBounds(instant, null);
+        long result = getWrappedField().set(instant, value);
+        checkBounds(result, "resulting");
+        return result;
+    }
+
+    public long set(long instant, String text, Locale locale) {
+        checkBounds(instant, null);
+        long result = getWrappedField().set(instant, text, locale);
+        checkBounds(result, "resulting");
+        return result;
+    }
+
+    public boolean isLeap(long instant) {
+        return getWrappedField().isLeap(instant);
+    }
+
+    public int getLeapAmount(long instant) {
+        return getWrappedField().getLeapAmount(instant);
+    }
+
+    public DurationField getLeapDurationField() {
+        return getWrappedField().getLeapDurationField();
+    }
+
+    public long roundFloor(long instant) {
+        checkBounds(instant, null);
+        long result = getWrappedField().roundFloor(instant);
+        checkBounds(result, "resulting");
+        return result;
+    }
+
+    public long roundCeiling(long instant) {
+        checkBounds(instant, null);
+        long result = getWrappedField().roundCeiling(instant);
+        checkBounds(result, "resulting");
+        return result;
+    }
+
+    public long roundHalfFloor(long instant) {
+        checkBounds(instant, null);
+        long result = getWrappedField().roundHalfFloor(instant);
+        checkBounds(result, "resulting");
+        return result;
+    }
+
+    public long roundHalfCeiling(long instant) {
+        checkBounds(instant, null);
+        long result = getWrappedField().roundHalfCeiling(instant);
+        checkBounds(result, "resulting");
+        return result;
+    }
+
+    public long roundHalfEven(long instant) {
+        checkBounds(instant, null);
+        long result = getWrappedField().roundHalfEven(instant);
+        checkBounds(result, "resulting");
+        return result;
+    }
+
+    public long remainder(long instant) {
+        checkBounds(instant, null);
+        long result = getWrappedField().remainder(instant);
+        checkBounds(result, "resulting");
+        return result;
+    }
+
+    /**
+     * Returns the milliseconds lower bound.
+     * 
+     * @return lower bound
+     */
+    public long getLowerBound() {
+        return iLowerBound;
+    }
+
+    /**
+     * Returns the milliseconds upper bound.
+     * 
+     * @return upper bound
+     */
+    public long getUpperBound() {
+        return iUpperBound;
+    }
+
+    private void checkBounds(long instant, String desc) {
+        if (instant < iLowerBound) {
+            throw new BoundsException(desc, true);
+        } else if (instant > iUpperBound) {
+            throw new BoundsException(desc, false);
+        }
+    }
+
+    /**
+     * Extends IllegalArgumentException such that the exception message is not
+     * generated unless it is actually requested.
+     */
+    private static class BoundsException extends IllegalArgumentException {
+        private final boolean iIsLow;
+
+        BoundsException(String desc, boolean isLow) {
+            super(desc);
+            iIsLow = isLow;
+        }
+
+        public String getMessage() {
+            StringBuffer buf = new StringBuffer(85);
+            buf.append("The");
+            String desc = super.getMessage();
+            if (desc != null) {
+                buf.append(' ');
+                buf.append(desc);
+            }
+            buf.append(" instant is ");
+            if (iIsLow) {
+                buf.append("below the supported minimum of ");
+            } else {
+                buf.append("above the supported maximum of ");
+            }
+            buf.append("TODO");
+            return buf.toString();
+        }
+
+        public String toString() {
+            return "IllegalArgumentException: " + getMessage();
+        }
+    }
+
+}
diff --git a/JodaTime/src/java/org/joda/time/chrono/MillisDurationField.java b/JodaTime/src/java/org/joda/time/field/MillisDurationField.java
similarity index 96%
rename from JodaTime/src/java/org/joda/time/chrono/MillisDurationField.java
rename to JodaTime/src/java/org/joda/time/field/MillisDurationField.java
index 438c219ca..851af285b 100644
--- a/JodaTime/src/java/org/joda/time/chrono/MillisDurationField.java
+++ b/JodaTime/src/java/org/joda/time/field/MillisDurationField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono;
+package org.joda.time.field;
 
 import java.io.Serializable;
 import org.joda.time.DurationField;
@@ -105,7 +105,7 @@ public final long getUnitMillis() {
 
     //------------------------------------------------------------------------
     public int getValue(long duration) {
-        return Utils.safeToInt(duration);
+        return FieldUtils.safeToInt(duration);
     }
 
     public long getValueAsLong(long duration) {
@@ -113,7 +113,7 @@ public long getValueAsLong(long duration) {
     }
 
     public int getValue(long duration, long instant) {
-        return Utils.safeToInt(duration);
+        return FieldUtils.safeToInt(duration);
     }
 
     public long getValueAsLong(long duration, long instant) {
@@ -145,7 +145,7 @@ public long add(long instant, long value) {
     }
 
     public int getDifference(long minuendInstant, long subtrahendInstant) {
-        return Utils.safeToInt(minuendInstant - subtrahendInstant);
+        return FieldUtils.safeToInt(minuendInstant - subtrahendInstant);
     }
 
     public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
diff --git a/JodaTime/src/java/org/joda/time/chrono/NonZeroDateTimeField.java b/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java
similarity index 98%
rename from JodaTime/src/java/org/joda/time/chrono/NonZeroDateTimeField.java
rename to JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java
index f083bb9ce..fdf4d6f3b 100644
--- a/JodaTime/src/java/org/joda/time/chrono/NonZeroDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/NonZeroDateTimeField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono;
+package org.joda.time.field;
 
 import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
@@ -111,7 +111,7 @@ public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
 
     public long set(long instant, int value) {
         int max = getMaximumValue();
-        Utils.verifyValueBounds(this, value, 1, max);
+        FieldUtils.verifyValueBounds(this, value, 1, max);
         if (value == max) {
             value = 0;
         }
diff --git a/JodaTime/src/java/org/joda/time/chrono/OffsetDateTimeField.java b/JodaTime/src/java/org/joda/time/field/OffsetDateTimeField.java
similarity index 96%
rename from JodaTime/src/java/org/joda/time/chrono/OffsetDateTimeField.java
rename to JodaTime/src/java/org/joda/time/field/OffsetDateTimeField.java
index adf65d49b..9b997fd77 100644
--- a/JodaTime/src/java/org/joda/time/chrono/OffsetDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/OffsetDateTimeField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono;
+package org.joda.time.field;
 
 import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
@@ -136,7 +136,7 @@ public int get(long instant) {
      */
     public long add(long instant, int amount) {
         instant = super.add(instant, amount);
-        Utils.verifyValueBounds(this, get(instant), iMin, iMax);
+        FieldUtils.verifyValueBounds(this, get(instant), iMin, iMax);
         return instant;
     }
 
@@ -150,7 +150,7 @@ public long add(long instant, int amount) {
      */
     public long add(long instant, long amount) {
         instant = super.add(instant, amount);
-        Utils.verifyValueBounds(this, get(instant), iMin, iMax);
+        FieldUtils.verifyValueBounds(this, get(instant), iMin, iMax);
         return instant;
     }
 
@@ -163,7 +163,7 @@ public long add(long instant, long amount) {
      * @return the updated time instant.
      */
     public long addWrapped(long instant, int amount) {
-        return set(instant, Utils.getWrappedValue(get(instant), amount, iMin, iMax));
+        return set(instant, FieldUtils.getWrappedValue(get(instant), amount, iMin, iMax));
     }
 
     /**
@@ -175,7 +175,7 @@ public long addWrapped(long instant, int amount) {
      * @throws IllegalArgumentException if value is too large or too small.
      */
     public long set(long instant, int value) {
-        Utils.verifyValueBounds(this, value, iMin, iMax);
+        FieldUtils.verifyValueBounds(this, value, iMin, iMax);
         return super.set(instant, value - iOffset);
     }
 
diff --git a/JodaTime/src/java/org/joda/time/chrono/PreciseDateTimeField.java b/JodaTime/src/java/org/joda/time/field/PreciseDateTimeField.java
similarity index 97%
rename from JodaTime/src/java/org/joda/time/chrono/PreciseDateTimeField.java
rename to JodaTime/src/java/org/joda/time/field/PreciseDateTimeField.java
index 0b4c4c086..31ae3023b 100644
--- a/JodaTime/src/java/org/joda/time/chrono/PreciseDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/PreciseDateTimeField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono;
+package org.joda.time.field;
 
 import org.joda.time.DurationField;
 
@@ -130,7 +130,7 @@ public int get(long instant) {
      */
     public long addWrapped(long instant, int amount) {
         int thisValue = get(instant);
-        int wrappedValue = Utils.getWrappedValue
+        int wrappedValue = FieldUtils.getWrappedValue
             (thisValue, amount, getMinimumValue(), getMaximumValue());
         // copy code from set() to avoid repeat call to get()
         return instant + (wrappedValue - thisValue) * getUnitMillis();
@@ -145,7 +145,7 @@ public long addWrapped(long instant, int amount) {
      * @throws IllegalArgumentException if value is too large or too small.
      */
     public long set(long instant, int value) {
-        Utils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValue());
+        FieldUtils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValue());
         return instant + (value - get(instant)) * iUnitMillis;
     }
 
diff --git a/JodaTime/src/java/org/joda/time/chrono/PreciseDurationDateTimeField.java b/JodaTime/src/java/org/joda/time/field/PreciseDurationDateTimeField.java
similarity index 96%
rename from JodaTime/src/java/org/joda/time/chrono/PreciseDurationDateTimeField.java
rename to JodaTime/src/java/org/joda/time/field/PreciseDurationDateTimeField.java
index aa9cbe4dc..fa804a770 100644
--- a/JodaTime/src/java/org/joda/time/chrono/PreciseDurationDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/PreciseDurationDateTimeField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono;
+package org.joda.time.field;
 
 import org.joda.time.DurationField;
 
@@ -127,7 +127,7 @@ public long add(long instant, long amount) {
     }
 
     public int getDifference(long minuendInstant, long subtrahendInstant) {
-        return Utils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));
+        return FieldUtils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));
     }
 
     public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
@@ -143,8 +143,8 @@ public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
      * @throws IllegalArgumentException if value is too large or too small.
      */
     public long set(long instant, int value) {
-        Utils.verifyValueBounds(this, value, getMinimumValue(),
-                                getMaximumValueForSet(instant, value));
+        FieldUtils.verifyValueBounds(this, value, getMinimumValue(),
+                                     getMaximumValueForSet(instant, value));
         return instant + (value - get(instant)) * iUnitMillis;
     }
 
diff --git a/JodaTime/src/java/org/joda/time/chrono/PreciseDurationField.java b/JodaTime/src/java/org/joda/time/field/PreciseDurationField.java
similarity index 99%
rename from JodaTime/src/java/org/joda/time/chrono/PreciseDurationField.java
rename to JodaTime/src/java/org/joda/time/field/PreciseDurationField.java
index 893537910..7e736f34e 100644
--- a/JodaTime/src/java/org/joda/time/chrono/PreciseDurationField.java
+++ b/JodaTime/src/java/org/joda/time/field/PreciseDurationField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono;
+package org.joda.time.field;
 
 /**
  * Duration field class representing a field with a fixed unit length.
diff --git a/JodaTime/src/java/org/joda/time/chrono/RemainderDateTimeField.java b/JodaTime/src/java/org/joda/time/field/RemainderDateTimeField.java
similarity index 97%
rename from JodaTime/src/java/org/joda/time/chrono/RemainderDateTimeField.java
rename to JodaTime/src/java/org/joda/time/field/RemainderDateTimeField.java
index 62d499ba6..efee8d77b 100644
--- a/JodaTime/src/java/org/joda/time/chrono/RemainderDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/RemainderDateTimeField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono;
+package org.joda.time.field;
 
 import org.joda.time.DateTimeField;
 import org.joda.time.DurationField;
@@ -141,7 +141,7 @@ public int get(long instant) {
      * @return the updated time instant.
      */
     public long addWrapped(long instant, int amount) {
-        return set(instant, Utils.getWrappedValue(get(instant), amount, 0, iDivisor - 1));
+        return set(instant, FieldUtils.getWrappedValue(get(instant), amount, 0, iDivisor - 1));
     }
 
     /**
@@ -153,7 +153,7 @@ public long addWrapped(long instant, int amount) {
      * @throws IllegalArgumentException if value is too large or too small.
      */
     public long set(long instant, int value) {
-        Utils.verifyValueBounds(this, value, 0, iDivisor - 1);
+        FieldUtils.verifyValueBounds(this, value, 0, iDivisor - 1);
         int divided = getDivided(getWrappedField().get(instant));
         return getWrappedField().set(instant, divided * iDivisor + value);
     }
diff --git a/JodaTime/src/java/org/joda/time/chrono/ScaledDurationField.java b/JodaTime/src/java/org/joda/time/field/ScaledDurationField.java
similarity index 99%
rename from JodaTime/src/java/org/joda/time/chrono/ScaledDurationField.java
rename to JodaTime/src/java/org/joda/time/field/ScaledDurationField.java
index fc9f3628c..db52dc1a9 100644
--- a/JodaTime/src/java/org/joda/time/chrono/ScaledDurationField.java
+++ b/JodaTime/src/java/org/joda/time/field/ScaledDurationField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono;
+package org.joda.time.field;
 
 import org.joda.time.DurationField;
 
diff --git a/JodaTime/src/java/org/joda/time/chrono/StrictDateTimeField.java b/JodaTime/src/java/org/joda/time/field/StrictDateTimeField.java
similarity index 97%
rename from JodaTime/src/java/org/joda/time/chrono/StrictDateTimeField.java
rename to JodaTime/src/java/org/joda/time/field/StrictDateTimeField.java
index 1047b0b9b..15e50ea34 100644
--- a/JodaTime/src/java/org/joda/time/chrono/StrictDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/StrictDateTimeField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono;
+package org.joda.time.field;
 
 import org.joda.time.DateTimeField;
 
@@ -62,6 +62,7 @@
  * StrictDateTimeField is thread-safe and immutable.
  *
  * @author Brian S O'Neill
+ * @see org.joda.time.chrono.StrictChronology
  * @see LenientDateTimeField
  */
 public class StrictDateTimeField extends DelegatedDateTimeField {
@@ -100,7 +101,7 @@ public final boolean isLenient() {
      * @throws IllegalArgumentException if the value is invalid
      */
     public long set(long instant, int value) {
-        Utils.verifyValueBounds
+        FieldUtils.verifyValueBounds
             (this, value, getMinimumValue(instant), getMaximumValue(instant));
         return super.set(instant, value);
     }
diff --git a/JodaTime/src/java/org/joda/time/chrono/UnsupportedDateTimeField.java b/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
similarity index 99%
rename from JodaTime/src/java/org/joda/time/chrono/UnsupportedDateTimeField.java
rename to JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
index b270d8149..d00055b9d 100644
--- a/JodaTime/src/java/org/joda/time/chrono/UnsupportedDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/field/UnsupportedDateTimeField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono;
+package org.joda.time.field;
 
 import java.io.Serializable;
 import java.util.HashMap;
diff --git a/JodaTime/src/java/org/joda/time/chrono/UnsupportedDurationField.java b/JodaTime/src/java/org/joda/time/field/UnsupportedDurationField.java
similarity index 99%
rename from JodaTime/src/java/org/joda/time/chrono/UnsupportedDurationField.java
rename to JodaTime/src/java/org/joda/time/field/UnsupportedDurationField.java
index 0ba23788a..88f66b7d9 100644
--- a/JodaTime/src/java/org/joda/time/chrono/UnsupportedDurationField.java
+++ b/JodaTime/src/java/org/joda/time/field/UnsupportedDurationField.java
@@ -51,7 +51,7 @@
  * created by Stephen Colebourne <scolebourne@joda.org>. For more
  * information on the Joda project, please see <http://www.joda.org/>.
  */
-package org.joda.time.chrono;
+package org.joda.time.field;
 
 import java.io.Serializable;
 import java.util.HashMap;
diff --git a/JodaTime/src/java/org/joda/time/chrono/buddhist/package.html b/JodaTime/src/java/org/joda/time/field/package.html
similarity index 86%
rename from JodaTime/src/java/org/joda/time/chrono/buddhist/package.html
rename to JodaTime/src/java/org/joda/time/field/package.html
index eacc09fcb..39a43bdf8 100644
--- a/JodaTime/src/java/org/joda/time/chrono/buddhist/package.html
+++ b/JodaTime/src/java/org/joda/time/field/package.html
@@ -1,13 +1,13 @@
 <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
 <html>
 <head>
-<title>org.joda.time.chrono.buddhist package</title>
+<title>org.joda.time.field package</title>
 <!--
 
    Joda Software License, Version 1.0
   
   
-   Copyright (c) 2001-03 Stephen Colebourne.
+   Copyright (c) 2001-2004 Stephen Colebourne.
    All rights reserved.
   
    Redistribution and use in source and binary forms, with or without
@@ -60,11 +60,7 @@
 </head>
 <body>
 <p>
-Provides a Buddhist Chronology implementation. The Buddhist calendar defines
-one era (BE) that runs 543 years out of sync with the Gregorian Julian
-calendar. In all other aspects the chronology follows the GJChronology. For
-example, the cutover date is the same as the default GJ cutover date.
+Provides DateTimeField and DurationField implementaions and support.
 </p>
 </body>
 </html>
-
diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java b/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java
index 775777710..6baac60df 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormat.java
@@ -68,8 +68,8 @@
 import org.joda.time.MutableDateTime;
 import org.joda.time.ReadWritableInstant;
 import org.joda.time.ReadableInstant;
-import org.joda.time.chrono.RemainderDateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.field.RemainderDateTimeField;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * DateTimeFormat provides localized printing and parsing capabilities for all
diff --git a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
index c087757d3..3fea8b244 100644
--- a/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
+++ b/JodaTime/src/java/org/joda/time/format/DateTimeFormatterBuilder.java
@@ -62,9 +62,9 @@
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeZone;
-import org.joda.time.chrono.MillisDurationField;
-import org.joda.time.chrono.PreciseDateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.field.MillisDurationField;
+import org.joda.time.field.PreciseDateTimeField;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * DateTimeFormatterBuilder is used for constructing {@link DateTimeFormatter}s.
diff --git a/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
index d4ffffdde..140f0f9a1 100644
--- a/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
+++ b/JodaTime/src/java/org/joda/time/format/ISODateTimeFormat.java
@@ -58,7 +58,7 @@
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeZone;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * ISODateTimeFormat provides factory methods for the ISO8601 standard.
diff --git a/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java b/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java
index ec8cd1a47..98d653bb7 100644
--- a/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java
+++ b/JodaTime/src/java/org/joda/time/tz/DateTimeZoneBuilder.java
@@ -68,7 +68,7 @@
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeZone;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * DateTimeZoneBuilder allows complex DateTimeZones to be constructed. Since
diff --git a/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java b/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java
index d824d90d4..b6cfbef67 100644
--- a/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java
+++ b/JodaTime/src/java/org/joda/time/tz/ZoneInfoCompiler.java
@@ -80,7 +80,7 @@
 import org.joda.time.format.DateTimeParser;
 import org.joda.time.format.ISODateTimeFormat;
 import org.joda.time.chrono.LenientChronology;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * Compiles Olson ZoneInfo database files into binary files for each time zone
@@ -98,7 +98,9 @@
  * @author Brian S O'Neill
  */
 public class ZoneInfoCompiler {
-    static final DateTimeOfYear START_OF_YEAR = new DateTimeOfYear();
+    static DateTimeOfYear cStartOfYear;
+
+    static Chronology cLenientISO;
 
     /**
      * Launches the ZoneInfoCompiler tool.
@@ -159,6 +161,20 @@ private static void printUsage() {
         System.out.println("  -dst <directory>    Specify where to write generated files");
     }
 
+    static DateTimeOfYear getStartOfYear() {
+        if (cStartOfYear == null) {
+            cStartOfYear = new DateTimeOfYear();
+        }
+        return cStartOfYear;
+    }
+
+    static Chronology getLenientISOChronology() {
+        if (cLenientISO == null) {
+            cLenientISO = LenientChronology.getInstance(ISOChronology.getInstanceUTC());
+        }
+        return cLenientISO;
+    }
+
     /**
      * @param zimap maps string ids to DateTimeZone objects.
      */
@@ -259,11 +275,10 @@ static String parseOptional(String str) {
     }
 
     static int parseTime(String str) {
-        Chronology chrono = new LenientChronology(ISOChronology.getInstanceUTC());
         DateTimeParser p = ISODateTimeFormat
-            .getInstance(chrono)
+            .getInstance(getLenientISOChronology())
             .hourMinuteSecondFraction();
-        MutableDateTime mdt = new MutableDateTime(0, chrono);
+        MutableDateTime mdt = new MutableDateTime(0, getLenientISOChronology());
         int pos = 0;
         if (str.startsWith("-")) {
             pos = 1;
@@ -768,7 +783,7 @@ private Zone(String name, StringTokenizer st) {
             iFormat = st.nextToken().intern();
 
             int year = Integer.MAX_VALUE;
-            DateTimeOfYear dtOfYear = START_OF_YEAR;
+            DateTimeOfYear dtOfYear = getStartOfYear();
 
             if (st.hasMoreTokens()) {
                 year = Integer.parseInt(st.nextToken());
diff --git a/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeCommon.java b/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeCommon.java
index 69c81e7f8..a3b6f5ce8 100644
--- a/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeCommon.java
+++ b/JodaTime/src/test/org/joda/test/time/AbstractTestDateTimeCommon.java
@@ -61,8 +61,8 @@
 import org.joda.time.DateTimeZone;
 import org.joda.time.Instant;
 import org.joda.time.ReadableInstant;
-import org.joda.time.chrono.gj.GJChronology;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.GJChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test base class for
diff --git a/JodaTime/src/test/org/joda/test/time/AbstractTestReadableInstant.java b/JodaTime/src/test/org/joda/test/time/AbstractTestReadableInstant.java
index 7b7e4b239..e02abddb2 100644
--- a/JodaTime/src/test/org/joda/test/time/AbstractTestReadableInstant.java
+++ b/JodaTime/src/test/org/joda/test/time/AbstractTestReadableInstant.java
@@ -67,7 +67,7 @@
 import org.joda.time.DateTimeZone;
 import org.joda.time.Instant;
 import org.joda.time.ReadableInstant;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 /**
  * This class is a Junit unit test base class for
  * ReadableInstant implementations.
diff --git a/JodaTime/src/test/org/joda/test/time/BulkMDTTests.java b/JodaTime/src/test/org/joda/test/time/BulkMDTTests.java
index e3959aa63..e18e33c42 100644
--- a/JodaTime/src/test/org/joda/test/time/BulkMDTTests.java
+++ b/JodaTime/src/test/org/joda/test/time/BulkMDTTests.java
@@ -60,7 +60,7 @@
 import junit.framework.TestSuite;
 
 import org.joda.time.*;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 /**
  * This class is a Junit unit test for the
  * org.joda.time.MutableDateTime class.
diff --git a/JodaTime/src/test/org/joda/test/time/BulkTest.java b/JodaTime/src/test/org/joda/test/time/BulkTest.java
index 0cdc56dcd..72320da4e 100644
--- a/JodaTime/src/test/org/joda/test/time/BulkTest.java
+++ b/JodaTime/src/test/org/joda/test/time/BulkTest.java
@@ -67,7 +67,7 @@
 import junit.framework.TestSuite;
 
 import org.joda.time.MutableDateTime;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 /**
  *  A {@link TestCase} that can define both simple and bulk test methods.<P>
  *
diff --git a/JodaTime/src/test/org/joda/test/time/TestBuddhistChronology.java b/JodaTime/src/test/org/joda/test/time/TestBuddhistChronology.java
index 6be12fb93..b9fc0e358 100644
--- a/JodaTime/src/test/org/joda/test/time/TestBuddhistChronology.java
+++ b/JodaTime/src/test/org/joda/test/time/TestBuddhistChronology.java
@@ -57,7 +57,7 @@
 
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeZone;
-import org.joda.time.chrono.buddhist.BuddhistChronology;
+import org.joda.time.chrono.BuddhistChronology;
 
 import junit.framework.TestSuite;
 /**
diff --git a/JodaTime/src/test/org/joda/test/time/TestDateTimeComparator.java b/JodaTime/src/test/org/joda/test/time/TestDateTimeComparator.java
index 937c35dc4..c615597df 100644
--- a/JodaTime/src/test/org/joda/test/time/TestDateTimeComparator.java
+++ b/JodaTime/src/test/org/joda/test/time/TestDateTimeComparator.java
@@ -67,7 +67,7 @@
 import org.joda.time.DateTimeComparator;
 import org.joda.time.DateTimeZone;
 import org.joda.time.ReadableInstant;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 /**
  * This class is a Junit unit test for the
  * org.joda.time.DateTimeComparator class.
diff --git a/JodaTime/src/test/org/joda/test/time/TestDateTimeCtors.java b/JodaTime/src/test/org/joda/test/time/TestDateTimeCtors.java
index efac6a57c..bf752af8b 100644
--- a/JodaTime/src/test/org/joda/test/time/TestDateTimeCtors.java
+++ b/JodaTime/src/test/org/joda/test/time/TestDateTimeCtors.java
@@ -58,8 +58,8 @@
 import org.joda.time.DateTime;
 import org.joda.time.DateTimeZone;
 import org.joda.time.ReadableInstant;
-import org.joda.time.chrono.gj.GJChronology;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.GJChronology;
+import org.joda.time.chrono.ISOChronology;
 /**
  * This class is a Junit unit test for the CTORs of the
  * DateTime date time class.  The DateTime class is passed
diff --git a/JodaTime/src/test/org/joda/test/time/TestMDTAdd.java b/JodaTime/src/test/org/joda/test/time/TestMDTAdd.java
index 850c50ba6..0dd0552bc 100644
--- a/JodaTime/src/test/org/joda/test/time/TestMDTAdd.java
+++ b/JodaTime/src/test/org/joda/test/time/TestMDTAdd.java
@@ -66,7 +66,7 @@
 import org.joda.time.Instant;
 import org.joda.time.MutableDateTime;
 import org.joda.time.ReadableInstant;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 /**
  * This class is a Junit unit test for the
  * org.joda.time.MutableDateTime class.
diff --git a/JodaTime/src/test/org/joda/test/time/TestMDTAddWrapped.java b/JodaTime/src/test/org/joda/test/time/TestMDTAddWrapped.java
index 694016cf1..22898807c 100644
--- a/JodaTime/src/test/org/joda/test/time/TestMDTAddWrapped.java
+++ b/JodaTime/src/test/org/joda/test/time/TestMDTAddWrapped.java
@@ -66,7 +66,7 @@
 import org.joda.time.Instant;
 import org.joda.time.MutableDateTime;
 import org.joda.time.ReadableInstant;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 /**
  * This class is a Junit unit test for the
  * org.joda.time.MutableDateTime class.
diff --git a/JodaTime/src/test/org/joda/test/time/TestMDTGet.java b/JodaTime/src/test/org/joda/test/time/TestMDTGet.java
index 8fe430b22..c63c4da96 100644
--- a/JodaTime/src/test/org/joda/test/time/TestMDTGet.java
+++ b/JodaTime/src/test/org/joda/test/time/TestMDTGet.java
@@ -65,7 +65,7 @@
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeConstants;
 import org.joda.time.MutableDateTime;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 /**
  * This class is a Junit unit test for the
  * org.joda.time.MutableDateTime class.
diff --git a/JodaTime/src/test/org/joda/test/time/TestMDTSet.java b/JodaTime/src/test/org/joda/test/time/TestMDTSet.java
index a9873568a..7f489526f 100644
--- a/JodaTime/src/test/org/joda/test/time/TestMDTSet.java
+++ b/JodaTime/src/test/org/joda/test/time/TestMDTSet.java
@@ -68,7 +68,7 @@
 import org.joda.time.Instant;
 import org.joda.time.MutableDateTime;
 import org.joda.time.ReadableInstant;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 /**
  * This class is a Junit unit test for the
  * org.joda.time.MutableDateTime class.
diff --git a/JodaTime/src/test/org/joda/test/time/TestMutableDateTime.java b/JodaTime/src/test/org/joda/test/time/TestMutableDateTime.java
index cf0baf413..15230ede4 100644
--- a/JodaTime/src/test/org/joda/test/time/TestMutableDateTime.java
+++ b/JodaTime/src/test/org/joda/test/time/TestMutableDateTime.java
@@ -63,7 +63,7 @@
 import junit.framework.TestSuite;
 
 import org.joda.time.MutableDateTime;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 /**
  * This class is a Junit unit test for the
  * org.joda.time.MutableDateTime class.
diff --git a/JodaTime/src/test/org/joda/test/time/TestMutableDateTimeCtors.java b/JodaTime/src/test/org/joda/test/time/TestMutableDateTimeCtors.java
index 57c17194e..b4eec7638 100644
--- a/JodaTime/src/test/org/joda/test/time/TestMutableDateTimeCtors.java
+++ b/JodaTime/src/test/org/joda/test/time/TestMutableDateTimeCtors.java
@@ -59,8 +59,8 @@
 import org.joda.time.DateTime;
 import org.joda.time.MutableDateTime;
 import org.joda.time.ReadableInstant;
-import org.joda.time.chrono.gj.GJChronology;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.GJChronology;
+import org.joda.time.chrono.ISOChronology;
 /**
  * This class is a Junit unit test for the CTORs of the
  * MutableDateTime date time class.  The MutableDateTime class is passed
diff --git a/JodaTime/src/test/org/joda/test/time/buddhist/TestBuddhistEraDateTimeField.java b/JodaTime/src/test/org/joda/test/time/buddhist/TestBuddhistEraDateTimeField.java
index f08d3fbb4..300658408 100644
--- a/JodaTime/src/test/org/joda/test/time/buddhist/TestBuddhistEraDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/buddhist/TestBuddhistEraDateTimeField.java
@@ -62,7 +62,7 @@
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.test.time.BulkTest;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.buddhist.BuddhistChronology;
+import org.joda.time.chrono.BuddhistChronology;
 /**
  * This class is the Junit unit test for a DateTimeField.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/Test.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/Test.java
index 66b80175c..8652a73f4 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/Test.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/Test.java
@@ -59,7 +59,8 @@
 import org.joda.time.DateTime;
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeZone;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GregorianChronology;
+import org.joda.time.chrono.JulianChronology;
 
 /**
  * Tests either the Julian or Gregorian chronology from org.joda.time.chrono.gj
@@ -203,10 +204,10 @@ public Test(int mode) {
         iMode = mode;
         if (mode == GREGORIAN_MODE) {
             iTest = new TestGregorianChronology();
-            iActual = GJChronology.getInstance(DateTimeZone.UTC, Long.MIN_VALUE, true);
+            iActual = GregorianChronology.getInstanceUTC();
         } else {
             iTest = new TestJulianChronology();
-            iActual = GJChronology.getInstance(DateTimeZone.UTC, Long.MAX_VALUE, true);
+            iActual = JulianChronology.getInstanceUTC();
         }
     }
 
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java
index a31f21972..eec544e9d 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJChronology.java
@@ -57,6 +57,7 @@
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeZone;
 import org.joda.time.DurationField;
+import org.joda.time.chrono.AbstractChronology;
 
 /**
  * A reference Gregorian/Julian chronology implementation, intended for testing
@@ -81,7 +82,7 @@
  *
  * @author Brian S O'Neill
  */
-abstract class TestGJChronology extends Chronology {
+abstract class TestGJChronology extends AbstractChronology {
     static final long MILLIS_PER_DAY = 24 * 60 * 60 * 1000;
 
     /**
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDateTimeField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDateTimeField.java
index a05509fdc..819e08a55 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestGJDateTimeField.java
@@ -53,8 +53,7 @@
  */
 package org.joda.test.time.chrono.gj;
 
-import org.joda.time.chrono.ImpreciseDateTimeField;
-import org.joda.time.chrono.Utils;
+import org.joda.time.field.ImpreciseDateTimeField;
 
 /**
  * 
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianWeekyearField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianWeekyearField.java
index d7e7ecd8a..13361cb19 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianWeekyearField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianWeekyearField.java
@@ -53,7 +53,7 @@
  */
 package org.joda.test.time.chrono.gj;
 
-import org.joda.time.chrono.Utils;
+import org.joda.time.field.FieldUtils;
 
 /**
  * 
@@ -66,14 +66,14 @@ public TestJulianWeekyearField(TestJulianChronology chrono) {
 
     public long addWrapped(long millis, int value) {
         int weekyear = get(millis);
-        int wrapped = Utils.getWrappedValue
+        int wrapped = FieldUtils.getWrappedValue
             (weekyear, value, getMinimumValue(), getMaximumValue());
         return add(millis, (long) wrapped - weekyear);
     }
 
     public long add(long millis, long value) {
         int weekyear = get(millis);
-        int newWeekyear = weekyear + Utils.safeToInt(value);
+        int newWeekyear = weekyear + FieldUtils.safeToInt(value);
         if (weekyear < 0) {
             if (newWeekyear >= 0) {
                 newWeekyear++;
diff --git a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianYearField.java b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianYearField.java
index 4ce54b6b1..616a2fa75 100644
--- a/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianYearField.java
+++ b/JodaTime/src/test/org/joda/test/time/chrono/gj/TestJulianYearField.java
@@ -53,7 +53,7 @@
  */
 package org.joda.test.time.chrono.gj;
 
-import org.joda.time.chrono.Utils;
+import org.joda.time.field.FieldUtils;
 
 /**
  * 
@@ -66,14 +66,14 @@ public TestJulianYearField(TestJulianChronology chrono) {
 
     public long addWrapped(long millis, int value) {
         int year = get(millis);
-        int wrapped = Utils.getWrappedValue
+        int wrapped = FieldUtils.getWrappedValue
             (year, value, getMinimumValue(), getMaximumValue());
         return add(millis, (long) wrapped - year);
     }
 
     public long add(long millis, long value) {
         int year = get(millis);
-        int newYear = year + Utils.safeToInt(value);
+        int newYear = year + FieldUtils.safeToInt(value);
         if (year < 0) {
             if (newYear >= 0) {
                 newYear++;
diff --git a/JodaTime/src/test/org/joda/test/time/gj/AbstractTestGJDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/AbstractTestGJDateTimeField.java
index ed3ff04c8..aa679f678 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/AbstractTestGJDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/AbstractTestGJDateTimeField.java
@@ -54,7 +54,7 @@
 package org.joda.test.time.gj;
 
 import org.joda.test.time.AbstractTestDateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
@@ -68,7 +68,7 @@ public AbstractTestGJDateTimeField(String name) {
     }
 
     static final int[] monthLengths = {-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
-    protected static final long GJ_CUTOVER_MILLIS = GJChronology.getInstanceUTC().getGregorianJulianCutoverMillis();
+    protected static final long GJ_CUTOVER_MILLIS = GJChronology.getInstanceUTC().getGregorianCutover().getMillis();
     
     protected int[] getDMYDS(long millis) {
         return getDMYDS(millis, GJ_CUTOVER_MILLIS, 1582, 10);
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfDayDateTimeField.java
index 895fa4e78..cf9b63d52 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfDayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfHalfdayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfHalfdayDateTimeField.java
index 2b097801b..a0c57ffd7 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfHalfdayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJClockhourOfHalfdayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfMonthDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfMonthDateTimeField.java
index 8de9c01be..f4c3c839c 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfMonthDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfMonthDateTimeField.java
@@ -56,7 +56,7 @@
 import junit.framework.TestSuite;
 
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfWeekDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfWeekDateTimeField.java
index 6d7f63426..c53307196 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfWeekDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfWeekDateTimeField.java
@@ -62,7 +62,7 @@
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfYearDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfYearDateTimeField.java
index 7482d8fd8..2d72b6bb8 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfYearDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJDayOfYearDateTimeField.java
@@ -56,7 +56,7 @@
 import junit.framework.TestSuite;
 
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJHalfdayOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJHalfdayOfDayDateTimeField.java
index debc0fa47..230a4bcb5 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJHalfdayOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJHalfdayOfDayDateTimeField.java
@@ -60,7 +60,7 @@
 
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfDayDateTimeField.java
index 21f275558..25620c1fb 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfDayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfHalfdayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfHalfdayDateTimeField.java
index 81de07d7b..0501304a4 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfHalfdayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJHourOfHalfdayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfDayDateTimeField.java
index b6a51a385..6f068a44e 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfDayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfSecondDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfSecondDateTimeField.java
index c2f6e4737..8bbe9d914 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfSecondDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJMillisOfSecondDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfDayDateTimeField.java
index 5d29af9e8..dada080f2 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfDayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfHourDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfHourDateTimeField.java
index da1b35960..2731d154f 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfHourDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJMinuteOfHourDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJMonthOfYearDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJMonthOfYearDateTimeField.java
index 9f9c5fb2e..005ceb987 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJMonthOfYearDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJMonthOfYearDateTimeField.java
@@ -59,7 +59,7 @@
 import junit.framework.TestSuite;
 
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfDayDateTimeField.java
index ef1922936..354e17077 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfDayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfMinuteDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfMinuteDateTimeField.java
index c52dacc80..56e82d387 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfMinuteDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJSecondOfMinuteDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJYearDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearDateTimeField.java
index 57f8ec27a..f6df1d41c 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJYearDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearDateTimeField.java
@@ -61,7 +61,7 @@
 import org.joda.time.DateTime;
 import org.joda.time.DateTimeField;
 import org.joda.time.Instant;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfCenturyDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfCenturyDateTimeField.java
index 1ca954b38..5e2a2daad 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfCenturyDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfCenturyDateTimeField.java
@@ -59,7 +59,7 @@
 
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfEraDateTimeField.java b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfEraDateTimeField.java
index dba4aa6fb..c9fcdb6ce 100644
--- a/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfEraDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/gj/TestGJYearOfEraDateTimeField.java
@@ -59,7 +59,7 @@
 
 import org.joda.test.time.AbstractTestDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.gj.GJChronology;
+import org.joda.time.chrono.GJChronology;
 /**
  * This class is a Junit unit test for the date time field.
  *
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfDayDateTimeField.java
index 90dea9538..75a9586df 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfDayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJClockhourOfDayDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfHalfdayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfHalfdayDateTimeField.java
index 29d3ac1a1..a9004c4c8 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfHalfdayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOClockhourOfHalfdayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJClockhourOfHalfdayDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfMonthDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfMonthDateTimeField.java
index 6a957da19..f043ced4c 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfMonthDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfMonthDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJDayOfMonthDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfWeekDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfWeekDateTimeField.java
index d1b5c4bd0..3f45f8396 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfWeekDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfWeekDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJDayOfWeekDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfYearDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfYearDateTimeField.java
index 2cc2cf8e4..83899df58 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfYearDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISODayOfYearDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJDayOfYearDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOHalfdayOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOHalfdayOfDayDateTimeField.java
index 2dc55c679..03252fb54 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOHalfdayOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOHalfdayOfDayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJHalfdayOfDayDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfDayDateTimeField.java
index a24e09e7e..2312c99ec 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfDayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJHourOfDayDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfHalfdayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfHalfdayDateTimeField.java
index 4ef344ba7..346fe3bbd 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfHalfdayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOHourOfHalfdayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJHourOfHalfdayDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfDayDateTimeField.java
index 3228f438e..355fead46 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfDayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJMillisOfDayDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfSecondDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfSecondDateTimeField.java
index 45dd4abd1..fc13c2504 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfSecondDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOMillisOfSecondDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJMillisOfSecondDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfDayDateTimeField.java
index 7343ae898..0c3129526 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfDayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJMinuteOfDayDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfHourDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfHourDateTimeField.java
index 8ace19889..fda43a2e5 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfHourDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOMinuteOfHourDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJMinuteOfHourDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOMonthOfYearDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOMonthOfYearDateTimeField.java
index 000672de5..af940d68f 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOMonthOfYearDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOMonthOfYearDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJMonthOfYearDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfDayDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfDayDateTimeField.java
index 2088a6854..1dfabac6d 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfDayDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfDayDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJSecondOfDayDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.
diff --git a/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfMinuteDateTimeField.java b/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfMinuteDateTimeField.java
index fc8a02e12..d18acb19f 100644
--- a/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfMinuteDateTimeField.java
+++ b/JodaTime/src/test/org/joda/test/time/iso/TestISOSecondOfMinuteDateTimeField.java
@@ -57,7 +57,7 @@
 
 import org.joda.test.time.gj.TestGJSecondOfMinuteDateTimeField;
 import org.joda.time.DateTimeField;
-import org.joda.time.chrono.iso.ISOChronology;
+import org.joda.time.chrono.ISOChronology;
 
 /**
  * This class is a Junit unit test for the date time field.

From 936a1677eb60f09b4dbaa0f74d0056636b6baf24 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Thu, 29 Jan 2004 06:00:24 +0000
Subject: [PATCH 121/143] Re-calc year limits.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@126 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/chrono/GregorianChronology.java    | 2 +-
 JodaTime/src/java/org/joda/time/chrono/JulianChronology.java  | 4 ++--
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java b/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java
index d7654d69e..9429192ab 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java
@@ -249,7 +249,7 @@ int getMinYear() {
 
     int getMaxYear() {
         // The highest year that can be fully supported.
-        return 292278993;
+        return 292277023;
     }
 
     long getAverageMillisPerYear() {
diff --git a/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java b/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java
index 1c0fc4f38..c05796d79 100644
--- a/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java
@@ -249,12 +249,12 @@ long calculateFirstDayOfYearMillis(int year) {
 
     int getMinYear() {
         // The lowest year that can be fully supported.
-        return -292269053;
+        return -292269054;
     }
 
     int getMaxYear() {
         // The highest year that can be fully supported.
-        return 292272992;
+        return 292271022;
     }
 
     long getAverageMillisPerYear() {

From 4226539fec08b7f04da862fa23189bb407916550 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Thu, 29 Jan 2004 06:00:59 +0000
Subject: [PATCH 122/143] Need special rule for set.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@127 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../time/chrono/CopticMonthOfYearDateTimeField.java | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/JodaTime/src/java/org/joda/time/chrono/CopticMonthOfYearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/CopticMonthOfYearDateTimeField.java
index b7a7f0649..e941a76bc 100644
--- a/JodaTime/src/java/org/joda/time/chrono/CopticMonthOfYearDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/CopticMonthOfYearDateTimeField.java
@@ -53,6 +53,7 @@
  */
 package org.joda.time.chrono;
 
+import org.joda.time.DateTimeConstants;
 import org.joda.time.DurationField;
 import org.joda.time.field.PreciseDurationDateTimeField;
 
@@ -79,6 +80,18 @@ public int get(long instant) {
         return (iChronology.getDayOfYear(instant) - 1) / 30 + 1;
     }
 
+    public long set(long instant, int value) {
+        instant = super.set(instant, value);
+        if (value == 13) {
+            int day = iChronology.getDayOfYear(instant);
+            if (day < 30) {
+                // Move back a few days to the end of the 13th "month".
+                instant -= (long)DateTimeConstants.MILLIS_PER_DAY * day;
+            }
+        }
+        return instant;
+    }
+
     public DurationField getRangeDurationField() {
         return iChronology.years();
     }

From 3ec1eb7ff17a6b61975e8ea72930d1ed927d4191 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Thu, 29 Jan 2004 06:01:32 +0000
Subject: [PATCH 123/143] Require special year field.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@128 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../joda/time/chrono/CopticChronology.java    |   9 +-
 .../time/chrono/CopticYearDateTimeField.java  | 205 ++++++++++++++++++
 2 files changed, 211 insertions(+), 3 deletions(-)
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/CopticYearDateTimeField.java

diff --git a/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java
index 54cbd560a..e4c6d1276 100644
--- a/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java
@@ -248,13 +248,12 @@ long calculateFirstDayOfYearMillis(int year) {
 
     int getMinYear() {
         // The lowest year that can be fully supported.
-        return 1;
+        return -292269337;
     }
 
     int getMaxYear() {
         // The highest year that can be fully supported.
-        // TODO
-        return 292272992;
+        return 292271022;
     }
 
     long getAverageMillisPerYear() {
@@ -272,6 +271,10 @@ long getApproxMillisAtEpoch() {
     protected void assemble(Fields fields) {
         if (getBase() == null) {
             super.assemble(fields);
+
+            fields.year = new CopticYearDateTimeField(this);
+            fields.years = fields.year.getDurationField();
+
             // Coptic, like Julian, has no year zero.
             fields.year = new JulianChronology.NoYearZeroField(this, fields.year);
             fields.weekyear = new JulianChronology.NoWeekyearZeroField(this, fields.weekyear);
diff --git a/JodaTime/src/java/org/joda/time/chrono/CopticYearDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/CopticYearDateTimeField.java
new file mode 100644
index 000000000..4ba2c729d
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/CopticYearDateTimeField.java
@@ -0,0 +1,205 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.  
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:  
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally 
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import org.joda.time.DateTimeConstants;
+import org.joda.time.DurationField;
+import org.joda.time.field.ImpreciseDateTimeField;
+import org.joda.time.field.FieldUtils;
+
+/**
+ *
+ * @author Brian S O'Neill
+ * @since 1.0
+ */
+final class CopticYearDateTimeField extends ImpreciseDateTimeField {
+
+    static final long serialVersionUID = 8990199361773280783L;
+
+    private final AbstractGJChronology iChronology;
+
+    /**
+     * Restricted constructor
+     */
+    CopticYearDateTimeField(AbstractGJChronology chronology) {
+        super("year", "years", chronology.getAverageMillisPerYear());
+        iChronology = chronology;
+    }
+
+    public boolean isLenient() {
+        return false;
+    }
+
+    public int get(long instant) {
+        return iChronology.getYear(instant);
+    }
+
+    public long add(long instant, int years) {
+        if (years == 0) {
+            return instant;
+        }
+        return set(instant, get(instant) + years);
+    }
+
+    public long add(long instant, long years) {
+        return add(instant, FieldUtils.safeToInt(years));
+    }
+
+    public long addWrapped(long instant, int years) {
+        if (years == 0) {
+            return instant;
+        }
+        // Return newly calculated millis value
+        int thisYear = iChronology.getYear(instant);
+        int wrappedYear = FieldUtils.getWrappedValue
+            (thisYear, years, iChronology.getMinYear(), iChronology.getMaxYear());
+        return set(instant, wrappedYear);
+    }
+
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        if (minuendInstant < subtrahendInstant) {
+            return -getDifference(subtrahendInstant, minuendInstant);
+        }
+
+        int minuendYear = get(minuendInstant);
+        int subtrahendYear = get(subtrahendInstant);
+
+        // Inlined remainder method to avoid duplicate calls to get.
+        long minuendRem = minuendInstant - iChronology.getYearMillis(minuendYear);
+        long subtrahendRem = subtrahendInstant - iChronology.getYearMillis(subtrahendYear);
+
+        int difference = minuendYear - subtrahendYear;
+        if (minuendRem < subtrahendRem) {
+            difference--;
+        }
+        return difference;
+    }
+
+    public long set(long instant, int year) {
+        FieldUtils.verifyValueBounds
+            (this, year, iChronology.getMinYear(), iChronology.getMaxYear());
+
+		AbstractGJChronology chrono = iChronology;
+
+        int thisYear = chrono.getYear(instant);
+        int dayOfYear = chrono.getDayOfYear(instant, thisYear);
+        int millisOfDay = chrono.getMillisOfDay(instant);
+
+        if (dayOfYear > 365) {
+			// Current year is leap, and day is leap.
+			if (!chrono.isLeapYear(year)) {
+				// Moving to a non-leap year, leap day doesn't exist.
+				dayOfYear--;
+			}
+        }
+
+        instant = chrono.getYearMonthDayMillis(year, 1, dayOfYear);
+        instant += millisOfDay;
+
+        return instant;
+    }
+
+    public DurationField getRangeDurationField() {
+        return null;
+    }
+
+    public boolean isLeap(long instant) {
+        return iChronology.isLeapYear(get(instant));
+    }
+
+    public int getLeapAmount(long instant) {
+        if (iChronology.isLeapYear(get(instant))) {
+            return 1;
+        } else {
+            return 0;
+        }
+    }
+
+    public DurationField getLeapDurationField() {
+        return iChronology.days();
+    }
+
+    public int getMinimumValue() {
+        return iChronology.getMinYear();
+    }
+
+    public int getMaximumValue() {
+        return iChronology.getMaxYear();
+    }
+
+    public long roundFloor(long instant) {
+        return iChronology.getYearMillis(get(instant));
+    }
+
+    public long roundCeiling(long instant) {
+        int year = get(instant);
+        long yearStartMillis = iChronology.getYearMillis(year);
+        if (instant != yearStartMillis) {
+            // Bump up to start of next year.
+            instant = iChronology.getYearMillis(year + 1);
+        }
+        return instant;
+    }
+
+    public long remainder(long instant) {
+        return instant - roundFloor(instant);
+    }
+
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return iChronology.year();
+    }
+}

From 8045bc2a55d2c01211177423753d7a4902fc4f27 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 31 Jan 2004 17:12:05 +0000
Subject: [PATCH 124/143] Typo fix.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@129 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/field/package.html | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/JodaTime/src/java/org/joda/time/field/package.html b/JodaTime/src/java/org/joda/time/field/package.html
index 39a43bdf8..3337248e1 100644
--- a/JodaTime/src/java/org/joda/time/field/package.html
+++ b/JodaTime/src/java/org/joda/time/field/package.html
@@ -60,7 +60,7 @@
 </head>
 <body>
 <p>
-Provides DateTimeField and DurationField implementaions and support.
+Provides DateTimeField and DurationField implementations and support.
 </p>
 </body>
 </html>

From c448a40c2e2a5c992a60afd3015fe7e0d244c0fb Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 31 Jan 2004 17:12:39 +0000
Subject: [PATCH 125/143] Updated docs.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@130 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../joda/time/chrono/AbstractGJChronology.java    |  7 ++++++-
 .../org/joda/time/chrono/AssembledChronology.java |  3 +++
 .../org/joda/time/chrono/CopticChronology.java    | 14 +++++++++++++-
 .../java/org/joda/time/chrono/GJChronology.java   | 12 ++++++------
 .../org/joda/time/chrono/GregorianChronology.java | 13 +++++++++++++
 .../java/org/joda/time/chrono/ISOChronology.java  |  6 ++++++
 .../org/joda/time/chrono/JulianChronology.java    | 15 +++++++++++++++
 7 files changed, 62 insertions(+), 8 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java b/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java
index 1936c111b..68d19b3cd 100644
--- a/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java
@@ -70,7 +70,12 @@
 import org.joda.time.field.RemainderDateTimeField;
 
 /**
- *
+ * Base class for implementing chronologies based on Gregorian/Julian formulas.
+ * Most of the utility methods required by subclasses are package-private,
+ * reflecting the intention that they be defined in the same package.
+ * <p>
+ * AbstractGJChronology is thread-safe and immutable, and all subclasses must
+ * be as well.
  *
  * @author Stephen Colebourne
  * @author Brian S O'Neill
diff --git a/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java b/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java
index 27b8bb598..e2fc6d5a2 100644
--- a/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java
@@ -453,6 +453,9 @@ private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundE
         setFields();
     }
 
+    /**
+     * A container of fields used for assembling a chronology.
+     */
     public static final class Fields {
         public DurationField millis;
         public DurationField seconds;
diff --git a/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java
index e4c6d1276..8f64396b8 100644
--- a/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java
@@ -64,7 +64,19 @@
 import org.joda.time.field.PreciseDurationField;
 
 /**
- * 
+ * Implements a Coptic calendar system, which defines every fourth year as
+ * leap, much like the Julian calendar. The year is broken down into 12 months,
+ * each 30 days in length. An extra period at the end of the year is either 5
+ * or 6 days in length. In this implementation, it is considered a 13th month.
+ * <p>
+ * Year 1 in the Coptic calendar began on August 29, 284 CE (Julian), thus
+ * Coptic years do not begin at the same time as Julian years. This chronology
+ * is not proleptic, as it does not allow dates before the first Coptic year.
+ * <p>
+ * CopticChronology is thread-safe and immutable.
+ *
+ * @see <a href="http://en.wikipedia.org/wiki/Coptic_calendar">Wikipedia</a>
+ * @see JulianChronology
  *
  * @author Brian S O'Neill
  */
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJChronology.java b/JodaTime/src/java/org/joda/time/chrono/GJChronology.java
index 34946b825..b04263172 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJChronology.java
@@ -81,11 +81,11 @@
  * Gregorian calendar was first instituted, October 15, 1582.
  * <p>
  * Before this date, this chronology uses the proleptic Julian calendar
- * (proleptic means extending indefinitely). The Julian calendar has leap 
- * years every four years, whereas the Gregorian has special rules for 100 
- * and 400 years. A meaningful result will thus be obtained for all input 
- * values. However before March 1, 4 CE, Julian leap years were irregular,
- * and before 45 BCE there was no Julian calendar.
+ * (proleptic means extending indefinitely). The Julian calendar has leap years
+ * every four years, whereas the Gregorian has special rules for 100 and 400
+ * years. A meaningful result will thus be obtained for all input values.
+ * However before 8 CE, Julian leap years were irregular, and before 45 BCE
+ * there was no Julian calendar.
  * <p>
  * This chronology differs from {@link java.util.GregorianCalendar
  * java.util.GregorianCalendar} in that years in BCE are returned
@@ -95,7 +95,7 @@
  * The Julian calendar does not have a year zero, and so year -1 is followed by
  * year 1. If the Gregorian cutover date is specified at or before year -1
  * (Julian), year zero is defined. In other words, the proleptic Gregorian
- * chronology implemented by this class has a year zero.
+ * chronology used by this class has a year zero.
  * <p>
  * To create a pure proleptic Julian chronology, use {@link JulianChronology},
  * and to create a pure proleptic Gregorian chronology, use
diff --git a/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java b/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java
index 9429192ab..34f8411b5 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java
@@ -65,6 +65,19 @@
 import org.joda.time.field.RemainderDateTimeField;
 
 /**
+ * Implements a pure proleptic Gregorian calendar system, which defines every
+ * fourth year as leap, unless the year is divisible by 100 and not by 400.
+ * This improves upon the Julian calendar leap year rule.
+ * <p>
+ * Although the Gregorian calendar did not exist before 1582 CE, this
+ * chronology assumes it did, thus it is proleptic. This implementation also
+ * fixes the start of the year at January 1, and defines the year zero.
+ * <p>
+ * GregorianChronology is thread-safe and immutable.
+ *
+ * @see <a href="http://en.wikipedia.org/wiki/Gregorian_calendar">Wikipedia</a>
+ * @see JulianChronology
+ * @see GJChronology
  * 
  * @author Guy Allard
  * @author Stephen Colebourne
diff --git a/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java b/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java
index 2eb9af376..4bdf20715 100644
--- a/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java
@@ -71,6 +71,12 @@
  * does not define a field, but it can be determined (such as AM/PM)
  * it is included.
  * <p>
+ * With the exception of century related fields, ISOChronology is exactly the
+ * same as {@link GregorianChronology}. In this chronology, centuries and year
+ * of century are zero based. For CE years, the century is determined by
+ * dropping the last two digits of the year. The year of century is the value
+ * of the last two digits.
+ * <p>
  * ISOChronology is thread-safe and immutable.
  *
  * @author Stephen Colebourne
diff --git a/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java b/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java
index c05796d79..eac80313a 100644
--- a/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java
@@ -64,6 +64,21 @@
 import org.joda.time.field.FieldUtils;
 
 /**
+ * Implements a pure proleptic Julian calendar system, which defines every
+ * fourth year as leap. This implementation follows the leap year rule
+ * strictly, even for dates before 8 CE, where leap years were actually
+ * irregular. In the Julian calendar, year zero does not exist: 1 BCE is
+ * followed by 1 CE.
+ * <p>
+ * Although the Julian calendar did not exist before 45 BCE, this chronology
+ * assumes it did, thus it is proleptic. This implementation also fixes the
+ * start of the year at January 1.
+ * <p>
+ * JulianChronology is thread-safe and immutable.
+ *
+ * @see <a href="http://en.wikipedia.org/wiki/Julian_calendar">Wikipedia</a>
+ * @see GregorianChronology
+ * @see GJChronology
  *
  * @author Guy Allard
  * @author Brian S O'Neill

From da90591d6b565a3f5c50446c7801a47f9a5959e3 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 31 Jan 2004 17:27:19 +0000
Subject: [PATCH 126/143] Comment fix.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@131 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/field/FieldUtils.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/JodaTime/src/java/org/joda/time/field/FieldUtils.java b/JodaTime/src/java/org/joda/time/field/FieldUtils.java
index da3bdc75e..4064aa778 100644
--- a/JodaTime/src/java/org/joda/time/field/FieldUtils.java
+++ b/JodaTime/src/java/org/joda/time/field/FieldUtils.java
@@ -58,7 +58,7 @@
 /**
  * General utilities that don't fit elsewhere.
  * <p>
- * Utils is thread-safe and immutable.
+ * FieldUtils is thread-safe and immutable.
  *
  * @author Stephen Colebourne
  * @since 1.0

From 5d755a53fef5cbdc696b632d61c8e88845d5b599 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 1 Feb 2004 16:59:57 +0000
Subject: [PATCH 127/143] Include year bounds check in getDateOnlyMillis.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@132 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/chrono/AbstractGJChronology.java   | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java b/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java
index 68d19b3cd..1424f20d2 100644
--- a/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java
@@ -245,9 +245,11 @@ public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
             return base.getDateOnlyMillis(year, monthOfYear, dayOfMonth);
         }
 
+        FieldUtils.verifyValueBounds("year", year, getMinYear(), getMaxYear());
+        FieldUtils.verifyValueBounds("monthOfYear", monthOfYear, 1, 12);
+
         boolean isLeap = isLeapYear(year);
 
-        FieldUtils.verifyValueBounds("monthOfYear", monthOfYear, 1, 12);
         FieldUtils.verifyValueBounds("dayOfMonth", dayOfMonth, 1,
                                 (isLeap ? MAX_DAYS_PER_MONTH_ARRAY : MIN_DAYS_PER_MONTH_ARRAY)
                                 [monthOfYear - 1]);

From d7bc2156a97e10be86006abc2c92ac86fa8678f8 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 1 Feb 2004 17:00:49 +0000
Subject: [PATCH 128/143] Override implementation of getDateOnlyMillis.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@133 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../joda/time/chrono/CopticChronology.java    | 28 +++++++++++++++++++
 1 file changed, 28 insertions(+)

diff --git a/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java
index 8f64396b8..19e6e0e6c 100644
--- a/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java
@@ -61,6 +61,7 @@
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeZone;
 import org.joda.time.DurationField;
+import org.joda.time.field.FieldUtils;
 import org.joda.time.field.PreciseDurationField;
 
 /**
@@ -227,6 +228,33 @@ public Chronology withDateTimeZone(DateTimeZone zone) {
         return getInstance(zone);
     }
 
+    public long getDateOnlyMillis(int year, int monthOfYear, int dayOfMonth)
+        throws IllegalArgumentException
+    {
+        Chronology base;
+        if ((base = getBase()) != null) {
+            return base.getDateOnlyMillis(year, monthOfYear, dayOfMonth);
+        }
+
+        FieldUtils.verifyValueBounds("year", year, getMinYear(), getMaxYear());
+        FieldUtils.verifyValueBounds("monthOfYear", monthOfYear, 1, 13);
+
+        int dayLimit = (monthOfYear != 13) ? 30 : (isLeapYear(year) ? 6 : 5);
+        FieldUtils.verifyValueBounds("dayOfMonth", dayOfMonth, 1, dayLimit);
+
+        long instant = getYearMillis(year);
+
+        if (monthOfYear > 1) {
+            instant += (monthOfYear - 1) * 30L * DateTimeConstants.MILLIS_PER_DAY;
+        }
+
+        if (dayOfMonth != 1) {
+            instant += (dayOfMonth - 1) * (long)DateTimeConstants.MILLIS_PER_DAY;
+        }
+
+        return instant;
+    }
+
     boolean isLeapYear(int year) {
         return (year & 3) == 3;
     }

From 6c6142b2ef5f4444cbfe5ef931a28f79a9a9f2c9 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 7 Feb 2004 06:49:44 +0000
Subject: [PATCH 129/143] Fixed bug which caused getInstance to fail on second
 identical call.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@134 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/time/chrono/GJChronology.java    | 37 ++++++++++---------
 1 file changed, 20 insertions(+), 17 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/chrono/GJChronology.java b/JodaTime/src/java/org/joda/time/chrono/GJChronology.java
index b04263172..e23930747 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJChronology.java
@@ -252,8 +252,12 @@ public static synchronized GJChronology getInstance(DateTimeZone zone,
                  GregorianChronology.getInstance(zone, minDaysInFirstWeek),
                  cutoverInstant);
         } else {
-            chrono = getInstance(DateTimeZone.UTC, gregorianCutover, minDaysInFirstWeek);
-            chrono = new GJChronology(ZonedChronology.getInstance(chrono, zone));
+            chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);
+            chrono = new GJChronology
+                (ZonedChronology.getInstance(chrono, zone),
+                 chrono.iJulianChronology,
+                 chrono.iGregorianChronology,
+                 chrono.iCutoverInstant);
         }
 
         chronos.add(chrono);
@@ -303,8 +307,11 @@ private GJChronology(JulianChronology julian,
     /**
      * Called when applying a time zone.
      */
-    private GJChronology(Chronology base) {
-        super(base, null);
+    private GJChronology(Chronology base,
+                         JulianChronology julian,
+                         GregorianChronology gregorian,
+                         Instant cutoverInstant) {
+        super(base, new Object[] {julian, gregorian, cutoverInstant});
     }
 
     /**
@@ -434,11 +441,7 @@ public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
      * @return the cutover instant
      */
     public Instant getGregorianCutover() {
-        Instant cutover = iCutoverInstant;
-        if (cutover == null) {
-            iCutoverInstant = cutover = new Instant(iCutoverMillis);
-        }
-        return cutover;
+        return iCutoverInstant;
     }
 
     public final int getMinimumDaysInFirstWeek() {
@@ -477,10 +480,6 @@ public String toString() {
     }
 
     protected void assemble(Fields fields) {
-        if (getBase() != null) {
-            return;
-        }
-
         Object[] params = (Object[])getParam();
 
         JulianChronology julian = (JulianChronology)params[0];
@@ -488,14 +487,18 @@ protected void assemble(Fields fields) {
         Instant cutoverInstant = (Instant)params[2];
         iCutoverMillis = cutoverInstant.getMillis();
 
-        if (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {
-            throw new IllegalArgumentException();
-        }
-
         iJulianChronology = julian;
         iGregorianChronology = gregorian;
         iCutoverInstant = cutoverInstant;
 
+        if (getBase() != null) {
+            return;
+        }
+
+        if (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {
+            throw new IllegalArgumentException();
+        }
+
         // Compute difference between the chronologies at the cutover instant
         iGapDuration = iCutoverMillis - julianToGregorianByYear(iCutoverMillis);
 

From fdf7600f911eb39de8ed60a45c41652d2510c130 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Mon, 9 Feb 2004 05:41:00 +0000
Subject: [PATCH 130/143] Javadoc fixes.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@135 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/Chronology.java | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/Chronology.java b/JodaTime/src/java/org/joda/time/Chronology.java
index c97580e05..987c4609b 100644
--- a/JodaTime/src/java/org/joda/time/Chronology.java
+++ b/JodaTime/src/java/org/joda/time/Chronology.java
@@ -58,12 +58,12 @@
  * chronological calendar system. Various chronologies are supported by
  * subclasses including ISO and GregorianJulian.
  * <p>
- * This class defines a number of fields with names from the ISO8601 standard.
- * Chronology does not 'strongly' define these fields however, thus subclasses
- * are free to interpret the field names as they wish. For example, a week
- * could be defined as 10 days and a month as 40 days in a special
- * WeirdChronology implementation. Clearly the GJ and ISO implementations
- * provided use the field names as you would expect.
+ * This interface defines a number of fields with names from the ISO8601
+ * standard. Chronology does not 'strongly' define these fields however, thus
+ * implementations are free to interpret the field names as they wish. For
+ * example, a week could be defined as 10 days and a month as 40 days in a
+ * special WeirdChronology implementation. Clearly the GJ and ISO
+ * implementations provided use the field names as you would expect.
  * 
  * @see org.joda.time.chrono.ISOChronology
  * @see org.joda.time.chrono.GJChronology

From 6a3b134c6537407d3ebbff10f2f68a2b96bb21a9 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 14 Feb 2004 18:07:38 +0000
Subject: [PATCH 131/143] Removed API consistency item.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@136 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/ToDo.txt        | 9 ---------
 JodaTime/xdocs/tasks.xml | 1 -
 2 files changed, 10 deletions(-)

diff --git a/JodaTime/ToDo.txt b/JodaTime/ToDo.txt
index 12552fe81..2129faa5e 100644
--- a/JodaTime/ToDo.txt
+++ b/JodaTime/ToDo.txt
@@ -11,15 +11,6 @@ Tests:
  ...write tests to cover all functionality
  Ensure all tests pass!
 
-Consistency:
- Check API for design and naming consistency
- eg. withXxx() vs toXxx() vs asXxx vs toCopyXxx()
- 
- Chronology: withUTC(), withDateTimeZone()
- DurationType: withChronology()
- ReadableInstant: withChronology(), withDateTimeZone()
- DateTimeProperty: addToCopy(), setCopy(), ...
- 
 
 Ideas longer term
 -----------------
diff --git a/JodaTime/xdocs/tasks.xml b/JodaTime/xdocs/tasks.xml
index 1d4f9d712..0c777a446 100644
--- a/JodaTime/xdocs/tasks.xml
+++ b/JodaTime/xdocs/tasks.xml
@@ -16,7 +16,6 @@ The following tasks still need doing:
 </p>
 
 <ul>
-<li>API consistency</li>
 <li>Testing</li>
 <li>Release!</li>
 </ul>

From b1a61729ecc5bf60d3dc69fa7a50b06395b5748c Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 14 Feb 2004 18:08:15 +0000
Subject: [PATCH 132/143] Removed unused import.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@137 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java  | 1 -
 1 file changed, 1 deletion(-)

diff --git a/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java
index 2a84c4f18..799c60b50 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java
@@ -53,7 +53,6 @@
  */
 package org.joda.time.chrono;
 
-import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeField;
 import org.joda.time.field.DecoratedDateTimeField;
 import org.joda.time.field.FieldUtils;

From ab25e10c839a4dd700500ab7e88fdb4aae7862f0 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 14 Feb 2004 18:08:48 +0000
Subject: [PATCH 133/143] Fixed definition of ISO century related fields.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@138 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/time/chrono/ISOChronology.java   |   8 +-
 .../chrono/ISOYearOfEraDateTimeField.java     | 143 ++++++++++++++++++
 2 files changed, 147 insertions(+), 4 deletions(-)
 create mode 100644 JodaTime/src/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java

diff --git a/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java b/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java
index 4bdf20715..8aa829526 100644
--- a/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java
@@ -73,9 +73,9 @@
  * <p>
  * With the exception of century related fields, ISOChronology is exactly the
  * same as {@link GregorianChronology}. In this chronology, centuries and year
- * of century are zero based. For CE years, the century is determined by
- * dropping the last two digits of the year. The year of century is the value
- * of the last two digits.
+ * of century are zero based. For all years, the century is determined by
+ * dropping the last two digits of the year, ignoring sign. The year of century
+ * is the value of the last two year digits.
  * <p>
  * ISOChronology is thread-safe and immutable.
  *
@@ -204,7 +204,7 @@ protected void assemble(Fields fields) {
         if (getBase().getDateTimeZone() == DateTimeZone.UTC) {
             // Use zero based century and year of century.
             fields.centuryOfEra = new DividedDateTimeField
-                (fields.yearOfEra, "centuryOfEra", "centuries", 100);
+                (ISOYearOfEraDateTimeField.INSTANCE, "centuryOfEra", "centuries", 100);
             fields.yearOfCentury = new RemainderDateTimeField
                 ((DividedDateTimeField)fields.centuryOfEra, "yearOfCentury");
 
diff --git a/JodaTime/src/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java b/JodaTime/src/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java
new file mode 100644
index 000000000..6b5ca45a1
--- /dev/null
+++ b/JodaTime/src/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java
@@ -0,0 +1,143 @@
+/*
+ * Joda Software License, Version 1.0
+ *
+ *
+ * Copyright (c) 2001-2004 Stephen Colebourne.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Joda project (http://www.joda.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The name "Joda" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact licence@joda.org.
+ *
+ * 5. Products derived from this software may not be called "Joda",
+ *    nor may "Joda" appear in their name, without prior written
+ *    permission of the Joda project.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Joda project and was originally
+ * created by Stephen Colebourne <scolebourne@joda.org>. For more
+ * information on the Joda project, please see <http://www.joda.org/>.
+ */
+package org.joda.time.chrono;
+
+import org.joda.time.DateTimeField;
+import org.joda.time.field.DecoratedDateTimeField;
+import org.joda.time.field.FieldUtils;
+
+/**
+ * This field is not publicy exposed by ISOChronology, but rather it is used to
+ * build the yearOfCentury and centuryOfEra fields. It merely drops the sign of
+ * the year.
+ *
+ * @author Brian S O'Neill
+ * @see GJYearOfEraDateTimeField
+ */
+class ISOYearOfEraDateTimeField extends DecoratedDateTimeField {
+
+    static final long serialVersionUID = 7037524068969447317L;
+
+    /**
+     * Singleton instance
+     */
+    static final DateTimeField INSTANCE = new ISOYearOfEraDateTimeField();
+
+    /**
+     * Restricted constructor.
+     */
+    private ISOYearOfEraDateTimeField() {
+        super(GregorianChronology.getInstanceUTC().year(), "yearOfEra");
+    }
+
+    public int get(long instant) {
+        int year = getWrappedField().get(instant);
+        return year < 0 ? -year : year;
+    }
+
+    public long add(long instant, int years) {
+        return getWrappedField().add(instant, years);
+    }
+
+    public long add(long instant, long years) {
+        return getWrappedField().add(instant, years);
+    }
+
+    public long addWrapped(long instant, int years) {
+        return getWrappedField().addWrapped(instant, years);
+    }
+
+    public int getDifference(long minuendInstant, long subtrahendInstant) {
+        return getWrappedField().getDifference(minuendInstant, subtrahendInstant);
+    }
+
+    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
+        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant);
+    }
+
+    public long set(long instant, int year) {
+        FieldUtils.verifyValueBounds(this, year, 0, getMaximumValue());
+        if (getWrappedField().get(instant) < 0) {
+            year = -year;
+        }
+        return super.set(instant, year);
+    }
+
+    public int getMinimumValue() {
+        return 0;
+    }
+
+    public int getMaximumValue() {
+        return getWrappedField().getMaximumValue();
+    }
+
+    public long roundFloor(long instant) {
+        return getWrappedField().roundFloor(instant);
+    }
+
+    public long roundCeiling(long instant) {
+        return getWrappedField().roundCeiling(instant);
+    }
+
+    public long remainder(long instant) {
+        return getWrappedField().remainder(instant);
+    }
+
+    /**
+     * Serialization singleton
+     */
+    private Object readResolve() {
+        return INSTANCE;
+    }
+}

From 19faa83d816e017a7d4a34193a1c3654fcb4d0db Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 14 Feb 2004 18:09:32 +0000
Subject: [PATCH 134/143] no message

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@139 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/time/field/LimitDateTimeField.j  | 332 ------------------
 1 file changed, 332 deletions(-)
 delete mode 100644 JodaTime/src/java/org/joda/time/field/LimitDateTimeField.j

diff --git a/JodaTime/src/java/org/joda/time/field/LimitDateTimeField.j b/JodaTime/src/java/org/joda/time/field/LimitDateTimeField.j
deleted file mode 100644
index 7f5828dbc..000000000
--- a/JodaTime/src/java/org/joda/time/field/LimitDateTimeField.j
+++ /dev/null
@@ -1,332 +0,0 @@
-/*
- * Joda Software License, Version 1.0
- *
- *
- * Copyright (c) 2001-03 Stephen Colebourne.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. The end-user documentation included with the redistribution,
- *    if any, must include the following acknowledgment:
- *       "This product includes software developed by the
- *        Joda project (http://www.joda.org/)."
- *    Alternately, this acknowledgment may appear in the software itself,
- *    if and wherever such third-party acknowledgments normally appear.
- *
- * 4. The name "Joda" must not be used to endorse or promote products
- *    derived from this software without prior written permission. For
- *    written permission, please contact licence@joda.org.
- *
- * 5. Products derived from this software may not be called "Joda",
- *    nor may "Joda" appear in their name, without prior written
- *    permission of the Joda project.
- *
- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED.  IN NO EVENT SHALL THE JODA AUTHORS OR THE PROJECT
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * ====================================================================
- *
- * This software consists of voluntary contributions made by many
- * individuals on behalf of the Joda project and was originally
- * created by Stephen Colebourne <scolebourne@joda.org>. For more
- * information on the Joda project, please see <http://www.joda.org/>.
- */
-package org.joda.time.chrono;
-
-import java.util.Locale;
-
-import org.joda.time.DateTimeField;
-import org.joda.time.DurationField;
-
-/**
- * Generic limiting datetime field.
- * <p>
- * This DateTimeField allows specific millisecond boundaries to be applied 
- * to DateTimeFields.
- * <p>
- * LimitDateTimeField is thread-safe and immutable.
- *
- * @author Stephen Colebourne
- * @author Brian S O'Neill
- * @since 1.0
- */
-// TODO: Move delete this
-// TODO: Also consider ShiftedChronology, for supporting Coptic.
-public class LimitDateTimeField extends DecoratedDateTimeField {
-
-    static final long serialVersionUID = -4969295623151287856L;
-
-    /** The lower boundary in millis */
-    private final long iLowerBound;
-    /** The upper boundary in millis */
-    private final long iUpperBound;
-
-    /**
-     * Constructor
-     * 
-     * @param lowerBound  milliseconds to form the lower boundary inclusive
-     * @param upperBound  milliseconds to form the upper boundary inclusive
-     * @throws IllegalArgumentException if field is null or boundary is invalid
-     */
-    public LimitDateTimeField(DateTimeField field,
-                              long lowerBound, long upperBound) {
-        this(field, field.getName(), lowerBound, upperBound);
-    }
-
-    /**
-     * Constructor
-     * 
-     * @param name  short, descriptive name, like "secondOfMinute".
-     * @param lowerBound  milliseconds to form the lower boundary inclusive
-     * @param upperBound  milliseconds to form the upper boundary inclusive
-     * @throws IllegalArgumentException if field is null or boundary is invalid
-     */
-    public LimitDateTimeField(DateTimeField field, String name,
-                              long lowerBound, long upperBound) {
-        super(field, name);
-                
-        if (lowerBound >= upperBound) {
-            throw new IllegalArgumentException("The lowerBound must be less than the upperBound");
-        }
-        iLowerBound = lowerBound;
-        iUpperBound = upperBound;
-    }
-
-    /**
-     * Get the amount of fractional units from the specified time instant.
-     * 
-     * @param instant  the time instant in millis to query.
-     * @return the amount of fractional units extracted from the input.
-     */
-    public int get(long instant) {
-        checkBounds(instant, null);
-        return getWrappedField().get(instant);
-    }
-
-    public String getAsText(long instant, Locale locale) {
-        checkBounds(instant, null);
-        return getWrappedField().getAsText(instant, locale);
-    }
-
-    public String getAsShortText(long instant, Locale locale) {
-        checkBounds(instant, null);
-        return getWrappedField().getAsShortText(instant, locale);
-    }
-
-    /**
-     * Add the specified amount of fractional units to the specified time
-     * instant. The amount added may be negative.
-     * 
-     * @param instant  the time instant in millis to update.
-     * @param amount  the amount of fractional units to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long add(long instant, int amount) {
-        checkBounds(instant, null);
-        long result = getWrappedField().add(instant, amount);
-        checkBounds(result, "resulting");
-        return result;
-    }
-
-    /**
-     * Add the specified amount of fractional units to the specified time
-     * instant. The amount added may be negative.
-     * 
-     * @param instant  the time instant in millis to update.
-     * @param amount  the amount of fractional units to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long add(long instant, long amount) {
-        checkBounds(instant, null);
-        long result = getWrappedField().add(instant, amount);
-        System.out.println(result);
-        System.out.println(iLowerBound);
-        checkBounds(result, "resulting");
-        return result;
-    }
-
-    /**
-     * Add to the fractional component of the specified time instant,
-     * wrapping around within that component if necessary.
-     * 
-     * @param instant  the time instant in millis to update.
-     * @param amount  the amount of fractional units to add (can be negative).
-     * @return the updated time instant.
-     */
-    public long addWrapped(long instant, int amount) {
-        checkBounds(instant, null);
-        long result = getWrappedField().addWrapped(instant, amount);
-        checkBounds(result, "resulting");
-        return result;
-    }
-
-    public int getDifference(long minuendInstant, long subtrahendInstant) {
-        checkBounds(minuendInstant, "minuend");
-        checkBounds(subtrahendInstant, "subtrahend");
-        return getWrappedField().getDifference(minuendInstant, subtrahendInstant);
-    }
-
-    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {
-        checkBounds(minuendInstant, "minuend");
-        checkBounds(subtrahendInstant, "subtrahend");
-        return getWrappedField().getDifferenceAsLong(minuendInstant, subtrahendInstant);
-    }
-
-    /**
-     * Set the specified amount of fractional units to the specified time instant.
-     * 
-     * @param instant  the time instant in millis to update.
-     * @param value  value of fractional units to set.
-     * @return the updated time instant.
-     * @throws IllegalArgumentException if value is too large or too small.
-     */
-    public long set(long instant, int value) {
-        checkBounds(instant, null);
-        long result = getWrappedField().set(instant, value);
-        checkBounds(result, "resulting");
-        return result;
-    }
-
-    public long set(long instant, String text, Locale locale) {
-        checkBounds(instant, null);
-        long result = getWrappedField().set(instant, text, locale);
-        checkBounds(result, "resulting");
-        return result;
-    }
-
-    public boolean isLeap(long instant) {
-        return getWrappedField().isLeap(instant);
-    }
-
-    public int getLeapAmount(long instant) {
-        return getWrappedField().getLeapAmount(instant);
-    }
-
-    public DurationField getLeapDurationField() {
-        return getWrappedField().getLeapDurationField();
-    }
-
-    public long roundFloor(long instant) {
-        checkBounds(instant, null);
-        long result = getWrappedField().roundFloor(instant);
-        checkBounds(result, "resulting");
-        return result;
-    }
-
-    public long roundCeiling(long instant) {
-        checkBounds(instant, null);
-        long result = getWrappedField().roundCeiling(instant);
-        checkBounds(result, "resulting");
-        return result;
-    }
-
-    public long roundHalfFloor(long instant) {
-        checkBounds(instant, null);
-        long result = getWrappedField().roundHalfFloor(instant);
-        checkBounds(result, "resulting");
-        return result;
-    }
-
-    public long roundHalfCeiling(long instant) {
-        checkBounds(instant, null);
-        long result = getWrappedField().roundHalfCeiling(instant);
-        checkBounds(result, "resulting");
-        return result;
-    }
-
-    public long roundHalfEven(long instant) {
-        checkBounds(instant, null);
-        long result = getWrappedField().roundHalfEven(instant);
-        checkBounds(result, "resulting");
-        return result;
-    }
-
-    public long remainder(long instant) {
-        checkBounds(instant, null);
-        long result = getWrappedField().remainder(instant);
-        checkBounds(result, "resulting");
-        return result;
-    }
-
-    /**
-     * Returns the milliseconds lower bound.
-     * 
-     * @return lower bound
-     */
-    public long getLowerBound() {
-        return iLowerBound;
-    }
-
-    /**
-     * Returns the milliseconds upper bound.
-     * 
-     * @return upper bound
-     */
-    public long getUpperBound() {
-        return iUpperBound;
-    }
-
-    private void checkBounds(long instant, String desc) {
-        if (instant < iLowerBound) {
-            throw new BoundsException(desc, true);
-        } else if (instant > iUpperBound) {
-            throw new BoundsException(desc, false);
-        }
-    }
-
-    /**
-     * Extends IllegalArgumentException such that the exception message is not
-     * generated unless it is actually requested.
-     */
-    private static class BoundsException extends IllegalArgumentException {
-        private final boolean iIsLow;
-
-        BoundsException(String desc, boolean isLow) {
-            super(desc);
-            iIsLow = isLow;
-        }
-
-        public String getMessage() {
-            StringBuffer buf = new StringBuffer(85);
-            buf.append("The");
-            String desc = super.getMessage();
-            if (desc != null) {
-                buf.append(' ');
-                buf.append(desc);
-            }
-            buf.append(" instant is ");
-            if (iIsLow) {
-                buf.append("below the supported minimum of ");
-            } else {
-                buf.append("above the supported maximum of ");
-            }
-            buf.append("TODO");
-            return buf.toString();
-        }
-
-        public String toString() {
-            return "IllegalArgumentException: " + getMessage();
-        }
-    }
-
-}

From 3163e8b8ba280c76e3cc1d4e7c99c7168c0c045b Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 14 Feb 2004 18:11:14 +0000
Subject: [PATCH 135/143] Updates to century related fields and more.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@140 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/field.html | 350 +++++++++++++--------
 1 file changed, 215 insertions(+), 135 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/field.html b/JodaTime/src/java/org/joda/time/field.html
index 81c35de6a..292d0058d 100644
--- a/JodaTime/src/java/org/joda/time/field.html
+++ b/JodaTime/src/java/org/joda/time/field.html
@@ -12,7 +12,7 @@ <h3>DateTime fields</h3>
 These fields are expressed as <code>XxxOfYyy</code> where <code>Xxx</code> and <code>Yyy</code> are two date time units.
 <code>Yyy</code> will always be larger than <code>Xxx</code>.
 For example, <code>DayOfWeek</code> or <code>SecondOfMinute</code>.
-A side effect of this is that these fields cannot be negative.
+A side effect of this is that these field values cannot be negative.
 </p>
 <p>
 Certain fields extend over all time, and do not include the word 'Of' in their names.
@@ -21,8 +21,8 @@ <h3>DateTime fields</h3>
 <p>
 <p>
 The fields are explained in more detail below (for the GJChronology):
-<center>
-<table cols="3" border="1" width="500">
+<p>
+<table cols="3" border="1">
 <tr>
 <th>Name
 <th>Min value (GJ)
@@ -30,112 +30,116 @@ <h3>DateTime fields</h3>
 <th>Notes
 </tr><tr>
 <td><a href="#millisOfSecond">millisOfSecond</a>
-<td>0
-<td>999
+<td align="center">0
+<td align="center">999
 <td>&nbsp;</td>
 </tr><tr>
 <td><a href="#millisOfDay">millisOfDay</a>
-<td>0
-<td>86399999
+<td align="center">0
+<td align="center">86 399 999
 <td>&nbsp;</td>
 </tr><tr>
 <td><a href="#secondOfMinute">secondOfMinute</a>
-<td>0
-<td>59
+<td align="center">0
+<td align="center">59
 <td>&nbsp;</td>
 </tr><tr>
 <td><a href="#secondOfDay">secondOfDay</a>
-<td>0
-<td>86399
+<td align="center">0
+<td align="center">86 399
 <td>&nbsp;</td>
 </tr><tr>
 <td><a href="#minuteOfHour">minuteOfHour</a>
-<td>0
-<td>59
+<td align="center">0
+<td align="center">59
 <td>&nbsp;</td>
 </tr><tr>
 <td><a href="#minuteOfDay">minuteOfDay</a>
-<td>0
-<td>1439
+<td align="center">0
+<td align="center">1439
 <td>&nbsp;</td>
 </tr><tr>
 <td><a href="#hourOfDay">hourOfDay</a>
-<td>0
-<td>23
+<td align="center">0
+<td align="center">23
 <td>&nbsp;</td>
 </tr><tr>
 <td><a href="#hourOfHalfday">hourOfHalfday</a>
-<td>0
-<td>11
+<td align="center">0
+<td align="center">11
+<td>&nbsp;</td>
+</tr><tr>
+<td><a href="#hourOfDay">clockhourOfDay</a>
+<td align="center">1
+<td align="center">24
+<td>&nbsp;</td>
+</tr><tr>
+<td><a href="#hourOfHalfday">clockhourOfHalfday</a>
+<td align="center">1
+<td align="center">12
 <td>&nbsp;</td>
 </tr><tr>
 <td><a href="#halfdayOfDay">halfdayOfDay</a>
-<td>0 (AM)
-<td>1 (PM)
+<td align="center">0 (AM)
+<td align="center">1 (PM)
 <td>&nbsp;</td>
 </tr><tr>
 <td><a href="#dayOfWeek">dayOfWeek</a>
-<td>1 (Monday)
-<td>7 (Sunday)
+<td align="center">1 (Monday)
+<td align="center">7 (Sunday)
 <td>&nbsp;</td>
 </tr><tr>
 <td><a href="#weekOfWeekyear">weekOfWeekyear</a>
-<td>1
-<td>53
+<td align="center">1
+<td align="center">53
 <td>&nbsp;</td>
 </tr><tr>
 <td><a href="#weekyear">weekyear</a>
-<td>Unbounded negative
-<td>Unbounded
+<td align="center">-292 000 000
+<td align="center">292 000 000
 <td>&nbsp;</td>
 </tr><tr>
 <td><a href="#dayOfMonth">dayOfMonth</a>
-<td>1
-<td>31
+<td align="center">1
+<td align="center">31
 <td>&nbsp;</td>
 </tr><tr>
 <td><a href="#dayOfYear">dayOfYear</a>
-<td>1
-<td>366
+<td align="center">1
+<td align="center">366
 <td>&nbsp;</td>
 </tr><tr>
 <td><a href="#monthOfYear">monthOfYear</a>
-<td>1 (January)
-<td>12 (December)
+<td align="center">1 (January)
+<td align="center">12 (December)
 <td>&nbsp;</td>
 </tr><tr>
 <td><a href="#year">year</a>
-<td>Unbounded negative
-<td>Unbounded
+<td align="center">-292 000 000
+<td align="center">292 000 000
 <td>&nbsp;</td>
 </tr><tr>
-<td><a href="#year">yearOfCentury</a>
-<td>1
-<td>100
-<td>[1]</td>
-</tr><tr>
-<td><a href="#year">yearOfEra</a>
-<td>1
-<td>Unbounded
-<td>&nbsp;</td>
+<td><a href="#yearOfCentury">yearOfCentury</a>
+<td align="center">1
+<td align="center">100
+<td align="center">[1]</td>
 </tr><tr>
-<td><a href="#year">century</a>
-<td>Unbounded
-<td>Unbounded
+<td><a href="#yearOfEra">yearOfEra</a>
+<td align="center">1
+<td align="center">292 000 000
 <td>&nbsp;</td>
 </tr><tr>
-<td><a href="#year">centuryOfEra</a>
-<td>1
-<td>Unbounded
-<td>[2]</td>
+<td><a href="#centuryOfEra">centuryOfEra</a>
+<td align="center">1
+<td align="center">2 920 000
+<td align="center">[2]</td>
 </tr><tr>
-<td><a href="#year">era</a>
-<td>0 (BC/BCE)
-<td>1 (AD/CE)
+<td><a href="#era">era</a>
+<td align="center">0 (BC/BCE)
+<td align="center">1 (AD/CE)
 <td>&nbsp;</td>
 </tr>
 </table>
-</center>
 [1] For the ISOChronology, the year of century range is from 0 to 99.<br />
 [2] For the ISOChronology, the century of era range is from 0.<br />
 </p>
@@ -186,9 +190,23 @@ <h4>MinuteOfDay</h4>
 <a name="hourOfDay" />
 <h4>HourOfDay</h4>
 <p>
-The number of hours in the specified time once the day and larger parts are removed.
+The number of hours in the specified time once the day and larger parts are
+removed. The clockhour value represents midnight of the current day as 24
+instead of 0.
+</p>
+
+<a name="hourOfHalfday" />
+<h4>HourOfHalfday</h4>
+<p>
+The number of hours within the half day. The clockhour value represents
+midnight or noon of the current day as 12 instead of 0.
 </p>
 
+<a name="halfdayOfDay" />
+<h4>HalfdayOfDay</h4>
+<p>
+The AM/PM value of the day.
+</p>
 
 <a name="dayOfWeek" />
 <h4>DayOfWeek</h4>
@@ -253,98 +271,160 @@ <h4>MonthOfYear</h4>
 <a name="year" />
 <h4>Year</h4>
 <p>
-The year, using negative values to represent years in the previous era.
-The GJ chronology allows the behaviour of this field to be controlled for years before 1.
-The options are to either include or not include the year zero.
-The ISO chronology always includes the year zero.
+The year, using negative values to represent years in the previous era. For the
+GJ chronology, year zero is not included, unless the cutover to Gregorian is
+specified at or before 1 BCE. The ISO chronology always includes the year
+zero.
 </p>
 
-
-<a name="yearOfCentury" />
-<a name="century" />
 <a name="centuryOfEra" />
-<h4>YearOfCentury, Century and CenturyOfEra</h4>
+<a name="yearOfCentury" />
+<h4>CenturyOfEra and YearOfCentury</h4>
 <p>
 The definition of these varies by chronology:
 </p>
 <p>
-<table cols="9" border="1" width="650">
+<table border="1">
 <tr>
-<th colspan="3">Year
-<th colspan="3">GJ
-<th colspan="3">ISO
-</tr>
-<tr>
-<th>output
-<th>GJ no year 0
-<th>ISO/ GJ inc year 0
-<th>year of century
-<th>century
-<th>century of era
-<th>year of century
-<th>century
-<th>century of era
-
-</tr><tr>
-<td align="center">2BC
-<td align="center">-2
-<td align="center">-1
-<td align="center">99
-<td align="center">-1
-<td align="center">1
-<td align="center">99
-<td align="center">-1
-<td align="center">0
+<th></th>
+<th colspan="3">GJ</th>
+<th colspan="3">ISO</th>
 </tr><tr>
-<td align="center">1BC
-<td align="center">-1
-<td align="center">0
-<td align="center">100
-<td align="center">-1
-<td align="center">1
-<td align="center">0
-<td align="center">0
-<td align="center">0
+<th>&nbsp;year of era&nbsp;</th>
+<th>&nbsp;year&nbsp;</th>
+<th>&nbsp;century of era&nbsp;</th>
+<th>&nbsp;year of century&nbsp;</th>
+<th>&nbsp;year&nbsp;</th>
+<th>&nbsp;century of era&nbsp;</th>
+<th>&nbsp;year of century&nbsp;</th>
 </tr><tr>
-<td align="center">1AD
-<td align="center">1
-<td align="center">1
-<td align="center">1
-<td align="center">1
-<td align="center">1
-<td align="center">1
-<td align="center">0
-<td align="center">0
+<td align="center">101 BCE</td>
+<td align="center">-101</td>
+<td align="center">2</td>
+<td align="center">1</td>
+<td align="center">-100</td>
+<td align="center">1</td>
+<td align="center">0</td>
 </tr><tr>
-<td align="center">99AD
-<td align="center">99
-<td align="center">99
-<td align="center">99
-<td align="center">1
-<td align="center">1
-<td align="center">99
-<td align="center">0
-<td align="center">0
+<td align="center">100 BCE</td>
+<td align="center">-100</td>
+<td align="center">1</td>
+<td align="center">100</td>
+<td align="center">-99</td>
+<td align="center">0</td>
+<td align="center">99</td>
 </tr><tr>
-<td align="center">100AD
-<td align="center">100
-<td align="center">100
-<td align="center">100
-<td align="center">1
-<td align="center">1
-<td align="center">0
-<td align="center">1
-<td align="center">1
+<td align="center">99 BCE</td>
+<td align="center">-99</td>
+<td align="center">1</td>
+<td align="center">99</td>
+<td align="center">-98</td>
+<td align="center">0</td>
+<td align="center">98</td>
 </tr><tr>
-<td align="center">101AD
-<td align="center">101
-<td align="center">101
-<td align="center">1
-<td align="center">2
-<td align="center">2
-<td align="center">1
-<td align="center">1
-<td align="center">1
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+</tr><tr>
+<td align="center">2 BCE</td>
+<td align="center">-2</td>
+<td align="center">1</td>
+<td align="center">2</td>
+<td align="center">-1</td>
+<td align="center">0</td>
+<td align="center">1</td>
+</tr><tr>
+<td align="center">1 BCE</td>
+<td align="center">-1</td>
+<td align="center">1</td>
+<td align="center">1</td>
+<td align="center">0</td>
+<td align="center">0</td>
+<td align="center">0</td>
+</tr><tr>
+<td align="center">1 CE</td>
+<td align="center">1</td>
+<td align="center">1</td>
+<td align="center">1</td>
+<td align="center">1</td>
+<td align="center">0</td>
+<td align="center">1</td>
+</tr><tr>
+<td align="center">2 CE</td>
+<td align="center">2</td>
+<td align="center">1</td>
+<td align="center">2</td>
+<td align="center">2</td>
+<td align="center">0</td>
+<td align="center">2</td>
+</tr><tr>
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+</tr><tr>
+<td align="center">99 CE</td>
+<td align="center">99</td>
+<td align="center">1</td>
+<td align="center">99</td>
+<td align="center">99</td>
+<td align="center">0</td>
+<td align="center">99</td>
+</tr><tr>
+<td align="center">100 CE</td>
+<td align="center">100</td>
+<td align="center">1</td>
+<td align="center">100</td>
+<td align="center">100</td>
+<td align="center">1</td>
+<td align="center">0</td>
+</tr><tr>
+<td align="center">101 CE</td>
+<td align="center">101</td>
+<td align="center">2</td>
+<td align="center">1</td>
+<td align="center">101</td>
+<td align="center">1</td>
+<td align="center">1</td>
+</tr><tr>
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+</tr><tr>
+<td align="center">1999 CE</td>
+<td align="center">1999</td>
+<td align="center">20</td>
+<td align="center">99</td>
+<td align="center">1999</td>
+<td align="center">19</td>
+<td align="center">99</td>
+</tr><tr>
+<td align="center">2000 CE</td>
+<td align="center">2000</td>
+<td align="center">20</td>
+<td align="center">100</td>
+<td align="center">2000</td>
+<td align="center">20</td>
+<td align="center">0</td>
+</tr><tr>
+<td align="center">2001 CE</td>
+<td align="center">2001</td>
+<td align="center">21</td>
+<td align="center">1</td>
+<td align="center">2001</td>
+<td align="center">20</td>
+<td align="center">1</td>
 </tr>
 </table>
 

From 8f0e2f14ff4610926dca4e8e2dfbfc78b8dde424 Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sat, 14 Feb 2004 18:32:36 +0000
Subject: [PATCH 136/143] Updated getName docs.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@141 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/DateTimeField.java | 6 +++++-
 JodaTime/src/java/org/joda/time/DurationField.java | 3 ++-
 2 files changed, 7 insertions(+), 2 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/DateTimeField.java b/JodaTime/src/java/org/joda/time/DateTimeField.java
index 5e519e231..5cba084e0 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeField.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeField.java
@@ -71,7 +71,11 @@
 public interface DateTimeField {
 
     /**
-     * Get the name of the field.
+     * Get the name of the field, intended for debugging purposes only. By
+     * convention, names follow a pattern of "dddOfRrr", where "ddd" represents
+     * the (singular) duration field name and "Rrr" represents the (singular)
+     * range duration field name. If the range field is not applicable, then
+     * the name of the field is simply the (singular) duration field name.
      * 
      * @return field name
      */
diff --git a/JodaTime/src/java/org/joda/time/DurationField.java b/JodaTime/src/java/org/joda/time/DurationField.java
index 160e3905a..6fa859907 100644
--- a/JodaTime/src/java/org/joda/time/DurationField.java
+++ b/JodaTime/src/java/org/joda/time/DurationField.java
@@ -68,7 +68,8 @@
 public interface DurationField extends Comparable {
 
     /**
-     * Get the name of the field.
+     * Get the name of the field, intended for debugging purposes only. By
+     * convention, names are plural.
      * 
      * @return field name
      */

From 2caf6667982451b43b421193b92a22b1b62f756d Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 15 Feb 2004 13:41:18 +0000
Subject: [PATCH 137/143] Add link to fields

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@142 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/package.html | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/package.html b/JodaTime/src/java/org/joda/time/package.html
index 96b54870c..09532ed79 100644
--- a/JodaTime/src/java/org/joda/time/package.html
+++ b/JodaTime/src/java/org/joda/time/package.html
@@ -7,7 +7,7 @@
    Joda Software License, Version 1.0
   
   
-   Copyright (c) 2001-03 Stephen Colebourne.
+   Copyright (c) 2001-2004 Stephen Colebourne.
    All rights reserved.
   
    Redistribution and use in source and binary forms, with or without
@@ -163,9 +163,10 @@ <h4>User defined APIs</h4>
 
 <h4>Chronologies and Fields</h4>
 <p>
-In order to enable the package to be easily extended, each field of the
+In order to enable the package to be easily extended, each 
+<a href="field.html">field</a> of the
 datetime, such as the month, is calculated by an implementation of
-<code>DateTimeField</code>. Likewise, duration fields are calculated by
+<code>DateTimeField</code>). Likewise, duration fields are calculated by
 specialized <code>DurationField</code> instances. If desired, users can write
 their own implementations to retrieve an unusual field from the millisecond
 value.

From cdcbcfe055d32ad7b44f04d0ae59ceb8cbad2e28 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 15 Feb 2004 17:04:48 +0000
Subject: [PATCH 138/143] Improve JDK1.4 compliance

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@143 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/test/org/joda/test/time/TestParseISO.java  | 14 +++++++-------
 1 file changed, 7 insertions(+), 7 deletions(-)

diff --git a/JodaTime/src/test/org/joda/test/time/TestParseISO.java b/JodaTime/src/test/org/joda/test/time/TestParseISO.java
index 4d4447aba..cd172ee48 100644
--- a/JodaTime/src/test/org/joda/test/time/TestParseISO.java
+++ b/JodaTime/src/test/org/joda/test/time/TestParseISO.java
@@ -335,7 +335,7 @@ protected Matcher(String spec, String extended, String basic) {
         }
         
         protected abstract void run();
-        protected void assert() {
+        protected void assertDate() {
             String msg = "\nSpec:   " + spec + "\nParsed: " + extended + "\nTo:     " + dt;
             assertEquals(msg + "\nCentury: ", century, dt.getCenturyOfEra());
             assertEquals(msg + "\nYear: ", yearOfCentury, dt.getYearOfCentury());
@@ -383,7 +383,7 @@ protected DTMatcher(String spec, String extended, String basic,
         protected void run() {
             dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);
             parse(ISODateTimeFormat.getInstance().dateTimeParser());
-            super.assert();
+            super.assertDate();
         }
     }
     protected static class DMatcher extends Matcher {
@@ -403,11 +403,11 @@ protected DMatcher(String spec, String extended, String basic,
         protected void run() {
             dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);
             parse(ISODateTimeFormat.getInstance().dateParser());
-            super.assert();
+            super.assertDate();
         
             dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);
             parse(ISODateTimeFormat.getInstance().dateTimeParser());
-            super.assert();
+            super.assertDate();
         }
     }
     protected static class TMatcher extends Matcher {
@@ -427,16 +427,16 @@ protected TMatcher(String spec, String extended, String basic,
         protected void run() {
             dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);
             parse(ISODateTimeFormat.getInstance().timeParser());
-            super.assert();
+            super.assertDate();
             
             extended = "T" + extended;
             dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);
             parse(ISODateTimeFormat.getInstance().timeParser());
-            super.assert();
+            super.assertDate();
             
             dt = new MutableDateTime(1972, 12, 3, 10, 32, 40, 205);
             parse(ISODateTimeFormat.getInstance().dateTimeParser());
-            super.assert();
+            super.assertDate();
         }
     }
 }

From 157fe66cee9dfb4fde894ad1015fa16f7a54bed9 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 15 Feb 2004 18:35:04 +0000
Subject: [PATCH 139/143] Improve javadoc

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@144 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../org/joda/time/DateTimeComparator.java     |  88 ++--
 .../java/org/joda/time/DateTimeConstants.java |  49 +-
 .../time/chrono/AbstractGJChronology.java     |   5 +-
 .../joda/time/chrono/AssembledChronology.java |   4 +-
 .../joda/time/chrono/BuddhistChronology.java  |  10 +-
 .../joda/time/chrono/CopticChronology.java    |   6 +-
 .../org/joda/time/chrono/GJChronology.java    |  16 +-
 .../joda/time/chrono/GregorianChronology.java |   8 +-
 .../joda/time/chrono/JulianChronology.java    |   4 +-
 .../joda/time/chrono/LenientChronology.java   |   6 +-
 .../org/joda/time/chrono/LimitChronology.java |  15 +-
 .../joda/time/chrono/StrictChronology.java    |   6 +-
 .../org/joda/time/chrono/ZonedChronology.java |   7 +-
 .../joda/time/convert/ConverterManager.java   |   4 +-
 .../java/org/joda/time/convert/package.html   |   2 +-
 JodaTime/src/java/org/joda/time/field.html    | 457 ------------------
 .../src/java/org/joda/time/field/package.html |   2 +
 .../java/org/joda/time/format/package.html    |   2 +-
 JodaTime/src/java/org/joda/time/package.html  |   3 +-
 .../java/org/joda/time/property/package.html  |   2 +-
 .../src/java/org/joda/time/tz/package.html    |   2 +-
 21 files changed, 140 insertions(+), 558 deletions(-)
 delete mode 100644 JodaTime/src/java/org/joda/time/field.html

diff --git a/JodaTime/src/java/org/joda/time/DateTimeComparator.java b/JodaTime/src/java/org/joda/time/DateTimeComparator.java
index 93fd4d663..dd8108f09 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeComparator.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeComparator.java
@@ -55,17 +55,23 @@
 
 import java.io.Serializable;
 import java.util.Comparator;
+
 import org.joda.time.convert.ConverterManager;
 
 /**
- * DateTimeComparator is the standard implementation of the Comparator
- * interface for various Joda and Java objects. The following types
- * are supported for comparison:
+ * DateTimeComparator provides comparators to compare one date with another.
+ * <p>
+ * Dates may be specified using any object recognised by the
+ * {@link org.joda.time.convert.ConverterManager ConverterManager} class.
+ * <p>
+ * The default objects recognised by the comparator are:
  * <ul>
  * <li>ReadableInstant
- * <li>java.util.Date
- * <li>java.util.Calendar
- * <li>java.util.Long (milliseconds)
+ * <li>PartialInstant
+ * <li>String
+ * <li>Calendar
+ * <li>Date
+ * <li>Long (milliseconds)
  * </ul>
  *
  * <p>
@@ -78,10 +84,18 @@
  */
 public class DateTimeComparator implements Comparator, Serializable {
 
-    static final long serialVersionUID = -6097339773320178364L;
+    /** Serialization lock */
+    private static final long serialVersionUID = -6097339773320178364L;
 
+    /** Singleton instance */
     private static final DateTimeComparator INSTANCE = new DateTimeComparator(null, null);
 
+    /** The lower limit of fields to compare, null if no limit */
+    private final DateTimeField iLowerLimit;
+    /** The upper limit of fields to compare, null if no limit */
+    private final DateTimeField iUpperLimit;
+
+    //-----------------------------------------------------------------------
     /**
      * Returns a DateTimeComparator the compares the entire date time value.
      */
@@ -131,23 +145,29 @@ public static DateTimeComparator getTimeOnlyInstance(Chronology chrono) {
         return getInstance(null, chrono.dayOfYear());
     }
 
-    private final DateTimeField iLowerLimit;
-    private final DateTimeField iUpperLimit;
-
+    //-----------------------------------------------------------------------
+    /**
+     * Restricted constructor.
+     */
     private DateTimeComparator(DateTimeField lowerLimit, DateTimeField upperLimit) {
+        super();
         iLowerLimit = lowerLimit;
         iUpperLimit = upperLimit;
     }
 
     /**
-     * @return null if no lower limit
+     * Gets the field that represents the lower limit of comparison.
+     * 
+     * @return the field, null if no upper limit
      */
     public DateTimeField getLowerLimit() {
         return iLowerLimit;
     }
 
     /**
-     * @return null if no upper limit
+     * Gets the field that represents the upper limit of comparison.
+     * 
+     * @return the field, null if no upper limit
      */
     public DateTimeField getUpperLimit() {
         return iUpperLimit;
@@ -157,12 +177,10 @@ public DateTimeField getUpperLimit() {
      * Compare two objects against only the range of date time fields as
      * specified in the constructor.
      * 
-     * @param lhsObj The first object, logically on the left of a &lt;
-     * comparison
-     * @param rhsObj The second object, logically on the right of a &lt;
-     * comparison
+     * @param lhsObj The first object, logically on the left of a &lt; comparison
+     * @param rhsObj The second object, logically on the right of a &lt; comparison
      * @return zero if order does not matter, negative value if lhsObj &lt;
-     * rhsObj, positive value otherwise.
+     *  rhsObj, positive value otherwise.
      * @throws IllegalArgumentException if either argument is not supported
      */
     public int compare(Object lhsObj, Object rhsObj) {
@@ -213,26 +231,34 @@ public int compare(Object lhsObj, Object rhsObj) {
     }
 
     /**
-     * Support serialization singletons
+     * Gets the millisecond value from an object using the converter system.
+     * 
+     * @param obj  the object to convert
+     * @return millis since the epoch
+     */
+    private static long getMillisFromObject(Object obj) {
+        return ConverterManager.getInstance().getInstantConverter(obj).getInstantMillis(obj);
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Support serialization singletons.
      */
     private Object readResolve() {
         return getInstance(iLowerLimit, iUpperLimit);
     }
 
-    /*
-     * Developer's note: The 'equals' method specified by the interface is not
-     * overridden here. It does not make sense to do so, since 'this' is a
-     * DateTimeComparator, and 'that' would (presumably) be one of the
-     * supported object types described elsewhere. The '==' logic provided by
-     * java.lang.Object for a DateTimeComparator object suffices.
-     */
-
-    /*
-     * @param obj
-     * @return millis since the epoch
+    /**
+     * Gets a debugging string.
+     * 
+     * @return a debugging string
      */
-    private static long getMillisFromObject(Object obj) {
-        return ConverterManager.getInstance().getInstantConverter(obj).getInstantMillis(obj);
+    public String toString() {
+        return "DateTimeComparator[lowerLimit:"
+            + (iLowerLimit == null ? "none" : iLowerLimit.getName())
+            + ",upperLimit:"
+            + (iUpperLimit == null ? "none" : iUpperLimit.getName())
+            + "]";
     }
 
 }
diff --git a/JodaTime/src/java/org/joda/time/DateTimeConstants.java b/JodaTime/src/java/org/joda/time/DateTimeConstants.java
index 7dde2e92c..46680e135 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeConstants.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeConstants.java
@@ -67,40 +67,40 @@
 public final class DateTimeConstants {
 
     // These are ints not enumerations as they represent genuine int values
-    /** Constant (1) representing January, the first month */
+    /** Constant (1) representing January, the first month (ISO) */
     public static final int JANUARY = 1;
 
-    /** Constant (2) representing February, the second month */
+    /** Constant (2) representing February, the second month (ISO) */
     public static final int FEBRUARY = 2;
 
-    /** Constant (3) representing March, the third month */
+    /** Constant (3) representing March, the third month (ISO) */
     public static final int MARCH = 3;
 
-    /** Constant (4) representing April, the fourth month */
+    /** Constant (4) representing April, the fourth month (ISO) */
     public static final int APRIL = 4;
 
-    /** Constant (5) representing May, the fifth month */
+    /** Constant (5) representing May, the fifth month (ISO) */
     public static final int MAY = 5;
 
-    /** Constant (6) representing June, the sixth month */
+    /** Constant (6) representing June, the sixth month (ISO) */
     public static final int JUNE = 6;
 
-    /** Constant (7) representing July, the seventh month */
+    /** Constant (7) representing July, the seventh month (ISO) */
     public static final int JULY = 7;
 
-    /** Constant (8) representing August, the eighth month */
+    /** Constant (8) representing August, the eighth month (ISO) */
     public static final int AUGUST = 8;
 
-    /** Constant (9) representing September, the nineth month */
+    /** Constant (9) representing September, the nineth month (ISO) */
     public static final int SEPTEMBER = 9;
 
-    /** Constant (10) representing October, the tenth month */
+    /** Constant (10) representing October, the tenth month (ISO) */
     public static final int OCTOBER = 10;
 
-    /** Constant (11) representing November, the eleventh month */
+    /** Constant (11) representing November, the eleventh month (ISO) */
     public static final int NOVEMBER = 11;
 
-    /** Constant (12) representing December, the twelfth month */
+    /** Constant (12) representing December, the twelfth month (ISO) */
     public static final int DECEMBER = 12;
 
     // These are ints not enumerations as they represent genuine int values
@@ -144,43 +144,46 @@
     public static final int CE = 1;
 
 
-    /** Milliseconds in one second (1000) */
+    /** Milliseconds in one second (1000) (ISO) */
     public static final int MILLIS_PER_SECOND = 1000;
 
-    /** Seconds in one minute (60) */
+    /** Seconds in one minute (60) (ISO) */
     public static final int SECONDS_PER_MINUTE = 60;
+    /** Milliseconds in one minute (ISO) */
     public static final int MILLIS_PER_MINUTE = MILLIS_PER_SECOND * SECONDS_PER_MINUTE;
 
-    /** Minutes in one hour (60) */
+    /** Minutes in one hour (ISO) */
     public static final int MINUTES_PER_HOUR = 60;
+    /** Milliseconds in one hour (ISO) */
     public static final int SECONDS_PER_HOUR = SECONDS_PER_MINUTE * MINUTES_PER_HOUR;
+    /** Minutes in one hour (60) (ISO) */
     public static final int MILLIS_PER_HOUR = MILLIS_PER_MINUTE * MINUTES_PER_HOUR;
 
-    /** Hours in a typical day (24). Due to time zone offset changes, the
+    /** Hours in a typical day (24) (ISO). Due to time zone offset changes, the
      * number of hours per day can vary. */
     public static final int HOURS_PER_DAY = 24;
-    /** Minutes in a typical day. Due to time zone offset changes, the number
+    /** Minutes in a typical day (ISO). Due to time zone offset changes, the number
      * of minutes per day can vary. */
     public static final int MINUTES_PER_DAY = MINUTES_PER_HOUR * HOURS_PER_DAY;
-    /** Seconds in a typical day. Due to time zone offset changes, the number
+    /** Seconds in a typical day (ISO). Due to time zone offset changes, the number
      * of seconds per day can vary. */
     public static final int SECONDS_PER_DAY = SECONDS_PER_HOUR * HOURS_PER_DAY;
-    /** Milliseconds in a typical day. Due to time zone offset changes, the
+    /** Milliseconds in a typical day (ISO). Due to time zone offset changes, the
      * number of milliseconds per day can vary. */
     public static final int MILLIS_PER_DAY = MILLIS_PER_HOUR * HOURS_PER_DAY;
 
-    /** Days in one week (7) */
+    /** Days in one week (7) (ISO) */
     public static final int DAYS_PER_WEEK = 7;
     /** Hours in a typical week. Due to time zone offset changes, the number of
      * hours per week can vary. */
     public static final int HOURS_PER_WEEK = HOURS_PER_DAY * DAYS_PER_WEEK;
-    /** Minutes in a typical week. Due to time zone offset changes, the number
+    /** Minutes in a typical week (ISO). Due to time zone offset changes, the number
      * of minutes per week can vary. */
     public static final int MINUTES_PER_WEEK = MINUTES_PER_DAY * DAYS_PER_WEEK;
-    /** Seconds in a typical week. Due to time zone offset changes, the number
+    /** Seconds in a typical week (ISO). Due to time zone offset changes, the number
      * of seconds per week can vary. */
     public static final int SECONDS_PER_WEEK = SECONDS_PER_DAY * DAYS_PER_WEEK;
-    /** Milliseconds in a typical week. Due to time zone offset changes, the
+    /** Milliseconds in a typical week (ISO). Due to time zone offset changes, the
      * number of milliseconds per week can vary. */
     public static final int MILLIS_PER_WEEK = MILLIS_PER_DAY * DAYS_PER_WEEK;
 
diff --git a/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java b/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java
index 1424f20d2..325feb4f3 100644
--- a/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/AbstractGJChronology.java
@@ -70,7 +70,7 @@
 import org.joda.time.field.RemainderDateTimeField;
 
 /**
- * Base class for implementing chronologies based on Gregorian/Julian formulas.
+ * Abstract Chronology for implementing chronologies based on Gregorian/Julian formulae.
  * Most of the utility methods required by subclasses are package-private,
  * reflecting the intention that they be defined in the same package.
  * <p>
@@ -84,7 +84,8 @@
  */
 public abstract class AbstractGJChronology extends AssembledChronology {
 
-    static final long serialVersionUID = 8283225332206808863L;
+    /** Serialization lock */
+    private static final long serialVersionUID = 8283225332206808863L;
 
     static final long MILLIS_1970_TO_2000 = 946684800000L;
 
diff --git a/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java b/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java
index e2fc6d5a2..24ec6b2d2 100644
--- a/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/AssembledChronology.java
@@ -62,11 +62,13 @@
 import org.joda.time.DurationField;
 
 /**
- * Allows chronologies to be assembled from a container of fields.
+ * Abstract Chronology that enables chronologies to be assembled from
+ * a container of fields.
  * <p>
  * AssembledChronology is thread-safe and immutable.
  *
  * @author Brian S O'Neill
+ * @since 1.0
  */
 public abstract class AssembledChronology extends AbstractChronology {
 
diff --git a/JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java b/JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java
index eff0211ff..9a713dcaa 100644
--- a/JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/BuddhistChronology.java
@@ -61,16 +61,15 @@
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeZone;
-import org.joda.time.DurationField;
 import org.joda.time.field.DividedDateTimeField;
 import org.joda.time.field.OffsetDateTimeField;
 import org.joda.time.field.RemainderDateTimeField;
 
 /**
- * <code>BuddhistChronology</code> provides access to the individual date
- * time fields for the Buddhist chronological calendar system.
+ * Implements the Buddhist calendar system, which is similar to Gregorian/Julian,
+ * except with the year offset by 543.
  * <p>
- * The Buddhist calendar differs from the GregorianJulian calendar only 
+ * The Buddhist calendar differs from the Gregorian/Julian calendar only 
  * in the year. This class is compatable with the BuddhistCalendar class 
  * supplied by Sun.
  * <p>
@@ -82,7 +81,8 @@
  */
 public final class BuddhistChronology extends AssembledChronology {
     
-    static final long serialVersionUID = -3474595157769370126L;
+    /** Serialization lock */
+    private static final long serialVersionUID = -3474595157769370126L;
 
     /**
      * Constant value for 'Buddhist Era', equivalent to the value returned
diff --git a/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java
index 19e6e0e6c..cf9e880f1 100644
--- a/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/CopticChronology.java
@@ -65,7 +65,7 @@
 import org.joda.time.field.PreciseDurationField;
 
 /**
- * Implements a Coptic calendar system, which defines every fourth year as
+ * Implements the Coptic calendar system, which defines every fourth year as
  * leap, much like the Julian calendar. The year is broken down into 12 months,
  * each 30 days in length. An extra period at the end of the year is either 5
  * or 6 days in length. In this implementation, it is considered a 13th month.
@@ -80,10 +80,12 @@
  * @see JulianChronology
  *
  * @author Brian S O'Neill
+ * @since 1.0
  */
 public final class CopticChronology extends AbstractGJChronology {
 
-    static final long serialVersionUID = -5972804258688333942L;
+    /** Serialization lock */
+    private static final long serialVersionUID = -5972804258688333942L;
 
     /**
      * Constant value for 'Anno Martyrum' or 'Era of the Martyrs', equivalent
diff --git a/JodaTime/src/java/org/joda/time/chrono/GJChronology.java b/JodaTime/src/java/org/joda/time/chrono/GJChronology.java
index e23930747..0bb2d8dae 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GJChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GJChronology.java
@@ -72,8 +72,9 @@
 import org.joda.time.format.ISODateTimeFormat;
 
 /**
- * GJChronology provides access to the individual date time fields for the
- * Gregorian/Julian defined chronological calendar system.
+ * Implements the Gregorian/Julian calendar system which is the calendar system
+ * used in most of the world. Wherever possible, it is recommended to use the
+ * {@link ISOChronology} instead.
  * <p>
  * The Gregorian calendar replaced the Julian calendar, and the point in time
  * when this chronology switches can be controlled using the second parameter
@@ -87,10 +88,10 @@
  * However before 8 CE, Julian leap years were irregular, and before 45 BCE
  * there was no Julian calendar.
  * <p>
- * This chronology differs from {@link java.util.GregorianCalendar
- * java.util.GregorianCalendar} in that years in BCE are returned
- * correctly. Thus year 1 BCE is returned as -1 instead of 1. The yearOfEra
- * field produces results compatible with GregorianCalendar.
+ * This chronology differs from
+ * {@link java.util.GregorianCalendar GregorianCalendar} in that years
+ * in BCE are returned correctly. Thus year 1 BCE is returned as -1 instead of 1.
+ * The yearOfEra field produces results compatible with GregorianCalendar.
  * <p>
  * The Julian calendar does not have a year zero, and so year -1 is followed by
  * year 1. If the Gregorian cutover date is specified at or before year -1
@@ -109,7 +110,8 @@
  */
 public final class GJChronology extends AssembledChronology {
 
-    static final long serialVersionUID = -2545574827706931671L;
+    /** Serialization lock */
+    private static final long serialVersionUID = -2545574827706931671L;
 
     /**
      * Convert a datetime from one chronology to another.
diff --git a/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java b/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java
index 34f8411b5..040f1b35b 100644
--- a/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/GregorianChronology.java
@@ -58,11 +58,7 @@
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeConstants;
-import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeZone;
-import org.joda.time.field.DividedDateTimeField;
-import org.joda.time.field.OffsetDateTimeField;
-import org.joda.time.field.RemainderDateTimeField;
 
 /**
  * Implements a pure proleptic Gregorian calendar system, which defines every
@@ -82,10 +78,12 @@
  * @author Guy Allard
  * @author Stephen Colebourne
  * @author Brian S O'Neill
+ * @since 1.0
  */
 public final class GregorianChronology extends AbstractGJChronology {
 
-    static final long serialVersionUID = -861407383323710522L;
+    /** Serialization lock */
+    private static final long serialVersionUID = -861407383323710522L;
 
     private static final long MILLIS_PER_YEAR =
         (long) (365.2425 * DateTimeConstants.MILLIS_PER_DAY);
diff --git a/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java b/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java
index eac80313a..f8d3ebe18 100644
--- a/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/JulianChronology.java
@@ -83,10 +83,12 @@
  * @author Guy Allard
  * @author Brian S O'Neill
  * @author Stephen Colebourne
+ * @since 1.0
  */
 public final class JulianChronology extends AbstractGJChronology {
 
-    static final long serialVersionUID = -8731039522547897247L;
+    /** Serialization lock */
+    private static final long serialVersionUID = -8731039522547897247L;
 
     private static final long MILLIS_PER_YEAR =
         (long) (365.25 * DateTimeConstants.MILLIS_PER_DAY);
diff --git a/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java b/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java
index 1a8e1b2ae..fbf0222d4 100644
--- a/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/LenientChronology.java
@@ -59,17 +59,19 @@
 import org.joda.time.field.LenientDateTimeField;
 
 /**
- * Wraps another chronology, ensuring all the fields are lenient.
+ * Wraps another Chronology, ensuring all the fields are lenient.
  * <p>
  * LenientChronology is thread-safe and immutable.
  *
  * @author Brian S O'Neill
+ * @since 1.0
  * @see LenientDateTimeField
  * @see StrictChronology
  */
 public final class LenientChronology extends AssembledChronology {
 
-    static final long serialVersionUID = -3148237568046877177L;
+    /** Serialization lock */
+    private static final long serialVersionUID = -3148237568046877177L;
 
     /**
      * Create a LenientChronology for any chronology.
diff --git a/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java b/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java
index 1963cc410..1d9676231 100644
--- a/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/LimitChronology.java
@@ -53,10 +53,6 @@
  */
 package org.joda.time.chrono;
 
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.Serializable;
-
 import java.util.HashMap;
 import java.util.Locale;
 
@@ -73,9 +69,9 @@
 import org.joda.time.format.ISODateTimeFormat;
 
 /**
- * Imposes limits on the range of instants that the fields within a Chronology
- * may support. The limits are applied to both DateTimeFields and
- * DurationFields.
+ * Wraps another Chronology to impose limits on the range of instants that
+ * the fields within a Chronology may support. The limits are applied to both
+ * DateTimeFields and DurationFields.
  * <p>
  * Methods in DateTimeField and DurationField throw an IllegalArgumentException
  * whenever given an input instant that is outside the limits or when an
@@ -89,14 +85,15 @@
  */
 public final class LimitChronology extends AssembledChronology {
 
-    static final long serialVersionUID = 7670866536893052522L;
+    /** Serialization lock */
+    private static final long serialVersionUID = 7670866536893052522L;
 
     /**
      * Wraps another chronology, with datetime limits. When withUTC or
      * withDateTimeZone is called, the returned LimitChronology instance has
      * the same limits, except they are time zone adjusted.
      *
-     * @param base base chronology to wrap
+     * @param base  base chronology to wrap
      * @param lowerLimit  inclusive lower limit, or null if none
      * @param upperLimit  exclusive upper limit, or null if none
      * @throws IllegalArgumentException if chronology is null or limits are invalid
diff --git a/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java b/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java
index 9ed16c7d9..4e1778aca 100644
--- a/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/StrictChronology.java
@@ -59,17 +59,19 @@
 import org.joda.time.field.StrictDateTimeField;
 
 /**
- * Wraps another chronology, ensuring all the fields are strict.
+ * Wraps another Chronology, ensuring all the fields are strict.
  * <p>
  * StrictChronology is thread-safe and immutable.
  *
  * @author Brian S O'Neill
+ * @since 1.0
  * @see StrictDateTimeField
  * @see LenientChronology
  */
 public final class StrictChronology extends AssembledChronology {
 
-    static final long serialVersionUID = 6633006628097111960L;
+    /** Serialization lock */
+    private static final long serialVersionUID = 6633006628097111960L;
 
     /**
      * Create a StrictChronology for any chronology.
diff --git a/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java b/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
index 1efb30776..6b0d9bf32 100644
--- a/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/ZonedChronology.java
@@ -65,7 +65,7 @@
 import org.joda.time.field.AbstractDurationField;
 
 /**
- * Wraps another Chronology for supporting time zones.
+ * Wraps another Chronology to add support for time zones.
  * <p>
  * ZonedChronology is thread-safe and immutable.
  *
@@ -75,6 +75,9 @@
  */
 public final class ZonedChronology extends AssembledChronology {
 
+    /** Serialization lock */
+    private static final long serialVersionUID = -1079258847191166848L;
+
     /**
      * Create a ZonedChronology for any chronology, overriding any time zone it
      * may already have.
@@ -97,8 +100,6 @@ public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {
         return new ZonedChronology(base, zone);
     }
 
-    static final long serialVersionUID = -1079258847191166848L;
-
     static boolean useTimeArithmetic(DurationField field) {
         // Use time of day arithmetic rules for unit durations less than
         // typical time zone offsets.
diff --git a/JodaTime/src/java/org/joda/time/convert/ConverterManager.java b/JodaTime/src/java/org/joda/time/convert/ConverterManager.java
index b6de0a94f..ea2731705 100644
--- a/JodaTime/src/java/org/joda/time/convert/ConverterManager.java
+++ b/JodaTime/src/java/org/joda/time/convert/ConverterManager.java
@@ -72,14 +72,14 @@
  * <li>String
  * <li>Calendar
  * <li>Date
- * <li>Long
+ * <li>Long (milliseconds)
  * </ul>
  * The default duration converters are:
  * <ul>
  * <li>ReadableDuration
  * <li>ReadableInterval
  * <li>String
- * <li>Long
+ * <li>Long (milliseconds)
  * </ul>
  *
  * The default interval converters are:
diff --git a/JodaTime/src/java/org/joda/time/convert/package.html b/JodaTime/src/java/org/joda/time/convert/package.html
index 68cb4c636..b2b70df29 100644
--- a/JodaTime/src/java/org/joda/time/convert/package.html
+++ b/JodaTime/src/java/org/joda/time/convert/package.html
@@ -7,7 +7,7 @@
    Joda Software License, Version 1.0
   
   
-   Copyright (c) 2001-03 Stephen Colebourne.
+   Copyright (c) 2001-2004 Stephen Colebourne.
    All rights reserved.
   
    Redistribution and use in source and binary forms, with or without
diff --git a/JodaTime/src/java/org/joda/time/field.html b/JodaTime/src/java/org/joda/time/field.html
deleted file mode 100644
index 292d0058d..000000000
--- a/JodaTime/src/java/org/joda/time/field.html
+++ /dev/null
@@ -1,457 +0,0 @@
-<body>
-<h3>DateTime fields</h3>
-<p>
-The library breaks up the date and time into a number of fields. This document
-defines what those fields mean.
-</p>
-<p>
-A naming convention is used to define the fields. These correspond to the common 
-names given to date and time concepts in the Gregorian calendar.
-</p>
-<p>Most fields are a view over part of the total time.
-These fields are expressed as <code>XxxOfYyy</code> where <code>Xxx</code> and <code>Yyy</code> are two date time units.
-<code>Yyy</code> will always be larger than <code>Xxx</code>.
-For example, <code>DayOfWeek</code> or <code>SecondOfMinute</code>.
-A side effect of this is that these field values cannot be negative.
-</p>
-<p>
-Certain fields extend over all time, and do not include the word 'Of' in their names.
-For example, <code>year</code> and <code>weekyear</code>.
-These fields can have negative values (see the table for details).
-<p>
-<p>
-The fields are explained in more detail below (for the GJChronology):
-<p>
-<table cols="3" border="1">
-<tr>
-<th>Name
-<th>Min value (GJ)
-<th>Max value (GJ)
-<th>Notes
-</tr><tr>
-<td><a href="#millisOfSecond">millisOfSecond</a>
-<td align="center">0
-<td align="center">999
-<td>&nbsp;</td>
-</tr><tr>
-<td><a href="#millisOfDay">millisOfDay</a>
-<td align="center">0
-<td align="center">86 399 999
-<td>&nbsp;</td>
-</tr><tr>
-<td><a href="#secondOfMinute">secondOfMinute</a>
-<td align="center">0
-<td align="center">59
-<td>&nbsp;</td>
-</tr><tr>
-<td><a href="#secondOfDay">secondOfDay</a>
-<td align="center">0
-<td align="center">86 399
-<td>&nbsp;</td>
-</tr><tr>
-<td><a href="#minuteOfHour">minuteOfHour</a>
-<td align="center">0
-<td align="center">59
-<td>&nbsp;</td>
-</tr><tr>
-<td><a href="#minuteOfDay">minuteOfDay</a>
-<td align="center">0
-<td align="center">1439
-<td>&nbsp;</td>
-</tr><tr>
-<td><a href="#hourOfDay">hourOfDay</a>
-<td align="center">0
-<td align="center">23
-<td>&nbsp;</td>
-</tr><tr>
-<td><a href="#hourOfHalfday">hourOfHalfday</a>
-<td align="center">0
-<td align="center">11
-<td>&nbsp;</td>
-</tr><tr>
-<td><a href="#hourOfDay">clockhourOfDay</a>
-<td align="center">1
-<td align="center">24
-<td>&nbsp;</td>
-</tr><tr>
-<td><a href="#hourOfHalfday">clockhourOfHalfday</a>
-<td align="center">1
-<td align="center">12
-<td>&nbsp;</td>
-</tr><tr>
-<td><a href="#halfdayOfDay">halfdayOfDay</a>
-<td align="center">0 (AM)
-<td align="center">1 (PM)
-<td>&nbsp;</td>
-</tr><tr>
-<td><a href="#dayOfWeek">dayOfWeek</a>
-<td align="center">1 (Monday)
-<td align="center">7 (Sunday)
-<td>&nbsp;</td>
-</tr><tr>
-<td><a href="#weekOfWeekyear">weekOfWeekyear</a>
-<td align="center">1
-<td align="center">53
-<td>&nbsp;</td>
-</tr><tr>
-<td><a href="#weekyear">weekyear</a>
-<td align="center">-292 000 000
-<td align="center">292 000 000
-<td>&nbsp;</td>
-</tr><tr>
-<td><a href="#dayOfMonth">dayOfMonth</a>
-<td align="center">1
-<td align="center">31
-<td>&nbsp;</td>
-</tr><tr>
-<td><a href="#dayOfYear">dayOfYear</a>
-<td align="center">1
-<td align="center">366
-<td>&nbsp;</td>
-</tr><tr>
-<td><a href="#monthOfYear">monthOfYear</a>
-<td align="center">1 (January)
-<td align="center">12 (December)
-<td>&nbsp;</td>
-</tr><tr>
-<td><a href="#year">year</a>
-<td align="center">-292 000 000
-<td align="center">292 000 000
-<td>&nbsp;</td>
-</tr><tr>
-<td><a href="#yearOfCentury">yearOfCentury</a>
-<td align="center">1
-<td align="center">100
-<td align="center">[1]</td>
-</tr><tr>
-<td><a href="#yearOfEra">yearOfEra</a>
-<td align="center">1
-<td align="center">292 000 000
-<td>&nbsp;</td>
-</tr><tr>
-<td><a href="#centuryOfEra">centuryOfEra</a>
-<td align="center">1
-<td align="center">2 920 000
-<td align="center">[2]</td>
-</tr><tr>
-<td><a href="#era">era</a>
-<td align="center">0 (BC/BCE)
-<td align="center">1 (AD/CE)
-<td>&nbsp;</td>
-</tr>
-</table>
-[1] For the ISOChronology, the year of century range is from 0 to 99.<br />
-[2] For the ISOChronology, the century of era range is from 0.<br />
-</p>
-
-
-<a name="millisOfSecond" />
-<h4>MillisOfSecond</h4>
-<p>
-The number of milliseconds in the specified time once the second and larger parts are removed.
-</p>
-
-
-<a name="millisOfDay" />
-<h4>MillisOfDay</h4>
-<p>
-The number of milliseconds in the specified time once the day and larger parts are removed.
-</p>
-
-
-<a name="secondOfMinute" />
-<h4>SecondOfMinute</h4>
-<p>
-The number of seconds in the specified time once the minute and larger parts are removed.
-</p>
-
-
-<a name="secondOfDay" />
-<h4>SecondOfDay</h4>
-<p>
-The number of seconds in the specified time once the day and larger parts are removed.
-</p>
-
-
-<a name="minuteOfHour" />
-<h4>MinuteOfHour</h4>
-<p>
-The number of minutes in the specified time once the hour and larger parts are removed.
-</p>
-
-
-<a name="minuteOfDay" />
-<h4>MinuteOfDay</h4>
-<p>
-The number of minutes in the specified time once the day and larger parts are removed.
-</p>
-
-
-<a name="hourOfDay" />
-<h4>HourOfDay</h4>
-<p>
-The number of hours in the specified time once the day and larger parts are
-removed. The clockhour value represents midnight of the current day as 24
-instead of 0.
-</p>
-
-<a name="hourOfHalfday" />
-<h4>HourOfHalfday</h4>
-<p>
-The number of hours within the half day. The clockhour value represents
-midnight or noon of the current day as 12 instead of 0.
-</p>
-
-<a name="halfdayOfDay" />
-<h4>HalfdayOfDay</h4>
-<p>
-The AM/PM value of the day.
-</p>
-
-<a name="dayOfWeek" />
-<h4>DayOfWeek</h4>
-<p>
-The day of week is defined by constants in <code>DateTimeConstants</code>.
-The values used are from the ISO8601 standard.
-Monday is defined as 1, through to Sunday as 7.
-</p>
-
-
-<a name="weekOfWeekyear" />
-<a name="weekyear" />
-<h4>WeekOfWeekyear and Weekyear</h4>
-<p>
-A week based year is one where dates are expressed as a day of week, week number and year (week based).
-The following description is of the ISO8601 standard used by implementations of this method in this library.
-<p>
-Weeks run from 1 to 52-53 in a week based year.
-The first day of the week is defined as Monday and given the value 1. 
-<p>
-The first week of a year is defined as the first week that has at least four days in the year.
-As a result of this definition, week 1 may extend into the previous year, and week 52/53 may extend into the following year.
-Hence the need for the year of weekyear field.
-<p>
-For example, 2003-01-01 was a Wednesday.
-This means that five days, Wednesday to Sunday, of that week are in 2003.
-Thus the whole week is considered to be the first week of 2003.
-Since all weeks start on Monday, the first week of 2003 started on 2002-12-30, ie. in 2002.
-<p>
-The week based year has a specific text format.<br />
-2002-12-30 (Monday 30th December 2002) would be represented as 2003-W01-1.<br />
-2003-01-01 (Wednesday 1st January 2003) would be represented as 2003-W01-3.
-</p>
-
-
-<a name="dayOfMonth" />
-<h4>DayOfMonth</h4>
-<p>
-The day of the month. For the GJ and ISO chronologies, this will run from 1 through to 
-28 or 29 in February, 30 in April, June, September and November and 31 otherwise.
-</p>
-
-
-<a name="dayOfYear" />
-<h4>DayOfYear</h4>
-<p>
-The day of the year. This runs from 1 to 365, or 366 in leap years. 
-The exception is when a Julian to Gregorian cutover has occurred.
-In that case, the count is from 1 to 355 (typically) and is unbroken.
-</p>
-
-
-<a name="monthOfYear" />
-<h4>MonthOfYear</h4>
-<p>
-The month of year defined by constants in <code>DateTimeConstants</code>.
-The values used are from the ISO8601 standard.
-January is defined as 1, through to December as 12.
-</p>
-
-
-<a name="year" />
-<h4>Year</h4>
-<p>
-The year, using negative values to represent years in the previous era. For the
-GJ chronology, year zero is not included, unless the cutover to Gregorian is
-specified at or before 1 BCE. The ISO chronology always includes the year
-zero.
-</p>
-
-<a name="centuryOfEra" />
-<a name="yearOfCentury" />
-<h4>CenturyOfEra and YearOfCentury</h4>
-<p>
-The definition of these varies by chronology:
-</p>
-<p>
-<table border="1">
-<tr>
-<th></th>
-<th colspan="3">GJ</th>
-<th colspan="3">ISO</th>
-</tr><tr>
-<th>&nbsp;year of era&nbsp;</th>
-<th>&nbsp;year&nbsp;</th>
-<th>&nbsp;century of era&nbsp;</th>
-<th>&nbsp;year of century&nbsp;</th>
-<th>&nbsp;year&nbsp;</th>
-<th>&nbsp;century of era&nbsp;</th>
-<th>&nbsp;year of century&nbsp;</th>
-</tr><tr>
-<td align="center">101 BCE</td>
-<td align="center">-101</td>
-<td align="center">2</td>
-<td align="center">1</td>
-<td align="center">-100</td>
-<td align="center">1</td>
-<td align="center">0</td>
-</tr><tr>
-<td align="center">100 BCE</td>
-<td align="center">-100</td>
-<td align="center">1</td>
-<td align="center">100</td>
-<td align="center">-99</td>
-<td align="center">0</td>
-<td align="center">99</td>
-</tr><tr>
-<td align="center">99 BCE</td>
-<td align="center">-99</td>
-<td align="center">1</td>
-<td align="center">99</td>
-<td align="center">-98</td>
-<td align="center">0</td>
-<td align="center">98</td>
-</tr><tr>
-<td align="center">...</td>
-<td align="center">...</td>
-<td align="center">...</td>
-<td align="center">...</td>
-<td align="center">...</td>
-<td align="center">...</td>
-<td align="center">...</td>
-</tr><tr>
-<td align="center">2 BCE</td>
-<td align="center">-2</td>
-<td align="center">1</td>
-<td align="center">2</td>
-<td align="center">-1</td>
-<td align="center">0</td>
-<td align="center">1</td>
-</tr><tr>
-<td align="center">1 BCE</td>
-<td align="center">-1</td>
-<td align="center">1</td>
-<td align="center">1</td>
-<td align="center">0</td>
-<td align="center">0</td>
-<td align="center">0</td>
-</tr><tr>
-<td align="center">1 CE</td>
-<td align="center">1</td>
-<td align="center">1</td>
-<td align="center">1</td>
-<td align="center">1</td>
-<td align="center">0</td>
-<td align="center">1</td>
-</tr><tr>
-<td align="center">2 CE</td>
-<td align="center">2</td>
-<td align="center">1</td>
-<td align="center">2</td>
-<td align="center">2</td>
-<td align="center">0</td>
-<td align="center">2</td>
-</tr><tr>
-<td align="center">...</td>
-<td align="center">...</td>
-<td align="center">...</td>
-<td align="center">...</td>
-<td align="center">...</td>
-<td align="center">...</td>
-<td align="center">...</td>
-</tr><tr>
-<td align="center">99 CE</td>
-<td align="center">99</td>
-<td align="center">1</td>
-<td align="center">99</td>
-<td align="center">99</td>
-<td align="center">0</td>
-<td align="center">99</td>
-</tr><tr>
-<td align="center">100 CE</td>
-<td align="center">100</td>
-<td align="center">1</td>
-<td align="center">100</td>
-<td align="center">100</td>
-<td align="center">1</td>
-<td align="center">0</td>
-</tr><tr>
-<td align="center">101 CE</td>
-<td align="center">101</td>
-<td align="center">2</td>
-<td align="center">1</td>
-<td align="center">101</td>
-<td align="center">1</td>
-<td align="center">1</td>
-</tr><tr>
-<td align="center">...</td>
-<td align="center">...</td>
-<td align="center">...</td>
-<td align="center">...</td>
-<td align="center">...</td>
-<td align="center">...</td>
-<td align="center">...</td>
-</tr><tr>
-<td align="center">1999 CE</td>
-<td align="center">1999</td>
-<td align="center">20</td>
-<td align="center">99</td>
-<td align="center">1999</td>
-<td align="center">19</td>
-<td align="center">99</td>
-</tr><tr>
-<td align="center">2000 CE</td>
-<td align="center">2000</td>
-<td align="center">20</td>
-<td align="center">100</td>
-<td align="center">2000</td>
-<td align="center">20</td>
-<td align="center">0</td>
-</tr><tr>
-<td align="center">2001 CE</td>
-<td align="center">2001</td>
-<td align="center">21</td>
-<td align="center">1</td>
-<td align="center">2001</td>
-<td align="center">20</td>
-<td align="center">1</td>
-</tr>
-</table>
-
-For GJ this is consistent with phrases such '2003 is in the 21st century'.<br />
-For ISO this represents a straight split of a textual ISO8601 year.
-</p>
-
-
-<a name="yearOfEra" />
-<h4>YearOfEra</h4>
-<p>
-The year as generally known (always positive).
-Both the GJ and ISO chronologies return 1 for 1BC/BCE, 2 for 2BC/CBE etc.
-In other words there is no year zero and no negative value for this field.
-</p>
-
-
-<a name="era" />
-<h4>Era</h4>
-<p>
-The era expressed as a constant, zero for BC/BCE, one for AD/CE.
-<p>
-</p>
-Other chronologies should respect the convention that one is the current era and
-zero is the previous era.
-If more eras are required the values should increase numerically over time.
-</p>
-
-
-</body>
diff --git a/JodaTime/src/java/org/joda/time/field/package.html b/JodaTime/src/java/org/joda/time/field/package.html
index 3337248e1..e3507042b 100644
--- a/JodaTime/src/java/org/joda/time/field/package.html
+++ b/JodaTime/src/java/org/joda/time/field/package.html
@@ -61,6 +61,8 @@
 <body>
 <p>
 Provides DateTimeField and DurationField implementations and support.
+Applications will only use this package directly if they want to write
+their own DateTimeField implementation.
 </p>
 </body>
 </html>
diff --git a/JodaTime/src/java/org/joda/time/format/package.html b/JodaTime/src/java/org/joda/time/format/package.html
index f2797e736..e83ca5884 100644
--- a/JodaTime/src/java/org/joda/time/format/package.html
+++ b/JodaTime/src/java/org/joda/time/format/package.html
@@ -7,7 +7,7 @@
    Joda Software License, Version 1.0
   
   
-   Copyright (c) 2001-03 Stephen Colebourne.
+   Copyright (c) 2001-2004 Stephen Colebourne.
    All rights reserved.
   
    Redistribution and use in source and binary forms, with or without
diff --git a/JodaTime/src/java/org/joda/time/package.html b/JodaTime/src/java/org/joda/time/package.html
index 09532ed79..faab2ad5d 100644
--- a/JodaTime/src/java/org/joda/time/package.html
+++ b/JodaTime/src/java/org/joda/time/package.html
@@ -163,8 +163,7 @@ <h4>User defined APIs</h4>
 
 <h4>Chronologies and Fields</h4>
 <p>
-In order to enable the package to be easily extended, each 
-<a href="field.html">field</a> of the
+In order to enable the package to be easily extended, each field of the
 datetime, such as the month, is calculated by an implementation of
 <code>DateTimeField</code>). Likewise, duration fields are calculated by
 specialized <code>DurationField</code> instances. If desired, users can write
diff --git a/JodaTime/src/java/org/joda/time/property/package.html b/JodaTime/src/java/org/joda/time/property/package.html
index 8dd8490a8..35a4c1a26 100644
--- a/JodaTime/src/java/org/joda/time/property/package.html
+++ b/JodaTime/src/java/org/joda/time/property/package.html
@@ -7,7 +7,7 @@
    Joda Software License, Version 1.0
   
   
-   Copyright (c) 2001-03 Stephen Colebourne.
+   Copyright (c) 2001-2004 Stephen Colebourne.
    All rights reserved.
   
    Redistribution and use in source and binary forms, with or without
diff --git a/JodaTime/src/java/org/joda/time/tz/package.html b/JodaTime/src/java/org/joda/time/tz/package.html
index 01814e75f..b54a50058 100644
--- a/JodaTime/src/java/org/joda/time/tz/package.html
+++ b/JodaTime/src/java/org/joda/time/tz/package.html
@@ -7,7 +7,7 @@
    Joda Software License, Version 1.0
   
   
-   Copyright (c) 2001-03 Stephen Colebourne.
+   Copyright (c) 2001-2004 Stephen Colebourne.
    All rights reserved.
   
    Redistribution and use in source and binary forms, with or without

From 93e4ec9fdb473f51636508c051800360865c6198 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 15 Feb 2004 18:45:13 +0000
Subject: [PATCH 140/143] Improve javadoc

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@145 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 .../src/java/org/joda/time/chrono/ISOChronology.java     | 9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

diff --git a/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java b/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java
index 8aa829526..b5fa448e8 100644
--- a/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java
+++ b/JodaTime/src/java/org/joda/time/chrono/ISOChronology.java
@@ -66,9 +66,9 @@
 import org.joda.time.field.RemainderDateTimeField;
 
 /**
- * ISOChronology provides access to the individual date time fields 
- * for the ISO8601 defined chronological calendar system. When ISO 
- * does not define a field, but it can be determined (such as AM/PM)
+ * Implements a chronology that follows the rules of the ISO8601 standard,
+ * which is compatible with Gregorian for all modern dates.
+ * When ISO does not define a field, but it can be determined (such as AM/PM)
  * it is included.
  * <p>
  * With the exception of century related fields, ISOChronology is exactly the
@@ -85,7 +85,8 @@
  */
 public final class ISOChronology extends AssembledChronology {
     
-    static final long serialVersionUID = -6212696554273812441L;
+    /** Serialization lock */
+    private static final long serialVersionUID = -6212696554273812441L;
 
     /** Singleton instance of a UTC ISOChronology */
     private static final ISOChronology INSTANCE_UTC =

From 0d54bf0fd57b700f2ff684ed28efbc38b2d0478c Mon Sep 17 00:00:00 2001
From: Brian S O'Neill <bronee@gmail.com>
Date: Sun, 15 Feb 2004 21:18:54 +0000
Subject: [PATCH 141/143] Comment fix.

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@146 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/DateTimeConstants.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/JodaTime/src/java/org/joda/time/DateTimeConstants.java b/JodaTime/src/java/org/joda/time/DateTimeConstants.java
index 46680e135..8e7b244d4 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeConstants.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeConstants.java
@@ -154,7 +154,7 @@
 
     /** Minutes in one hour (ISO) */
     public static final int MINUTES_PER_HOUR = 60;
-    /** Milliseconds in one hour (ISO) */
+    /** Seconds in one hour (ISO) */
     public static final int SECONDS_PER_HOUR = SECONDS_PER_MINUTE * MINUTES_PER_HOUR;
     /** Minutes in one hour (60) (ISO) */
     public static final int MILLIS_PER_HOUR = MILLIS_PER_MINUTE * MINUTES_PER_HOUR;

From fd9230013c662db7e1ac34952745fc3a1c09e015 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 15 Feb 2004 22:09:01 +0000
Subject: [PATCH 142/143] Improve javadoc

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@147 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/src/java/org/joda/time/DateTimeConstants.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/JodaTime/src/java/org/joda/time/DateTimeConstants.java b/JodaTime/src/java/org/joda/time/DateTimeConstants.java
index 8e7b244d4..16ee5dc3f 100644
--- a/JodaTime/src/java/org/joda/time/DateTimeConstants.java
+++ b/JodaTime/src/java/org/joda/time/DateTimeConstants.java
@@ -156,7 +156,7 @@
     public static final int MINUTES_PER_HOUR = 60;
     /** Seconds in one hour (ISO) */
     public static final int SECONDS_PER_HOUR = SECONDS_PER_MINUTE * MINUTES_PER_HOUR;
-    /** Minutes in one hour (60) (ISO) */
+    /** Milliseconds in one hour (60) (ISO) */
     public static final int MILLIS_PER_HOUR = MILLIS_PER_MINUTE * MINUTES_PER_HOUR;
 
     /** Hours in a typical day (24) (ISO). Due to time zone offset changes, the

From 513311d668af24b4ffce503897a76215d006ea4c Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 15 Feb 2004 22:12:22 +0000
Subject: [PATCH 143/143] Update site docs

git-svn-id: https://joda-time.svn.sourceforge.net/svnroot/joda-time/trunk@148 1e1cfbb7-5c0e-0410-a2f0-f98d92ec03a1
---
 JodaTime/xdocs/field.xml      | 488 ++++++++++++++++++++++++++++++++++
 JodaTime/xdocs/index.xml      |  13 +-
 JodaTime/xdocs/navigation.xml |   9 +-
 JodaTime/xdocs/userguide.xml  |   5 +-
 4 files changed, 503 insertions(+), 12 deletions(-)
 create mode 100644 JodaTime/xdocs/field.xml

diff --git a/JodaTime/xdocs/field.xml b/JodaTime/xdocs/field.xml
new file mode 100644
index 000000000..6b14ac5ad
--- /dev/null
+++ b/JodaTime/xdocs/field.xml
@@ -0,0 +1,488 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+
+<document>
+
+ <properties>
+  <title>Joda Time Fields</title>
+  <author email="scolebourne@users.sourceforge.net">Stephen Colebourne</author>
+ </properties>
+
+ <body>
+
+<section name="Date and Time fields">
+<p>
+The library breaks up the date and time into a number of fields. This document
+defines what those fields mean.
+</p>
+<p>
+A naming convention is used to define the fields. These correspond to the common 
+names given to date and time concepts in the Gregorian calendar.
+</p>
+<p>Most fields are a view over part of the total time.
+These fields are expressed as <code>XxxOfYyy</code> where <code>Xxx</code> and <code>Yyy</code> are two date time units.
+<code>Yyy</code> will always be larger than <code>Xxx</code>.
+For example, <code>DayOfWeek</code> or <code>SecondOfMinute</code>.
+A side effect of this is that these field values cannot be negative.
+</p>
+<p>
+Certain fields extend over all time, and do not include the word 'Of' in their names.
+For example, <code>year</code> and <code>weekyear</code>.
+These fields can have negative values (see the table for details).
+</p>
+<p>
+The fields are explained in more detail below (for the GJChronology):
+</p>
+<table cols="3" border="1">
+<tr>
+<th>Name</th>
+<th>Min value (GJ)</th>
+<th>Max value (GJ)</th>
+<th>Notes</th>
+</tr><tr>
+<td><a href="#millisOfSecond">millisOfSecond</a></td>
+<td align="center">0</td>
+<td align="center">999</td>
+<td><span></span></td>
+</tr><tr>
+<td><a href="#millisOfDay">millisOfDay</a></td>
+<td align="center">0</td>
+<td align="center">86 399 999</td>
+<td><span></span></td>
+</tr><tr>
+<td><a href="#secondOfMinute">secondOfMinute</a></td>
+<td align="center">0</td>
+<td align="center">59</td>
+<td><span></span></td>
+</tr><tr>
+<td><a href="#secondOfDay">secondOfDay</a></td>
+<td align="center">0</td>
+<td align="center">86 399</td>
+<td><span></span></td>
+</tr><tr>
+<td><a href="#minuteOfHour">minuteOfHour</a></td>
+<td align="center">0</td>
+<td align="center">59</td>
+<td><span></span></td>
+</tr><tr>
+<td><a href="#minuteOfDay">minuteOfDay</a></td>
+<td align="center">0</td>
+<td align="center">1439</td>
+<td><span></span></td>
+</tr><tr>
+<td><a href="#hourOfDay">hourOfDay</a></td>
+<td align="center">0</td>
+<td align="center">23</td>
+<td><span></span></td>
+</tr><tr>
+<td><a href="#hourOfHalfday">hourOfHalfday</a></td>
+<td align="center">0</td>
+<td align="center">11</td>
+<td><span></span></td>
+</tr><tr>
+<td><a href="#hourOfDay">clockhourOfDay</a></td>
+<td align="center">1</td>
+<td align="center">24</td>
+<td><span></span></td>
+</tr><tr>
+<td><a href="#hourOfHalfday">clockhourOfHalfday</a></td>
+<td align="center">1</td>
+<td align="center">12</td>
+<td><span></span></td>
+</tr><tr>
+<td><a href="#halfdayOfDay">halfdayOfDay</a></td>
+<td align="center">0 (AM)</td>
+<td align="center">1 (PM)</td>
+<td><span></span></td>
+</tr><tr>
+<td><a href="#dayOfWeek">dayOfWeek</a></td>
+<td align="center">1 (Monday)</td>
+<td align="center">7 (Sunday)</td>
+<td><span></span></td>
+</tr><tr>
+<td><a href="#weekOfWeekyear">weekOfWeekyear</a></td>
+<td align="center">1</td>
+<td align="center">53</td>
+<td><span></span></td>
+</tr><tr>
+<td><a href="#weekyear">weekyear</a></td>
+<td align="center">-292 000 000</td>
+<td align="center">292 000 000</td>
+<td><span></span></td>
+</tr><tr>
+<td><a href="#dayOfMonth">dayOfMonth</a></td>
+<td align="center">1</td>
+<td align="center">31</td>
+<td><span></span></td>
+</tr><tr>
+<td><a href="#dayOfYear">dayOfYear</a></td>
+<td align="center">1</td>
+<td align="center">366</td>
+<td><span></span></td>
+</tr><tr>
+<td><a href="#monthOfYear">monthOfYear</a></td>
+<td align="center">1 (January)</td>
+<td align="center">12 (December)</td>
+<td><span></span></td>
+</tr><tr>
+<td><a href="#year">year</a></td>
+<td align="center">-292 000 000</td>
+<td align="center">292 000 000</td>
+<td><span></span></td>
+</tr><tr>
+<td><a href="#yearOfCentury">yearOfCentury</a></td>
+<td align="center">1</td>
+<td align="center">100</td>
+<td align="center">[1]</td>
+</tr><tr>
+<td><a href="#yearOfEra">yearOfEra</a></td>
+<td align="center">1</td>
+<td align="center">292 000 000</td>
+<td><span></span></td>
+</tr><tr>
+<td><a href="#centuryOfEra">centuryOfEra</a></td>
+<td align="center">1</td>
+<td align="center">2 920 000</td>
+<td align="center">[2]</td>
+</tr><tr>
+<td><a href="#era">era</a></td>
+<td align="center">0 (BC/BCE)</td>
+<td align="center">1 (AD/CE)</td>
+<td><span></span></td>
+</tr>
+</table>
+<p>
+[1] For the ISOChronology, the year of century range is from 0 to 99.<br />
+[2] For the ISOChronology, the century of era range is from 0.<br />
+</p>
+
+<a name="millisOfSecond" />
+<subsection name="MillisOfSecond">
+<p>
+The number of milliseconds in the specified time once the second and larger parts are removed.
+</p>
+</subsection>
+
+
+<a name="millisOfDay" />
+<subsection name="MillisOfDay">
+<p>
+The number of milliseconds in the specified time once the day and larger parts are removed.
+</p>
+</subsection>
+
+
+<a name="secondOfMinute" />
+<subsection name="SecondOfMinute">
+<p>
+The number of seconds in the specified time once the minute and larger parts are removed.
+</p>
+</subsection>
+
+
+<a name="secondOfDay" />
+<subsection name="SecondOfDay">
+<p>
+The number of seconds in the specified time once the day and larger parts are removed.
+</p>
+</subsection>
+
+
+<a name="minuteOfHour" />
+<subsection name="MinuteOfHour">
+<p>
+The number of minutes in the specified time once the hour and larger parts are removed.
+</p>
+</subsection>
+
+
+<a name="minuteOfDay" />
+<subsection name="MinuteOfDay">
+<p>
+The number of minutes in the specified time once the day and larger parts are removed.
+</p>
+</subsection>
+
+
+<a name="hourOfDay" />
+<subsection name="HourOfDay">
+<p>
+The number of hours in the specified time once the day and larger parts are
+removed. The clockhour value represents midnight of the current day as 24
+instead of 0.
+</p>
+</subsection>
+
+<a name="hourOfHalfday" />
+<subsection name="HourOfHalfday">
+<p>
+The number of hours within the half day. The clockhour value represents
+midnight or noon of the current day as 12 instead of 0.
+</p>
+</subsection>
+
+<a name="halfdayOfDay" />
+<subsection name="HalfdayOfDay">
+<p>
+The AM/PM value of the day.
+</p>
+</subsection>
+
+<a name="dayOfWeek" />
+<subsection name="DayOfWeek">
+<p>
+The day of week is defined by constants in <code>DateTimeConstants</code>.
+The values used are from the ISO8601 standard.
+Monday is defined as 1, through to Sunday as 7.
+</p>
+</subsection>
+
+
+<a name="weekOfWeekyear" />
+<a name="weekyear" />
+<subsection name="WeekOfWeekyear and Weekyear">
+<p>
+A week based year is one where dates are expressed as a day of week, week number and year (week based).
+The following description is of the ISO8601 standard used by implementations of this method in this library.
+</p>
+<p>
+Weeks run from 1 to 52-53 in a week based year.
+The first day of the week is defined as Monday and given the value 1. 
+</p>
+<p>
+The first week of a year is defined as the first week that has at least four days in the year.
+As a result of this definition, week 1 may extend into the previous year, and week 52/53 may extend into the following year.
+Hence the need for the year of weekyear field.
+</p>
+<p>
+For example, 2003-01-01 was a Wednesday.
+This means that five days, Wednesday to Sunday, of that week are in 2003.
+Thus the whole week is considered to be the first week of 2003.
+Since all weeks start on Monday, the first week of 2003 started on 2002-12-30, ie. in 2002.
+</p>
+<p>
+The week based year has a specific text format.<br />
+2002-12-30 (Monday 30th December 2002) would be represented as 2003-W01-1.<br />
+2003-01-01 (Wednesday 1st January 2003) would be represented as 2003-W01-3.
+</p>
+</subsection>
+
+
+<a name="dayOfMonth" />
+<subsection name="DayOfMonth">
+<p>
+The day of the month. For the GJ and ISO chronologies, this will run from 1 through to 
+28 or 29 in February, 30 in April, June, September and November and 31 otherwise.
+</p>
+</subsection>
+
+
+<a name="dayOfYear" />
+<subsection name="DayOfYear">
+<p>
+The day of the year. This runs from 1 to 365, or 366 in leap years. 
+The exception is when a Julian to Gregorian cutover has occurred.
+In that case, the count is from 1 to 355 (typically) and is unbroken.
+</p>
+</subsection>
+
+
+<a name="monthOfYear" />
+<subsection name="MonthOfYear">
+<p>
+The month of year defined by constants in <code>DateTimeConstants</code>.
+The values used are from the ISO8601 standard.
+January is defined as 1, through to December as 12.
+</p>
+</subsection>
+
+
+<a name="year" />
+<subsection name="Year">
+<p>
+The year, using negative values to represent years in the previous era. For the
+GJ chronology, year zero is not included, unless the cutover to Gregorian is
+specified at or before 1 BCE. The ISO chronology always includes the year
+zero.
+</p>
+</subsection>
+
+<a name="centuryOfEra" />
+<a name="yearOfCentury" />
+<subsection name="CenturyOfEra and YearOfCentury">
+<p>
+The definition of these varies by chronology:
+</p>
+<table border="1">
+<tr>
+<th></th>
+<th colspan="3">GJ</th>
+<th colspan="3">ISO</th>
+</tr><tr>
+<th>year of era</th>
+<th>year</th>
+<th>century of era</th>
+<th>year of century</th>
+<th>year</th>
+<th>century of era</th>
+<th>year of century</th>
+</tr><tr>
+<td align="center">101 BCE</td>
+<td align="center">-101</td>
+<td align="center">2</td>
+<td align="center">1</td>
+<td align="center">-100</td>
+<td align="center">1</td>
+<td align="center">0</td>
+</tr><tr>
+<td align="center">100 BCE</td>
+<td align="center">-100</td>
+<td align="center">1</td>
+<td align="center">100</td>
+<td align="center">-99</td>
+<td align="center">0</td>
+<td align="center">99</td>
+</tr><tr>
+<td align="center">99 BCE</td>
+<td align="center">-99</td>
+<td align="center">1</td>
+<td align="center">99</td>
+<td align="center">-98</td>
+<td align="center">0</td>
+<td align="center">98</td>
+</tr><tr>
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+</tr><tr>
+<td align="center">2 BCE</td>
+<td align="center">-2</td>
+<td align="center">1</td>
+<td align="center">2</td>
+<td align="center">-1</td>
+<td align="center">0</td>
+<td align="center">1</td>
+</tr><tr>
+<td align="center">1 BCE</td>
+<td align="center">-1</td>
+<td align="center">1</td>
+<td align="center">1</td>
+<td align="center">0</td>
+<td align="center">0</td>
+<td align="center">0</td>
+</tr><tr>
+<td align="center">1 CE</td>
+<td align="center">1</td>
+<td align="center">1</td>
+<td align="center">1</td>
+<td align="center">1</td>
+<td align="center">0</td>
+<td align="center">1</td>
+</tr><tr>
+<td align="center">2 CE</td>
+<td align="center">2</td>
+<td align="center">1</td>
+<td align="center">2</td>
+<td align="center">2</td>
+<td align="center">0</td>
+<td align="center">2</td>
+</tr><tr>
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+</tr><tr>
+<td align="center">99 CE</td>
+<td align="center">99</td>
+<td align="center">1</td>
+<td align="center">99</td>
+<td align="center">99</td>
+<td align="center">0</td>
+<td align="center">99</td>
+</tr><tr>
+<td align="center">100 CE</td>
+<td align="center">100</td>
+<td align="center">1</td>
+<td align="center">100</td>
+<td align="center">100</td>
+<td align="center">1</td>
+<td align="center">0</td>
+</tr><tr>
+<td align="center">101 CE</td>
+<td align="center">101</td>
+<td align="center">2</td>
+<td align="center">1</td>
+<td align="center">101</td>
+<td align="center">1</td>
+<td align="center">1</td>
+</tr><tr>
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+<td align="center">...</td>
+</tr><tr>
+<td align="center">1999 CE</td>
+<td align="center">1999</td>
+<td align="center">20</td>
+<td align="center">99</td>
+<td align="center">1999</td>
+<td align="center">19</td>
+<td align="center">99</td>
+</tr><tr>
+<td align="center">2000 CE</td>
+<td align="center">2000</td>
+<td align="center">20</td>
+<td align="center">100</td>
+<td align="center">2000</td>
+<td align="center">20</td>
+<td align="center">0</td>
+</tr><tr>
+<td align="center">2001 CE</td>
+<td align="center">2001</td>
+<td align="center">21</td>
+<td align="center">1</td>
+<td align="center">2001</td>
+<td align="center">20</td>
+<td align="center">1</td>
+</tr>
+</table>
+<p>
+For GJ this is consistent with phrases such '2003 is in the 21st century'.<br />
+For ISO this represents a straight split of a textual ISO8601 year.
+</p>
+</subsection>
+
+
+<a name="yearOfEra" />
+<subsection name="YearOfEra">
+<p>
+The year as generally known (always positive).
+Both the GJ and ISO chronologies return 1 for 1BC/BCE, 2 for 2BC/CBE etc.
+In other words there is no year zero and no negative value for this field.
+</p>
+</subsection>
+
+<a name="era" />
+<subsection name="Era">
+<p>
+The era expressed as a constant, zero for BC/BCE, one for AD/CE.
+</p>
+<p>
+Other chronologies should respect the convention that one is the current era and
+zero is the previous era.
+If more eras are required the values should increase numerically over time.
+</p>
+</subsection>
+
+</section>
+</body>
+</document>
diff --git a/JodaTime/xdocs/index.xml b/JodaTime/xdocs/index.xml
index e08e9de7e..9cd1e5c1a 100644
--- a/JodaTime/xdocs/index.xml
+++ b/JodaTime/xdocs/index.xml
@@ -75,13 +75,14 @@ which is an Apache/BSD cloned licence.
 
 <section name="Documentation">
 <p>
-The JavaDoc API documents are available online for the
-<a href="api-0.9/index.html">current release</a> and the
-<a href="apidocs/index.html">latest CVS</a>.
-</p>
-<p>
-The <a href="http://cvs.sourceforge.net/viewcvs.py/joda-time">CVS repository</a> can be browsed.
+Various documentation is available:
 </p>
+<ul>
+<li>The javadoc for the <a href="apidocs-release/index.html">current release</a></li>
+<li>The javadoc for the <a href="apidocs/index.html">latest CVS</a></li>
+<li>The <a href="http://cvs.sourceforge.net/viewcvs.py/joda-time/JodaTime">CVS repository</a></li>
+</ul>
+
 </section>
 
 <section name="Releases">
diff --git a/JodaTime/xdocs/navigation.xml b/JodaTime/xdocs/navigation.xml
index ce19cf8dd..4f2db9533 100644
--- a/JodaTime/xdocs/navigation.xml
+++ b/JodaTime/xdocs/navigation.xml
@@ -10,14 +10,15 @@
       <item name="Overview" href="/index.html"/>
       <item name="Users guide" href="/userguide.html"/>
       <item name="Sourceforge" href="http://sourceforge.net/projects/joda-time/"/>
-      <item name="Javadoc (0.9)" href="/api-0.9/index.html"/>
-      <item name="Javadoc (CVS)" href="/apidocs/index.html"/>
-      <item name="CVS" href="http://cvs.sourceforge.net/viewcvs.py/joda-time/"/>
+      <item name="Javadoc (Release)" href="/apidocs-release/index.html"/>
       <item name="Test results" href="/junit-report.html"/>
       <item name="Mailing lists" href="/mail-lists.html"/>
-      <item name="TODO" href="/tasks.html"/>
+      <item name="Tasks" href="/tasks.html"/>
       <item name="License" href="/license.html"/>
+      <item name="CVS" href="http://cvs.sourceforge.net/viewcvs.py/joda-time/JodaTime/"/>
+      <item name="Javadoc (CVS)" href="/apidocs/index.html"/>
     </menu>
+    
     <menu name="Joda">
       <item name="Joda home" href="http://joda.sourceforge.net"/>
       <item name="Beans" href="http://joda.sourceforge.net/beans.html"/>
diff --git a/JodaTime/xdocs/userguide.xml b/JodaTime/xdocs/userguide.xml
index af6c34f9c..5bf9f1871 100644
--- a/JodaTime/xdocs/userguide.xml
+++ b/JodaTime/xdocs/userguide.xml
@@ -34,6 +34,7 @@ The current chronologies supplied are:
 <li>ISOChronology - Implements the ISO8601 standard, which is compatible with Gregorian in modern times.</li>
 <li>GJChronology - The Gregorian/Julian calendar system, for historical use.</li>
 <li>BuddhistChronology - Offset from Gregorian/Julian by 543 years.</li>
+<li>CopticChronology - Offset from Gregorian/Julian by 284 years.</li>
 </ul>
 <p>
 It is hoped that other chronologies will be added over time.
@@ -68,7 +69,7 @@ The design principle is the same as the Java Collections Framework (List/Map/Set
 
 <p>
 The main date instance used is <a href="apidocs/org/joda/time/DateTime.html">DateTime</a>.
-This holds the millisecond time of the date and the chronology used to calculate the fields.
+This holds the millisecond time of the date and the chronology used to calculate the <a href="field.html">fields</a>.
 DateTime is immutable, and once created the values do not change.
 Thus, this class can safely be passed around and used in multiple threads without synchronization.
 </p>
@@ -88,7 +89,7 @@ Interoperability is also made simple via the <code>toDate()</code>, <code>toCale
 <section name="Properties">
 
 <p>
-The main API of DateTime has been kept small, limited to just get methods for each field.
+The main API of DateTime has been kept small, limited to just get methods for each <a href="field.html">field</a>.
 There is much more power available however through the use of <i>properties</i>.
 In addition to the <code>getDayOfYear()</code> method you will find <code>dayOfYear()</code>.
 This returns a <a href="apidocs/org/joda/time/property/DateTimeFieldProperty.html">property</a> with considerable functionality.