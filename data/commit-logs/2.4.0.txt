From aef185e1c238cc6c63dbe4678607f4ed73422e74 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Fri, 16 Aug 2013 18:43:49 +0100
Subject: [PATCH 01/86] Bump version

---
 RELEASE-NOTES.txt | 82 ++++-------------------------------------------
 pom.xml           |  2 +-
 2 files changed, 8 insertions(+), 76 deletions(-)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index fc2249f11..1a0c83324 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -1,4 +1,4 @@
-Joda-Time version 2.3
+Joda-Time version 2.4
 ---------------------
 
 Joda-Time is a date and time handling library that seeks to replace the JDK
@@ -16,30 +16,11 @@ of restrictions. If the license causes you problems please contact the mailing l
 ** http://www.joda.org/joda-time/related.html **
 
 
-Enhancements since 2.2
+Enhancements since 2.3
 ----------------------
-- Interval/MutableInterval .isEqual() [#20]
-  Add method to compare intervals ignoring the chronology
-  https://github.com/JodaOrg/joda-time/issues/20
 
-- Chronology classes now define equals methods [#36]
-  Previously, the Chronology classes relied on caching in factory methods
-  to guarantee instances were singletons
-  Now, there are dedicated, normal, equals methods
-  This will aid weird cases where deserialization or similar avoids the caches
-  It will make no difference to most users
 
-- Maximum size for pattern cache [#49]
-  Sets a maximum size for the cache to avoid memory issues
-
-- Add LocalDateTime.toDate(TimeZone) [#48]
-  Provides an alternate way to create a java.util.Date that avoids some synchronization
-
-- Home page moved
-  http://www.joda.org/joda-time
-
-
-Compatibility with 2.2
+Compatibility with 2.3
 ----------------------
 Build system - Yes
 
@@ -52,64 +33,15 @@ Serialization compatible - Yes
 Data compatible - Yes, except
  - DateTimeZone data updated to version 2013d
 
-Semantic compatible - Yes, except
- - DateTimeZone is now limited to offsets from -23:59:59.999 to +23:59:59.999
+Semantic compatible - Yes
 
- - BasicChronology now defines an equals method
-   This which would affect you if you subclassed it (unlikely)
 
- - GJChronology now has a minimum cutover instant of 0001-01-01 (Gregorian)
-   Its unlikely you have it set earlier than this
-   If you did your code was broken anyway
-
-
-Deprecations since 2.2
+Deprecations since 2.3
 ----------------------
-- DateMidnight [#41]
-  This class is flawed in concept
-  The time of midnight occasionally does not occur in some time-zones
-  This is a result of a daylight savings time from 00:00 to 01:00
-  DateMidnight is essentially a DateTime with a time locked to midnight
-  Such a concept is more generally a poor one to use, given LocalDate
-  Replace DateMidnight with LocalDate
-  Or replace it with DateTime, perhaps using the withTimeAtStartOfDay() method
 
 
-Bug fixes since 2.2
+Bug fixes since 2.3
 -------------------
-- ZoneInfoCompiler and DateTimeZoneBuilder multi-threading [#18]
-  A thread local variable was previously only initialised in one thread causing NPE
-  https://github.com/JodaOrg/joda-time/issues/18
-
-- Short time-zone name parsing failed to match the longest name
-  This affected two short names where one is a short form of the second such as "UT" and "UTC"
-
-- Days.daysBetween fails for MonthDay [#22]
-  Incorrect calculation around leap years
-
-- DateTimeZone failed to validate offsets [#43]
-  Previously, there was little validation, resulting in the ability to create large offsets
-  Those offsets could fail in other parts of the library
-  Now, it is limited to -23:59:59.999 to +23:59:59.999
-
-- DateTimeZone.forOffsetHoursMinutes failed to allow offsets from -00:01 to -00:59 [#42]
-  The forOffsetHoursMinutes() method could not create an offset  from -00:01 to -00:59
-  This was due to an inappropriate design
-  A backwards compatible change to the input handling has been made
-  forOffsetHoursMinutes(0, -15) now creates -00:15
-
-- DateTimeFormatter.parseInto [#21]
-  Fix parseInto() where it obtains the default year for parsing from the ReadWritableInstant
-  Previously, the wrong year could be obtained at the start or end of the year in non UTC zones
-  Now obtains the year from the ReadWritableInstant using the chronology of the ReadWritableInstant
-
-- Better thread-safety in ISODateTimeFormat [#45]
-
-- Fix GJChronology.plus/minus across cutover and year zero [#28]
-  When subtracting a number of years from a date in the GJChronology there are two considerations
-  The cutover date might be crossed, and year zero might be crossed (there is no year zero in GJ)
-  Previously, each were handled separately, but not together. Now it is fixed
-  As part of this change, the minimum cutover instant was set to 0001-01-01 (Gregorian)
 
 
 Scala
@@ -127,4 +59,4 @@ https://github.com/JodaOrg/joda-time/
 Feedback is also welcomed via the joda-interest mailing list.
 
 The Joda team
-http://joda-time.sourceforge.net
+http://www.joda.org/joda-time/
diff --git a/pom.xml b/pom.xml
index eb2e4c095..732aa5b17 100644
--- a/pom.xml
+++ b/pom.xml
@@ -9,7 +9,7 @@
   <artifactId>joda-time</artifactId>
   <packaging>jar</packaging>
   <name>Joda-Time</name>
-  <version>2.3</version>
+  <version>2.4-SNAPSHOT</version>
   <description>Date and time library to replace JDK date handling</description>
   <url>http://www.joda.org/joda-time/</url>
 

From 2e3dd4492d3abc7ee89066c35cf05f01a064bdbc Mon Sep 17 00:00:00 2001
From: RenniePet <rp@merlinia.com>
Date: Sat, 17 Aug 2013 14:59:59 +0200
Subject: [PATCH 02/86] One too many "are"s in the heading.

---
 src/site/xdoc/faq.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/site/xdoc/faq.xml b/src/site/xdoc/faq.xml
index b749d86bf..6f8488338 100644
--- a/src/site/xdoc/faq.xml
+++ b/src/site/xdoc/faq.xml
@@ -68,7 +68,7 @@ Hopefully this FAQ has explained what the error means allowing you to work out w
 
 
 <a name="rulesoutofdate" />
-<subsection name="Are the time-zone rules are out of date?">
+<subsection name="Are the time-zone rules out of date?">
 <p>
 Joda-Time releases only occur infrequently.
 But time-zone changes happen all the time.

From f6a98adcf40dfe56cd1f0f3188c760e3e3141c63 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Mon, 19 Aug 2013 12:15:10 +0100
Subject: [PATCH 03/86] Minor tidy

---
 src/site/site.xml                                |  4 ++--
 src/site/xdoc/index.xml                          |  4 ++--
 src/site/xdoc/userguide.xml                      | 10 +++++-----
 src/test/java/org/joda/time/TestAllPackages.java |  8 ++------
 4 files changed, 11 insertions(+), 15 deletions(-)

diff --git a/src/site/site.xml b/src/site/site.xml
index 1b8ab6657..ea42d5050 100644
--- a/src/site/site.xml
+++ b/src/site/site.xml
@@ -18,7 +18,7 @@
       <item name="I18N" href="http://www.joda.org/joda-time-i18n/"/>
     </links>
 
-    <menu name="Joda Time">
+    <menu name="Joda-Time">
       <item name="Overview" href="index.html"/>
       <item name="Quick start guide" href="quickstart.html"/>
       <item name="User guide" href="userguide.html"/>
@@ -52,8 +52,8 @@
 
     <menu name="Development">
       <item name="GitHub" href="https://github.com/JodaOrg/joda-time"/>
+      <item name="Bugs/Issues" href="https://github.com/JodaOrg/joda-time/issues"/>
       <item name="Test results" href="surefire-report.html"/>
-      <item name="Mailing lists" href="mail-lists.html"/>
       <item name="Sourceforge" href="http://sourceforge.net/projects/joda-time/"/>
     </menu>
 
diff --git a/src/site/xdoc/index.xml b/src/site/xdoc/index.xml
index ba85bae14..51917214f 100644
--- a/src/site/xdoc/index.xml
+++ b/src/site/xdoc/index.xml
@@ -10,7 +10,7 @@
 
  <body>
 
-<section name="Joda Time - Java date and time API">
+<section name="Joda-Time - Java date and time API">
 <p>
 Joda-Time provides a quality replacement for the Java <em>date</em>
 and <em>time</em> classes. The design allows for multiple <em>calendar</em>
@@ -60,7 +60,7 @@ Version 2.3 was released on 2013-08-16 -
 </section>
 
 
-<section name="Why Joda Time?">
+<section name="Why Joda-Time?">
 <p>
 Joda-Time has been created to radically change date and time handling in Java.
 The JDK classes Date and Calendar are very badly designed, have had numerous bugs
diff --git a/src/site/xdoc/userguide.xml b/src/site/xdoc/userguide.xml
index 576a311a2..6c97a6745 100644
--- a/src/site/xdoc/userguide.xml
+++ b/src/site/xdoc/userguide.xml
@@ -12,7 +12,7 @@
 
 <section name="Introduction">
 <p>
-Joda Time is like an iceberg, 9/10ths of it is invisible to user-code.
+Joda-Time is like an iceberg, 9/10ths of it is invisible to user-code.
 Many, perhaps most, applications will never need to see what's below the surface.
 This document provides an introduction to the Joda-Time API for the
 average user, not for the would-be API developer.
@@ -101,7 +101,7 @@ more advanced topics.
 
 <section name="Architecture Overview">
 <p>
-The major building blocks of joda time are introduced below. These are the concepts
+The major building blocks of Joda-Time are introduced below. These are the concepts
 of <em>instant</em>, <em>interval</em>, <em>duration</em>, <em>period</em>,
 <em>chronology</em> and <em>timezones</em>. We then say a few words about the role
 of interfaces in the library design, which is a little different than the norm. We
@@ -821,7 +821,7 @@ today, in particular the ISO8601. These must also be supported by most datetime
 applications.
 </p>
 <p>
-Joda time supports these different requirements through a flexible architecture.
+Joda-Time supports these different requirements through a flexible architecture.
 We will now describe the various elements of this architecture.
 </p>
 
@@ -889,7 +889,7 @@ Formatters are immutable, so the original is not altered by the
 <subsection name="Freaky Formatters">
 <p>
 Finally, if you have a format that is not easily represented by a pattern string,
-Joda Time architecture exposes a builder class that can be used to build a custom
+Joda-Time architecture exposes a builder class that can be used to build a custom
 formatter which is programatically defined. Thus if you wanted a formatter to
 print and parse dates of the form "22-Jan-65", you could do the following:
 <source>
@@ -912,7 +912,7 @@ the interpretation of a two digit year is ambiguous, the
 range of the two digits, by specifying the mid point of the range. In this example
 the range will be (1956 - 50) = 1906, to (1956 + 49) = 2005. Thus 04 will be 2004
 but 07 will be 1907. This kind of conversion is not possible with ordinary format
-strings, highlighting the power of the Joda time formatting architecture.
+strings, highlighting the power of the Joda-Time formatting architecture.
 </p>
 </subsection>
 
diff --git a/src/test/java/org/joda/time/TestAllPackages.java b/src/test/java/org/joda/time/TestAllPackages.java
index 2395dd540..81f9d7ced 100644
--- a/src/test/java/org/joda/time/TestAllPackages.java
+++ b/src/test/java/org/joda/time/TestAllPackages.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2011 Stephen Colebourne
+ *  Copyright 2001-2013 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -23,11 +23,7 @@
 import junit.framework.TestSuite;
 
 /**
- * Entry point for all tests in Joda Time.
- * 
- * @version $Revision$ $Date$
- * 
- * @author Stephen Colebourne
+ * Entry point for all tests in Joda-Time.
  */
 public class TestAllPackages extends TestCase {
 

From 878d057f2f5187950152497efcbbecf05980eefa Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Thu, 12 Sep 2013 12:20:54 +0100
Subject: [PATCH 04/86] Enhance Javadoc wrt parsing of format patterns

Fixes #60
---
 RELEASE-NOTES.txt                                      | 1 +
 src/main/java/org/joda/time/format/DateTimeFormat.java | 5 +++--
 2 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 1a0c83324..cfcbb6d9e 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -42,6 +42,7 @@ Deprecations since 2.3
 
 Bug fixes since 2.3
 -------------------
+- Better Javadoc for parsing of numbers in format patterns [#60]
 
 
 Scala
diff --git a/src/main/java/org/joda/time/format/DateTimeFormat.java b/src/main/java/org/joda/time/format/DateTimeFormat.java
index 79f979a40..961b7e60d 100644
--- a/src/main/java/org/joda/time/format/DateTimeFormat.java
+++ b/src/main/java/org/joda/time/format/DateTimeFormat.java
@@ -95,8 +95,9 @@
  * the full form is used; otherwise a short or abbreviated form is used if
  * available.
  * <p>
- * <strong>Number</strong>: The minimum number of digits. Shorter numbers
- * are zero-padded to this amount.
+ * <strong>Number</strong>: The minimum number of digits.
+ * Shorter numbers are zero-padded to this amount.
+ * When parsing, any number of digits are accepted.
  * <p>
  * <strong>Year</strong>: Numeric presentation for year and weekyear fields
  * are handled specially. For example, if the count of 'y' is 2, the year

From 55876b98250c1afaf23be12fb5fc4bd3677abbce Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Thu, 12 Sep 2013 15:48:16 +0100
Subject: [PATCH 05/86] Remove uncaughtException calls

Previously the code called ThreadGroup.uncaughtException() which was invalid
Now it throws a RuntimeException or logs to System.err
Fixes #59
---
 RELEASE-NOTES.txt                             |  3 ++
 src/main/java/org/joda/time/DateTimeZone.java | 12 +++----
 .../org/joda/time/tz/ZoneInfoProvider.java    |  8 ++---
 .../java/org/joda/time/TestDateTimeZone.java  | 36 ++++++++-----------
 4 files changed, 24 insertions(+), 35 deletions(-)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index cfcbb6d9e..685720305 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -44,6 +44,9 @@ Bug fixes since 2.3
 -------------------
 - Better Javadoc for parsing of numbers in format patterns [#60]
 
+- Remove uncaughtException calls [#59]
+  Previously the code called ThreadGroup.uncaughtException() which was invalid
+
 
 Scala
 --------
diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java
index 3691ec98f..19fbc8648 100644
--- a/src/main/java/org/joda/time/DateTimeZone.java
+++ b/src/main/java/org/joda/time/DateTimeZone.java
@@ -471,14 +471,12 @@ private static Provider getDefaultProvider() {
         Provider provider = null;
 
         try {
-            String providerClass =
-                System.getProperty("org.joda.time.DateTimeZone.Provider");
+            String providerClass = System.getProperty("org.joda.time.DateTimeZone.Provider");
             if (providerClass != null) {
                 try {
                     provider = (Provider) Class.forName(providerClass).newInstance();
                 } catch (Exception ex) {
-                    Thread thread = Thread.currentThread();
-                    thread.getThreadGroup().uncaughtException(thread, ex);
+                    throw new RuntimeException(ex);
                 }
             }
         } catch (SecurityException ex) {
@@ -489,8 +487,7 @@ private static Provider getDefaultProvider() {
             try {
                 provider = new ZoneInfoProvider("org/joda/time/tz/data");
             } catch (Exception ex) {
-                Thread thread = Thread.currentThread();
-                thread.getThreadGroup().uncaughtException(thread, ex);
+                ex.printStackTrace();
             }
         }
 
@@ -561,8 +558,7 @@ private static NameProvider getDefaultNameProvider() {
                 try {
                     nameProvider = (NameProvider) Class.forName(providerClass).newInstance();
                 } catch (Exception ex) {
-                    Thread thread = Thread.currentThread();
-                    thread.getThreadGroup().uncaughtException(thread, ex);
+                    throw new RuntimeException(ex);
                 }
             }
         } catch (SecurityException ex) {
diff --git a/src/main/java/org/joda/time/tz/ZoneInfoProvider.java b/src/main/java/org/joda/time/tz/ZoneInfoProvider.java
index 1903ca046..455880887 100644
--- a/src/main/java/org/joda/time/tz/ZoneInfoProvider.java
+++ b/src/main/java/org/joda/time/tz/ZoneInfoProvider.java
@@ -125,9 +125,8 @@ private ZoneInfoProvider(String resourcePath,
 
     //-----------------------------------------------------------------------
     /**
-     * If an error is thrown while loading zone data, uncaughtException is
-     * called to log the error and null is returned for this and all future
-     * requests.
+     * If an error is thrown while loading zone data, the exception is logged
+     * to system error and null is returned for this and all future requests.
      * 
      * @param id  the id to load
      * @return the loaded zone
@@ -180,8 +179,7 @@ public DateTimeZone getZone(String id) {
      * @param ex  the exception
      */
     protected void uncaughtException(Exception ex) {
-        Thread t = Thread.currentThread();
-        t.getThreadGroup().uncaughtException(t, ex);
+        ex.printStackTrace();
     }
 
     /**
diff --git a/src/test/java/org/joda/time/TestDateTimeZone.java b/src/test/java/org/joda/time/TestDateTimeZone.java
index cec86cd43..d5d31f7cf 100644
--- a/src/test/java/org/joda/time/TestDateTimeZone.java
+++ b/src/test/java/org/joda/time/TestDateTimeZone.java
@@ -458,23 +458,19 @@ public void testProvider() {
             DateTimeZone.setProvider(null);
             assertEquals(ZoneInfoProvider.class, DateTimeZone.getProvider().getClass());
         }
-        
-        PrintStream syserr = System.err;
+    }
+
+    public void testProvider_badClassName() {
         try {
             System.setProperty("org.joda.time.DateTimeZone.Provider", "xxx");
-            ByteArrayOutputStream baos = new ByteArrayOutputStream();
-            System.setErr(new PrintStream(baos));
-            
             DateTimeZone.setProvider(null);
             
+        } catch (RuntimeException ex) {
+            // expected
             assertEquals(ZoneInfoProvider.class, DateTimeZone.getProvider().getClass());
-            String str = new String(baos.toByteArray());
-            assertTrue(str.indexOf("java.lang.ClassNotFoundException") >= 0);
         } finally {
-            System.setErr(syserr);
             System.getProperties().remove("org.joda.time.DateTimeZone.Provider");
             DateTimeZone.setProvider(null);
-            assertEquals(ZoneInfoProvider.class, DateTimeZone.getProvider().getClass());
         }
     }
     
@@ -572,26 +568,22 @@ public void testNameProvider() {
             DateTimeZone.setNameProvider(null);
             assertEquals(DefaultNameProvider.class, DateTimeZone.getNameProvider().getClass());
         }
-        
-        PrintStream syserr = System.err;
+    }
+
+    public void testNameProvider_badClassName() {
         try {
             System.setProperty("org.joda.time.DateTimeZone.NameProvider", "xxx");
-            ByteArrayOutputStream baos = new ByteArrayOutputStream();
-            System.setErr(new PrintStream(baos));
-            
-            DateTimeZone.setNameProvider(null);
+            DateTimeZone.setProvider(null);
             
+        } catch (RuntimeException ex) {
+            // expected
             assertEquals(DefaultNameProvider.class, DateTimeZone.getNameProvider().getClass());
-            String str = new String(baos.toByteArray());
-            assertTrue(str.indexOf("java.lang.ClassNotFoundException") >= 0);
         } finally {
-            System.setErr(syserr);
             System.getProperties().remove("org.joda.time.DateTimeZone.NameProvider");
-            DateTimeZone.setNameProvider(null);
-            assertEquals(DefaultNameProvider.class, DateTimeZone.getNameProvider().getClass());
+            DateTimeZone.setProvider(null);
         }
-    }        
-    
+    }
+
     public void testNameProviderSecurity() {
         if (OLD_JDK) {
             return;

From c23a46bb0540976f7c40f50a35a27f5be8d79429 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Fri, 13 Sep 2013 10:15:15 +0100
Subject: [PATCH 06/86] Better description of ISO printing/parsing

See #60
---
 src/main/java/org/joda/time/format/ISODateTimeFormat.java | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/src/main/java/org/joda/time/format/ISODateTimeFormat.java b/src/main/java/org/joda/time/format/ISODateTimeFormat.java
index c849d16bc..a49381e9f 100644
--- a/src/main/java/org/joda/time/format/ISODateTimeFormat.java
+++ b/src/main/java/org/joda/time/format/ISODateTimeFormat.java
@@ -22,9 +22,9 @@
 import org.joda.time.DateTimeFieldType;
 
 /**
- * Factory that creates instances of DateTimeFormatter for the ISO8601 standard.
+ * Factory that creates instances of DateTimeFormatter based on the ISO8601 standard.
  * <p>
- * Datetime formatting is performed by the {@link DateTimeFormatter} class.
+ * Date-time formatting is performed by the {@link DateTimeFormatter} class.
  * Three classes provide factory methods to create formatters, and this is one.
  * The others are {@link DateTimeFormat} and {@link DateTimeFormatterBuilder}.
  * <p>
@@ -40,6 +40,10 @@
  * String str = fmt.print(dt);
  * </pre>
  * <p>
+ * Note that these formatters mostly follow the ISO-8601 standard for printing.
+ * For parsing, the formatters are more lenient and allow formats that are not
+ * in strict compliance with the standard.
+ * <p>
  * It is important to understand that these formatters are not linked to
  * the <code>ISOChronology</code>. These formatters may be used with any
  * chronology, however there may be certain side effects with more unusual

From 13d3ea10dea99f1e6bbac06e18da450fe1e9add2 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 14 Sep 2013 16:46:29 +0100
Subject: [PATCH 07/86] Use ISO8601 for consistency with rest of Joda-Time

See #60
---
 src/main/java/org/joda/time/format/ISODateTimeFormat.java | 2 +-
 src/main/java/org/joda/time/package.html                  | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/main/java/org/joda/time/format/ISODateTimeFormat.java b/src/main/java/org/joda/time/format/ISODateTimeFormat.java
index a49381e9f..af53ee4fc 100644
--- a/src/main/java/org/joda/time/format/ISODateTimeFormat.java
+++ b/src/main/java/org/joda/time/format/ISODateTimeFormat.java
@@ -40,7 +40,7 @@
  * String str = fmt.print(dt);
  * </pre>
  * <p>
- * Note that these formatters mostly follow the ISO-8601 standard for printing.
+ * Note that these formatters mostly follow the ISO8601 standard for printing.
  * For parsing, the formatters are more lenient and allow formats that are not
  * in strict compliance with the standard.
  * <p>
diff --git a/src/main/java/org/joda/time/package.html b/src/main/java/org/joda/time/package.html
index da3eed1bf..6a72a5929 100644
--- a/src/main/java/org/joda/time/package.html
+++ b/src/main/java/org/joda/time/package.html
@@ -68,7 +68,7 @@ <h4>Implementations</h4>
 <code>Instant</code>. This is a simple immutable class that stores the
 millisecond value and integrates with Java Date and Calendar.
 The class follows the definition of the millisecond instant fully, thus
-it references the ISO-8601 calendar system and UTC time zone.
+it references the ISO8601 calendar system and UTC time zone.
 If you are dealing with an instant in time but do not know, or do not want to specify,
 which calendar system it refers to, then you should use this class.
 </p>

From 970139e65c754536b95a2b706f65ad3484ba68f5 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Fri, 27 Sep 2013 08:15:20 -0700
Subject: [PATCH 08/86] Fix README reference to change notes

See #66
---
 README.md | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/README.md b/README.md
index 59122d501..3fad88bfe 100644
--- a/README.md
+++ b/README.md
@@ -42,8 +42,7 @@ Various documentation is available:
 * Two user guides - [quick](http://www.joda.org/joda-time/quickstart.html) and [full](http://www.joda.org/joda-time/userguide.html)
 * The [Javadoc](http://www.joda.org/joda-time/apidocs/index.html)
 * The [FAQ](http://www.joda.org/joda-time/faq.html) list
-* The change notes for the [releases](http://www.joda.org/joda-time/changes-report.html)
-* Information on [downloading and installing](http://www.joda.org/joda-time/installation.html) Joda-Time
+* Information on [downloading and installing](http://www.joda.org/joda-time/installation.html) Joda-Time including release notes
 
 
 ### Releases

From 229c7d01edb902fa093ea36ee5ca2f21409d9a95 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Fri, 27 Sep 2013 08:16:32 -0700
Subject: [PATCH 09/86] Enhance home page link to release notes

Fixes #66
---
 src/site/xdoc/index.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/site/xdoc/index.xml b/src/site/xdoc/index.xml
index 51917214f..1aa869b43 100644
--- a/src/site/xdoc/index.xml
+++ b/src/site/xdoc/index.xml
@@ -130,7 +130,7 @@ Various documentation is available:
 <li>Two user guides - <a href="quickstart.html">quick</a> and <a href="userguide.html">full</a></li>
 <li>The key concepts and chronology documents in the left navigation area</li>
 <li>The <a href="apidocs/index.html">Javadoc</a></li>
-<li>Information on <a href="installation.html">downloading and installing</a> Joda-Time</li>
+<li>Information on <a href="installation.html">downloading and installing</a> Joda-Time including release notes</li>
 <li>The <a href="faq.html">FAQ</a> list</li>
 <li>The <a href="https://github.com/JodaOrg/joda-time">GitHub</a> source repository</li>
 </ul>

From fba9e5e62a5c7dc3f9c480b2862010c7a322a2d3 Mon Sep 17 00:00:00 2001
From: Vsevolod Ivanov <vi@touchin.ru>
Date: Tue, 1 Oct 2013 17:20:39 +0400
Subject: [PATCH 10/86] caches should not be serialized

---
 src/main/java/org/joda/time/tz/CachedDateTimeZone.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/main/java/org/joda/time/tz/CachedDateTimeZone.java b/src/main/java/org/joda/time/tz/CachedDateTimeZone.java
index b6aa0d323..5ffcd7709 100644
--- a/src/main/java/org/joda/time/tz/CachedDateTimeZone.java
+++ b/src/main/java/org/joda/time/tz/CachedDateTimeZone.java
@@ -81,7 +81,7 @@ public static CachedDateTimeZone forZone(DateTimeZone zone) {
 
     private final DateTimeZone iZone;
 
-    private final Info[] iInfoCache = new Info[cInfoCacheMask + 1];
+    private final transient Info[] iInfoCache = new Info[cInfoCacheMask + 1];
 
     private CachedDateTimeZone(DateTimeZone zone) {
         super(zone.getID());

From 6fbb9bc9ad13012a429c970b19b50a22f8dbebdb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Bj=C3=B6rn=20Pollex?= <bjoern.pollex@googlemail.com>
Date: Tue, 1 Oct 2013 23:07:08 +0200
Subject: [PATCH 11/86] Added tests and implementation for
 `Duration.multipliedBy(long factor)`

---
 src/main/java/org/joda/time/Duration.java           |  7 +++++++
 .../java/org/joda/time/TestDuration_Basics.java     | 13 +++++++++++++
 2 files changed, 20 insertions(+)

diff --git a/src/main/java/org/joda/time/Duration.java b/src/main/java/org/joda/time/Duration.java
index fd6f63b33..346c40024 100644
--- a/src/main/java/org/joda/time/Duration.java
+++ b/src/main/java/org/joda/time/Duration.java
@@ -470,4 +470,11 @@ public Duration minus(ReadableDuration amount) {
         return withDurationAdded(amount.getMillis(), -1);
     }
 
+    public Duration multipliedBy(long factor)
+    {
+        if(factor == 1)
+            return this;
+        return new Duration(FieldUtils.safeMultiply(getMillis(), factor));
+    }
+
 }
diff --git a/src/test/java/org/joda/time/TestDuration_Basics.java b/src/test/java/org/joda/time/TestDuration_Basics.java
index 5850b5613..54a42875b 100644
--- a/src/test/java/org/joda/time/TestDuration_Basics.java
+++ b/src/test/java/org/joda/time/TestDuration_Basics.java
@@ -678,6 +678,19 @@ public void testMinus_long2() {
         assertSame(test, result);
     }
 
+    //-----------------------------------------------------------------------
+    public void testMul_long1() {
+        Duration test = new Duration(123L);
+        Duration result = test.multipliedBy(2L);
+        assertEquals(246L, result.getMillis());
+    }
+
+    public void testMul_long2() {
+        Duration test = new Duration(123L);
+        Duration result = test.multipliedBy(1L);
+        assertSame(test, result);
+    }
+
     //-----------------------------------------------------------------------
     public void testWithDurationAdded_RD_int1() {
         Duration test = new Duration(123L);

From 6d8d6e625dc76b8d2fbcc7ee8c9e15402f2c7ca7 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Bj=C3=B6rn=20Pollex?= <bjoern.pollex@googlemail.com>
Date: Tue, 1 Oct 2013 23:34:30 +0200
Subject: [PATCH 12/86] * added tests and implementation for
 `Duration.dividedBy(long divisor)` * added tests and implementation for
 `FieldUtils.safeDivide` * renamed multiplication tests to match method name *
 renamed parameter name of `Duration.multipliedBy` to match Java 8 API

---
 src/main/java/org/joda/time/Duration.java     | 13 ++++++--
 .../java/org/joda/time/field/FieldUtils.java  |  7 +++++
 .../org/joda/time/TestDuration_Basics.java    | 17 +++++++++--
 .../org/joda/time/field/TestFieldUtils.java   | 30 +++++++++++++++++++
 4 files changed, 62 insertions(+), 5 deletions(-)

diff --git a/src/main/java/org/joda/time/Duration.java b/src/main/java/org/joda/time/Duration.java
index 346c40024..e0c9af6bd 100644
--- a/src/main/java/org/joda/time/Duration.java
+++ b/src/main/java/org/joda/time/Duration.java
@@ -470,11 +470,18 @@ public Duration minus(ReadableDuration amount) {
         return withDurationAdded(amount.getMillis(), -1);
     }
 
-    public Duration multipliedBy(long factor)
+    public Duration multipliedBy(long multiplicant)
     {
-        if(factor == 1)
+        if(multiplicant == 1)
             return this;
-        return new Duration(FieldUtils.safeMultiply(getMillis(), factor));
+        return new Duration(FieldUtils.safeMultiply(getMillis(), multiplicant));
+    }
+
+    public Duration dividedBy(long divisor)
+    {
+        if(divisor == 1)
+            return this;
+        return new Duration(FieldUtils.safeDivide(getMillis(), divisor));
     }
 
 }
diff --git a/src/main/java/org/joda/time/field/FieldUtils.java b/src/main/java/org/joda/time/field/FieldUtils.java
index 1e045b22a..34ab47a45 100644
--- a/src/main/java/org/joda/time/field/FieldUtils.java
+++ b/src/main/java/org/joda/time/field/FieldUtils.java
@@ -327,4 +327,11 @@ public static boolean equals(Object object1, Object object2) {
         return object1.equals(object2);
     }
 
+    public static long safeDivide(long dividend, long divisor)
+    {
+        if(dividend == Long.MIN_VALUE && divisor == -1L)
+            throw new ArithmeticException("Multiplication overflows a long: " + dividend + " / " + divisor);
+        return dividend / divisor;
+    }
+
 }
diff --git a/src/test/java/org/joda/time/TestDuration_Basics.java b/src/test/java/org/joda/time/TestDuration_Basics.java
index 54a42875b..a67be8674 100644
--- a/src/test/java/org/joda/time/TestDuration_Basics.java
+++ b/src/test/java/org/joda/time/TestDuration_Basics.java
@@ -679,18 +679,31 @@ public void testMinus_long2() {
     }
 
     //-----------------------------------------------------------------------
-    public void testMul_long1() {
+    public void testMultipliedBy_long1() {
         Duration test = new Duration(123L);
         Duration result = test.multipliedBy(2L);
         assertEquals(246L, result.getMillis());
     }
 
-    public void testMul_long2() {
+    public void testMultipliedBy_long2() {
         Duration test = new Duration(123L);
         Duration result = test.multipliedBy(1L);
         assertSame(test, result);
     }
 
+    //-----------------------------------------------------------------------
+    public void testDividedBy_long1() {
+        Duration test = new Duration(246L);
+        Duration result = test.dividedBy(2L);
+        assertEquals(123L, result.getMillis());
+    }
+
+    public void testDividedBy_long2() {
+        Duration test = new Duration(123L);
+        Duration result = test.dividedBy(1L);
+        assertSame(test, result);
+    }
+
     //-----------------------------------------------------------------------
     public void testWithDurationAdded_RD_int1() {
         Duration test = new Duration(123L);
diff --git a/src/test/java/org/joda/time/field/TestFieldUtils.java b/src/test/java/org/joda/time/field/TestFieldUtils.java
index e60d1923a..5c8395703 100644
--- a/src/test/java/org/joda/time/field/TestFieldUtils.java
+++ b/src/test/java/org/joda/time/field/TestFieldUtils.java
@@ -280,5 +280,35 @@ public void testSafeMultiplyLongInt() {
         } catch (ArithmeticException e) {
         }
     }
+
+    //-----------------------------------------------------------------------
+    public void testSafeDivideLongLong() {
+        assertEquals(1L, FieldUtils.safeDivide(1L, 1L));
+        
+        assertEquals(1L, FieldUtils.safeDivide(3L, 3L));
+        assertEquals(0L, FieldUtils.safeDivide(1L, 3L));
+        assertEquals(3L, FieldUtils.safeDivide(3L, 1L));
+        
+        assertEquals(2L, FieldUtils.safeDivide(6L, 3L));
+        assertEquals(-2L, FieldUtils.safeDivide(6L, -3L));
+        assertEquals(-2L, FieldUtils.safeDivide(-6L, 3L));
+        assertEquals(2L, FieldUtils.safeDivide(-6L, -3L));
+        
+        assertEquals(Long.MAX_VALUE, FieldUtils.safeDivide(Long.MAX_VALUE, 1L));
+        assertEquals(Long.MIN_VALUE, FieldUtils.safeDivide(Long.MIN_VALUE, 1L));
+        assertEquals(-Long.MAX_VALUE, FieldUtils.safeDivide(Long.MAX_VALUE, -1L));
+        
+        try {
+            FieldUtils.safeDivide(Long.MIN_VALUE, -1L);
+            fail();
+        } catch (ArithmeticException e) {
+        }
+        
+        try {
+            FieldUtils.safeDivide(1L, 0L);
+            fail();
+        } catch (ArithmeticException e) {
+        }
+    }
 }
 

From bd39d516521f3346067c7e54c3ecc4809c695d2c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Bj=C3=B6rn=20Pollex?= <bjoern.pollex@googlemail.com>
Date: Tue, 1 Oct 2013 23:40:11 +0200
Subject: [PATCH 13/86] added tests and implementation of `Duration.negated()`

---
 src/main/java/org/joda/time/Duration.java     |  7 ++++++
 .../org/joda/time/TestDuration_Basics.java    | 23 +++++++++++++++++++
 2 files changed, 30 insertions(+)

diff --git a/src/main/java/org/joda/time/Duration.java b/src/main/java/org/joda/time/Duration.java
index e0c9af6bd..3aafd274d 100644
--- a/src/main/java/org/joda/time/Duration.java
+++ b/src/main/java/org/joda/time/Duration.java
@@ -484,4 +484,11 @@ public Duration dividedBy(long divisor)
         return new Duration(FieldUtils.safeDivide(getMillis(), divisor));
     }
 
+    public Duration negated()
+    {
+        if(getMillis() == Long.MIN_VALUE)
+            throw new ArithmeticException("Negation of this duration would overflow");
+        return new Duration(-getMillis());
+    }
+
 }
diff --git a/src/test/java/org/joda/time/TestDuration_Basics.java b/src/test/java/org/joda/time/TestDuration_Basics.java
index a67be8674..4483b5b29 100644
--- a/src/test/java/org/joda/time/TestDuration_Basics.java
+++ b/src/test/java/org/joda/time/TestDuration_Basics.java
@@ -704,6 +704,29 @@ public void testDividedBy_long2() {
         assertSame(test, result);
     }
 
+    //-----------------------------------------------------------------------
+    public void testNegated_long1() {
+        Duration test = new Duration(246L);
+        Duration result = test.negated();
+        assertEquals(-246L, result.getMillis());
+    }
+
+    public void testNegated_long2() {
+        Duration test = new Duration(-246L);
+        Duration result = test.negated();
+        assertEquals(246L, result.getMillis());
+    }
+
+    public void testNegated_long3() {
+        Duration test = new Duration(Long.MIN_VALUE);
+        try {
+            test.negated();
+            fail();
+        } catch(ArithmeticException e) {
+            // expected
+        }
+    }
+
     //-----------------------------------------------------------------------
     public void testWithDurationAdded_RD_int1() {
         Duration test = new Duration(123L);

From 57e51720a8383744ef577a14a08eb7ef10cc8fb2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Bj=C3=B6rn=20Pollex?= <bjoern.pollex@googlemail.com>
Date: Wed, 2 Oct 2013 00:07:11 +0200
Subject: [PATCH 14/86] added documentation for all newly introduced methods

---
 src/main/java/org/joda/time/Duration.java     | 32 +++++++++++++++++--
 .../java/org/joda/time/field/FieldUtils.java  | 23 +++++++++----
 2 files changed, 45 insertions(+), 10 deletions(-)

diff --git a/src/main/java/org/joda/time/Duration.java b/src/main/java/org/joda/time/Duration.java
index 3aafd274d..8f0e7895b 100644
--- a/src/main/java/org/joda/time/Duration.java
+++ b/src/main/java/org/joda/time/Duration.java
@@ -470,13 +470,33 @@ public Duration minus(ReadableDuration amount) {
         return withDurationAdded(amount.getMillis(), -1);
     }
 
-    public Duration multipliedBy(long multiplicant)
+    /**
+     * Returns a new duration with this length multiplied by the 
+     * specified multiplicand.
+     * This instance is immutable and is not altered.
+     * <p>
+     * If the multiplicand is one, this instance is returned.
+     * 
+     * @param multiplicand  the multiplicand to multiply this one by
+     * @return the new duration instance
+     */
+    public Duration multipliedBy(long multiplicand)
     {
-        if(multiplicant == 1)
+        if(multiplicand == 1)
             return this;
-        return new Duration(FieldUtils.safeMultiply(getMillis(), multiplicant));
+        return new Duration(FieldUtils.safeMultiply(getMillis(), multiplicand));
     }
 
+    /**
+     * Returns a new duration with this length divided by the 
+     * specified divisor.
+     * This instance is immutable and is not altered.
+     * <p>
+     * If the divisor is one, this instance is returned.
+     * 
+     * @param divisor  the divisor to divide this one by
+     * @return the new duration instance
+     */
     public Duration dividedBy(long divisor)
     {
         if(divisor == 1)
@@ -484,6 +504,12 @@ public Duration dividedBy(long divisor)
         return new Duration(FieldUtils.safeDivide(getMillis(), divisor));
     }
 
+    /**
+     * Returns a new duration with this length negated.
+     * This instance is immutable and is not altered.
+     * 
+     * @return the new duration instance
+     */
     public Duration negated()
     {
         if(getMillis() == Long.MIN_VALUE)
diff --git a/src/main/java/org/joda/time/field/FieldUtils.java b/src/main/java/org/joda/time/field/FieldUtils.java
index 34ab47a45..73dffa1b8 100644
--- a/src/main/java/org/joda/time/field/FieldUtils.java
+++ b/src/main/java/org/joda/time/field/FieldUtils.java
@@ -176,6 +176,22 @@ public static long safeMultiply(long val1, long val2) {
         return total;
     }
     
+    /**
+     * Divides the dividend by the divisor throwing an exception if 
+     * overflow occurs or the divisor is zero.
+     * 
+     * @param dividend  the dividend
+     * @param divisor  the divisor
+     * @return the new total
+     * @throws ArithmeticException if the operation overflows or the divisor is zero
+     */
+    public static long safeDivide(long dividend, long divisor)
+    {
+        if(dividend == Long.MIN_VALUE && divisor == -1L)
+            throw new ArithmeticException("Multiplication overflows a long: " + dividend + " / " + divisor);
+        return dividend / divisor;
+    }
+
     /**
      * Casts to an int throwing an exception if overflow occurs.
      * 
@@ -327,11 +343,4 @@ public static boolean equals(Object object1, Object object2) {
         return object1.equals(object2);
     }
 
-    public static long safeDivide(long dividend, long divisor)
-    {
-        if(dividend == Long.MIN_VALUE && divisor == -1L)
-            throw new ArithmeticException("Multiplication overflows a long: " + dividend + " / " + divisor);
-        return dividend / divisor;
-    }
-
 }

From d0346a85a0417d2affdd31c9f1bf8adb8d917046 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Fri, 4 Oct 2013 13:52:13 +0100
Subject: [PATCH 15/86] Enhance formatting documentation

---
 src/site/site.xml            |   1 +
 src/site/xdoc/key_format.xml | 149 +++++++++++++++++++++++++++++++++++
 2 files changed, 150 insertions(+)
 create mode 100644 src/site/xdoc/key_format.xml

diff --git a/src/site/site.xml b/src/site/site.xml
index ea42d5050..d51b26522 100644
--- a/src/site/site.xml
+++ b/src/site/site.xml
@@ -36,6 +36,7 @@
       <item name="Duration" href="key_duration.html"/>
       <item name="Period" href="key_period.html"/>
       <item name="Chronology" href="key_chronology.html"/>
+      <item name="Formatting" href="key_format.html"/>
       <item name="Time zone update" href="tz_update.html"/>
     </menu>
 
diff --git a/src/site/xdoc/key_format.xml b/src/site/xdoc/key_format.xml
new file mode 100644
index 000000000..326f15b32
--- /dev/null
+++ b/src/site/xdoc/key_format.xml
@@ -0,0 +1,149 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+
+<document>
+
+ <properties>
+  <title>Java date and time API - Formatting</title>
+  <author>Stephen Colebourne</author>
+ </properties>
+
+ <body>
+
+<section name="Formatting">
+<p>
+Joda-Time provides a comprehensive formatting system.
+There are two layers:
+</p>
+<ul>
+<li>High level - pre-packaged constant formatters</li>
+<li>Mid level - pattern-based, like <code>SimpleDateFormat</code></li>
+<li>Low level - builder</li>
+</ul>
+</section>
+
+<section name="Constant and Localized formatting">
+<p>
+The class <code><a href="apidocs/org/joda/time/format/ISODateTimeFormat.html">ISODateTimeFormat</a></code>
+contains a large number of pre-defined formatters based on the ISO-8601
+specification (although not all are fully compatible).
+These handle many common cases.
+</p>
+<p>
+The class <code><a href="apidocs/org/joda/time/format/DateTimeFormat.html">DateTimeFormat</a></code>
+contains an additional set of pre-defined formatters based on <code>Locale</code>.
+These "style-based" formatters handle the case where the application needs to
+format a date-time in a manner appropriate to a particular global location.
+</p>
+</section>
+
+<section name="Pattern-based formatting">
+<p>
+The class <code><a href="apidocs/org/joda/time/format/DateTimeFormat.html">DateTimeFormat</a></code>
+provides a single method <code>forPattern(String)</code> that supports formatting by pattern.
+These "pattern-based" formatters provide a similar approach to that of <code>SimpleDateFormat</code>.
+</p>
+<p>
+For example:
+</p>
+<source>
+LocalDate date = LocalDate.now();
+DateTimeFormatter fmt = DateTimeFormat.forPattern("d MMMM, yyyy");
+String str = date.toString(fmt);
+// might output "6 October, 2013"
+</source>
+<p>
+The <a href="apidocs/org/joda/time/format/DateTimeFormat.html">pattern letters</a> are:
+</p>
+<source>
+Symbol  Meaning                      Presentation  Examples
+------  -------                      ------------  -------
+ G       era                          text          AD
+ C       century of era (>=0)         number        20
+ Y       year of era (>=0)            year          1996
+
+ x       weekyear                     year          1996
+ w       week of weekyear             number        27
+ e       day of week                  number        2
+ E       day of week                  text          Tuesday; Tue
+
+ y       year                         year          1996
+ D       day of year                  number        189
+ M       month of year                month         July; Jul; 07
+ d       day of month                 number        10
+
+ a       halfday of day               text          PM
+ K       hour of halfday (0~11)       number        0
+ h       clockhour of halfday (1~12)  number        12
+
+ H       hour of day (0~23)           number        0
+ k       clockhour of day (1~24)      number        24
+ m       minute of hour               number        30
+ s       second of minute             number        55
+ S       fraction of second           number        978
+
+ z       time zone                    text          Pacific Standard Time; PST
+ Z       time zone offset/id          zone          -0800; -08:00; America/Los_Angeles
+
+ '       escape for text              delimiter
+ ''      single quote                 literal       '
+</source>
+<p>
+The count of pattern letters determine the format.
+</p>
+<p>
+Text: If the number of pattern letters is 4 or more, the full form is used;
+otherwise a short or abbreviated form is used if available.
+Thus, "EEEE" might output "Monday" whereas "E" might output "Mon" (the short form of Monday).
+</p>
+<p>
+Number: The minimum number of digits. Shorter numbers are zero-padded to this amount.
+Thus, "HH" might output "09" whereas "H" might output "9" (for the hour-of-day of 9 in the morning).
+</p>
+<p>
+Year: Numeric presentation for year and weekyear fields are handled specially.
+For example, if the count of 'y' is 2, the year will be displayed as the zero-based
+year of the century, which is two digits.
+</p>
+<p>
+Month: 3 or over, use text, otherwise use number.
+Thus, "MM" might output "03" whereas "MMM" might output "Mar" (the short form of March)
+and "MMMM" might output "March".
+</p>
+<p>
+Zone: 'Z' outputs offset without a colon, 'ZZ' outputs the offset with a colon, 'ZZZ' or more outputs the zone id.
+</p>
+<p>
+Zone names: Time zone names ('z') cannot be parsed.
+</p>
+<p>
+Any characters in the pattern that are not in the ranges of ['a'..'z'] and ['A'..'Z']
+will be treated as quoted text. For instance, characters like ':', '.', ' ', '#' and '?'
+will appear in the resulting time text even they are not embraced within single quotes. 
+</p>
+</section>
+
+<section name="Builder">
+<p>
+All formatting is ultimately built using 
+<code><a href="apidocs/org/joda/time/format/DateTimeFormatterBuilder.html">DateTimeFormatterBuilder</a></code>.
+The builder allows a format pattern to be built up step by step, consisting of
+literal, text, numeric, pattern and localized elements in any order.
+Some facilities are only available via the builder.
+</p>
+<p>
+For example, this will build a formatter consisting of the month and year:
+</p>
+<source>
+DateTimeFormatter monthAndYear = new DateTimeFormatterBuilder()
+     .appendMonthOfYearText()
+     .appendLiteral(' ')
+     .appendYear(4, 4)
+     .toFormatter();
+</source>
+<p>
+<br />
+</p>
+</section>
+
+</body>
+</document>

From 6ac6c0beed7674eeabdd272549e94d928a05d25c Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Fri, 4 Oct 2013 14:21:55 +0100
Subject: [PATCH 16/86] Enhance thread-safety documentation

See #67
---
 RELEASE-NOTES.txt                              | 2 ++
 src/main/java/org/joda/time/DateTimeUtils.java | 4 +++-
 2 files changed, 5 insertions(+), 1 deletion(-)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 685720305..fa921631a 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -47,6 +47,8 @@ Bug fixes since 2.3
 - Remove uncaughtException calls [#59]
   Previously the code called ThreadGroup.uncaughtException() which was invalid
 
+- Better Javadoc for thread saefty of DateTimeUtils [#67]
+
 
 Scala
 --------
diff --git a/src/main/java/org/joda/time/DateTimeUtils.java b/src/main/java/org/joda/time/DateTimeUtils.java
index 20ff68153..4059c543d 100644
--- a/src/main/java/org/joda/time/DateTimeUtils.java
+++ b/src/main/java/org/joda/time/DateTimeUtils.java
@@ -28,7 +28,9 @@
 /**
  * DateTimeUtils provide public utility methods for the date-time library.
  * <p>
- * DateTimeUtils is thread-safe although shared static variables are used.
+ * DateTimeUtils uses shared static variables which are declared as volatile
+ * for thread-safety. These can be changed during the lifetime of the application
+ * however doing so is generally a bad idea.
  *
  * @author Stephen Colebourne
  * @since 1.0

From f6f98b71d7c945238bc9d377298d1aae1bc12708 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Fri, 4 Oct 2013 14:49:15 +0100
Subject: [PATCH 17/86] Remove unnecessary volatile on LocalDate has code
 instance variable

LocalDate hash code meets criteria of the racy single-check idiom
Fixes #68
---
 RELEASE-NOTES.txt                          | 3 +++
 src/main/java/org/joda/time/LocalDate.java | 2 +-
 2 files changed, 4 insertions(+), 1 deletion(-)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index fa921631a..81cf2cfc8 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -18,6 +18,9 @@ of restrictions. If the license causes you problems please contact the mailing l
 
 Enhancements since 2.3
 ----------------------
+- LocalDate.hashCode()
+  Remove unnecessary volatile on instance variable [#68]
+  LocalDate hash code meets criteria of the racy single-check idiom
 
 
 Compatibility with 2.3
diff --git a/src/main/java/org/joda/time/LocalDate.java b/src/main/java/org/joda/time/LocalDate.java
index 7d9b480e9..9806eb32f 100644
--- a/src/main/java/org/joda/time/LocalDate.java
+++ b/src/main/java/org/joda/time/LocalDate.java
@@ -110,7 +110,7 @@
     /** The chronology to use in UTC. */
     private final Chronology iChronology;
     /** The cached hash code. */
-    private transient volatile int iHash;
+    private transient int iHash;
 
     //-----------------------------------------------------------------------
     /**

From 06867a48517f71c740016cd3d9e84558ab56cd49 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Fri, 4 Oct 2013 15:13:33 +0100
Subject: [PATCH 18/86] Add Duration multipliedBy/dividedBy/negated

Tweak pull request
Fixes #72
---
 RELEASE-NOTES.txt                              |  3 +++
 pom.xml                                        |  4 ++++
 src/main/java/org/joda/time/Duration.java      | 18 +++++++++---------
 .../java/org/joda/time/field/FieldUtils.java   |  8 ++++----
 .../org/joda/time/field/TestFieldUtils.java    | 12 +++++++++++-
 5 files changed, 31 insertions(+), 14 deletions(-)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 81cf2cfc8..fb3e3a351 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -18,6 +18,9 @@ of restrictions. If the license causes you problems please contact the mailing l
 
 Enhancements since 2.3
 ----------------------
+- Duration.multipliedBy(), .dividedBy(), .negated()
+  Additional methods on Duration
+
 - LocalDate.hashCode()
   Remove unnecessary volatile on instance variable [#68]
   LocalDate hash code meets criteria of the racy single-check idiom
diff --git a/pom.xml b/pom.xml
index 732aa5b17..be8b2855d 100644
--- a/pom.xml
+++ b/pom.xml
@@ -129,6 +129,10 @@
     <contributor>
       <name>Michael Plump</name>
     </contributor>
+    <contributor>
+      <name>Bjorn Pollex</name>
+      <url>https://github.com/bjoernpollex</url>
+    </contributor>
     <contributor>
       <name>Ryan Propper</name>
     </contributor>
diff --git a/src/main/java/org/joda/time/Duration.java b/src/main/java/org/joda/time/Duration.java
index 8f0e7895b..34c3dc9b4 100644
--- a/src/main/java/org/joda/time/Duration.java
+++ b/src/main/java/org/joda/time/Duration.java
@@ -480,10 +480,10 @@ public Duration minus(ReadableDuration amount) {
      * @param multiplicand  the multiplicand to multiply this one by
      * @return the new duration instance
      */
-    public Duration multipliedBy(long multiplicand)
-    {
-        if(multiplicand == 1)
+    public Duration multipliedBy(long multiplicand) {
+        if (multiplicand == 1) {
             return this;
+        }
         return new Duration(FieldUtils.safeMultiply(getMillis(), multiplicand));
     }
 
@@ -497,10 +497,10 @@ public Duration multipliedBy(long multiplicand)
      * @param divisor  the divisor to divide this one by
      * @return the new duration instance
      */
-    public Duration dividedBy(long divisor)
-    {
-        if(divisor == 1)
+    public Duration dividedBy(long divisor) {
+        if (divisor == 1) {
             return this;
+        }
         return new Duration(FieldUtils.safeDivide(getMillis(), divisor));
     }
 
@@ -510,10 +510,10 @@ public Duration dividedBy(long divisor)
      * 
      * @return the new duration instance
      */
-    public Duration negated()
-    {
-        if(getMillis() == Long.MIN_VALUE)
+    public Duration negated() {
+        if (getMillis() == Long.MIN_VALUE) {
             throw new ArithmeticException("Negation of this duration would overflow");
+        }
         return new Duration(-getMillis());
     }
 
diff --git a/src/main/java/org/joda/time/field/FieldUtils.java b/src/main/java/org/joda/time/field/FieldUtils.java
index 73dffa1b8..36b0b2d29 100644
--- a/src/main/java/org/joda/time/field/FieldUtils.java
+++ b/src/main/java/org/joda/time/field/FieldUtils.java
@@ -175,7 +175,7 @@ public static long safeMultiply(long val1, long val2) {
         }
         return total;
     }
-    
+
     /**
      * Divides the dividend by the divisor throwing an exception if 
      * overflow occurs or the divisor is zero.
@@ -185,10 +185,10 @@ public static long safeMultiply(long val1, long val2) {
      * @return the new total
      * @throws ArithmeticException if the operation overflows or the divisor is zero
      */
-    public static long safeDivide(long dividend, long divisor)
-    {
-        if(dividend == Long.MIN_VALUE && divisor == -1L)
+    public static long safeDivide(long dividend, long divisor) {
+        if (dividend == Long.MIN_VALUE && divisor == -1L) {
             throw new ArithmeticException("Multiplication overflows a long: " + dividend + " / " + divisor);
+        }
         return dividend / divisor;
     }
 
diff --git a/src/test/java/org/joda/time/field/TestFieldUtils.java b/src/test/java/org/joda/time/field/TestFieldUtils.java
index 5c8395703..0d1328c38 100644
--- a/src/test/java/org/joda/time/field/TestFieldUtils.java
+++ b/src/test/java/org/joda/time/field/TestFieldUtils.java
@@ -289,11 +289,21 @@ public void testSafeDivideLongLong() {
         assertEquals(0L, FieldUtils.safeDivide(1L, 3L));
         assertEquals(3L, FieldUtils.safeDivide(3L, 1L));
         
+        assertEquals(1L, FieldUtils.safeDivide(5L, 3L));
+        assertEquals(-1L, FieldUtils.safeDivide(5L, -3L));
+        assertEquals(-1L, FieldUtils.safeDivide(-5L, 3L));
+        assertEquals(1L, FieldUtils.safeDivide(-5L, -3L));
+        
         assertEquals(2L, FieldUtils.safeDivide(6L, 3L));
         assertEquals(-2L, FieldUtils.safeDivide(6L, -3L));
         assertEquals(-2L, FieldUtils.safeDivide(-6L, 3L));
         assertEquals(2L, FieldUtils.safeDivide(-6L, -3L));
         
+        assertEquals(2L, FieldUtils.safeDivide(7L, 3L));
+        assertEquals(-2L, FieldUtils.safeDivide(7L, -3L));
+        assertEquals(-2L, FieldUtils.safeDivide(-7L, 3L));
+        assertEquals(2L, FieldUtils.safeDivide(-7L, -3L));
+        
         assertEquals(Long.MAX_VALUE, FieldUtils.safeDivide(Long.MAX_VALUE, 1L));
         assertEquals(Long.MIN_VALUE, FieldUtils.safeDivide(Long.MIN_VALUE, 1L));
         assertEquals(-Long.MAX_VALUE, FieldUtils.safeDivide(Long.MAX_VALUE, -1L));
@@ -310,5 +320,5 @@ public void testSafeDivideLongLong() {
         } catch (ArithmeticException e) {
         }
     }
-}
 
+}

From b4e35700f883fefa579245e425cd3015c10cf77d Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 5 Oct 2013 01:06:20 +0100
Subject: [PATCH 19/86] Record pull request contribution

---
 pom.xml | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/pom.xml b/pom.xml
index be8b2855d..1da2ce7e0 100644
--- a/pom.xml
+++ b/pom.xml
@@ -89,6 +89,10 @@
     <contributor>
       <name>Sean Geoghegan</name>
     </contributor>
+    <contributor>
+      <name>Vsevolod Ivanov</name>
+      <url>https://github.com/seva-ask</url>
+    </contributor>
     <contributor>
       <name>mjunginger</name>
       <url>https://github.com/mjunginger</url>

From 7889dd16ce34af5912d6c89a92bf4aa7c2a30d3c Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Mon, 23 Sep 2013 07:01:07 -0700
Subject: [PATCH 20/86] Ignore time-zone data

---
 .gitignore | 1 +
 1 file changed, 1 insertion(+)

diff --git a/.gitignore b/.gitignore
index b958a5868..aca150cba 100644
--- a/.gitignore
+++ b/.gitignore
@@ -15,3 +15,4 @@
 /test-output/
 src/tz-data/
 *TempTest*
+/src/main/resources/org/joda/time/tz/data/

From 4e2042fae407224a08d01d21e9b9ce2279a44db1 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 5 Oct 2013 02:21:29 +0100
Subject: [PATCH 21/86] Better Javadoc for DateTimeComparator

See #73
---
 RELEASE-NOTES.txt                              |  2 ++
 .../java/org/joda/time/DateTimeComparator.java | 18 ++++++++++++++++++
 2 files changed, 20 insertions(+)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index fb3e3a351..678f10fdb 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -55,6 +55,8 @@ Bug fixes since 2.3
 
 - Better Javadoc for thread saefty of DateTimeUtils [#67]
 
+- Better Javadoc for DateTimeComparator [#73]
+
 
 Scala
 --------
diff --git a/src/main/java/org/joda/time/DateTimeComparator.java b/src/main/java/org/joda/time/DateTimeComparator.java
index 7a4895563..646918f56 100644
--- a/src/main/java/org/joda/time/DateTimeComparator.java
+++ b/src/main/java/org/joda/time/DateTimeComparator.java
@@ -75,6 +75,10 @@ public static DateTimeComparator getInstance() {
     /**
      * Returns a DateTimeComparator with a lower limit only. Fields of a
      * magnitude less than the lower limit are excluded from comparisons.
+     * <p>
+     * The time-zone is considered when using this comparator.
+     * The input millis are truncated using the time-zone of that input value.
+     * Thus, two inputs with different time-zones will typically not be equal
      *
      * @param lowerLimit  inclusive lower limit for fields to be compared, null means no limit
      * @return a comparator over all fields above the lower limit
@@ -89,6 +93,10 @@ public static DateTimeComparator getInstance(DateTimeFieldType lowerLimit) {
      * Fields of a magnitude greater than or equal to the upper limit are also
      * excluded from comparisons. Either limit may be specified as null, which
      * indicates an unbounded limit.
+     * <p>
+     * The time-zone is considered when using this comparator unless both limits are null.
+     * The input millis are rounded/truncated using the time-zone of that input value.
+     * Thus, two inputs with different time-zones will typically not be equal
      *
      * @param lowerLimit  inclusive lower limit for fields to be compared, null means no limit
      * @param upperLimit  exclusive upper limit for fields to be compared, null means no limit
@@ -110,6 +118,11 @@ public static DateTimeComparator getInstance(DateTimeFieldType lowerLimit, DateT
     /**
      * Returns a comparator that only considers date fields.
      * Time of day is ignored.
+     * <p>
+     * The time-zone is considered when using this comparator.
+     * The input millis are rounded down to the start of the day
+     * in the time-zone of that input value. Thus, two inputs with
+     * different time-zones will typically not be equal
      * 
      * @return a comparator over all date fields
      */
@@ -120,6 +133,11 @@ public static DateTimeComparator getDateOnlyInstance() {
     /**
      * Returns a comparator that only considers time fields.
      * Date is ignored.
+     * <p>
+     * The time-zone is considered when using this comparator.
+     * The input millis are truncated to be within the day
+     * in the time-zone of that input value. Thus, two inputs with
+     * different time-zones will typically not be equal
      * 
      * @return a comparator over all time fields
      */

From 0a47ac1ccafc02adae2f5e6d92da9d2c23e4982e Mon Sep 17 00:00:00 2001
From: Artur Dryomov <ming13@users.noreply.github.com>
Date: Fri, 25 Oct 2013 03:00:14 +0300
Subject: [PATCH 22/86] Use syntax highlighting in the readme file.

---
 README.md | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/README.md b/README.md
index 3fad88bfe..9bcf72603 100644
--- a/README.md
+++ b/README.md
@@ -9,7 +9,7 @@ Supporting classes include time zone, duration, format and parsing.
 
 As a flavour of Joda-Time, here's some example code:
 
-```
+```java
 public boolean isAfterPayDay(DateTime datetime) {
   if (datetime.getMonthOfYear() == 2) {   // February is month 2!!
     return datetime.getDayOfMonth() > 26;

From f248cec4ac17197849357a55f286541241b84dd9 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Fri, 1 Nov 2013 11:57:58 +0000
Subject: [PATCH 23/86] Fix IANA time zone database links

Fixes #83
---
 RELEASE-NOTES.txt                                    | 2 ++
 src/main/java/org/joda/time/tz/ZoneInfoCompiler.java | 6 +++---
 src/main/java/org/joda/time/tz/src/Readme.txt        | 4 ++--
 src/site/xdoc/timezones.xml                          | 6 +++---
 src/site/xdoc/userguide.xml                          | 7 +++----
 5 files changed, 13 insertions(+), 12 deletions(-)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 678f10fdb..5beb66f75 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -57,6 +57,8 @@ Bug fixes since 2.3
 
 - Better Javadoc for DateTimeComparator [#73]
 
+- Fix the links to the IANA time zone database [#83]
+
 
 Scala
 --------
diff --git a/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java b/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java
index 64da5ea5c..4e56fef1a 100644
--- a/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java
+++ b/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java
@@ -45,14 +45,14 @@
 import org.joda.time.format.ISODateTimeFormat;
 
 /**
- * Compiles Olson ZoneInfo database files into binary files for each time zone
+ * Compiles IANA ZoneInfo database files into binary files for each time zone
  * in the database. {@link DateTimeZoneBuilder} is used to construct and encode
  * compiled data files. {@link ZoneInfoProvider} loads the encoded files and
  * converts them back into {@link DateTimeZone} objects.
  * <p>
  * Although this tool is similar to zic, the binary formats are not
- * compatible. The latest Olson database files may be obtained
- * <a href="http://www.twinsun.com/tz/tz-link.htm">here</a>.
+ * compatible. The latest IANA time zone database files may be obtained
+ * <a href="http://www.iana.org/time-zones">here</a>.
  * <p>
  * ZoneInfoCompiler is mutable and not thread-safe, although the main method
  * may be safely invoked by multiple threads.
diff --git a/src/main/java/org/joda/time/tz/src/Readme.txt b/src/main/java/org/joda/time/tz/src/Readme.txt
index 8f19af450..2ddfc0585 100644
--- a/src/main/java/org/joda/time/tz/src/Readme.txt
+++ b/src/main/java/org/joda/time/tz/src/Readme.txt
@@ -1,2 +1,2 @@
-The data files in this directory were obtained from the public tz database,
-http://www.twinsun.com/tz/tz-link.htm, version 2013d.
+The data files in this directory were obtained from the public IANA time zone database,
+http://www.iana.org/time-zones, version 2013d.
diff --git a/src/site/xdoc/timezones.xml b/src/site/xdoc/timezones.xml
index 5a94a2db9..90a894d46 100644
--- a/src/site/xdoc/timezones.xml
+++ b/src/site/xdoc/timezones.xml
@@ -11,9 +11,9 @@
 
 <section name="Available Time Zones">
 <p>
-Time zone data is provided by the public <a href="http://www.twinsun.com/tz/tz-link.htm">tz</a>
-database, otherwise known as the Olson database. The following table shows all the time zones
-supported by Joda-Time, using version 2010k of the tz database.
+Time zone data is provided by the public IANA <a href="http://www.iana.org/time-zones">time zone database</a>.
+The following table shows all the time zones supported by Joda-Time, using version 2013d
+of the database.
 It is also possible to update to a <a href="tz_update.html">later version of the database</a>.
 This table can be rebuilt by running <code>org.joda.example.time.TimeZoneTable</code>.
 </p>
diff --git a/src/site/xdoc/userguide.xml b/src/site/xdoc/userguide.xml
index 6c97a6745..45976325f 100644
--- a/src/site/xdoc/userguide.xml
+++ b/src/site/xdoc/userguide.xml
@@ -333,10 +333,9 @@ DateTimeZone zoneUTC = DateTimeZone.forOffsetHours(hours);
 </source>
 </p>
 <p>
-The TimeZone implementation is based on data provided by the public
-<a href="http://www.twinsun.com/tz/tz-link.htm">tz database</a>,
-otherwise known as the Olson database.
-A full list of timezone ids can be found <a href="timezones.html">here</a>
+The time zone implementation is based on data provided by the public
+IANA <a href="http://www.iana.org/time-zones">time zone database</a>.
+A full list of time zone ids can be found <a href="timezones.html">here</a>
 </p>
 <p>
 Joda-Time provides a default time zone which is used in many operations when a

From a38b5e0c620a4a4dc310d35105e3e432c4e91fc3 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Fri, 1 Nov 2013 11:57:58 +0000
Subject: [PATCH 24/86] Add generics

---
 src/example/org/joda/example/time/TimeZoneTable.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/example/org/joda/example/time/TimeZoneTable.java b/src/example/org/joda/example/time/TimeZoneTable.java
index b959fe3af..9538796d7 100644
--- a/src/example/org/joda/example/time/TimeZoneTable.java
+++ b/src/example/org/joda/example/time/TimeZoneTable.java
@@ -63,7 +63,7 @@ public static void main(String[] args) throws Exception {
                     "</tr>");
 
         ZoneData canonical = null;
-        List aliases = new ArrayList();
+        List<ZoneData> aliases = new ArrayList<ZoneData>();
 
         for (int i=0; i<zones.length; i++) {
             ZoneData zone = zones[i];

From a6cb59ed2280ab0a32995fa8b5f1a7b0d47cb815 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Fri, 1 Nov 2013 14:06:59 +0000
Subject: [PATCH 25/86] Fix handling of PeriodType when either years or months
 missing

Fixes #79
---
 RELEASE-NOTES.txt                             |  3 ++
 src/main/java/org/joda/time/Period.java       | 21 ++++++---
 .../java/org/joda/time/TestPeriod_Basics.java | 43 +++++++++++++++++++
 3 files changed, 60 insertions(+), 7 deletions(-)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 5beb66f75..84f44dd68 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -48,6 +48,9 @@ Deprecations since 2.3
 
 Bug fixes since 2.3
 -------------------
+- Period.normalizedStandard(PeriodType) [#79]
+  Fix handling of PeriodType when either years or months missing
+
 - Better Javadoc for parsing of numbers in format patterns [#60]
 
 - Remove uncaughtException calls [#59]
diff --git a/src/main/java/org/joda/time/Period.java b/src/main/java/org/joda/time/Period.java
index 5b36bc504..5ea67a7c1 100644
--- a/src/main/java/org/joda/time/Period.java
+++ b/src/main/java/org/joda/time/Period.java
@@ -1614,23 +1614,30 @@ public Period normalizedStandard() {
      * @since 1.5
      */
     public Period normalizedStandard(PeriodType type) {
+        type = DateTimeUtils.getPeriodType(type);
         long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs
         millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));
         millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));
         millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));
         millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));
         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));
-        Period result = new Period(millis, DateTimeUtils.getPeriodType(type), ISOChronology.getInstanceUTC());
+        Period result = new Period(millis, type, ISOChronology.getInstanceUTC());
         int years = getYears();
         int months = getMonths();
         if (years != 0 || months != 0) {
-            years = FieldUtils.safeAdd(years, months / 12);
-            months = months % 12;
-            if (years != 0) {
-                result = result.withYears(years);
+            long totalMonths = years * 12L + months;
+            if (type.isSupported(DurationFieldType.YEARS_TYPE)) {
+                int normalizedYears = FieldUtils.safeToInt(totalMonths / 12);
+                result = result.withYears(normalizedYears);
+                totalMonths = totalMonths - (normalizedYears * 12);
+            }
+            if (type.isSupported(DurationFieldType.MONTHS_TYPE)) {
+                int normalizedMonths = FieldUtils.safeToInt(totalMonths);
+                result = result.withMonths(normalizedMonths);
+                totalMonths = totalMonths - normalizedMonths;
             }
-            if (months != 0) {
-                result = result.withMonths(months);
+            if (totalMonths != 0) {
+                throw new UnsupportedOperationException("Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: " + toString());
             }
         }
         return result;
diff --git a/src/test/java/org/joda/time/TestPeriod_Basics.java b/src/test/java/org/joda/time/TestPeriod_Basics.java
index f291c9bb6..82030f808 100644
--- a/src/test/java/org/joda/time/TestPeriod_Basics.java
+++ b/src/test/java/org/joda/time/TestPeriod_Basics.java
@@ -217,6 +217,7 @@ public void testEqualsHashCode() {
     }
     
     class MockPeriod extends BasePeriod {
+        private static final long serialVersionUID = 1L;
         public MockPeriod(long value) {
             super(value, null, null);
         }
@@ -1516,4 +1517,46 @@ public void testNormalizedStandard_periodType_yearMonthDay() {
         assertEquals(new Period(2, 3, 0, 37, 3, 0, 0, 0, PeriodType.yearMonthDayTime()), result);
     }
 
+    public void testNormalizedStandard_periodType_months1() {
+        Period test = new Period(1, 15, 0, 0, 0, 0, 0, 0);
+        Period result = test.normalizedStandard(PeriodType.months());
+        assertEquals(new Period(1, 15, 0, 0, 0, 0, 0, 0), test);
+        assertEquals(new Period(0, 27, 0, 0, 0, 0, 0, 0, PeriodType.months()), result);
+    }
+
+    public void testNormalizedStandard_periodType_months2() {
+        Period test = new Period(-2, 15, 0, 0, 0, 0, 0, 0);
+        Period result = test.normalizedStandard(PeriodType.months());
+        assertEquals(new Period(-2, 15, 0, 0, 0, 0, 0, 0), test);
+        assertEquals(new Period(0, -9, 0, 0, 0, 0, 0, 0, PeriodType.months()), result);
+    }
+
+    public void testNormalizedStandard_periodType_months3() {
+        Period test = new Period(0, 4, 0, 0, 0, 0, 0, 0);
+        Period result = test.normalizedStandard(PeriodType.months());
+        assertEquals(new Period(0, 4, 0, 0, 0, 0, 0, 0), test);
+        assertEquals(new Period(0, 4, 0, 0, 0, 0, 0, 0, PeriodType.months()), result);
+    }
+
+    public void testNormalizedStandard_periodType_years() {
+        Period test = new Period(1, 15, 0, 0, 0, 0, 0, 0);
+        try {
+            test.normalizedStandard(PeriodType.years());
+            fail();
+        } catch (UnsupportedOperationException ex) {
+            // expected
+        }
+    }
+
+    public void testNormalizedStandard_periodType_monthsWeeks() {
+        PeriodType type = PeriodType.forFields(new DurationFieldType[]{
+                        DurationFieldType.months(),
+                        DurationFieldType.weeks(),
+                        DurationFieldType.days()});
+        Period test = new Period(2, 4, 6, 0, 0, 0, 0, 0);
+        Period result = test.normalizedStandard(type);
+        assertEquals(new Period(2, 4, 6, 0, 0, 0, 0, 0), test);
+        assertEquals(new Period(0, 28, 6, 0, 0, 0, 0, 0, type), result);
+    }
+
 }

From e02af2cb44051bb085966b884722665669330a4e Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Fri, 1 Nov 2013 14:36:27 +0000
Subject: [PATCH 26/86] Better Javadoc for DateTimeFormatter parsing

See #78
---
 RELEASE-NOTES.txt                                        | 2 ++
 .../java/org/joda/time/format/DateTimeFormatter.java     | 9 +++++++++
 2 files changed, 11 insertions(+)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 84f44dd68..c24719c8a 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -62,6 +62,8 @@ Bug fixes since 2.3
 
 - Fix the links to the IANA time zone database [#83]
 
+- Better Javadoc for DateTimeFormatter parsing [#78]
+
 
 Scala
 --------
diff --git a/src/main/java/org/joda/time/format/DateTimeFormatter.java b/src/main/java/org/joda/time/format/DateTimeFormatter.java
index 8f1bc631e..16cc6fdef 100644
--- a/src/main/java/org/joda/time/format/DateTimeFormatter.java
+++ b/src/main/java/org/joda/time/format/DateTimeFormatter.java
@@ -72,6 +72,15 @@
  * // parse using the Paris zone
  * DateTime date = formatter.withZone(DateTimeZone.forID("Europe/Paris")).parseDateTime(str);
  * </pre>
+ * <p>
+ * Parsing builds up the resultant instant by 'setting' the value of each parsed field
+ * from largest to smallest onto an initial instant, typically 1970-01-01T00:00Z.
+ * This design means that day-of-month is set before day-of-week.
+ * As such, if both the day-of-month and day-of-week are parsed, and the day-of-week
+ * is incorrect, then the day-of-week overrides the day-of-month.
+ * 
+ * This has a side effect if the input is not consistent.
+ * 
  * 
  * @author Brian S O'Neill
  * @author Stephen Colebourne

From 8f79f89acd75833a5325212a05dc04e30a7f36a0 Mon Sep 17 00:00:00 2001
From: Peter Marsh <pete@modeltwozero.com>
Date: Tue, 5 Nov 2013 10:50:50 +0000
Subject: [PATCH 27/86] Add a seperate description for fraction of second
 presentation

---
 src/main/java/org/joda/time/format/DateTimeFormat.java | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/src/main/java/org/joda/time/format/DateTimeFormat.java b/src/main/java/org/joda/time/format/DateTimeFormat.java
index 961b7e60d..ee5167753 100644
--- a/src/main/java/org/joda/time/format/DateTimeFormat.java
+++ b/src/main/java/org/joda/time/format/DateTimeFormat.java
@@ -80,7 +80,7 @@
  * k       clockhour of day (1~24)      number        24
  * m       minute of hour               number        30
  * s       second of minute             number        55
- * S       fraction of second           number        978
+ * S       fraction of second           millis        978
  *
  * z       time zone                    text          Pacific Standard Time; PST
  * Z       time zone offset/id          zone          -0800; -08:00; America/Los_Angeles
@@ -106,6 +106,12 @@
  * <p>
  * <strong>Month</strong>: 3 or over, use text, otherwise use number.
  * <p>
+ * <strong>Millis</strong>: The exact number of fractional digits. If more
+ * millisecond digits are available then specified the number will be
+ * truncated, if there are fewer than specified then the number will be
+ * zero-padded to the right. When parsing, only the eact number of digits
+ * are accepted.
+ * <p>
  * <strong>Zone</strong>: 'Z' outputs offset without a colon, 'ZZ' outputs
  * the offset with a colon, 'ZZZ' or more outputs the zone id.
  * <p>

From 2d9d9cdae4fc74ae136b06d2996b0549a14b6f3d Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Tue, 5 Nov 2013 14:39:35 +0000
Subject: [PATCH 28/86] Fixup pull request for fraction of second

Fixes #62
---
 RELEASE-NOTES.txt                                      | 2 ++
 pom.xml                                                | 4 ++++
 src/main/java/org/joda/time/format/DateTimeFormat.java | 9 ++++-----
 3 files changed, 10 insertions(+), 5 deletions(-)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index c24719c8a..b4accf1e4 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -64,6 +64,8 @@ Bug fixes since 2.3
 
 - Better Javadoc for DateTimeFormatter parsing [#78]
 
+- Better Javadoc for DateTimeFormat fraction of second [#62]
+
 
 Scala
 --------
diff --git a/pom.xml b/pom.xml
index 1da2ce7e0..ec8c6652f 100644
--- a/pom.xml
+++ b/pom.xml
@@ -124,6 +124,10 @@
     <contributor>
       <name>Al Major</name>
     </contributor>
+    <contributor>
+      <name>Pete Marsh</name>
+      <url>https://github.com/petedmarsh</url>
+    </contributor>
     <contributor>
       <name>Blair Martin</name>
     </contributor>
diff --git a/src/main/java/org/joda/time/format/DateTimeFormat.java b/src/main/java/org/joda/time/format/DateTimeFormat.java
index ee5167753..4558eb74d 100644
--- a/src/main/java/org/joda/time/format/DateTimeFormat.java
+++ b/src/main/java/org/joda/time/format/DateTimeFormat.java
@@ -106,11 +106,10 @@
  * <p>
  * <strong>Month</strong>: 3 or over, use text, otherwise use number.
  * <p>
- * <strong>Millis</strong>: The exact number of fractional digits. If more
- * millisecond digits are available then specified the number will be
- * truncated, if there are fewer than specified then the number will be
- * zero-padded to the right. When parsing, only the eact number of digits
- * are accepted.
+ * <strong>Millis</strong>: The exact number of fractional digits.
+ * If more millisecond digits are available then specified the number will be truncated,
+ * if there are fewer than specified then the number will be zero-padded to the right.
+ * When parsing, only the exact number of digits are accepted.
  * <p>
  * <strong>Zone</strong>: 'Z' outputs offset without a colon, 'ZZ' outputs
  * the offset with a colon, 'ZZZ' or more outputs the zone id.

From 3755205b2b987f67f100a55707e1b9db93462dda Mon Sep 17 00:00:00 2001
From: David Haguenauer <ml@kurokatta.org>
Date: Thu, 7 Nov 2013 15:53:54 +0100
Subject: [PATCH 29/86] Spelling.

---
 src/main/java/org/joda/time/Duration.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/main/java/org/joda/time/Duration.java b/src/main/java/org/joda/time/Duration.java
index 34c3dc9b4..4f3ea076a 100644
--- a/src/main/java/org/joda/time/Duration.java
+++ b/src/main/java/org/joda/time/Duration.java
@@ -363,7 +363,7 @@ public Seconds toStandardSeconds() {
 
     //-----------------------------------------------------------------------
     /**
-     * Creates a new Duration instance with a different milisecond length.
+     * Creates a new Duration instance with a different millisecond length.
      * 
      * @param duration  the new length of the duration
      * @return the new duration instance

From 88189883556c6b3f2b6bf54edd61d6a297ff6c8e Mon Sep 17 00:00:00 2001
From: David Haguenauer <ml@kurokatta.org>
Date: Thu, 7 Nov 2013 16:06:13 +0100
Subject: [PATCH 30/86] Spelling.

---
 src/main/java/org/joda/time/Duration.java | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/main/java/org/joda/time/Duration.java b/src/main/java/org/joda/time/Duration.java
index 4f3ea076a..4e2b17f0a 100644
--- a/src/main/java/org/joda/time/Duration.java
+++ b/src/main/java/org/joda/time/Duration.java
@@ -181,7 +181,7 @@ public Duration(long duration) {
      *
      * @param startInstant  interval start, in milliseconds
      * @param endInstant  interval end, in milliseconds
-     * @throws ArithmeticException if the duration exceeds a 64 bit long
+     * @throws ArithmeticException if the duration exceeds a 64-bit long
      */
     public Duration(long startInstant, long endInstant) {
         super(startInstant, endInstant);
@@ -192,7 +192,7 @@ public Duration(long startInstant, long endInstant) {
      *
      * @param start  interval start, null means now
      * @param end  interval end, null means now
-     * @throws ArithmeticException if the duration exceeds a 64 bit long
+     * @throws ArithmeticException if the duration exceeds a 64-bit long
      */
     public Duration(ReadableInstant start, ReadableInstant end) {
         super(start, end);

From ade422e9211bf23c276ff135822e3325693160b8 Mon Sep 17 00:00:00 2001
From: David Haguenauer <ml@kurokatta.org>
Date: Thu, 7 Nov 2013 16:11:29 +0100
Subject: [PATCH 31/86] Spelling.

---
 src/main/java/org/joda/time/Duration.java | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/src/main/java/org/joda/time/Duration.java b/src/main/java/org/joda/time/Duration.java
index 4e2b17f0a..7d664ebc0 100644
--- a/src/main/java/org/joda/time/Duration.java
+++ b/src/main/java/org/joda/time/Duration.java
@@ -27,7 +27,7 @@
  * A duration is defined by a fixed number of milliseconds.
  * There is no concept of fields, such as days or seconds, as these fields can vary in length.
  * A duration may be converted to a {@link Period} to obtain field values.
- * This conversion will typically cause a loss of precision however.
+ * This conversion will typically cause a loss of precision, however.
  * <p>
  * Duration is thread-safe and immutable.
  *
@@ -70,7 +70,7 @@ public static Duration parse(String str) {
      * Savings changes will not have 24 hours, so use this method with care.
      * <p>
      * A Duration is a representation of an amount of time. If you want to express
-     * the concepts of 'days' you should consider using the {@link Days} class.
+     * the concept of 'days' you should consider using the {@link Days} class.
      *
      * @param days  the number of standard days in this duration
      * @return the duration, never null
@@ -93,7 +93,7 @@ public static Duration standardDays(long days) {
      * All currently supplied chronologies use this definition.
      * <p>
      * A Duration is a representation of an amount of time. If you want to express
-     * the concepts of 'hours' you should consider using the {@link Hours} class.
+     * the concept of 'hours' you should consider using the {@link Hours} class.
      *
      * @param hours  the number of standard hours in this duration
      * @return the duration, never null
@@ -116,7 +116,7 @@ public static Duration standardHours(long hours) {
      * All currently supplied chronologies use this definition.
      * <p>
      * A Duration is a representation of an amount of time. If you want to express
-     * the concepts of 'minutes' you should consider using the {@link Minutes} class.
+     * the concept of 'minutes' you should consider using the {@link Minutes} class.
      *
      * @param minutes  the number of standard minutes in this duration
      * @return the duration, never null
@@ -138,7 +138,7 @@ public static Duration standardMinutes(long minutes) {
      * All currently supplied chronologies use this definition.
      * <p>
      * A Duration is a representation of an amount of time. If you want to express
-     * the concepts of 'seconds' you should consider using the {@link Seconds} class.
+     * the concept of 'seconds' you should consider using the {@link Seconds} class.
      *
      * @param seconds  the number of standard seconds in this duration
      * @return the duration, never null

From e72c41ca90db6923f6e8680c2063a8091f86ffcb Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Wed, 27 Nov 2013 12:21:54 +0000
Subject: [PATCH 32/86] Fixup pull request

---
 pom.xml                                              | 12 ++++++++----
 src/main/java/org/joda/time/Duration.java            |  5 +++--
 src/main/java/org/joda/time/base/BaseDuration.java   |  4 ++--
 .../java/org/joda/time/tz/DateTimeZoneBuilder.java   |  4 ++--
 4 files changed, 15 insertions(+), 10 deletions(-)

diff --git a/pom.xml b/pom.xml
index ec8c6652f..15ded7e4a 100644
--- a/pom.xml
+++ b/pom.xml
@@ -90,12 +90,12 @@
       <name>Sean Geoghegan</name>
     </contributor>
     <contributor>
-      <name>Vsevolod Ivanov</name>
-      <url>https://github.com/seva-ask</url>
+      <name>haguenau</name>
+      <url>https://github.com/haguenau</url>
     </contributor>
     <contributor>
-      <name>mjunginger</name>
-      <url>https://github.com/mjunginger</url>
+      <name>Vsevolod Ivanov</name>
+      <url>https://github.com/seva-ask</url>
     </contributor>
     <contributor>
       <name>Ashish Katyal</name>
@@ -121,6 +121,10 @@
     <contributor>
       <name>Kostas Maistrelis</name>
     </contributor>
+    <contributor>
+      <name>mjunginger</name>
+      <url>https://github.com/mjunginger</url>
+    </contributor>
     <contributor>
       <name>Al Major</name>
     </contributor>
diff --git a/src/main/java/org/joda/time/Duration.java b/src/main/java/org/joda/time/Duration.java
index 7d664ebc0..15fe52d0c 100644
--- a/src/main/java/org/joda/time/Duration.java
+++ b/src/main/java/org/joda/time/Duration.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2010 Stephen Colebourne
+ *  Copyright 2001-2013 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -26,8 +26,9 @@
  * <p>
  * A duration is defined by a fixed number of milliseconds.
  * There is no concept of fields, such as days or seconds, as these fields can vary in length.
+ * <p>
  * A duration may be converted to a {@link Period} to obtain field values.
- * This conversion will typically cause a loss of precision, however.
+ * This conversion will typically cause a loss of precision.
  * <p>
  * Duration is thread-safe and immutable.
  *
diff --git a/src/main/java/org/joda/time/base/BaseDuration.java b/src/main/java/org/joda/time/base/BaseDuration.java
index 69359f5eb..ffc684020 100644
--- a/src/main/java/org/joda/time/base/BaseDuration.java
+++ b/src/main/java/org/joda/time/base/BaseDuration.java
@@ -67,7 +67,7 @@ protected BaseDuration(long duration) {
      *
      * @param startInstant  interval start, in milliseconds
      * @param endInstant  interval end, in milliseconds
-     * @throws ArithmeticException if the duration exceeds a 64 bit long
+     * @throws ArithmeticException if the duration exceeds a 64-bit long
      */
     protected BaseDuration(long startInstant, long endInstant) {
         super();
@@ -79,7 +79,7 @@ protected BaseDuration(long startInstant, long endInstant) {
      *
      * @param start  interval start, null means now
      * @param end  interval end, null means now
-     * @throws ArithmeticException if the duration exceeds a 64 bit long
+     * @throws ArithmeticException if the duration exceeds a 64-bit long
      */
     protected BaseDuration(ReadableInstant start, ReadableInstant end) {
         super();
diff --git a/src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java b/src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java
index 8166b4e16..fa5c16443 100644
--- a/src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java
+++ b/src/main/java/org/joda/time/tz/DateTimeZoneBuilder.java
@@ -171,7 +171,7 @@ static void writeMillis(DataOutput out, long millis) throws IOException {
         // Write milliseconds either because the additional precision is
         // required or the minutes didn't fit in the field.
         
-        // Form 11 (64 bits effective precision, but write as if 70 bits)
+        // Form 11 (64-bits effective precision, but write as if 70 bits)
         out.writeByte(millis < 0 ? 0xff : 0xc0);
         out.writeLong(millis);
     }
@@ -205,7 +205,7 @@ static long readMillis(DataInput in) throws IOException {
             return w * 1000L;
 
         case 3:
-            // Form 11 (64 bits effective precision)
+            // Form 11 (64-bits effective precision)
             return in.readLong();
         }
     }

From a61b3ff22820c70d36958ac9090f241f99a0dd0b Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Wed, 27 Nov 2013 12:21:54 +0000
Subject: [PATCH 33/86] Simplify tests

---
 .../time/chrono/TestBuddhistChronology.java   | 216 ++++++++--------
 .../time/chrono/TestCopticChronology.java     | 215 ++++++++--------
 .../time/chrono/TestEthiopicChronology.java   | 215 ++++++++--------
 .../joda/time/chrono/TestGJChronology.java    | 216 ++++++++--------
 .../time/chrono/TestGregorianChronology.java  | 216 ++++++++--------
 .../joda/time/chrono/TestISOChronology.java   | 241 +++++++++---------
 .../time/chrono/TestIslamicChronology.java    | 215 ++++++++--------
 .../time/chrono/TestJulianChronology.java     | 215 ++++++++--------
 8 files changed, 895 insertions(+), 854 deletions(-)

diff --git a/src/test/java/org/joda/time/chrono/TestBuddhistChronology.java b/src/test/java/org/joda/time/chrono/TestBuddhistChronology.java
index 873926eef..fba1bfc5b 100644
--- a/src/test/java/org/joda/time/chrono/TestBuddhistChronology.java
+++ b/src/test/java/org/joda/time/chrono/TestBuddhistChronology.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2005 Stephen Colebourne
+ *  Copyright 2001-2013 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -42,7 +42,6 @@
     private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");
     private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo");
     private static final Chronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC();
-    private static final Chronology COPTIC_UTC = CopticChronology.getInstanceUTC();
     private static final Chronology JULIAN_UTC = JulianChronology.getInstanceUTC();
     private static final Chronology GJ_UTC = GJChronology.getInstanceUTC();
     private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC();
@@ -144,122 +143,127 @@ public void testToString() {
 
     //-----------------------------------------------------------------------
     public void testDurationFields() {
-        assertEquals("eras", BuddhistChronology.getInstance().eras().getName());
-        assertEquals("centuries", BuddhistChronology.getInstance().centuries().getName());
-        assertEquals("years", BuddhistChronology.getInstance().years().getName());
-        assertEquals("weekyears", BuddhistChronology.getInstance().weekyears().getName());
-        assertEquals("months", BuddhistChronology.getInstance().months().getName());
-        assertEquals("weeks", BuddhistChronology.getInstance().weeks().getName());
-        assertEquals("days", BuddhistChronology.getInstance().days().getName());
+        final BuddhistChronology buddhist = BuddhistChronology.getInstance();
+        assertEquals("eras", buddhist.eras().getName());
+        assertEquals("centuries", buddhist.centuries().getName());
+        assertEquals("years", buddhist.years().getName());
+        assertEquals("weekyears", buddhist.weekyears().getName());
+        assertEquals("months", buddhist.months().getName());
+        assertEquals("weeks", buddhist.weeks().getName());
+        assertEquals("days", buddhist.days().getName());
         assertEquals("halfdays", GregorianChronology.getInstance().halfdays().getName());
-        assertEquals("hours", BuddhistChronology.getInstance().hours().getName());
-        assertEquals("minutes", BuddhistChronology.getInstance().minutes().getName());
-        assertEquals("seconds", BuddhistChronology.getInstance().seconds().getName());
-        assertEquals("millis", BuddhistChronology.getInstance().millis().getName());
+        assertEquals("hours", buddhist.hours().getName());
+        assertEquals("minutes", buddhist.minutes().getName());
+        assertEquals("seconds", buddhist.seconds().getName());
+        assertEquals("millis", buddhist.millis().getName());
         
-        assertEquals(false, BuddhistChronology.getInstance().eras().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().centuries().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().years().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().weekyears().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().months().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().weeks().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().days().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().halfdays().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().hours().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().minutes().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().seconds().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().millis().isSupported());
+        assertEquals(false, buddhist.eras().isSupported());
+        assertEquals(true, buddhist.centuries().isSupported());
+        assertEquals(true, buddhist.years().isSupported());
+        assertEquals(true, buddhist.weekyears().isSupported());
+        assertEquals(true, buddhist.months().isSupported());
+        assertEquals(true, buddhist.weeks().isSupported());
+        assertEquals(true, buddhist.days().isSupported());
+        assertEquals(true, buddhist.halfdays().isSupported());
+        assertEquals(true, buddhist.hours().isSupported());
+        assertEquals(true, buddhist.minutes().isSupported());
+        assertEquals(true, buddhist.seconds().isSupported());
+        assertEquals(true, buddhist.millis().isSupported());
         
-        assertEquals(false, BuddhistChronology.getInstance().centuries().isPrecise());
-        assertEquals(false, BuddhistChronology.getInstance().years().isPrecise());
-        assertEquals(false, BuddhistChronology.getInstance().weekyears().isPrecise());
-        assertEquals(false, BuddhistChronology.getInstance().months().isPrecise());
-        assertEquals(false, BuddhistChronology.getInstance().weeks().isPrecise());
-        assertEquals(false, BuddhistChronology.getInstance().days().isPrecise());
-        assertEquals(false, BuddhistChronology.getInstance().halfdays().isPrecise());
-        assertEquals(true, BuddhistChronology.getInstance().hours().isPrecise());
-        assertEquals(true, BuddhistChronology.getInstance().minutes().isPrecise());
-        assertEquals(true, BuddhistChronology.getInstance().seconds().isPrecise());
-        assertEquals(true, BuddhistChronology.getInstance().millis().isPrecise());
+        assertEquals(false, buddhist.centuries().isPrecise());
+        assertEquals(false, buddhist.years().isPrecise());
+        assertEquals(false, buddhist.weekyears().isPrecise());
+        assertEquals(false, buddhist.months().isPrecise());
+        assertEquals(false, buddhist.weeks().isPrecise());
+        assertEquals(false, buddhist.days().isPrecise());
+        assertEquals(false, buddhist.halfdays().isPrecise());
+        assertEquals(true, buddhist.hours().isPrecise());
+        assertEquals(true, buddhist.minutes().isPrecise());
+        assertEquals(true, buddhist.seconds().isPrecise());
+        assertEquals(true, buddhist.millis().isPrecise());
         
-        assertEquals(false, BuddhistChronology.getInstanceUTC().centuries().isPrecise());
-        assertEquals(false, BuddhistChronology.getInstanceUTC().years().isPrecise());
-        assertEquals(false, BuddhistChronology.getInstanceUTC().weekyears().isPrecise());
-        assertEquals(false, BuddhistChronology.getInstanceUTC().months().isPrecise());
-        assertEquals(true, BuddhistChronology.getInstanceUTC().weeks().isPrecise());
-        assertEquals(true, BuddhistChronology.getInstanceUTC().days().isPrecise());
-        assertEquals(true, BuddhistChronology.getInstanceUTC().halfdays().isPrecise());
-        assertEquals(true, BuddhistChronology.getInstanceUTC().hours().isPrecise());
-        assertEquals(true, BuddhistChronology.getInstanceUTC().minutes().isPrecise());
-        assertEquals(true, BuddhistChronology.getInstanceUTC().seconds().isPrecise());
-        assertEquals(true, BuddhistChronology.getInstanceUTC().millis().isPrecise());
+        final BuddhistChronology buddhistUTC = BuddhistChronology.getInstanceUTC();
+        assertEquals(false, buddhistUTC.centuries().isPrecise());
+        assertEquals(false, buddhistUTC.years().isPrecise());
+        assertEquals(false, buddhistUTC.weekyears().isPrecise());
+        assertEquals(false, buddhistUTC.months().isPrecise());
+        assertEquals(true, buddhistUTC.weeks().isPrecise());
+        assertEquals(true, buddhistUTC.days().isPrecise());
+        assertEquals(true, buddhistUTC.halfdays().isPrecise());
+        assertEquals(true, buddhistUTC.hours().isPrecise());
+        assertEquals(true, buddhistUTC.minutes().isPrecise());
+        assertEquals(true, buddhistUTC.seconds().isPrecise());
+        assertEquals(true, buddhistUTC.millis().isPrecise());
         
-        DateTimeZone gmt = DateTimeZone.forID("Etc/GMT");
-        assertEquals(false, BuddhistChronology.getInstance(gmt).centuries().isPrecise());
-        assertEquals(false, BuddhistChronology.getInstance(gmt).years().isPrecise());
-        assertEquals(false, BuddhistChronology.getInstance(gmt).weekyears().isPrecise());
-        assertEquals(false, BuddhistChronology.getInstance(gmt).months().isPrecise());
-        assertEquals(true, BuddhistChronology.getInstance(gmt).weeks().isPrecise());
-        assertEquals(true, BuddhistChronology.getInstance(gmt).days().isPrecise());
-        assertEquals(true, BuddhistChronology.getInstance(gmt).halfdays().isPrecise());
-        assertEquals(true, BuddhistChronology.getInstance(gmt).hours().isPrecise());
-        assertEquals(true, BuddhistChronology.getInstance(gmt).minutes().isPrecise());
-        assertEquals(true, BuddhistChronology.getInstance(gmt).seconds().isPrecise());
-        assertEquals(true, BuddhistChronology.getInstance(gmt).millis().isPrecise());
+        final DateTimeZone gmt = DateTimeZone.forID("Etc/GMT");
+        final BuddhistChronology buddhistGMT = BuddhistChronology.getInstance(gmt);
+        assertEquals(false, buddhistGMT.centuries().isPrecise());
+        assertEquals(false, buddhistGMT.years().isPrecise());
+        assertEquals(false, buddhistGMT.weekyears().isPrecise());
+        assertEquals(false, buddhistGMT.months().isPrecise());
+        assertEquals(true, buddhistGMT.weeks().isPrecise());
+        assertEquals(true, buddhistGMT.days().isPrecise());
+        assertEquals(true, buddhistGMT.halfdays().isPrecise());
+        assertEquals(true, buddhistGMT.hours().isPrecise());
+        assertEquals(true, buddhistGMT.minutes().isPrecise());
+        assertEquals(true, buddhistGMT.seconds().isPrecise());
+        assertEquals(true, buddhistGMT.millis().isPrecise());
     }
 
     public void testDateFields() {
-        assertEquals("era", BuddhistChronology.getInstance().era().getName());
-        assertEquals("centuryOfEra", BuddhistChronology.getInstance().centuryOfEra().getName());
-        assertEquals("yearOfCentury", BuddhistChronology.getInstance().yearOfCentury().getName());
-        assertEquals("yearOfEra", BuddhistChronology.getInstance().yearOfEra().getName());
-        assertEquals("year", BuddhistChronology.getInstance().year().getName());
-        assertEquals("monthOfYear", BuddhistChronology.getInstance().monthOfYear().getName());
-        assertEquals("weekyearOfCentury", BuddhistChronology.getInstance().weekyearOfCentury().getName());
-        assertEquals("weekyear", BuddhistChronology.getInstance().weekyear().getName());
-        assertEquals("weekOfWeekyear", BuddhistChronology.getInstance().weekOfWeekyear().getName());
-        assertEquals("dayOfYear", BuddhistChronology.getInstance().dayOfYear().getName());
-        assertEquals("dayOfMonth", BuddhistChronology.getInstance().dayOfMonth().getName());
-        assertEquals("dayOfWeek", BuddhistChronology.getInstance().dayOfWeek().getName());
+        final BuddhistChronology buddhist = BuddhistChronology.getInstance();
+        assertEquals("era", buddhist.era().getName());
+        assertEquals("centuryOfEra", buddhist.centuryOfEra().getName());
+        assertEquals("yearOfCentury", buddhist.yearOfCentury().getName());
+        assertEquals("yearOfEra", buddhist.yearOfEra().getName());
+        assertEquals("year", buddhist.year().getName());
+        assertEquals("monthOfYear", buddhist.monthOfYear().getName());
+        assertEquals("weekyearOfCentury", buddhist.weekyearOfCentury().getName());
+        assertEquals("weekyear", buddhist.weekyear().getName());
+        assertEquals("weekOfWeekyear", buddhist.weekOfWeekyear().getName());
+        assertEquals("dayOfYear", buddhist.dayOfYear().getName());
+        assertEquals("dayOfMonth", buddhist.dayOfMonth().getName());
+        assertEquals("dayOfWeek", buddhist.dayOfWeek().getName());
         
-        assertEquals(true, BuddhistChronology.getInstance().era().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().centuryOfEra().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().yearOfCentury().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().yearOfEra().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().year().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().monthOfYear().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().weekyearOfCentury().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().weekyear().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().weekOfWeekyear().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().dayOfYear().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().dayOfMonth().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().dayOfWeek().isSupported());
+        assertEquals(true, buddhist.era().isSupported());
+        assertEquals(true, buddhist.centuryOfEra().isSupported());
+        assertEquals(true, buddhist.yearOfCentury().isSupported());
+        assertEquals(true, buddhist.yearOfEra().isSupported());
+        assertEquals(true, buddhist.year().isSupported());
+        assertEquals(true, buddhist.monthOfYear().isSupported());
+        assertEquals(true, buddhist.weekyearOfCentury().isSupported());
+        assertEquals(true, buddhist.weekyear().isSupported());
+        assertEquals(true, buddhist.weekOfWeekyear().isSupported());
+        assertEquals(true, buddhist.dayOfYear().isSupported());
+        assertEquals(true, buddhist.dayOfMonth().isSupported());
+        assertEquals(true, buddhist.dayOfWeek().isSupported());
     }
 
     public void testTimeFields() {
-        assertEquals("halfdayOfDay", BuddhistChronology.getInstance().halfdayOfDay().getName());
-        assertEquals("clockhourOfHalfday", BuddhistChronology.getInstance().clockhourOfHalfday().getName());
-        assertEquals("hourOfHalfday", BuddhistChronology.getInstance().hourOfHalfday().getName());
-        assertEquals("clockhourOfDay", BuddhistChronology.getInstance().clockhourOfDay().getName());
-        assertEquals("hourOfDay", BuddhistChronology.getInstance().hourOfDay().getName());
-        assertEquals("minuteOfDay", BuddhistChronology.getInstance().minuteOfDay().getName());
-        assertEquals("minuteOfHour", BuddhistChronology.getInstance().minuteOfHour().getName());
-        assertEquals("secondOfDay", BuddhistChronology.getInstance().secondOfDay().getName());
-        assertEquals("secondOfMinute", BuddhistChronology.getInstance().secondOfMinute().getName());
-        assertEquals("millisOfDay", BuddhistChronology.getInstance().millisOfDay().getName());
-        assertEquals("millisOfSecond", BuddhistChronology.getInstance().millisOfSecond().getName());
+        final BuddhistChronology buddhist = BuddhistChronology.getInstance();
+        assertEquals("halfdayOfDay", buddhist.halfdayOfDay().getName());
+        assertEquals("clockhourOfHalfday", buddhist.clockhourOfHalfday().getName());
+        assertEquals("hourOfHalfday", buddhist.hourOfHalfday().getName());
+        assertEquals("clockhourOfDay", buddhist.clockhourOfDay().getName());
+        assertEquals("hourOfDay", buddhist.hourOfDay().getName());
+        assertEquals("minuteOfDay", buddhist.minuteOfDay().getName());
+        assertEquals("minuteOfHour", buddhist.minuteOfHour().getName());
+        assertEquals("secondOfDay", buddhist.secondOfDay().getName());
+        assertEquals("secondOfMinute", buddhist.secondOfMinute().getName());
+        assertEquals("millisOfDay", buddhist.millisOfDay().getName());
+        assertEquals("millisOfSecond", buddhist.millisOfSecond().getName());
         
-        assertEquals(true, BuddhistChronology.getInstance().halfdayOfDay().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().clockhourOfHalfday().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().hourOfHalfday().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().clockhourOfDay().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().hourOfDay().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().minuteOfDay().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().minuteOfHour().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().secondOfDay().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().secondOfMinute().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().millisOfDay().isSupported());
-        assertEquals(true, BuddhistChronology.getInstance().millisOfSecond().isSupported());
+        assertEquals(true, buddhist.halfdayOfDay().isSupported());
+        assertEquals(true, buddhist.clockhourOfHalfday().isSupported());
+        assertEquals(true, buddhist.hourOfHalfday().isSupported());
+        assertEquals(true, buddhist.clockhourOfDay().isSupported());
+        assertEquals(true, buddhist.hourOfDay().isSupported());
+        assertEquals(true, buddhist.minuteOfDay().isSupported());
+        assertEquals(true, buddhist.minuteOfHour().isSupported());
+        assertEquals(true, buddhist.secondOfDay().isSupported());
+        assertEquals(true, buddhist.secondOfMinute().isSupported());
+        assertEquals(true, buddhist.millisOfDay().isSupported());
+        assertEquals(true, buddhist.millisOfSecond().isSupported());
     }
 
     //-----------------------------------------------------------------------
@@ -342,8 +346,6 @@ public void testCalendar() {
         DateTimeField gjDayOfMonth = GJ_UTC.dayOfMonth();
         DateTimeField gjMonthOfYear = GJ_UTC.monthOfYear();
         DateTimeField gjYear = GJ_UTC.year();
-        DateTimeField gjYearOfEra = GJ_UTC.yearOfEra();
-        DateTimeField gjEra = GJ_UTC.era();
         while (millis < end) {
             assertEquals(gjDayOfWeek.get(millis), dayOfWeek.get(millis));
             assertEquals(gjDayOfYear.get(millis), dayOfYear.get(millis));
diff --git a/src/test/java/org/joda/time/chrono/TestCopticChronology.java b/src/test/java/org/joda/time/chrono/TestCopticChronology.java
index 4c9531688..023d82397 100644
--- a/src/test/java/org/joda/time/chrono/TestCopticChronology.java
+++ b/src/test/java/org/joda/time/chrono/TestCopticChronology.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2005 Stephen Colebourne
+ *  Copyright 2001-2013 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -146,122 +146,127 @@ public void testToString() {
 
     //-----------------------------------------------------------------------
     public void testDurationFields() {
-        assertEquals("eras", CopticChronology.getInstance().eras().getName());
-        assertEquals("centuries", CopticChronology.getInstance().centuries().getName());
-        assertEquals("years", CopticChronology.getInstance().years().getName());
-        assertEquals("weekyears", CopticChronology.getInstance().weekyears().getName());
-        assertEquals("months", CopticChronology.getInstance().months().getName());
-        assertEquals("weeks", CopticChronology.getInstance().weeks().getName());
-        assertEquals("days", CopticChronology.getInstance().days().getName());
-        assertEquals("halfdays", CopticChronology.getInstance().halfdays().getName());
-        assertEquals("hours", CopticChronology.getInstance().hours().getName());
-        assertEquals("minutes", CopticChronology.getInstance().minutes().getName());
-        assertEquals("seconds", CopticChronology.getInstance().seconds().getName());
-        assertEquals("millis", CopticChronology.getInstance().millis().getName());
+        final CopticChronology coptic = CopticChronology.getInstance();
+        assertEquals("eras", coptic.eras().getName());
+        assertEquals("centuries", coptic.centuries().getName());
+        assertEquals("years", coptic.years().getName());
+        assertEquals("weekyears", coptic.weekyears().getName());
+        assertEquals("months", coptic.months().getName());
+        assertEquals("weeks", coptic.weeks().getName());
+        assertEquals("days", coptic.days().getName());
+        assertEquals("halfdays", coptic.halfdays().getName());
+        assertEquals("hours", coptic.hours().getName());
+        assertEquals("minutes", coptic.minutes().getName());
+        assertEquals("seconds", coptic.seconds().getName());
+        assertEquals("millis", coptic.millis().getName());
         
-        assertEquals(false, CopticChronology.getInstance().eras().isSupported());
-        assertEquals(true, CopticChronology.getInstance().centuries().isSupported());
-        assertEquals(true, CopticChronology.getInstance().years().isSupported());
-        assertEquals(true, CopticChronology.getInstance().weekyears().isSupported());
-        assertEquals(true, CopticChronology.getInstance().months().isSupported());
-        assertEquals(true, CopticChronology.getInstance().weeks().isSupported());
-        assertEquals(true, CopticChronology.getInstance().days().isSupported());
-        assertEquals(true, CopticChronology.getInstance().halfdays().isSupported());
-        assertEquals(true, CopticChronology.getInstance().hours().isSupported());
-        assertEquals(true, CopticChronology.getInstance().minutes().isSupported());
-        assertEquals(true, CopticChronology.getInstance().seconds().isSupported());
-        assertEquals(true, CopticChronology.getInstance().millis().isSupported());
+        assertEquals(false, coptic.eras().isSupported());
+        assertEquals(true, coptic.centuries().isSupported());
+        assertEquals(true, coptic.years().isSupported());
+        assertEquals(true, coptic.weekyears().isSupported());
+        assertEquals(true, coptic.months().isSupported());
+        assertEquals(true, coptic.weeks().isSupported());
+        assertEquals(true, coptic.days().isSupported());
+        assertEquals(true, coptic.halfdays().isSupported());
+        assertEquals(true, coptic.hours().isSupported());
+        assertEquals(true, coptic.minutes().isSupported());
+        assertEquals(true, coptic.seconds().isSupported());
+        assertEquals(true, coptic.millis().isSupported());
         
-        assertEquals(false, CopticChronology.getInstance().centuries().isPrecise());
-        assertEquals(false, CopticChronology.getInstance().years().isPrecise());
-        assertEquals(false, CopticChronology.getInstance().weekyears().isPrecise());
-        assertEquals(false, CopticChronology.getInstance().months().isPrecise());
-        assertEquals(false, CopticChronology.getInstance().weeks().isPrecise());
-        assertEquals(false, CopticChronology.getInstance().days().isPrecise());
-        assertEquals(false, CopticChronology.getInstance().halfdays().isPrecise());
-        assertEquals(true, CopticChronology.getInstance().hours().isPrecise());
-        assertEquals(true, CopticChronology.getInstance().minutes().isPrecise());
-        assertEquals(true, CopticChronology.getInstance().seconds().isPrecise());
-        assertEquals(true, CopticChronology.getInstance().millis().isPrecise());
+        assertEquals(false, coptic.centuries().isPrecise());
+        assertEquals(false, coptic.years().isPrecise());
+        assertEquals(false, coptic.weekyears().isPrecise());
+        assertEquals(false, coptic.months().isPrecise());
+        assertEquals(false, coptic.weeks().isPrecise());
+        assertEquals(false, coptic.days().isPrecise());
+        assertEquals(false, coptic.halfdays().isPrecise());
+        assertEquals(true, coptic.hours().isPrecise());
+        assertEquals(true, coptic.minutes().isPrecise());
+        assertEquals(true, coptic.seconds().isPrecise());
+        assertEquals(true, coptic.millis().isPrecise());
         
-        assertEquals(false, CopticChronology.getInstanceUTC().centuries().isPrecise());
-        assertEquals(false, CopticChronology.getInstanceUTC().years().isPrecise());
-        assertEquals(false, CopticChronology.getInstanceUTC().weekyears().isPrecise());
-        assertEquals(false, CopticChronology.getInstanceUTC().months().isPrecise());
-        assertEquals(true, CopticChronology.getInstanceUTC().weeks().isPrecise());
-        assertEquals(true, CopticChronology.getInstanceUTC().days().isPrecise());
-        assertEquals(true, CopticChronology.getInstanceUTC().halfdays().isPrecise());
-        assertEquals(true, CopticChronology.getInstanceUTC().hours().isPrecise());
-        assertEquals(true, CopticChronology.getInstanceUTC().minutes().isPrecise());
-        assertEquals(true, CopticChronology.getInstanceUTC().seconds().isPrecise());
-        assertEquals(true, CopticChronology.getInstanceUTC().millis().isPrecise());
+        final CopticChronology copticUTC = CopticChronology.getInstanceUTC();
+        assertEquals(false, copticUTC.centuries().isPrecise());
+        assertEquals(false, copticUTC.years().isPrecise());
+        assertEquals(false, copticUTC.weekyears().isPrecise());
+        assertEquals(false, copticUTC.months().isPrecise());
+        assertEquals(true, copticUTC.weeks().isPrecise());
+        assertEquals(true, copticUTC.days().isPrecise());
+        assertEquals(true, copticUTC.halfdays().isPrecise());
+        assertEquals(true, copticUTC.hours().isPrecise());
+        assertEquals(true, copticUTC.minutes().isPrecise());
+        assertEquals(true, copticUTC.seconds().isPrecise());
+        assertEquals(true, copticUTC.millis().isPrecise());
         
-        DateTimeZone gmt = DateTimeZone.forID("Etc/GMT");
-        assertEquals(false, CopticChronology.getInstance(gmt).centuries().isPrecise());
-        assertEquals(false, CopticChronology.getInstance(gmt).years().isPrecise());
-        assertEquals(false, CopticChronology.getInstance(gmt).weekyears().isPrecise());
-        assertEquals(false, CopticChronology.getInstance(gmt).months().isPrecise());
-        assertEquals(true, CopticChronology.getInstance(gmt).weeks().isPrecise());
-        assertEquals(true, CopticChronology.getInstance(gmt).days().isPrecise());
-        assertEquals(true, CopticChronology.getInstance(gmt).halfdays().isPrecise());
-        assertEquals(true, CopticChronology.getInstance(gmt).hours().isPrecise());
-        assertEquals(true, CopticChronology.getInstance(gmt).minutes().isPrecise());
-        assertEquals(true, CopticChronology.getInstance(gmt).seconds().isPrecise());
-        assertEquals(true, CopticChronology.getInstance(gmt).millis().isPrecise());
+        final DateTimeZone gmt = DateTimeZone.forID("Etc/GMT");
+        final CopticChronology copticGMT = CopticChronology.getInstance(gmt);
+        assertEquals(false, copticGMT.centuries().isPrecise());
+        assertEquals(false, copticGMT.years().isPrecise());
+        assertEquals(false, copticGMT.weekyears().isPrecise());
+        assertEquals(false, copticGMT.months().isPrecise());
+        assertEquals(true, copticGMT.weeks().isPrecise());
+        assertEquals(true, copticGMT.days().isPrecise());
+        assertEquals(true, copticGMT.halfdays().isPrecise());
+        assertEquals(true, copticGMT.hours().isPrecise());
+        assertEquals(true, copticGMT.minutes().isPrecise());
+        assertEquals(true, copticGMT.seconds().isPrecise());
+        assertEquals(true, copticGMT.millis().isPrecise());
     }
 
     public void testDateFields() {
-        assertEquals("era", CopticChronology.getInstance().era().getName());
-        assertEquals("centuryOfEra", CopticChronology.getInstance().centuryOfEra().getName());
-        assertEquals("yearOfCentury", CopticChronology.getInstance().yearOfCentury().getName());
-        assertEquals("yearOfEra", CopticChronology.getInstance().yearOfEra().getName());
-        assertEquals("year", CopticChronology.getInstance().year().getName());
-        assertEquals("monthOfYear", CopticChronology.getInstance().monthOfYear().getName());
-        assertEquals("weekyearOfCentury", CopticChronology.getInstance().weekyearOfCentury().getName());
-        assertEquals("weekyear", CopticChronology.getInstance().weekyear().getName());
-        assertEquals("weekOfWeekyear", CopticChronology.getInstance().weekOfWeekyear().getName());
-        assertEquals("dayOfYear", CopticChronology.getInstance().dayOfYear().getName());
-        assertEquals("dayOfMonth", CopticChronology.getInstance().dayOfMonth().getName());
-        assertEquals("dayOfWeek", CopticChronology.getInstance().dayOfWeek().getName());
+        final CopticChronology coptic = CopticChronology.getInstance();
+        assertEquals("era", coptic.era().getName());
+        assertEquals("centuryOfEra", coptic.centuryOfEra().getName());
+        assertEquals("yearOfCentury", coptic.yearOfCentury().getName());
+        assertEquals("yearOfEra", coptic.yearOfEra().getName());
+        assertEquals("year", coptic.year().getName());
+        assertEquals("monthOfYear", coptic.monthOfYear().getName());
+        assertEquals("weekyearOfCentury", coptic.weekyearOfCentury().getName());
+        assertEquals("weekyear", coptic.weekyear().getName());
+        assertEquals("weekOfWeekyear", coptic.weekOfWeekyear().getName());
+        assertEquals("dayOfYear", coptic.dayOfYear().getName());
+        assertEquals("dayOfMonth", coptic.dayOfMonth().getName());
+        assertEquals("dayOfWeek", coptic.dayOfWeek().getName());
         
-        assertEquals(true, CopticChronology.getInstance().era().isSupported());
-        assertEquals(true, CopticChronology.getInstance().centuryOfEra().isSupported());
-        assertEquals(true, CopticChronology.getInstance().yearOfCentury().isSupported());
-        assertEquals(true, CopticChronology.getInstance().yearOfEra().isSupported());
-        assertEquals(true, CopticChronology.getInstance().year().isSupported());
-        assertEquals(true, CopticChronology.getInstance().monthOfYear().isSupported());
-        assertEquals(true, CopticChronology.getInstance().weekyearOfCentury().isSupported());
-        assertEquals(true, CopticChronology.getInstance().weekyear().isSupported());
-        assertEquals(true, CopticChronology.getInstance().weekOfWeekyear().isSupported());
-        assertEquals(true, CopticChronology.getInstance().dayOfYear().isSupported());
-        assertEquals(true, CopticChronology.getInstance().dayOfMonth().isSupported());
-        assertEquals(true, CopticChronology.getInstance().dayOfWeek().isSupported());
+        assertEquals(true, coptic.era().isSupported());
+        assertEquals(true, coptic.centuryOfEra().isSupported());
+        assertEquals(true, coptic.yearOfCentury().isSupported());
+        assertEquals(true, coptic.yearOfEra().isSupported());
+        assertEquals(true, coptic.year().isSupported());
+        assertEquals(true, coptic.monthOfYear().isSupported());
+        assertEquals(true, coptic.weekyearOfCentury().isSupported());
+        assertEquals(true, coptic.weekyear().isSupported());
+        assertEquals(true, coptic.weekOfWeekyear().isSupported());
+        assertEquals(true, coptic.dayOfYear().isSupported());
+        assertEquals(true, coptic.dayOfMonth().isSupported());
+        assertEquals(true, coptic.dayOfWeek().isSupported());
     }
 
     public void testTimeFields() {
-        assertEquals("halfdayOfDay", CopticChronology.getInstance().halfdayOfDay().getName());
-        assertEquals("clockhourOfHalfday", CopticChronology.getInstance().clockhourOfHalfday().getName());
-        assertEquals("hourOfHalfday", CopticChronology.getInstance().hourOfHalfday().getName());
-        assertEquals("clockhourOfDay", CopticChronology.getInstance().clockhourOfDay().getName());
-        assertEquals("hourOfDay", CopticChronology.getInstance().hourOfDay().getName());
-        assertEquals("minuteOfDay", CopticChronology.getInstance().minuteOfDay().getName());
-        assertEquals("minuteOfHour", CopticChronology.getInstance().minuteOfHour().getName());
-        assertEquals("secondOfDay", CopticChronology.getInstance().secondOfDay().getName());
-        assertEquals("secondOfMinute", CopticChronology.getInstance().secondOfMinute().getName());
-        assertEquals("millisOfDay", CopticChronology.getInstance().millisOfDay().getName());
-        assertEquals("millisOfSecond", CopticChronology.getInstance().millisOfSecond().getName());
+        final CopticChronology coptic = CopticChronology.getInstance();
+        assertEquals("halfdayOfDay", coptic.halfdayOfDay().getName());
+        assertEquals("clockhourOfHalfday", coptic.clockhourOfHalfday().getName());
+        assertEquals("hourOfHalfday", coptic.hourOfHalfday().getName());
+        assertEquals("clockhourOfDay", coptic.clockhourOfDay().getName());
+        assertEquals("hourOfDay", coptic.hourOfDay().getName());
+        assertEquals("minuteOfDay", coptic.minuteOfDay().getName());
+        assertEquals("minuteOfHour", coptic.minuteOfHour().getName());
+        assertEquals("secondOfDay", coptic.secondOfDay().getName());
+        assertEquals("secondOfMinute", coptic.secondOfMinute().getName());
+        assertEquals("millisOfDay", coptic.millisOfDay().getName());
+        assertEquals("millisOfSecond", coptic.millisOfSecond().getName());
         
-        assertEquals(true, CopticChronology.getInstance().halfdayOfDay().isSupported());
-        assertEquals(true, CopticChronology.getInstance().clockhourOfHalfday().isSupported());
-        assertEquals(true, CopticChronology.getInstance().hourOfHalfday().isSupported());
-        assertEquals(true, CopticChronology.getInstance().clockhourOfDay().isSupported());
-        assertEquals(true, CopticChronology.getInstance().hourOfDay().isSupported());
-        assertEquals(true, CopticChronology.getInstance().minuteOfDay().isSupported());
-        assertEquals(true, CopticChronology.getInstance().minuteOfHour().isSupported());
-        assertEquals(true, CopticChronology.getInstance().secondOfDay().isSupported());
-        assertEquals(true, CopticChronology.getInstance().secondOfMinute().isSupported());
-        assertEquals(true, CopticChronology.getInstance().millisOfDay().isSupported());
-        assertEquals(true, CopticChronology.getInstance().millisOfSecond().isSupported());
+        assertEquals(true, coptic.halfdayOfDay().isSupported());
+        assertEquals(true, coptic.clockhourOfHalfday().isSupported());
+        assertEquals(true, coptic.hourOfHalfday().isSupported());
+        assertEquals(true, coptic.clockhourOfDay().isSupported());
+        assertEquals(true, coptic.hourOfDay().isSupported());
+        assertEquals(true, coptic.minuteOfDay().isSupported());
+        assertEquals(true, coptic.minuteOfHour().isSupported());
+        assertEquals(true, coptic.secondOfDay().isSupported());
+        assertEquals(true, coptic.secondOfMinute().isSupported());
+        assertEquals(true, coptic.millisOfDay().isSupported());
+        assertEquals(true, coptic.millisOfSecond().isSupported());
     }
 
     //-----------------------------------------------------------------------
diff --git a/src/test/java/org/joda/time/chrono/TestEthiopicChronology.java b/src/test/java/org/joda/time/chrono/TestEthiopicChronology.java
index 1eacbdec3..1f5a1285d 100644
--- a/src/test/java/org/joda/time/chrono/TestEthiopicChronology.java
+++ b/src/test/java/org/joda/time/chrono/TestEthiopicChronology.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2005 Stephen Colebourne
+ *  Copyright 2001-2013 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -146,122 +146,127 @@ public void testToString() {
 
     //-----------------------------------------------------------------------
     public void testDurationFields() {
-        assertEquals("eras", EthiopicChronology.getInstance().eras().getName());
-        assertEquals("centuries", EthiopicChronology.getInstance().centuries().getName());
-        assertEquals("years", EthiopicChronology.getInstance().years().getName());
-        assertEquals("weekyears", EthiopicChronology.getInstance().weekyears().getName());
-        assertEquals("months", EthiopicChronology.getInstance().months().getName());
-        assertEquals("weeks", EthiopicChronology.getInstance().weeks().getName());
-        assertEquals("days", EthiopicChronology.getInstance().days().getName());
-        assertEquals("halfdays", EthiopicChronology.getInstance().halfdays().getName());
-        assertEquals("hours", EthiopicChronology.getInstance().hours().getName());
-        assertEquals("minutes", EthiopicChronology.getInstance().minutes().getName());
-        assertEquals("seconds", EthiopicChronology.getInstance().seconds().getName());
-        assertEquals("millis", EthiopicChronology.getInstance().millis().getName());
+        final EthiopicChronology ethiopic = EthiopicChronology.getInstance();
+        assertEquals("eras", ethiopic.eras().getName());
+        assertEquals("centuries", ethiopic.centuries().getName());
+        assertEquals("years", ethiopic.years().getName());
+        assertEquals("weekyears", ethiopic.weekyears().getName());
+        assertEquals("months", ethiopic.months().getName());
+        assertEquals("weeks", ethiopic.weeks().getName());
+        assertEquals("days", ethiopic.days().getName());
+        assertEquals("halfdays", ethiopic.halfdays().getName());
+        assertEquals("hours", ethiopic.hours().getName());
+        assertEquals("minutes", ethiopic.minutes().getName());
+        assertEquals("seconds", ethiopic.seconds().getName());
+        assertEquals("millis", ethiopic.millis().getName());
         
-        assertEquals(false, EthiopicChronology.getInstance().eras().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().centuries().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().years().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().weekyears().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().months().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().weeks().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().days().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().halfdays().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().hours().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().minutes().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().seconds().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().millis().isSupported());
+        assertEquals(false, ethiopic.eras().isSupported());
+        assertEquals(true, ethiopic.centuries().isSupported());
+        assertEquals(true, ethiopic.years().isSupported());
+        assertEquals(true, ethiopic.weekyears().isSupported());
+        assertEquals(true, ethiopic.months().isSupported());
+        assertEquals(true, ethiopic.weeks().isSupported());
+        assertEquals(true, ethiopic.days().isSupported());
+        assertEquals(true, ethiopic.halfdays().isSupported());
+        assertEquals(true, ethiopic.hours().isSupported());
+        assertEquals(true, ethiopic.minutes().isSupported());
+        assertEquals(true, ethiopic.seconds().isSupported());
+        assertEquals(true, ethiopic.millis().isSupported());
         
-        assertEquals(false, EthiopicChronology.getInstance().centuries().isPrecise());
-        assertEquals(false, EthiopicChronology.getInstance().years().isPrecise());
-        assertEquals(false, EthiopicChronology.getInstance().weekyears().isPrecise());
-        assertEquals(false, EthiopicChronology.getInstance().months().isPrecise());
-        assertEquals(false, EthiopicChronology.getInstance().weeks().isPrecise());
-        assertEquals(false, EthiopicChronology.getInstance().days().isPrecise());
-        assertEquals(false, EthiopicChronology.getInstance().halfdays().isPrecise());
-        assertEquals(true, EthiopicChronology.getInstance().hours().isPrecise());
-        assertEquals(true, EthiopicChronology.getInstance().minutes().isPrecise());
-        assertEquals(true, EthiopicChronology.getInstance().seconds().isPrecise());
-        assertEquals(true, EthiopicChronology.getInstance().millis().isPrecise());
+        assertEquals(false, ethiopic.centuries().isPrecise());
+        assertEquals(false, ethiopic.years().isPrecise());
+        assertEquals(false, ethiopic.weekyears().isPrecise());
+        assertEquals(false, ethiopic.months().isPrecise());
+        assertEquals(false, ethiopic.weeks().isPrecise());
+        assertEquals(false, ethiopic.days().isPrecise());
+        assertEquals(false, ethiopic.halfdays().isPrecise());
+        assertEquals(true, ethiopic.hours().isPrecise());
+        assertEquals(true, ethiopic.minutes().isPrecise());
+        assertEquals(true, ethiopic.seconds().isPrecise());
+        assertEquals(true, ethiopic.millis().isPrecise());
         
-        assertEquals(false, EthiopicChronology.getInstanceUTC().centuries().isPrecise());
-        assertEquals(false, EthiopicChronology.getInstanceUTC().years().isPrecise());
-        assertEquals(false, EthiopicChronology.getInstanceUTC().weekyears().isPrecise());
-        assertEquals(false, EthiopicChronology.getInstanceUTC().months().isPrecise());
-        assertEquals(true, EthiopicChronology.getInstanceUTC().weeks().isPrecise());
-        assertEquals(true, EthiopicChronology.getInstanceUTC().days().isPrecise());
-        assertEquals(true, EthiopicChronology.getInstanceUTC().halfdays().isPrecise());
-        assertEquals(true, EthiopicChronology.getInstanceUTC().hours().isPrecise());
-        assertEquals(true, EthiopicChronology.getInstanceUTC().minutes().isPrecise());
-        assertEquals(true, EthiopicChronology.getInstanceUTC().seconds().isPrecise());
-        assertEquals(true, EthiopicChronology.getInstanceUTC().millis().isPrecise());
+        final EthiopicChronology ethiopicUTC = EthiopicChronology.getInstanceUTC();
+        assertEquals(false, ethiopicUTC.centuries().isPrecise());
+        assertEquals(false, ethiopicUTC.years().isPrecise());
+        assertEquals(false, ethiopicUTC.weekyears().isPrecise());
+        assertEquals(false, ethiopicUTC.months().isPrecise());
+        assertEquals(true, ethiopicUTC.weeks().isPrecise());
+        assertEquals(true, ethiopicUTC.days().isPrecise());
+        assertEquals(true, ethiopicUTC.halfdays().isPrecise());
+        assertEquals(true, ethiopicUTC.hours().isPrecise());
+        assertEquals(true, ethiopicUTC.minutes().isPrecise());
+        assertEquals(true, ethiopicUTC.seconds().isPrecise());
+        assertEquals(true, ethiopicUTC.millis().isPrecise());
         
-        DateTimeZone gmt = DateTimeZone.forID("Etc/GMT");
-        assertEquals(false, EthiopicChronology.getInstance(gmt).centuries().isPrecise());
-        assertEquals(false, EthiopicChronology.getInstance(gmt).years().isPrecise());
-        assertEquals(false, EthiopicChronology.getInstance(gmt).weekyears().isPrecise());
-        assertEquals(false, EthiopicChronology.getInstance(gmt).months().isPrecise());
-        assertEquals(true, EthiopicChronology.getInstance(gmt).weeks().isPrecise());
-        assertEquals(true, EthiopicChronology.getInstance(gmt).days().isPrecise());
-        assertEquals(true, EthiopicChronology.getInstance(gmt).halfdays().isPrecise());
-        assertEquals(true, EthiopicChronology.getInstance(gmt).hours().isPrecise());
-        assertEquals(true, EthiopicChronology.getInstance(gmt).minutes().isPrecise());
-        assertEquals(true, EthiopicChronology.getInstance(gmt).seconds().isPrecise());
-        assertEquals(true, EthiopicChronology.getInstance(gmt).millis().isPrecise());
+        final DateTimeZone gmt = DateTimeZone.forID("Etc/GMT");
+        final EthiopicChronology ethiopicGMT = EthiopicChronology.getInstance(gmt);
+        assertEquals(false, ethiopicGMT.centuries().isPrecise());
+        assertEquals(false, ethiopicGMT.years().isPrecise());
+        assertEquals(false, ethiopicGMT.weekyears().isPrecise());
+        assertEquals(false, ethiopicGMT.months().isPrecise());
+        assertEquals(true, ethiopicGMT.weeks().isPrecise());
+        assertEquals(true, ethiopicGMT.days().isPrecise());
+        assertEquals(true, ethiopicGMT.halfdays().isPrecise());
+        assertEquals(true, ethiopicGMT.hours().isPrecise());
+        assertEquals(true, ethiopicGMT.minutes().isPrecise());
+        assertEquals(true, ethiopicGMT.seconds().isPrecise());
+        assertEquals(true, ethiopicGMT.millis().isPrecise());
     }
 
     public void testDateFields() {
-        assertEquals("era", EthiopicChronology.getInstance().era().getName());
-        assertEquals("centuryOfEra", EthiopicChronology.getInstance().centuryOfEra().getName());
-        assertEquals("yearOfCentury", EthiopicChronology.getInstance().yearOfCentury().getName());
-        assertEquals("yearOfEra", EthiopicChronology.getInstance().yearOfEra().getName());
-        assertEquals("year", EthiopicChronology.getInstance().year().getName());
-        assertEquals("monthOfYear", EthiopicChronology.getInstance().monthOfYear().getName());
-        assertEquals("weekyearOfCentury", EthiopicChronology.getInstance().weekyearOfCentury().getName());
-        assertEquals("weekyear", EthiopicChronology.getInstance().weekyear().getName());
-        assertEquals("weekOfWeekyear", EthiopicChronology.getInstance().weekOfWeekyear().getName());
-        assertEquals("dayOfYear", EthiopicChronology.getInstance().dayOfYear().getName());
-        assertEquals("dayOfMonth", EthiopicChronology.getInstance().dayOfMonth().getName());
-        assertEquals("dayOfWeek", EthiopicChronology.getInstance().dayOfWeek().getName());
+        final EthiopicChronology ethiopic = EthiopicChronology.getInstance();
+        assertEquals("era", ethiopic.era().getName());
+        assertEquals("centuryOfEra", ethiopic.centuryOfEra().getName());
+        assertEquals("yearOfCentury", ethiopic.yearOfCentury().getName());
+        assertEquals("yearOfEra", ethiopic.yearOfEra().getName());
+        assertEquals("year", ethiopic.year().getName());
+        assertEquals("monthOfYear", ethiopic.monthOfYear().getName());
+        assertEquals("weekyearOfCentury", ethiopic.weekyearOfCentury().getName());
+        assertEquals("weekyear", ethiopic.weekyear().getName());
+        assertEquals("weekOfWeekyear", ethiopic.weekOfWeekyear().getName());
+        assertEquals("dayOfYear", ethiopic.dayOfYear().getName());
+        assertEquals("dayOfMonth", ethiopic.dayOfMonth().getName());
+        assertEquals("dayOfWeek", ethiopic.dayOfWeek().getName());
         
-        assertEquals(true, EthiopicChronology.getInstance().era().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().centuryOfEra().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().yearOfCentury().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().yearOfEra().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().year().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().monthOfYear().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().weekyearOfCentury().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().weekyear().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().weekOfWeekyear().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().dayOfYear().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().dayOfMonth().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().dayOfWeek().isSupported());
+        assertEquals(true, ethiopic.era().isSupported());
+        assertEquals(true, ethiopic.centuryOfEra().isSupported());
+        assertEquals(true, ethiopic.yearOfCentury().isSupported());
+        assertEquals(true, ethiopic.yearOfEra().isSupported());
+        assertEquals(true, ethiopic.year().isSupported());
+        assertEquals(true, ethiopic.monthOfYear().isSupported());
+        assertEquals(true, ethiopic.weekyearOfCentury().isSupported());
+        assertEquals(true, ethiopic.weekyear().isSupported());
+        assertEquals(true, ethiopic.weekOfWeekyear().isSupported());
+        assertEquals(true, ethiopic.dayOfYear().isSupported());
+        assertEquals(true, ethiopic.dayOfMonth().isSupported());
+        assertEquals(true, ethiopic.dayOfWeek().isSupported());
     }
 
     public void testTimeFields() {
-        assertEquals("halfdayOfDay", EthiopicChronology.getInstance().halfdayOfDay().getName());
-        assertEquals("clockhourOfHalfday", EthiopicChronology.getInstance().clockhourOfHalfday().getName());
-        assertEquals("hourOfHalfday", EthiopicChronology.getInstance().hourOfHalfday().getName());
-        assertEquals("clockhourOfDay", EthiopicChronology.getInstance().clockhourOfDay().getName());
-        assertEquals("hourOfDay", EthiopicChronology.getInstance().hourOfDay().getName());
-        assertEquals("minuteOfDay", EthiopicChronology.getInstance().minuteOfDay().getName());
-        assertEquals("minuteOfHour", EthiopicChronology.getInstance().minuteOfHour().getName());
-        assertEquals("secondOfDay", EthiopicChronology.getInstance().secondOfDay().getName());
-        assertEquals("secondOfMinute", EthiopicChronology.getInstance().secondOfMinute().getName());
-        assertEquals("millisOfDay", EthiopicChronology.getInstance().millisOfDay().getName());
-        assertEquals("millisOfSecond", EthiopicChronology.getInstance().millisOfSecond().getName());
+        final EthiopicChronology ethiopic = EthiopicChronology.getInstance();
+        assertEquals("halfdayOfDay", ethiopic.halfdayOfDay().getName());
+        assertEquals("clockhourOfHalfday", ethiopic.clockhourOfHalfday().getName());
+        assertEquals("hourOfHalfday", ethiopic.hourOfHalfday().getName());
+        assertEquals("clockhourOfDay", ethiopic.clockhourOfDay().getName());
+        assertEquals("hourOfDay", ethiopic.hourOfDay().getName());
+        assertEquals("minuteOfDay", ethiopic.minuteOfDay().getName());
+        assertEquals("minuteOfHour", ethiopic.minuteOfHour().getName());
+        assertEquals("secondOfDay", ethiopic.secondOfDay().getName());
+        assertEquals("secondOfMinute", ethiopic.secondOfMinute().getName());
+        assertEquals("millisOfDay", ethiopic.millisOfDay().getName());
+        assertEquals("millisOfSecond", ethiopic.millisOfSecond().getName());
         
-        assertEquals(true, EthiopicChronology.getInstance().halfdayOfDay().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().clockhourOfHalfday().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().hourOfHalfday().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().clockhourOfDay().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().hourOfDay().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().minuteOfDay().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().minuteOfHour().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().secondOfDay().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().secondOfMinute().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().millisOfDay().isSupported());
-        assertEquals(true, EthiopicChronology.getInstance().millisOfSecond().isSupported());
+        assertEquals(true, ethiopic.halfdayOfDay().isSupported());
+        assertEquals(true, ethiopic.clockhourOfHalfday().isSupported());
+        assertEquals(true, ethiopic.hourOfHalfday().isSupported());
+        assertEquals(true, ethiopic.clockhourOfDay().isSupported());
+        assertEquals(true, ethiopic.hourOfDay().isSupported());
+        assertEquals(true, ethiopic.minuteOfDay().isSupported());
+        assertEquals(true, ethiopic.minuteOfHour().isSupported());
+        assertEquals(true, ethiopic.secondOfDay().isSupported());
+        assertEquals(true, ethiopic.secondOfMinute().isSupported());
+        assertEquals(true, ethiopic.millisOfDay().isSupported());
+        assertEquals(true, ethiopic.millisOfSecond().isSupported());
     }
 
     //-----------------------------------------------------------------------
diff --git a/src/test/java/org/joda/time/chrono/TestGJChronology.java b/src/test/java/org/joda/time/chrono/TestGJChronology.java
index 3cf495024..d0e8ddfde 100644
--- a/src/test/java/org/joda/time/chrono/TestGJChronology.java
+++ b/src/test/java/org/joda/time/chrono/TestGJChronology.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2005 Stephen Colebourne
+ *  Copyright 2001-2013 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -39,6 +39,7 @@
  *
  * @author Stephen Colebourne
  */
+@SuppressWarnings("deprecation")
 public class TestGJChronology extends TestCase {
 
     private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");
@@ -195,122 +196,127 @@ public void testToString() {
 
     //-----------------------------------------------------------------------
     public void testDurationFields() {
-        assertEquals("eras", GJChronology.getInstance().eras().getName());
-        assertEquals("centuries", GJChronology.getInstance().centuries().getName());
-        assertEquals("years", GJChronology.getInstance().years().getName());
-        assertEquals("weekyears", GJChronology.getInstance().weekyears().getName());
-        assertEquals("months", GJChronology.getInstance().months().getName());
-        assertEquals("weeks", GJChronology.getInstance().weeks().getName());
-        assertEquals("halfdays", GJChronology.getInstance().halfdays().getName());
-        assertEquals("days", GJChronology.getInstance().days().getName());
-        assertEquals("hours", GJChronology.getInstance().hours().getName());
-        assertEquals("minutes", GJChronology.getInstance().minutes().getName());
-        assertEquals("seconds", GJChronology.getInstance().seconds().getName());
-        assertEquals("millis", GJChronology.getInstance().millis().getName());
+        final GJChronology gj = GJChronology.getInstance();
+        assertEquals("eras", gj.eras().getName());
+        assertEquals("centuries", gj.centuries().getName());
+        assertEquals("years", gj.years().getName());
+        assertEquals("weekyears", gj.weekyears().getName());
+        assertEquals("months", gj.months().getName());
+        assertEquals("weeks", gj.weeks().getName());
+        assertEquals("halfdays", gj.halfdays().getName());
+        assertEquals("days", gj.days().getName());
+        assertEquals("hours", gj.hours().getName());
+        assertEquals("minutes", gj.minutes().getName());
+        assertEquals("seconds", gj.seconds().getName());
+        assertEquals("millis", gj.millis().getName());
         
-        assertEquals(false, GJChronology.getInstance().eras().isSupported());
-        assertEquals(true, GJChronology.getInstance().centuries().isSupported());
-        assertEquals(true, GJChronology.getInstance().years().isSupported());
-        assertEquals(true, GJChronology.getInstance().weekyears().isSupported());
-        assertEquals(true, GJChronology.getInstance().months().isSupported());
-        assertEquals(true, GJChronology.getInstance().weeks().isSupported());
-        assertEquals(true, GJChronology.getInstance().days().isSupported());
-        assertEquals(true, GJChronology.getInstance().halfdays().isSupported());
-        assertEquals(true, GJChronology.getInstance().hours().isSupported());
-        assertEquals(true, GJChronology.getInstance().minutes().isSupported());
-        assertEquals(true, GJChronology.getInstance().seconds().isSupported());
-        assertEquals(true, GJChronology.getInstance().millis().isSupported());
+        assertEquals(false, gj.eras().isSupported());
+        assertEquals(true, gj.centuries().isSupported());
+        assertEquals(true, gj.years().isSupported());
+        assertEquals(true, gj.weekyears().isSupported());
+        assertEquals(true, gj.months().isSupported());
+        assertEquals(true, gj.weeks().isSupported());
+        assertEquals(true, gj.days().isSupported());
+        assertEquals(true, gj.halfdays().isSupported());
+        assertEquals(true, gj.hours().isSupported());
+        assertEquals(true, gj.minutes().isSupported());
+        assertEquals(true, gj.seconds().isSupported());
+        assertEquals(true, gj.millis().isSupported());
         
-        assertEquals(false, GJChronology.getInstance().centuries().isPrecise());
-        assertEquals(false, GJChronology.getInstance().years().isPrecise());
-        assertEquals(false, GJChronology.getInstance().weekyears().isPrecise());
-        assertEquals(false, GJChronology.getInstance().months().isPrecise());
-        assertEquals(false, GJChronology.getInstance().weeks().isPrecise());
-        assertEquals(false, GJChronology.getInstance().days().isPrecise());
-        assertEquals(false, GJChronology.getInstance().halfdays().isPrecise());
-        assertEquals(true, GJChronology.getInstance().hours().isPrecise());
-        assertEquals(true, GJChronology.getInstance().minutes().isPrecise());
-        assertEquals(true, GJChronology.getInstance().seconds().isPrecise());
-        assertEquals(true, GJChronology.getInstance().millis().isPrecise());
+        assertEquals(false, gj.centuries().isPrecise());
+        assertEquals(false, gj.years().isPrecise());
+        assertEquals(false, gj.weekyears().isPrecise());
+        assertEquals(false, gj.months().isPrecise());
+        assertEquals(false, gj.weeks().isPrecise());
+        assertEquals(false, gj.days().isPrecise());
+        assertEquals(false, gj.halfdays().isPrecise());
+        assertEquals(true, gj.hours().isPrecise());
+        assertEquals(true, gj.minutes().isPrecise());
+        assertEquals(true, gj.seconds().isPrecise());
+        assertEquals(true, gj.millis().isPrecise());
         
-        assertEquals(false, GJChronology.getInstanceUTC().centuries().isPrecise());
-        assertEquals(false, GJChronology.getInstanceUTC().years().isPrecise());
-        assertEquals(false, GJChronology.getInstanceUTC().weekyears().isPrecise());
-        assertEquals(false, GJChronology.getInstanceUTC().months().isPrecise());
-        assertEquals(true, GJChronology.getInstanceUTC().weeks().isPrecise());
-        assertEquals(true, GJChronology.getInstanceUTC().days().isPrecise());
-        assertEquals(true, GJChronology.getInstanceUTC().halfdays().isPrecise());
-        assertEquals(true, GJChronology.getInstanceUTC().hours().isPrecise());
-        assertEquals(true, GJChronology.getInstanceUTC().minutes().isPrecise());
-        assertEquals(true, GJChronology.getInstanceUTC().seconds().isPrecise());
-        assertEquals(true, GJChronology.getInstanceUTC().millis().isPrecise());
+        final GJChronology gjUTC = GJChronology.getInstanceUTC();
+        assertEquals(false, gjUTC.centuries().isPrecise());
+        assertEquals(false, gjUTC.years().isPrecise());
+        assertEquals(false, gjUTC.weekyears().isPrecise());
+        assertEquals(false, gjUTC.months().isPrecise());
+        assertEquals(true, gjUTC.weeks().isPrecise());
+        assertEquals(true, gjUTC.days().isPrecise());
+        assertEquals(true, gjUTC.halfdays().isPrecise());
+        assertEquals(true, gjUTC.hours().isPrecise());
+        assertEquals(true, gjUTC.minutes().isPrecise());
+        assertEquals(true, gjUTC.seconds().isPrecise());
+        assertEquals(true, gjUTC.millis().isPrecise());
         
-        DateTimeZone gmt = DateTimeZone.forID("Etc/GMT");
-        assertEquals(false, GJChronology.getInstance(gmt).centuries().isPrecise());
-        assertEquals(false, GJChronology.getInstance(gmt).years().isPrecise());
-        assertEquals(false, GJChronology.getInstance(gmt).weekyears().isPrecise());
-        assertEquals(false, GJChronology.getInstance(gmt).months().isPrecise());
-        assertEquals(true, GJChronology.getInstance(gmt).weeks().isPrecise());
-        assertEquals(true, GJChronology.getInstance(gmt).days().isPrecise());
-        assertEquals(true, GJChronology.getInstance(gmt).halfdays().isPrecise());
-        assertEquals(true, GJChronology.getInstance(gmt).hours().isPrecise());
-        assertEquals(true, GJChronology.getInstance(gmt).minutes().isPrecise());
-        assertEquals(true, GJChronology.getInstance(gmt).seconds().isPrecise());
-        assertEquals(true, GJChronology.getInstance(gmt).millis().isPrecise());
+        final DateTimeZone gmt = DateTimeZone.forID("Etc/GMT");
+        final GJChronology gjGMT = GJChronology.getInstance(gmt);
+        assertEquals(false, gjGMT.centuries().isPrecise());
+        assertEquals(false, gjGMT.years().isPrecise());
+        assertEquals(false, gjGMT.weekyears().isPrecise());
+        assertEquals(false, gjGMT.months().isPrecise());
+        assertEquals(true, gjGMT.weeks().isPrecise());
+        assertEquals(true, gjGMT.days().isPrecise());
+        assertEquals(true, gjGMT.halfdays().isPrecise());
+        assertEquals(true, gjGMT.hours().isPrecise());
+        assertEquals(true, gjGMT.minutes().isPrecise());
+        assertEquals(true, gjGMT.seconds().isPrecise());
+        assertEquals(true, gjGMT.millis().isPrecise());
     }
 
     public void testDateFields() {
-        assertEquals("era", GJChronology.getInstance().era().getName());
-        assertEquals("centuryOfEra", GJChronology.getInstance().centuryOfEra().getName());
-        assertEquals("yearOfCentury", GJChronology.getInstance().yearOfCentury().getName());
-        assertEquals("yearOfEra", GJChronology.getInstance().yearOfEra().getName());
-        assertEquals("year", GJChronology.getInstance().year().getName());
-        assertEquals("monthOfYear", GJChronology.getInstance().monthOfYear().getName());
-        assertEquals("weekyearOfCentury", GJChronology.getInstance().weekyearOfCentury().getName());
-        assertEquals("weekyear", GJChronology.getInstance().weekyear().getName());
-        assertEquals("weekOfWeekyear", GJChronology.getInstance().weekOfWeekyear().getName());
-        assertEquals("dayOfYear", GJChronology.getInstance().dayOfYear().getName());
-        assertEquals("dayOfMonth", GJChronology.getInstance().dayOfMonth().getName());
-        assertEquals("dayOfWeek", GJChronology.getInstance().dayOfWeek().getName());
+        final GJChronology gj = GJChronology.getInstance();
+        assertEquals("era", gj.era().getName());
+        assertEquals("centuryOfEra", gj.centuryOfEra().getName());
+        assertEquals("yearOfCentury", gj.yearOfCentury().getName());
+        assertEquals("yearOfEra", gj.yearOfEra().getName());
+        assertEquals("year", gj.year().getName());
+        assertEquals("monthOfYear", gj.monthOfYear().getName());
+        assertEquals("weekyearOfCentury", gj.weekyearOfCentury().getName());
+        assertEquals("weekyear", gj.weekyear().getName());
+        assertEquals("weekOfWeekyear", gj.weekOfWeekyear().getName());
+        assertEquals("dayOfYear", gj.dayOfYear().getName());
+        assertEquals("dayOfMonth", gj.dayOfMonth().getName());
+        assertEquals("dayOfWeek", gj.dayOfWeek().getName());
         
-        assertEquals(true, GJChronology.getInstance().era().isSupported());
-        assertEquals(true, GJChronology.getInstance().centuryOfEra().isSupported());
-        assertEquals(true, GJChronology.getInstance().yearOfCentury().isSupported());
-        assertEquals(true, GJChronology.getInstance().yearOfEra().isSupported());
-        assertEquals(true, GJChronology.getInstance().year().isSupported());
-        assertEquals(true, GJChronology.getInstance().monthOfYear().isSupported());
-        assertEquals(true, GJChronology.getInstance().weekyearOfCentury().isSupported());
-        assertEquals(true, GJChronology.getInstance().weekyear().isSupported());
-        assertEquals(true, GJChronology.getInstance().weekOfWeekyear().isSupported());
-        assertEquals(true, GJChronology.getInstance().dayOfYear().isSupported());
-        assertEquals(true, GJChronology.getInstance().dayOfMonth().isSupported());
-        assertEquals(true, GJChronology.getInstance().dayOfWeek().isSupported());
+        assertEquals(true, gj.era().isSupported());
+        assertEquals(true, gj.centuryOfEra().isSupported());
+        assertEquals(true, gj.yearOfCentury().isSupported());
+        assertEquals(true, gj.yearOfEra().isSupported());
+        assertEquals(true, gj.year().isSupported());
+        assertEquals(true, gj.monthOfYear().isSupported());
+        assertEquals(true, gj.weekyearOfCentury().isSupported());
+        assertEquals(true, gj.weekyear().isSupported());
+        assertEquals(true, gj.weekOfWeekyear().isSupported());
+        assertEquals(true, gj.dayOfYear().isSupported());
+        assertEquals(true, gj.dayOfMonth().isSupported());
+        assertEquals(true, gj.dayOfWeek().isSupported());
     }
 
     public void testTimeFields() {
-        assertEquals("halfdayOfDay", GJChronology.getInstance().halfdayOfDay().getName());
-        assertEquals("clockhourOfHalfday", GJChronology.getInstance().clockhourOfHalfday().getName());
-        assertEquals("hourOfHalfday", GJChronology.getInstance().hourOfHalfday().getName());
-        assertEquals("clockhourOfDay", GJChronology.getInstance().clockhourOfDay().getName());
-        assertEquals("hourOfDay", GJChronology.getInstance().hourOfDay().getName());
-        assertEquals("minuteOfDay", GJChronology.getInstance().minuteOfDay().getName());
-        assertEquals("minuteOfHour", GJChronology.getInstance().minuteOfHour().getName());
-        assertEquals("secondOfDay", GJChronology.getInstance().secondOfDay().getName());
-        assertEquals("secondOfMinute", GJChronology.getInstance().secondOfMinute().getName());
-        assertEquals("millisOfDay", GJChronology.getInstance().millisOfDay().getName());
-        assertEquals("millisOfSecond", GJChronology.getInstance().millisOfSecond().getName());
+        final GJChronology gj = GJChronology.getInstance();
+        assertEquals("halfdayOfDay", gj.halfdayOfDay().getName());
+        assertEquals("clockhourOfHalfday", gj.clockhourOfHalfday().getName());
+        assertEquals("hourOfHalfday", gj.hourOfHalfday().getName());
+        assertEquals("clockhourOfDay", gj.clockhourOfDay().getName());
+        assertEquals("hourOfDay", gj.hourOfDay().getName());
+        assertEquals("minuteOfDay", gj.minuteOfDay().getName());
+        assertEquals("minuteOfHour", gj.minuteOfHour().getName());
+        assertEquals("secondOfDay", gj.secondOfDay().getName());
+        assertEquals("secondOfMinute", gj.secondOfMinute().getName());
+        assertEquals("millisOfDay", gj.millisOfDay().getName());
+        assertEquals("millisOfSecond", gj.millisOfSecond().getName());
         
-        assertEquals(true, GJChronology.getInstance().halfdayOfDay().isSupported());
-        assertEquals(true, GJChronology.getInstance().clockhourOfHalfday().isSupported());
-        assertEquals(true, GJChronology.getInstance().hourOfHalfday().isSupported());
-        assertEquals(true, GJChronology.getInstance().clockhourOfDay().isSupported());
-        assertEquals(true, GJChronology.getInstance().hourOfDay().isSupported());
-        assertEquals(true, GJChronology.getInstance().minuteOfDay().isSupported());
-        assertEquals(true, GJChronology.getInstance().minuteOfHour().isSupported());
-        assertEquals(true, GJChronology.getInstance().secondOfDay().isSupported());
-        assertEquals(true, GJChronology.getInstance().secondOfMinute().isSupported());
-        assertEquals(true, GJChronology.getInstance().millisOfDay().isSupported());
-        assertEquals(true, GJChronology.getInstance().millisOfSecond().isSupported());
+        assertEquals(true, gj.halfdayOfDay().isSupported());
+        assertEquals(true, gj.clockhourOfHalfday().isSupported());
+        assertEquals(true, gj.hourOfHalfday().isSupported());
+        assertEquals(true, gj.clockhourOfDay().isSupported());
+        assertEquals(true, gj.hourOfDay().isSupported());
+        assertEquals(true, gj.minuteOfDay().isSupported());
+        assertEquals(true, gj.minuteOfHour().isSupported());
+        assertEquals(true, gj.secondOfDay().isSupported());
+        assertEquals(true, gj.secondOfMinute().isSupported());
+        assertEquals(true, gj.millisOfDay().isSupported());
+        assertEquals(true, gj.millisOfSecond().isSupported());
     }
 
     public void testIllegalDates() {
diff --git a/src/test/java/org/joda/time/chrono/TestGregorianChronology.java b/src/test/java/org/joda/time/chrono/TestGregorianChronology.java
index de7630006..d1a32b42c 100644
--- a/src/test/java/org/joda/time/chrono/TestGregorianChronology.java
+++ b/src/test/java/org/joda/time/chrono/TestGregorianChronology.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2005 Stephen Colebourne
+ *  Copyright 2001-2013 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -33,6 +33,7 @@
  *
  * @author Stephen Colebourne
  */
+@SuppressWarnings("deprecation")
 public class TestGregorianChronology extends TestCase {
 
     private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");
@@ -151,122 +152,127 @@ public void testToString() {
 
     //-----------------------------------------------------------------------
     public void testDurationFields() {
-        assertEquals("eras", GregorianChronology.getInstance().eras().getName());
-        assertEquals("centuries", GregorianChronology.getInstance().centuries().getName());
-        assertEquals("years", GregorianChronology.getInstance().years().getName());
-        assertEquals("weekyears", GregorianChronology.getInstance().weekyears().getName());
-        assertEquals("months", GregorianChronology.getInstance().months().getName());
-        assertEquals("weeks", GregorianChronology.getInstance().weeks().getName());
-        assertEquals("days", GregorianChronology.getInstance().days().getName());
-        assertEquals("halfdays", GregorianChronology.getInstance().halfdays().getName());
-        assertEquals("hours", GregorianChronology.getInstance().hours().getName());
-        assertEquals("minutes", GregorianChronology.getInstance().minutes().getName());
-        assertEquals("seconds", GregorianChronology.getInstance().seconds().getName());
-        assertEquals("millis", GregorianChronology.getInstance().millis().getName());
+        final GregorianChronology greg = GregorianChronology.getInstance();
+        assertEquals("eras", greg.eras().getName());
+        assertEquals("centuries", greg.centuries().getName());
+        assertEquals("years", greg.years().getName());
+        assertEquals("weekyears", greg.weekyears().getName());
+        assertEquals("months", greg.months().getName());
+        assertEquals("weeks", greg.weeks().getName());
+        assertEquals("days", greg.days().getName());
+        assertEquals("halfdays", greg.halfdays().getName());
+        assertEquals("hours", greg.hours().getName());
+        assertEquals("minutes", greg.minutes().getName());
+        assertEquals("seconds", greg.seconds().getName());
+        assertEquals("millis", greg.millis().getName());
         
-        assertEquals(false, GregorianChronology.getInstance().eras().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().centuries().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().years().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().weekyears().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().months().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().weeks().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().days().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().halfdays().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().hours().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().minutes().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().seconds().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().millis().isSupported());
+        assertEquals(false, greg.eras().isSupported());
+        assertEquals(true, greg.centuries().isSupported());
+        assertEquals(true, greg.years().isSupported());
+        assertEquals(true, greg.weekyears().isSupported());
+        assertEquals(true, greg.months().isSupported());
+        assertEquals(true, greg.weeks().isSupported());
+        assertEquals(true, greg.days().isSupported());
+        assertEquals(true, greg.halfdays().isSupported());
+        assertEquals(true, greg.hours().isSupported());
+        assertEquals(true, greg.minutes().isSupported());
+        assertEquals(true, greg.seconds().isSupported());
+        assertEquals(true, greg.millis().isSupported());
         
-        assertEquals(false, GregorianChronology.getInstance().centuries().isPrecise());
-        assertEquals(false, GregorianChronology.getInstance().years().isPrecise());
-        assertEquals(false, GregorianChronology.getInstance().weekyears().isPrecise());
-        assertEquals(false, GregorianChronology.getInstance().months().isPrecise());
-        assertEquals(false, GregorianChronology.getInstance().weeks().isPrecise());
-        assertEquals(false, GregorianChronology.getInstance().days().isPrecise());
-        assertEquals(false, GregorianChronology.getInstance().halfdays().isPrecise());
-        assertEquals(true, GregorianChronology.getInstance().hours().isPrecise());
-        assertEquals(true, GregorianChronology.getInstance().minutes().isPrecise());
-        assertEquals(true, GregorianChronology.getInstance().seconds().isPrecise());
-        assertEquals(true, GregorianChronology.getInstance().millis().isPrecise());
+        assertEquals(false, greg.centuries().isPrecise());
+        assertEquals(false, greg.years().isPrecise());
+        assertEquals(false, greg.weekyears().isPrecise());
+        assertEquals(false, greg.months().isPrecise());
+        assertEquals(false, greg.weeks().isPrecise());
+        assertEquals(false, greg.days().isPrecise());
+        assertEquals(false, greg.halfdays().isPrecise());
+        assertEquals(true, greg.hours().isPrecise());
+        assertEquals(true, greg.minutes().isPrecise());
+        assertEquals(true, greg.seconds().isPrecise());
+        assertEquals(true, greg.millis().isPrecise());
         
-        assertEquals(false, GregorianChronology.getInstanceUTC().centuries().isPrecise());
-        assertEquals(false, GregorianChronology.getInstanceUTC().years().isPrecise());
-        assertEquals(false, GregorianChronology.getInstanceUTC().weekyears().isPrecise());
-        assertEquals(false, GregorianChronology.getInstanceUTC().months().isPrecise());
-        assertEquals(true, GregorianChronology.getInstanceUTC().weeks().isPrecise());
-        assertEquals(true, GregorianChronology.getInstanceUTC().days().isPrecise());
-        assertEquals(true, GregorianChronology.getInstanceUTC().halfdays().isPrecise());
-        assertEquals(true, GregorianChronology.getInstanceUTC().hours().isPrecise());
-        assertEquals(true, GregorianChronology.getInstanceUTC().minutes().isPrecise());
-        assertEquals(true, GregorianChronology.getInstanceUTC().seconds().isPrecise());
-        assertEquals(true, GregorianChronology.getInstanceUTC().millis().isPrecise());
+        final GregorianChronology gregUTC = GregorianChronology.getInstanceUTC();
+        assertEquals(false, gregUTC.centuries().isPrecise());
+        assertEquals(false, gregUTC.years().isPrecise());
+        assertEquals(false, gregUTC.weekyears().isPrecise());
+        assertEquals(false, gregUTC.months().isPrecise());
+        assertEquals(true, gregUTC.weeks().isPrecise());
+        assertEquals(true, gregUTC.days().isPrecise());
+        assertEquals(true, gregUTC.halfdays().isPrecise());
+        assertEquals(true, gregUTC.hours().isPrecise());
+        assertEquals(true, gregUTC.minutes().isPrecise());
+        assertEquals(true, gregUTC.seconds().isPrecise());
+        assertEquals(true, gregUTC.millis().isPrecise());
         
-        DateTimeZone gmt = DateTimeZone.forID("Etc/GMT");
-        assertEquals(false, GregorianChronology.getInstance(gmt).centuries().isPrecise());
-        assertEquals(false, GregorianChronology.getInstance(gmt).years().isPrecise());
-        assertEquals(false, GregorianChronology.getInstance(gmt).weekyears().isPrecise());
-        assertEquals(false, GregorianChronology.getInstance(gmt).months().isPrecise());
-        assertEquals(true, GregorianChronology.getInstance(gmt).weeks().isPrecise());
-        assertEquals(true, GregorianChronology.getInstance(gmt).days().isPrecise());
-        assertEquals(true, GregorianChronology.getInstance(gmt).halfdays().isPrecise());
-        assertEquals(true, GregorianChronology.getInstance(gmt).hours().isPrecise());
-        assertEquals(true, GregorianChronology.getInstance(gmt).minutes().isPrecise());
-        assertEquals(true, GregorianChronology.getInstance(gmt).seconds().isPrecise());
-        assertEquals(true, GregorianChronology.getInstance(gmt).millis().isPrecise());
+        final DateTimeZone gmt = DateTimeZone.forID("Etc/GMT");
+        final GregorianChronology gregGMT = GregorianChronology.getInstance(gmt);
+        assertEquals(false, gregGMT.centuries().isPrecise());
+        assertEquals(false, gregGMT.years().isPrecise());
+        assertEquals(false, gregGMT.weekyears().isPrecise());
+        assertEquals(false, gregGMT.months().isPrecise());
+        assertEquals(true, gregGMT.weeks().isPrecise());
+        assertEquals(true, gregGMT.days().isPrecise());
+        assertEquals(true, gregGMT.halfdays().isPrecise());
+        assertEquals(true, gregGMT.hours().isPrecise());
+        assertEquals(true, gregGMT.minutes().isPrecise());
+        assertEquals(true, gregGMT.seconds().isPrecise());
+        assertEquals(true, gregGMT.millis().isPrecise());
     }
 
     public void testDateFields() {
-        assertEquals("era", GregorianChronology.getInstance().era().getName());
-        assertEquals("centuryOfEra", GregorianChronology.getInstance().centuryOfEra().getName());
-        assertEquals("yearOfCentury", GregorianChronology.getInstance().yearOfCentury().getName());
-        assertEquals("yearOfEra", GregorianChronology.getInstance().yearOfEra().getName());
-        assertEquals("year", GregorianChronology.getInstance().year().getName());
-        assertEquals("monthOfYear", GregorianChronology.getInstance().monthOfYear().getName());
-        assertEquals("weekyearOfCentury", GregorianChronology.getInstance().weekyearOfCentury().getName());
-        assertEquals("weekyear", GregorianChronology.getInstance().weekyear().getName());
-        assertEquals("weekOfWeekyear", GregorianChronology.getInstance().weekOfWeekyear().getName());
-        assertEquals("dayOfYear", GregorianChronology.getInstance().dayOfYear().getName());
-        assertEquals("dayOfMonth", GregorianChronology.getInstance().dayOfMonth().getName());
-        assertEquals("dayOfWeek", GregorianChronology.getInstance().dayOfWeek().getName());
+        final GregorianChronology greg = GregorianChronology.getInstance();
+        assertEquals("era", greg.era().getName());
+        assertEquals("centuryOfEra", greg.centuryOfEra().getName());
+        assertEquals("yearOfCentury", greg.yearOfCentury().getName());
+        assertEquals("yearOfEra", greg.yearOfEra().getName());
+        assertEquals("year", greg.year().getName());
+        assertEquals("monthOfYear", greg.monthOfYear().getName());
+        assertEquals("weekyearOfCentury", greg.weekyearOfCentury().getName());
+        assertEquals("weekyear", greg.weekyear().getName());
+        assertEquals("weekOfWeekyear", greg.weekOfWeekyear().getName());
+        assertEquals("dayOfYear", greg.dayOfYear().getName());
+        assertEquals("dayOfMonth", greg.dayOfMonth().getName());
+        assertEquals("dayOfWeek", greg.dayOfWeek().getName());
         
-        assertEquals(true, GregorianChronology.getInstance().era().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().centuryOfEra().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().yearOfCentury().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().yearOfEra().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().year().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().monthOfYear().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().weekyearOfCentury().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().weekyear().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().weekOfWeekyear().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().dayOfYear().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().dayOfMonth().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().dayOfWeek().isSupported());
+        assertEquals(true, greg.era().isSupported());
+        assertEquals(true, greg.centuryOfEra().isSupported());
+        assertEquals(true, greg.yearOfCentury().isSupported());
+        assertEquals(true, greg.yearOfEra().isSupported());
+        assertEquals(true, greg.year().isSupported());
+        assertEquals(true, greg.monthOfYear().isSupported());
+        assertEquals(true, greg.weekyearOfCentury().isSupported());
+        assertEquals(true, greg.weekyear().isSupported());
+        assertEquals(true, greg.weekOfWeekyear().isSupported());
+        assertEquals(true, greg.dayOfYear().isSupported());
+        assertEquals(true, greg.dayOfMonth().isSupported());
+        assertEquals(true, greg.dayOfWeek().isSupported());
     }
 
     public void testTimeFields() {
-        assertEquals("halfdayOfDay", GregorianChronology.getInstance().halfdayOfDay().getName());
-        assertEquals("clockhourOfHalfday", GregorianChronology.getInstance().clockhourOfHalfday().getName());
-        assertEquals("hourOfHalfday", GregorianChronology.getInstance().hourOfHalfday().getName());
-        assertEquals("clockhourOfDay", GregorianChronology.getInstance().clockhourOfDay().getName());
-        assertEquals("hourOfDay", GregorianChronology.getInstance().hourOfDay().getName());
-        assertEquals("minuteOfDay", GregorianChronology.getInstance().minuteOfDay().getName());
-        assertEquals("minuteOfHour", GregorianChronology.getInstance().minuteOfHour().getName());
-        assertEquals("secondOfDay", GregorianChronology.getInstance().secondOfDay().getName());
-        assertEquals("secondOfMinute", GregorianChronology.getInstance().secondOfMinute().getName());
-        assertEquals("millisOfDay", GregorianChronology.getInstance().millisOfDay().getName());
-        assertEquals("millisOfSecond", GregorianChronology.getInstance().millisOfSecond().getName());
+        final GregorianChronology greg = GregorianChronology.getInstance();
+        assertEquals("halfdayOfDay", greg.halfdayOfDay().getName());
+        assertEquals("clockhourOfHalfday", greg.clockhourOfHalfday().getName());
+        assertEquals("hourOfHalfday", greg.hourOfHalfday().getName());
+        assertEquals("clockhourOfDay", greg.clockhourOfDay().getName());
+        assertEquals("hourOfDay", greg.hourOfDay().getName());
+        assertEquals("minuteOfDay", greg.minuteOfDay().getName());
+        assertEquals("minuteOfHour", greg.minuteOfHour().getName());
+        assertEquals("secondOfDay", greg.secondOfDay().getName());
+        assertEquals("secondOfMinute", greg.secondOfMinute().getName());
+        assertEquals("millisOfDay", greg.millisOfDay().getName());
+        assertEquals("millisOfSecond", greg.millisOfSecond().getName());
         
-        assertEquals(true, GregorianChronology.getInstance().halfdayOfDay().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().clockhourOfHalfday().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().hourOfHalfday().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().clockhourOfDay().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().hourOfDay().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().minuteOfDay().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().minuteOfHour().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().secondOfDay().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().secondOfMinute().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().millisOfDay().isSupported());
-        assertEquals(true, GregorianChronology.getInstance().millisOfSecond().isSupported());
+        assertEquals(true, greg.halfdayOfDay().isSupported());
+        assertEquals(true, greg.clockhourOfHalfday().isSupported());
+        assertEquals(true, greg.hourOfHalfday().isSupported());
+        assertEquals(true, greg.clockhourOfDay().isSupported());
+        assertEquals(true, greg.hourOfDay().isSupported());
+        assertEquals(true, greg.minuteOfDay().isSupported());
+        assertEquals(true, greg.minuteOfHour().isSupported());
+        assertEquals(true, greg.secondOfDay().isSupported());
+        assertEquals(true, greg.secondOfMinute().isSupported());
+        assertEquals(true, greg.millisOfDay().isSupported());
+        assertEquals(true, greg.millisOfSecond().isSupported());
     }
 
     public void testMaximumValue() {
diff --git a/src/test/java/org/joda/time/chrono/TestISOChronology.java b/src/test/java/org/joda/time/chrono/TestISOChronology.java
index 83001cd64..b4cf0e695 100644
--- a/src/test/java/org/joda/time/chrono/TestISOChronology.java
+++ b/src/test/java/org/joda/time/chrono/TestISOChronology.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2005 Stephen Colebourne
+ *  Copyright 2001-2013 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -39,6 +39,7 @@
  *
  * @author Stephen Colebourne
  */
+@SuppressWarnings("deprecation")
 public class TestISOChronology extends TestCase {
 
     private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");
@@ -141,135 +142,141 @@ public void testToString() {
 
     //-----------------------------------------------------------------------
     public void testDurationFields() {
-        assertEquals("eras", ISOChronology.getInstance().eras().getName());
-        assertEquals("centuries", ISOChronology.getInstance().centuries().getName());
-        assertEquals("years", ISOChronology.getInstance().years().getName());
-        assertEquals("weekyears", ISOChronology.getInstance().weekyears().getName());
-        assertEquals("months", ISOChronology.getInstance().months().getName());
-        assertEquals("weeks", ISOChronology.getInstance().weeks().getName());
-        assertEquals("days", ISOChronology.getInstance().days().getName());
-        assertEquals("halfdays", ISOChronology.getInstance().halfdays().getName());
-        assertEquals("hours", ISOChronology.getInstance().hours().getName());
-        assertEquals("minutes", ISOChronology.getInstance().minutes().getName());
-        assertEquals("seconds", ISOChronology.getInstance().seconds().getName());
-        assertEquals("millis", ISOChronology.getInstance().millis().getName());
+        final ISOChronology iso = ISOChronology.getInstance();
+        assertEquals("eras", iso.eras().getName());
+        assertEquals("centuries", iso.centuries().getName());
+        assertEquals("years", iso.years().getName());
+        assertEquals("weekyears", iso.weekyears().getName());
+        assertEquals("months", iso.months().getName());
+        assertEquals("weeks", iso.weeks().getName());
+        assertEquals("days", iso.days().getName());
+        assertEquals("halfdays", iso.halfdays().getName());
+        assertEquals("hours", iso.hours().getName());
+        assertEquals("minutes", iso.minutes().getName());
+        assertEquals("seconds", iso.seconds().getName());
+        assertEquals("millis", iso.millis().getName());
         
-        assertEquals(false, ISOChronology.getInstance().eras().isSupported());
-        assertEquals(true, ISOChronology.getInstance().centuries().isSupported());
-        assertEquals(true, ISOChronology.getInstance().years().isSupported());
-        assertEquals(true, ISOChronology.getInstance().weekyears().isSupported());
-        assertEquals(true, ISOChronology.getInstance().months().isSupported());
-        assertEquals(true, ISOChronology.getInstance().weeks().isSupported());
-        assertEquals(true, ISOChronology.getInstance().days().isSupported());
-        assertEquals(true, ISOChronology.getInstance().halfdays().isSupported());
-        assertEquals(true, ISOChronology.getInstance().hours().isSupported());
-        assertEquals(true, ISOChronology.getInstance().minutes().isSupported());
-        assertEquals(true, ISOChronology.getInstance().seconds().isSupported());
-        assertEquals(true, ISOChronology.getInstance().millis().isSupported());
+        assertEquals(false, iso.eras().isSupported());
+        assertEquals(true, iso.centuries().isSupported());
+        assertEquals(true, iso.years().isSupported());
+        assertEquals(true, iso.weekyears().isSupported());
+        assertEquals(true, iso.months().isSupported());
+        assertEquals(true, iso.weeks().isSupported());
+        assertEquals(true, iso.days().isSupported());
+        assertEquals(true, iso.halfdays().isSupported());
+        assertEquals(true, iso.hours().isSupported());
+        assertEquals(true, iso.minutes().isSupported());
+        assertEquals(true, iso.seconds().isSupported());
+        assertEquals(true, iso.millis().isSupported());
         
-        assertEquals(false, ISOChronology.getInstance().centuries().isPrecise());
-        assertEquals(false, ISOChronology.getInstance().years().isPrecise());
-        assertEquals(false, ISOChronology.getInstance().weekyears().isPrecise());
-        assertEquals(false, ISOChronology.getInstance().months().isPrecise());
-        assertEquals(false, ISOChronology.getInstance().weeks().isPrecise());
-        assertEquals(false, ISOChronology.getInstance().days().isPrecise());
-        assertEquals(false, ISOChronology.getInstance().halfdays().isPrecise());
-        assertEquals(true, ISOChronology.getInstance().hours().isPrecise());
-        assertEquals(true, ISOChronology.getInstance().minutes().isPrecise());
-        assertEquals(true, ISOChronology.getInstance().seconds().isPrecise());
-        assertEquals(true, ISOChronology.getInstance().millis().isPrecise());
+        assertEquals(false, iso.centuries().isPrecise());
+        assertEquals(false, iso.years().isPrecise());
+        assertEquals(false, iso.weekyears().isPrecise());
+        assertEquals(false, iso.months().isPrecise());
+        assertEquals(false, iso.weeks().isPrecise());
+        assertEquals(false, iso.days().isPrecise());
+        assertEquals(false, iso.halfdays().isPrecise());
+        assertEquals(true, iso.hours().isPrecise());
+        assertEquals(true, iso.minutes().isPrecise());
+        assertEquals(true, iso.seconds().isPrecise());
+        assertEquals(true, iso.millis().isPrecise());
         
-        assertEquals(false, ISOChronology.getInstanceUTC().centuries().isPrecise());
-        assertEquals(false, ISOChronology.getInstanceUTC().years().isPrecise());
-        assertEquals(false, ISOChronology.getInstanceUTC().weekyears().isPrecise());
-        assertEquals(false, ISOChronology.getInstanceUTC().months().isPrecise());
-        assertEquals(true, ISOChronology.getInstanceUTC().weeks().isPrecise());
-        assertEquals(true, ISOChronology.getInstanceUTC().days().isPrecise());
-        assertEquals(true, ISOChronology.getInstanceUTC().halfdays().isPrecise());
-        assertEquals(true, ISOChronology.getInstanceUTC().hours().isPrecise());
-        assertEquals(true, ISOChronology.getInstanceUTC().minutes().isPrecise());
-        assertEquals(true, ISOChronology.getInstanceUTC().seconds().isPrecise());
-        assertEquals(true, ISOChronology.getInstanceUTC().millis().isPrecise());
+        final ISOChronology isoUTC = ISOChronology.getInstanceUTC();
+        assertEquals(false, isoUTC.centuries().isPrecise());
+        assertEquals(false, isoUTC.years().isPrecise());
+        assertEquals(false, isoUTC.weekyears().isPrecise());
+        assertEquals(false, isoUTC.months().isPrecise());
+        assertEquals(true, isoUTC.weeks().isPrecise());
+        assertEquals(true, isoUTC.days().isPrecise());
+        assertEquals(true, isoUTC.halfdays().isPrecise());
+        assertEquals(true, isoUTC.hours().isPrecise());
+        assertEquals(true, isoUTC.minutes().isPrecise());
+        assertEquals(true, isoUTC.seconds().isPrecise());
+        assertEquals(true, isoUTC.millis().isPrecise());
         
-        DateTimeZone gmt = DateTimeZone.forID("Etc/GMT");
-        assertEquals(false, ISOChronology.getInstance(gmt).centuries().isPrecise());
-        assertEquals(false, ISOChronology.getInstance(gmt).years().isPrecise());
-        assertEquals(false, ISOChronology.getInstance(gmt).weekyears().isPrecise());
-        assertEquals(false, ISOChronology.getInstance(gmt).months().isPrecise());
-        assertEquals(true, ISOChronology.getInstance(gmt).weeks().isPrecise());
-        assertEquals(true, ISOChronology.getInstance(gmt).days().isPrecise());
-        assertEquals(true, ISOChronology.getInstance(gmt).halfdays().isPrecise());
-        assertEquals(true, ISOChronology.getInstance(gmt).hours().isPrecise());
-        assertEquals(true, ISOChronology.getInstance(gmt).minutes().isPrecise());
-        assertEquals(true, ISOChronology.getInstance(gmt).seconds().isPrecise());
-        assertEquals(true, ISOChronology.getInstance(gmt).millis().isPrecise());
+        final DateTimeZone gmt = DateTimeZone.forID("Etc/GMT");
+        final ISOChronology isoGMT = ISOChronology.getInstance(gmt);
+        assertEquals(false, isoGMT.centuries().isPrecise());
+        assertEquals(false, isoGMT.years().isPrecise());
+        assertEquals(false, isoGMT.weekyears().isPrecise());
+        assertEquals(false, isoGMT.months().isPrecise());
+        assertEquals(true, isoGMT.weeks().isPrecise());
+        assertEquals(true, isoGMT.days().isPrecise());
+        assertEquals(true, isoGMT.halfdays().isPrecise());
+        assertEquals(true, isoGMT.hours().isPrecise());
+        assertEquals(true, isoGMT.minutes().isPrecise());
+        assertEquals(true, isoGMT.seconds().isPrecise());
+        assertEquals(true, isoGMT.millis().isPrecise());
         
-        DateTimeZone offset = DateTimeZone.forOffsetHours(1);
-        assertEquals(false, ISOChronology.getInstance(offset).centuries().isPrecise());
-        assertEquals(false, ISOChronology.getInstance(offset).years().isPrecise());
-        assertEquals(false, ISOChronology.getInstance(offset).weekyears().isPrecise());
-        assertEquals(false, ISOChronology.getInstance(offset).months().isPrecise());
-        assertEquals(true, ISOChronology.getInstance(offset).weeks().isPrecise());
-        assertEquals(true, ISOChronology.getInstance(offset).days().isPrecise());
-        assertEquals(true, ISOChronology.getInstance(offset).halfdays().isPrecise());
-        assertEquals(true, ISOChronology.getInstance(offset).hours().isPrecise());
-        assertEquals(true, ISOChronology.getInstance(offset).minutes().isPrecise());
-        assertEquals(true, ISOChronology.getInstance(offset).seconds().isPrecise());
-        assertEquals(true, ISOChronology.getInstance(offset).millis().isPrecise());
+        final DateTimeZone offset = DateTimeZone.forOffsetHours(1);
+        final ISOChronology isoOffset1 = ISOChronology.getInstance(offset);
+        assertEquals(false, isoOffset1.centuries().isPrecise());
+        assertEquals(false, isoOffset1.years().isPrecise());
+        assertEquals(false, isoOffset1.weekyears().isPrecise());
+        assertEquals(false, isoOffset1.months().isPrecise());
+        assertEquals(true, isoOffset1.weeks().isPrecise());
+        assertEquals(true, isoOffset1.days().isPrecise());
+        assertEquals(true, isoOffset1.halfdays().isPrecise());
+        assertEquals(true, isoOffset1.hours().isPrecise());
+        assertEquals(true, isoOffset1.minutes().isPrecise());
+        assertEquals(true, isoOffset1.seconds().isPrecise());
+        assertEquals(true, isoOffset1.millis().isPrecise());
     }
 
     public void testDateFields() {
-        assertEquals("era", ISOChronology.getInstance().era().getName());
-        assertEquals("centuryOfEra", ISOChronology.getInstance().centuryOfEra().getName());
-        assertEquals("yearOfCentury", ISOChronology.getInstance().yearOfCentury().getName());
-        assertEquals("yearOfEra", ISOChronology.getInstance().yearOfEra().getName());
-        assertEquals("year", ISOChronology.getInstance().year().getName());
-        assertEquals("monthOfYear", ISOChronology.getInstance().monthOfYear().getName());
-        assertEquals("weekyearOfCentury", ISOChronology.getInstance().weekyearOfCentury().getName());
-        assertEquals("weekyear", ISOChronology.getInstance().weekyear().getName());
-        assertEquals("weekOfWeekyear", ISOChronology.getInstance().weekOfWeekyear().getName());
-        assertEquals("dayOfYear", ISOChronology.getInstance().dayOfYear().getName());
-        assertEquals("dayOfMonth", ISOChronology.getInstance().dayOfMonth().getName());
-        assertEquals("dayOfWeek", ISOChronology.getInstance().dayOfWeek().getName());
+        final ISOChronology iso = ISOChronology.getInstance();
+        assertEquals("era", iso.era().getName());
+        assertEquals("centuryOfEra", iso.centuryOfEra().getName());
+        assertEquals("yearOfCentury", iso.yearOfCentury().getName());
+        assertEquals("yearOfEra", iso.yearOfEra().getName());
+        assertEquals("year", iso.year().getName());
+        assertEquals("monthOfYear", iso.monthOfYear().getName());
+        assertEquals("weekyearOfCentury", iso.weekyearOfCentury().getName());
+        assertEquals("weekyear", iso.weekyear().getName());
+        assertEquals("weekOfWeekyear", iso.weekOfWeekyear().getName());
+        assertEquals("dayOfYear", iso.dayOfYear().getName());
+        assertEquals("dayOfMonth", iso.dayOfMonth().getName());
+        assertEquals("dayOfWeek", iso.dayOfWeek().getName());
         
-        assertEquals(true, ISOChronology.getInstance().era().isSupported());
-        assertEquals(true, ISOChronology.getInstance().centuryOfEra().isSupported());
-        assertEquals(true, ISOChronology.getInstance().yearOfCentury().isSupported());
-        assertEquals(true, ISOChronology.getInstance().yearOfEra().isSupported());
-        assertEquals(true, ISOChronology.getInstance().year().isSupported());
-        assertEquals(true, ISOChronology.getInstance().monthOfYear().isSupported());
-        assertEquals(true, ISOChronology.getInstance().weekyearOfCentury().isSupported());
-        assertEquals(true, ISOChronology.getInstance().weekyear().isSupported());
-        assertEquals(true, ISOChronology.getInstance().weekOfWeekyear().isSupported());
-        assertEquals(true, ISOChronology.getInstance().dayOfYear().isSupported());
-        assertEquals(true, ISOChronology.getInstance().dayOfMonth().isSupported());
-        assertEquals(true, ISOChronology.getInstance().dayOfWeek().isSupported());
+        assertEquals(true, iso.era().isSupported());
+        assertEquals(true, iso.centuryOfEra().isSupported());
+        assertEquals(true, iso.yearOfCentury().isSupported());
+        assertEquals(true, iso.yearOfEra().isSupported());
+        assertEquals(true, iso.year().isSupported());
+        assertEquals(true, iso.monthOfYear().isSupported());
+        assertEquals(true, iso.weekyearOfCentury().isSupported());
+        assertEquals(true, iso.weekyear().isSupported());
+        assertEquals(true, iso.weekOfWeekyear().isSupported());
+        assertEquals(true, iso.dayOfYear().isSupported());
+        assertEquals(true, iso.dayOfMonth().isSupported());
+        assertEquals(true, iso.dayOfWeek().isSupported());
     }
 
     public void testTimeFields() {
-        assertEquals("halfdayOfDay", ISOChronology.getInstance().halfdayOfDay().getName());
-        assertEquals("clockhourOfHalfday", ISOChronology.getInstance().clockhourOfHalfday().getName());
-        assertEquals("hourOfHalfday", ISOChronology.getInstance().hourOfHalfday().getName());
-        assertEquals("clockhourOfDay", ISOChronology.getInstance().clockhourOfDay().getName());
-        assertEquals("hourOfDay", ISOChronology.getInstance().hourOfDay().getName());
-        assertEquals("minuteOfDay", ISOChronology.getInstance().minuteOfDay().getName());
-        assertEquals("minuteOfHour", ISOChronology.getInstance().minuteOfHour().getName());
-        assertEquals("secondOfDay", ISOChronology.getInstance().secondOfDay().getName());
-        assertEquals("secondOfMinute", ISOChronology.getInstance().secondOfMinute().getName());
-        assertEquals("millisOfDay", ISOChronology.getInstance().millisOfDay().getName());
-        assertEquals("millisOfSecond", ISOChronology.getInstance().millisOfSecond().getName());
+        final ISOChronology iso = ISOChronology.getInstance();
+        assertEquals("halfdayOfDay", iso.halfdayOfDay().getName());
+        assertEquals("clockhourOfHalfday", iso.clockhourOfHalfday().getName());
+        assertEquals("hourOfHalfday", iso.hourOfHalfday().getName());
+        assertEquals("clockhourOfDay", iso.clockhourOfDay().getName());
+        assertEquals("hourOfDay", iso.hourOfDay().getName());
+        assertEquals("minuteOfDay", iso.minuteOfDay().getName());
+        assertEquals("minuteOfHour", iso.minuteOfHour().getName());
+        assertEquals("secondOfDay", iso.secondOfDay().getName());
+        assertEquals("secondOfMinute", iso.secondOfMinute().getName());
+        assertEquals("millisOfDay", iso.millisOfDay().getName());
+        assertEquals("millisOfSecond", iso.millisOfSecond().getName());
         
-        assertEquals(true, ISOChronology.getInstance().halfdayOfDay().isSupported());
-        assertEquals(true, ISOChronology.getInstance().clockhourOfHalfday().isSupported());
-        assertEquals(true, ISOChronology.getInstance().hourOfHalfday().isSupported());
-        assertEquals(true, ISOChronology.getInstance().clockhourOfDay().isSupported());
-        assertEquals(true, ISOChronology.getInstance().hourOfDay().isSupported());
-        assertEquals(true, ISOChronology.getInstance().minuteOfDay().isSupported());
-        assertEquals(true, ISOChronology.getInstance().minuteOfHour().isSupported());
-        assertEquals(true, ISOChronology.getInstance().secondOfDay().isSupported());
-        assertEquals(true, ISOChronology.getInstance().secondOfMinute().isSupported());
-        assertEquals(true, ISOChronology.getInstance().millisOfDay().isSupported());
-        assertEquals(true, ISOChronology.getInstance().millisOfSecond().isSupported());
+        assertEquals(true, iso.halfdayOfDay().isSupported());
+        assertEquals(true, iso.clockhourOfHalfday().isSupported());
+        assertEquals(true, iso.hourOfHalfday().isSupported());
+        assertEquals(true, iso.clockhourOfDay().isSupported());
+        assertEquals(true, iso.hourOfDay().isSupported());
+        assertEquals(true, iso.minuteOfDay().isSupported());
+        assertEquals(true, iso.minuteOfHour().isSupported());
+        assertEquals(true, iso.secondOfDay().isSupported());
+        assertEquals(true, iso.secondOfMinute().isSupported());
+        assertEquals(true, iso.millisOfDay().isSupported());
+        assertEquals(true, iso.millisOfSecond().isSupported());
     }
 
     public void testMaxYear() {
diff --git a/src/test/java/org/joda/time/chrono/TestIslamicChronology.java b/src/test/java/org/joda/time/chrono/TestIslamicChronology.java
index a7e7d2c78..fa1b6b884 100644
--- a/src/test/java/org/joda/time/chrono/TestIslamicChronology.java
+++ b/src/test/java/org/joda/time/chrono/TestIslamicChronology.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2005 Stephen Colebourne
+ *  Copyright 2001-2013 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -143,122 +143,127 @@ public void testToString() {
 
     //-----------------------------------------------------------------------
     public void testDurationFields() {
-        assertEquals("eras", IslamicChronology.getInstance().eras().getName());
-        assertEquals("centuries", IslamicChronology.getInstance().centuries().getName());
-        assertEquals("years", IslamicChronology.getInstance().years().getName());
-        assertEquals("weekyears", IslamicChronology.getInstance().weekyears().getName());
-        assertEquals("months", IslamicChronology.getInstance().months().getName());
-        assertEquals("weeks", IslamicChronology.getInstance().weeks().getName());
-        assertEquals("days", IslamicChronology.getInstance().days().getName());
-        assertEquals("halfdays", IslamicChronology.getInstance().halfdays().getName());
-        assertEquals("hours", IslamicChronology.getInstance().hours().getName());
-        assertEquals("minutes", IslamicChronology.getInstance().minutes().getName());
-        assertEquals("seconds", IslamicChronology.getInstance().seconds().getName());
-        assertEquals("millis", IslamicChronology.getInstance().millis().getName());
+        final IslamicChronology islamic = IslamicChronology.getInstance();
+        assertEquals("eras", islamic.eras().getName());
+        assertEquals("centuries", islamic.centuries().getName());
+        assertEquals("years", islamic.years().getName());
+        assertEquals("weekyears", islamic.weekyears().getName());
+        assertEquals("months", islamic.months().getName());
+        assertEquals("weeks", islamic.weeks().getName());
+        assertEquals("days", islamic.days().getName());
+        assertEquals("halfdays", islamic.halfdays().getName());
+        assertEquals("hours", islamic.hours().getName());
+        assertEquals("minutes", islamic.minutes().getName());
+        assertEquals("seconds", islamic.seconds().getName());
+        assertEquals("millis", islamic.millis().getName());
         
-        assertEquals(false, IslamicChronology.getInstance().eras().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().centuries().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().years().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().weekyears().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().months().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().weeks().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().days().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().halfdays().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().hours().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().minutes().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().seconds().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().millis().isSupported());
+        assertEquals(false, islamic.eras().isSupported());
+        assertEquals(true, islamic.centuries().isSupported());
+        assertEquals(true, islamic.years().isSupported());
+        assertEquals(true, islamic.weekyears().isSupported());
+        assertEquals(true, islamic.months().isSupported());
+        assertEquals(true, islamic.weeks().isSupported());
+        assertEquals(true, islamic.days().isSupported());
+        assertEquals(true, islamic.halfdays().isSupported());
+        assertEquals(true, islamic.hours().isSupported());
+        assertEquals(true, islamic.minutes().isSupported());
+        assertEquals(true, islamic.seconds().isSupported());
+        assertEquals(true, islamic.millis().isSupported());
         
-        assertEquals(false, IslamicChronology.getInstance().centuries().isPrecise());
-        assertEquals(false, IslamicChronology.getInstance().years().isPrecise());
-        assertEquals(false, IslamicChronology.getInstance().weekyears().isPrecise());
-        assertEquals(false, IslamicChronology.getInstance().months().isPrecise());
-        assertEquals(false, IslamicChronology.getInstance().weeks().isPrecise());
-        assertEquals(false, IslamicChronology.getInstance().days().isPrecise());
-        assertEquals(false, IslamicChronology.getInstance().halfdays().isPrecise());
-        assertEquals(true, IslamicChronology.getInstance().hours().isPrecise());
-        assertEquals(true, IslamicChronology.getInstance().minutes().isPrecise());
-        assertEquals(true, IslamicChronology.getInstance().seconds().isPrecise());
-        assertEquals(true, IslamicChronology.getInstance().millis().isPrecise());
+        assertEquals(false, islamic.centuries().isPrecise());
+        assertEquals(false, islamic.years().isPrecise());
+        assertEquals(false, islamic.weekyears().isPrecise());
+        assertEquals(false, islamic.months().isPrecise());
+        assertEquals(false, islamic.weeks().isPrecise());
+        assertEquals(false, islamic.days().isPrecise());
+        assertEquals(false, islamic.halfdays().isPrecise());
+        assertEquals(true, islamic.hours().isPrecise());
+        assertEquals(true, islamic.minutes().isPrecise());
+        assertEquals(true, islamic.seconds().isPrecise());
+        assertEquals(true, islamic.millis().isPrecise());
         
-        assertEquals(false, IslamicChronology.getInstanceUTC().centuries().isPrecise());
-        assertEquals(false, IslamicChronology.getInstanceUTC().years().isPrecise());
-        assertEquals(false, IslamicChronology.getInstanceUTC().weekyears().isPrecise());
-        assertEquals(false, IslamicChronology.getInstanceUTC().months().isPrecise());
-        assertEquals(true, IslamicChronology.getInstanceUTC().weeks().isPrecise());
-        assertEquals(true, IslamicChronology.getInstanceUTC().days().isPrecise());
-        assertEquals(true, IslamicChronology.getInstanceUTC().halfdays().isPrecise());
-        assertEquals(true, IslamicChronology.getInstanceUTC().hours().isPrecise());
-        assertEquals(true, IslamicChronology.getInstanceUTC().minutes().isPrecise());
-        assertEquals(true, IslamicChronology.getInstanceUTC().seconds().isPrecise());
-        assertEquals(true, IslamicChronology.getInstanceUTC().millis().isPrecise());
+        final IslamicChronology islamicUTC = IslamicChronology.getInstanceUTC();
+        assertEquals(false, islamicUTC.centuries().isPrecise());
+        assertEquals(false, islamicUTC.years().isPrecise());
+        assertEquals(false, islamicUTC.weekyears().isPrecise());
+        assertEquals(false, islamicUTC.months().isPrecise());
+        assertEquals(true, islamicUTC.weeks().isPrecise());
+        assertEquals(true, islamicUTC.days().isPrecise());
+        assertEquals(true, islamicUTC.halfdays().isPrecise());
+        assertEquals(true, islamicUTC.hours().isPrecise());
+        assertEquals(true, islamicUTC.minutes().isPrecise());
+        assertEquals(true, islamicUTC.seconds().isPrecise());
+        assertEquals(true, islamicUTC.millis().isPrecise());
         
-        DateTimeZone gmt = DateTimeZone.forID("Etc/GMT");
-        assertEquals(false, IslamicChronology.getInstance(gmt).centuries().isPrecise());
-        assertEquals(false, IslamicChronology.getInstance(gmt).years().isPrecise());
-        assertEquals(false, IslamicChronology.getInstance(gmt).weekyears().isPrecise());
-        assertEquals(false, IslamicChronology.getInstance(gmt).months().isPrecise());
-        assertEquals(true, IslamicChronology.getInstance(gmt).weeks().isPrecise());
-        assertEquals(true, IslamicChronology.getInstance(gmt).days().isPrecise());
-        assertEquals(true, IslamicChronology.getInstance(gmt).halfdays().isPrecise());
-        assertEquals(true, IslamicChronology.getInstance(gmt).hours().isPrecise());
-        assertEquals(true, IslamicChronology.getInstance(gmt).minutes().isPrecise());
-        assertEquals(true, IslamicChronology.getInstance(gmt).seconds().isPrecise());
-        assertEquals(true, IslamicChronology.getInstance(gmt).millis().isPrecise());
+        final DateTimeZone gmt = DateTimeZone.forID("Etc/GMT");
+        final IslamicChronology islamicGMT = IslamicChronology.getInstance(gmt);
+        assertEquals(false, islamicGMT.centuries().isPrecise());
+        assertEquals(false, islamicGMT.years().isPrecise());
+        assertEquals(false, islamicGMT.weekyears().isPrecise());
+        assertEquals(false, islamicGMT.months().isPrecise());
+        assertEquals(true, islamicGMT.weeks().isPrecise());
+        assertEquals(true, islamicGMT.days().isPrecise());
+        assertEquals(true, islamicGMT.halfdays().isPrecise());
+        assertEquals(true, islamicGMT.hours().isPrecise());
+        assertEquals(true, islamicGMT.minutes().isPrecise());
+        assertEquals(true, islamicGMT.seconds().isPrecise());
+        assertEquals(true, islamicGMT.millis().isPrecise());
     }
 
     public void testDateFields() {
-        assertEquals("era", IslamicChronology.getInstance().era().getName());
-        assertEquals("centuryOfEra", IslamicChronology.getInstance().centuryOfEra().getName());
-        assertEquals("yearOfCentury", IslamicChronology.getInstance().yearOfCentury().getName());
-        assertEquals("yearOfEra", IslamicChronology.getInstance().yearOfEra().getName());
-        assertEquals("year", IslamicChronology.getInstance().year().getName());
-        assertEquals("monthOfYear", IslamicChronology.getInstance().monthOfYear().getName());
-        assertEquals("weekyearOfCentury", IslamicChronology.getInstance().weekyearOfCentury().getName());
-        assertEquals("weekyear", IslamicChronology.getInstance().weekyear().getName());
-        assertEquals("weekOfWeekyear", IslamicChronology.getInstance().weekOfWeekyear().getName());
-        assertEquals("dayOfYear", IslamicChronology.getInstance().dayOfYear().getName());
-        assertEquals("dayOfMonth", IslamicChronology.getInstance().dayOfMonth().getName());
-        assertEquals("dayOfWeek", IslamicChronology.getInstance().dayOfWeek().getName());
+        final IslamicChronology islamic = IslamicChronology.getInstance();
+        assertEquals("era", islamic.era().getName());
+        assertEquals("centuryOfEra", islamic.centuryOfEra().getName());
+        assertEquals("yearOfCentury", islamic.yearOfCentury().getName());
+        assertEquals("yearOfEra", islamic.yearOfEra().getName());
+        assertEquals("year", islamic.year().getName());
+        assertEquals("monthOfYear", islamic.monthOfYear().getName());
+        assertEquals("weekyearOfCentury", islamic.weekyearOfCentury().getName());
+        assertEquals("weekyear", islamic.weekyear().getName());
+        assertEquals("weekOfWeekyear", islamic.weekOfWeekyear().getName());
+        assertEquals("dayOfYear", islamic.dayOfYear().getName());
+        assertEquals("dayOfMonth", islamic.dayOfMonth().getName());
+        assertEquals("dayOfWeek", islamic.dayOfWeek().getName());
         
-        assertEquals(true, IslamicChronology.getInstance().era().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().centuryOfEra().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().yearOfCentury().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().yearOfEra().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().year().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().monthOfYear().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().weekyearOfCentury().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().weekyear().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().weekOfWeekyear().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().dayOfYear().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().dayOfMonth().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().dayOfWeek().isSupported());
+        assertEquals(true, islamic.era().isSupported());
+        assertEquals(true, islamic.centuryOfEra().isSupported());
+        assertEquals(true, islamic.yearOfCentury().isSupported());
+        assertEquals(true, islamic.yearOfEra().isSupported());
+        assertEquals(true, islamic.year().isSupported());
+        assertEquals(true, islamic.monthOfYear().isSupported());
+        assertEquals(true, islamic.weekyearOfCentury().isSupported());
+        assertEquals(true, islamic.weekyear().isSupported());
+        assertEquals(true, islamic.weekOfWeekyear().isSupported());
+        assertEquals(true, islamic.dayOfYear().isSupported());
+        assertEquals(true, islamic.dayOfMonth().isSupported());
+        assertEquals(true, islamic.dayOfWeek().isSupported());
     }
 
     public void testTimeFields() {
-        assertEquals("halfdayOfDay", IslamicChronology.getInstance().halfdayOfDay().getName());
-        assertEquals("clockhourOfHalfday", IslamicChronology.getInstance().clockhourOfHalfday().getName());
-        assertEquals("hourOfHalfday", IslamicChronology.getInstance().hourOfHalfday().getName());
-        assertEquals("clockhourOfDay", IslamicChronology.getInstance().clockhourOfDay().getName());
-        assertEquals("hourOfDay", IslamicChronology.getInstance().hourOfDay().getName());
-        assertEquals("minuteOfDay", IslamicChronology.getInstance().minuteOfDay().getName());
-        assertEquals("minuteOfHour", IslamicChronology.getInstance().minuteOfHour().getName());
-        assertEquals("secondOfDay", IslamicChronology.getInstance().secondOfDay().getName());
-        assertEquals("secondOfMinute", IslamicChronology.getInstance().secondOfMinute().getName());
-        assertEquals("millisOfDay", IslamicChronology.getInstance().millisOfDay().getName());
-        assertEquals("millisOfSecond", IslamicChronology.getInstance().millisOfSecond().getName());
+        final IslamicChronology islamic = IslamicChronology.getInstance();
+        assertEquals("halfdayOfDay", islamic.halfdayOfDay().getName());
+        assertEquals("clockhourOfHalfday", islamic.clockhourOfHalfday().getName());
+        assertEquals("hourOfHalfday", islamic.hourOfHalfday().getName());
+        assertEquals("clockhourOfDay", islamic.clockhourOfDay().getName());
+        assertEquals("hourOfDay", islamic.hourOfDay().getName());
+        assertEquals("minuteOfDay", islamic.minuteOfDay().getName());
+        assertEquals("minuteOfHour", islamic.minuteOfHour().getName());
+        assertEquals("secondOfDay", islamic.secondOfDay().getName());
+        assertEquals("secondOfMinute", islamic.secondOfMinute().getName());
+        assertEquals("millisOfDay", islamic.millisOfDay().getName());
+        assertEquals("millisOfSecond", islamic.millisOfSecond().getName());
         
-        assertEquals(true, IslamicChronology.getInstance().halfdayOfDay().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().clockhourOfHalfday().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().hourOfHalfday().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().clockhourOfDay().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().hourOfDay().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().minuteOfDay().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().minuteOfHour().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().secondOfDay().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().secondOfMinute().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().millisOfDay().isSupported());
-        assertEquals(true, IslamicChronology.getInstance().millisOfSecond().isSupported());
+        assertEquals(true, islamic.halfdayOfDay().isSupported());
+        assertEquals(true, islamic.clockhourOfHalfday().isSupported());
+        assertEquals(true, islamic.hourOfHalfday().isSupported());
+        assertEquals(true, islamic.clockhourOfDay().isSupported());
+        assertEquals(true, islamic.hourOfDay().isSupported());
+        assertEquals(true, islamic.minuteOfDay().isSupported());
+        assertEquals(true, islamic.minuteOfHour().isSupported());
+        assertEquals(true, islamic.secondOfDay().isSupported());
+        assertEquals(true, islamic.secondOfMinute().isSupported());
+        assertEquals(true, islamic.millisOfDay().isSupported());
+        assertEquals(true, islamic.millisOfSecond().isSupported());
     }
 
     //-----------------------------------------------------------------------
diff --git a/src/test/java/org/joda/time/chrono/TestJulianChronology.java b/src/test/java/org/joda/time/chrono/TestJulianChronology.java
index 3a344677c..ac98a891b 100644
--- a/src/test/java/org/joda/time/chrono/TestJulianChronology.java
+++ b/src/test/java/org/joda/time/chrono/TestJulianChronology.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2005 Stephen Colebourne
+ *  Copyright 2001-2013 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -148,122 +148,127 @@ public void testToString() {
 
     //-----------------------------------------------------------------------
     public void testDurationFields() {
-        assertEquals("eras", JulianChronology.getInstance().eras().getName());
-        assertEquals("centuries", JulianChronology.getInstance().centuries().getName());
-        assertEquals("years", JulianChronology.getInstance().years().getName());
-        assertEquals("weekyears", JulianChronology.getInstance().weekyears().getName());
-        assertEquals("months", JulianChronology.getInstance().months().getName());
-        assertEquals("weeks", JulianChronology.getInstance().weeks().getName());
-        assertEquals("days", JulianChronology.getInstance().days().getName());
-        assertEquals("halfdays", JulianChronology.getInstance().halfdays().getName());
-        assertEquals("hours", JulianChronology.getInstance().hours().getName());
-        assertEquals("minutes", JulianChronology.getInstance().minutes().getName());
-        assertEquals("seconds", JulianChronology.getInstance().seconds().getName());
-        assertEquals("millis", JulianChronology.getInstance().millis().getName());
+        final JulianChronology julian = JulianChronology.getInstance();
+        assertEquals("eras", julian.eras().getName());
+        assertEquals("centuries", julian.centuries().getName());
+        assertEquals("years", julian.years().getName());
+        assertEquals("weekyears", julian.weekyears().getName());
+        assertEquals("months", julian.months().getName());
+        assertEquals("weeks", julian.weeks().getName());
+        assertEquals("days", julian.days().getName());
+        assertEquals("halfdays", julian.halfdays().getName());
+        assertEquals("hours", julian.hours().getName());
+        assertEquals("minutes", julian.minutes().getName());
+        assertEquals("seconds", julian.seconds().getName());
+        assertEquals("millis", julian.millis().getName());
         
-        assertEquals(false, JulianChronology.getInstance().eras().isSupported());
-        assertEquals(true, JulianChronology.getInstance().centuries().isSupported());
-        assertEquals(true, JulianChronology.getInstance().years().isSupported());
-        assertEquals(true, JulianChronology.getInstance().weekyears().isSupported());
-        assertEquals(true, JulianChronology.getInstance().months().isSupported());
-        assertEquals(true, JulianChronology.getInstance().weeks().isSupported());
-        assertEquals(true, JulianChronology.getInstance().days().isSupported());
-        assertEquals(true, JulianChronology.getInstance().halfdays().isSupported());
-        assertEquals(true, JulianChronology.getInstance().hours().isSupported());
-        assertEquals(true, JulianChronology.getInstance().minutes().isSupported());
-        assertEquals(true, JulianChronology.getInstance().seconds().isSupported());
-        assertEquals(true, JulianChronology.getInstance().millis().isSupported());
+        assertEquals(false, julian.eras().isSupported());
+        assertEquals(true, julian.centuries().isSupported());
+        assertEquals(true, julian.years().isSupported());
+        assertEquals(true, julian.weekyears().isSupported());
+        assertEquals(true, julian.months().isSupported());
+        assertEquals(true, julian.weeks().isSupported());
+        assertEquals(true, julian.days().isSupported());
+        assertEquals(true, julian.halfdays().isSupported());
+        assertEquals(true, julian.hours().isSupported());
+        assertEquals(true, julian.minutes().isSupported());
+        assertEquals(true, julian.seconds().isSupported());
+        assertEquals(true, julian.millis().isSupported());
         
-        assertEquals(false, JulianChronology.getInstance().centuries().isPrecise());
-        assertEquals(false, JulianChronology.getInstance().years().isPrecise());
-        assertEquals(false, JulianChronology.getInstance().weekyears().isPrecise());
-        assertEquals(false, JulianChronology.getInstance().months().isPrecise());
-        assertEquals(false, JulianChronology.getInstance().weeks().isPrecise());
-        assertEquals(false, JulianChronology.getInstance().days().isPrecise());
-        assertEquals(false, JulianChronology.getInstance().halfdays().isPrecise());
-        assertEquals(true, JulianChronology.getInstance().hours().isPrecise());
-        assertEquals(true, JulianChronology.getInstance().minutes().isPrecise());
-        assertEquals(true, JulianChronology.getInstance().seconds().isPrecise());
-        assertEquals(true, JulianChronology.getInstance().millis().isPrecise());
+        assertEquals(false, julian.centuries().isPrecise());
+        assertEquals(false, julian.years().isPrecise());
+        assertEquals(false, julian.weekyears().isPrecise());
+        assertEquals(false, julian.months().isPrecise());
+        assertEquals(false, julian.weeks().isPrecise());
+        assertEquals(false, julian.days().isPrecise());
+        assertEquals(false, julian.halfdays().isPrecise());
+        assertEquals(true, julian.hours().isPrecise());
+        assertEquals(true, julian.minutes().isPrecise());
+        assertEquals(true, julian.seconds().isPrecise());
+        assertEquals(true, julian.millis().isPrecise());
         
-        assertEquals(false, JulianChronology.getInstanceUTC().centuries().isPrecise());
-        assertEquals(false, JulianChronology.getInstanceUTC().years().isPrecise());
-        assertEquals(false, JulianChronology.getInstanceUTC().weekyears().isPrecise());
-        assertEquals(false, JulianChronology.getInstanceUTC().months().isPrecise());
-        assertEquals(true, JulianChronology.getInstanceUTC().weeks().isPrecise());
-        assertEquals(true, JulianChronology.getInstanceUTC().days().isPrecise());
-        assertEquals(true, JulianChronology.getInstanceUTC().halfdays().isPrecise());
-        assertEquals(true, JulianChronology.getInstanceUTC().hours().isPrecise());
-        assertEquals(true, JulianChronology.getInstanceUTC().minutes().isPrecise());
-        assertEquals(true, JulianChronology.getInstanceUTC().seconds().isPrecise());
-        assertEquals(true, JulianChronology.getInstanceUTC().millis().isPrecise());
+        final JulianChronology julianUTC = JulianChronology.getInstanceUTC();
+        assertEquals(false, julianUTC.centuries().isPrecise());
+        assertEquals(false, julianUTC.years().isPrecise());
+        assertEquals(false, julianUTC.weekyears().isPrecise());
+        assertEquals(false, julianUTC.months().isPrecise());
+        assertEquals(true, julianUTC.weeks().isPrecise());
+        assertEquals(true, julianUTC.days().isPrecise());
+        assertEquals(true, julianUTC.halfdays().isPrecise());
+        assertEquals(true, julianUTC.hours().isPrecise());
+        assertEquals(true, julianUTC.minutes().isPrecise());
+        assertEquals(true, julianUTC.seconds().isPrecise());
+        assertEquals(true, julianUTC.millis().isPrecise());
         
-        DateTimeZone gmt = DateTimeZone.forID("Etc/GMT");
-        assertEquals(false, JulianChronology.getInstance(gmt).centuries().isPrecise());
-        assertEquals(false, JulianChronology.getInstance(gmt).years().isPrecise());
-        assertEquals(false, JulianChronology.getInstance(gmt).weekyears().isPrecise());
-        assertEquals(false, JulianChronology.getInstance(gmt).months().isPrecise());
-        assertEquals(true, JulianChronology.getInstance(gmt).weeks().isPrecise());
-        assertEquals(true, JulianChronology.getInstance(gmt).days().isPrecise());
-        assertEquals(true, JulianChronology.getInstance(gmt).halfdays().isPrecise());
-        assertEquals(true, JulianChronology.getInstance(gmt).hours().isPrecise());
-        assertEquals(true, JulianChronology.getInstance(gmt).minutes().isPrecise());
-        assertEquals(true, JulianChronology.getInstance(gmt).seconds().isPrecise());
-        assertEquals(true, JulianChronology.getInstance(gmt).millis().isPrecise());
+        final DateTimeZone gmt = DateTimeZone.forID("Etc/GMT");
+        final JulianChronology julianGMT = JulianChronology.getInstance(gmt);
+        assertEquals(false, julianGMT.centuries().isPrecise());
+        assertEquals(false, julianGMT.years().isPrecise());
+        assertEquals(false, julianGMT.weekyears().isPrecise());
+        assertEquals(false, julianGMT.months().isPrecise());
+        assertEquals(true, julianGMT.weeks().isPrecise());
+        assertEquals(true, julianGMT.days().isPrecise());
+        assertEquals(true, julianGMT.halfdays().isPrecise());
+        assertEquals(true, julianGMT.hours().isPrecise());
+        assertEquals(true, julianGMT.minutes().isPrecise());
+        assertEquals(true, julianGMT.seconds().isPrecise());
+        assertEquals(true, julianGMT.millis().isPrecise());
     }
 
     public void testDateFields() {
-        assertEquals("era", JulianChronology.getInstance().era().getName());
-        assertEquals("centuryOfEra", JulianChronology.getInstance().centuryOfEra().getName());
-        assertEquals("yearOfCentury", JulianChronology.getInstance().yearOfCentury().getName());
-        assertEquals("yearOfEra", JulianChronology.getInstance().yearOfEra().getName());
-        assertEquals("year", JulianChronology.getInstance().year().getName());
-        assertEquals("monthOfYear", JulianChronology.getInstance().monthOfYear().getName());
-        assertEquals("weekyearOfCentury", JulianChronology.getInstance().weekyearOfCentury().getName());
-        assertEquals("weekyear", JulianChronology.getInstance().weekyear().getName());
-        assertEquals("weekOfWeekyear", JulianChronology.getInstance().weekOfWeekyear().getName());
-        assertEquals("dayOfYear", JulianChronology.getInstance().dayOfYear().getName());
-        assertEquals("dayOfMonth", JulianChronology.getInstance().dayOfMonth().getName());
-        assertEquals("dayOfWeek", JulianChronology.getInstance().dayOfWeek().getName());
+        final JulianChronology julian = JulianChronology.getInstance();
+        assertEquals("era", julian.era().getName());
+        assertEquals("centuryOfEra", julian.centuryOfEra().getName());
+        assertEquals("yearOfCentury", julian.yearOfCentury().getName());
+        assertEquals("yearOfEra", julian.yearOfEra().getName());
+        assertEquals("year", julian.year().getName());
+        assertEquals("monthOfYear", julian.monthOfYear().getName());
+        assertEquals("weekyearOfCentury", julian.weekyearOfCentury().getName());
+        assertEquals("weekyear", julian.weekyear().getName());
+        assertEquals("weekOfWeekyear", julian.weekOfWeekyear().getName());
+        assertEquals("dayOfYear", julian.dayOfYear().getName());
+        assertEquals("dayOfMonth", julian.dayOfMonth().getName());
+        assertEquals("dayOfWeek", julian.dayOfWeek().getName());
         
-        assertEquals(true, JulianChronology.getInstance().era().isSupported());
-        assertEquals(true, JulianChronology.getInstance().centuryOfEra().isSupported());
-        assertEquals(true, JulianChronology.getInstance().yearOfCentury().isSupported());
-        assertEquals(true, JulianChronology.getInstance().yearOfEra().isSupported());
-        assertEquals(true, JulianChronology.getInstance().year().isSupported());
-        assertEquals(true, JulianChronology.getInstance().monthOfYear().isSupported());
-        assertEquals(true, JulianChronology.getInstance().weekyearOfCentury().isSupported());
-        assertEquals(true, JulianChronology.getInstance().weekyear().isSupported());
-        assertEquals(true, JulianChronology.getInstance().weekOfWeekyear().isSupported());
-        assertEquals(true, JulianChronology.getInstance().dayOfYear().isSupported());
-        assertEquals(true, JulianChronology.getInstance().dayOfMonth().isSupported());
-        assertEquals(true, JulianChronology.getInstance().dayOfWeek().isSupported());
+        assertEquals(true, julian.era().isSupported());
+        assertEquals(true, julian.centuryOfEra().isSupported());
+        assertEquals(true, julian.yearOfCentury().isSupported());
+        assertEquals(true, julian.yearOfEra().isSupported());
+        assertEquals(true, julian.year().isSupported());
+        assertEquals(true, julian.monthOfYear().isSupported());
+        assertEquals(true, julian.weekyearOfCentury().isSupported());
+        assertEquals(true, julian.weekyear().isSupported());
+        assertEquals(true, julian.weekOfWeekyear().isSupported());
+        assertEquals(true, julian.dayOfYear().isSupported());
+        assertEquals(true, julian.dayOfMonth().isSupported());
+        assertEquals(true, julian.dayOfWeek().isSupported());
     }
 
     public void testTimeFields() {
-        assertEquals("halfdayOfDay", JulianChronology.getInstance().halfdayOfDay().getName());
-        assertEquals("clockhourOfHalfday", JulianChronology.getInstance().clockhourOfHalfday().getName());
-        assertEquals("hourOfHalfday", JulianChronology.getInstance().hourOfHalfday().getName());
-        assertEquals("clockhourOfDay", JulianChronology.getInstance().clockhourOfDay().getName());
-        assertEquals("hourOfDay", JulianChronology.getInstance().hourOfDay().getName());
-        assertEquals("minuteOfDay", JulianChronology.getInstance().minuteOfDay().getName());
-        assertEquals("minuteOfHour", JulianChronology.getInstance().minuteOfHour().getName());
-        assertEquals("secondOfDay", JulianChronology.getInstance().secondOfDay().getName());
-        assertEquals("secondOfMinute", JulianChronology.getInstance().secondOfMinute().getName());
-        assertEquals("millisOfDay", JulianChronology.getInstance().millisOfDay().getName());
-        assertEquals("millisOfSecond", JulianChronology.getInstance().millisOfSecond().getName());
+        final JulianChronology julian = JulianChronology.getInstance();
+        assertEquals("halfdayOfDay", julian.halfdayOfDay().getName());
+        assertEquals("clockhourOfHalfday", julian.clockhourOfHalfday().getName());
+        assertEquals("hourOfHalfday", julian.hourOfHalfday().getName());
+        assertEquals("clockhourOfDay", julian.clockhourOfDay().getName());
+        assertEquals("hourOfDay", julian.hourOfDay().getName());
+        assertEquals("minuteOfDay", julian.minuteOfDay().getName());
+        assertEquals("minuteOfHour", julian.minuteOfHour().getName());
+        assertEquals("secondOfDay", julian.secondOfDay().getName());
+        assertEquals("secondOfMinute", julian.secondOfMinute().getName());
+        assertEquals("millisOfDay", julian.millisOfDay().getName());
+        assertEquals("millisOfSecond", julian.millisOfSecond().getName());
         
-        assertEquals(true, JulianChronology.getInstance().halfdayOfDay().isSupported());
-        assertEquals(true, JulianChronology.getInstance().clockhourOfHalfday().isSupported());
-        assertEquals(true, JulianChronology.getInstance().hourOfHalfday().isSupported());
-        assertEquals(true, JulianChronology.getInstance().clockhourOfDay().isSupported());
-        assertEquals(true, JulianChronology.getInstance().hourOfDay().isSupported());
-        assertEquals(true, JulianChronology.getInstance().minuteOfDay().isSupported());
-        assertEquals(true, JulianChronology.getInstance().minuteOfHour().isSupported());
-        assertEquals(true, JulianChronology.getInstance().secondOfDay().isSupported());
-        assertEquals(true, JulianChronology.getInstance().secondOfMinute().isSupported());
-        assertEquals(true, JulianChronology.getInstance().millisOfDay().isSupported());
-        assertEquals(true, JulianChronology.getInstance().millisOfSecond().isSupported());
+        assertEquals(true, julian.halfdayOfDay().isSupported());
+        assertEquals(true, julian.clockhourOfHalfday().isSupported());
+        assertEquals(true, julian.hourOfHalfday().isSupported());
+        assertEquals(true, julian.clockhourOfDay().isSupported());
+        assertEquals(true, julian.hourOfDay().isSupported());
+        assertEquals(true, julian.minuteOfDay().isSupported());
+        assertEquals(true, julian.minuteOfHour().isSupported());
+        assertEquals(true, julian.secondOfDay().isSupported());
+        assertEquals(true, julian.secondOfMinute().isSupported());
+        assertEquals(true, julian.millisOfDay().isSupported());
+        assertEquals(true, julian.millisOfSecond().isSupported());
     }
 
 }

From 81a818471a9ef5f0e884ae2d319668eff5002738 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Wed, 27 Nov 2013 12:21:54 +0000
Subject: [PATCH 34/86] DurationField is incorrect in complex DateTimeField
 instances

Fixes #92
---
 RELEASE-NOTES.txt                             | 11 ++-
 .../org/joda/time/chrono/BasicChronology.java |  5 +-
 .../joda/time/chrono/BuddhistChronology.java  | 12 ++-
 .../org/joda/time/chrono/GJChronology.java    | 76 +++++++++++++------
 .../time/chrono/GJYearOfEraDateTimeField.java |  6 ++
 .../org/joda/time/chrono/ISOChronology.java   |  6 +-
 .../chrono/ISOYearOfEraDateTimeField.java     |  6 ++
 .../org/joda/time/chrono/ZonedChronology.java | 36 +++++++++
 .../time/field/DelegatedDateTimeField.java    | 23 +++++-
 .../joda/time/field/DividedDateTimeField.java | 46 ++++++++---
 .../time/field/RemainderDateTimeField.java    | 40 ++++++++++
 .../time/TestDateMidnight_Properties.java     |  4 +-
 .../joda/time/TestDateTime_Properties.java    |  4 +-
 .../time/TestMutableDateTime_Properties.java  |  6 +-
 .../time/chrono/TestBuddhistChronology.java   | 26 +++++++
 .../time/chrono/TestCopticChronology.java     | 26 +++++++
 .../time/chrono/TestEthiopicChronology.java   | 26 +++++++
 .../joda/time/chrono/TestGJChronology.java    | 26 +++++++
 .../time/chrono/TestGregorianChronology.java  | 26 +++++++
 .../joda/time/chrono/TestISOChronology.java   | 26 +++++++
 .../time/chrono/TestIslamicChronology.java    | 26 +++++++
 .../time/chrono/TestJulianChronology.java     | 26 +++++++
 22 files changed, 435 insertions(+), 54 deletions(-)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index b4accf1e4..d8817cc77 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -39,7 +39,10 @@ Serialization compatible - Yes
 Data compatible - Yes, except
  - DateTimeZone data updated to version 2013d
 
-Semantic compatible - Yes
+Semantic compatible - Yes, except
+- DateTimeField duration fields have been fixed
+  For example, yearOfEra() now has a range of eras() rather than null
+  The DurationField instances now compare using equals() correctly
 
 
 Deprecations since 2.3
@@ -48,6 +51,12 @@ Deprecations since 2.3
 
 Bug fixes since 2.3
 -------------------
+- DateTimeField.getDurationField() / DateTimeField.getRangeDurationField() [#92]
+  Previously some of the complex cases were wrong, notably around centuries and eras
+  For example, yearOfEra() returned a range of null when it should be eras()
+  A slew of tests were added and a variety of bugs fixed
+  This affects DateTimeField.getDurationField() and DateTimeField.getRangeDurationField()
+
 - Period.normalizedStandard(PeriodType) [#79]
   Fix handling of PeriodType when either years or months missing
 
diff --git a/src/main/java/org/joda/time/chrono/BasicChronology.java b/src/main/java/org/joda/time/chrono/BasicChronology.java
index 0753d86d7..63f394aee 100644
--- a/src/main/java/org/joda/time/chrono/BasicChronology.java
+++ b/src/main/java/org/joda/time/chrono/BasicChronology.java
@@ -278,6 +278,7 @@ protected void assemble(Fields fields) {
             fields.yearOfEra, 99);
         fields.centuryOfEra = new DividedDateTimeField(
             field, DateTimeFieldType.centuryOfEra(), 100);
+        fields.centuries = fields.centuryOfEra.getDurationField();
         
         field = new RemainderDateTimeField(
             (DividedDateTimeField) fields.centuryOfEra);
@@ -293,15 +294,13 @@ protected void assemble(Fields fields) {
         fields.weekOfWeekyear = new BasicWeekOfWeekyearDateTimeField(this, fields.weeks);
         
         field = new RemainderDateTimeField(
-            fields.weekyear, DateTimeFieldType.weekyearOfCentury(), 100);
+            fields.weekyear, fields.centuries, DateTimeFieldType.weekyearOfCentury(), 100);
         fields.weekyearOfCentury = new OffsetDateTimeField(
             field, DateTimeFieldType.weekyearOfCentury(), 1);
         
         // The remaining (imprecise) durations are available from the newly
         // created datetime fields.
-
         fields.years = fields.year.getDurationField();
-        fields.centuries = fields.centuryOfEra.getDurationField();
         fields.months = fields.monthOfYear.getDurationField();
         fields.weekyears = fields.weekyear.getDurationField();
     }
diff --git a/src/main/java/org/joda/time/chrono/BuddhistChronology.java b/src/main/java/org/joda/time/chrono/BuddhistChronology.java
index b05fb8372..fc6a1ec43 100644
--- a/src/main/java/org/joda/time/chrono/BuddhistChronology.java
+++ b/src/main/java/org/joda/time/chrono/BuddhistChronology.java
@@ -24,11 +24,13 @@
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeFieldType;
 import org.joda.time.DateTimeZone;
+import org.joda.time.DurationFieldType;
 import org.joda.time.field.DelegatedDateTimeField;
 import org.joda.time.field.DividedDateTimeField;
 import org.joda.time.field.OffsetDateTimeField;
 import org.joda.time.field.RemainderDateTimeField;
 import org.joda.time.field.SkipUndoDateTimeField;
+import org.joda.time.field.UnsupportedDurationField;
 
 /**
  * A chronology that matches the BuddhistCalendar class supplied by Sun.
@@ -213,6 +215,9 @@ public String toString() {
 
     protected void assemble(Fields fields) {
         if (getParam() == null) {
+            // force init as used below
+            fields.eras = UnsupportedDurationField.getInstance(DurationFieldType.eras());
+            
             // julian chrono removed zero, but we need to put it back
             DateTimeField field = fields.year;
             fields.year = new OffsetDateTimeField(
@@ -221,7 +226,7 @@ protected void assemble(Fields fields) {
             // one era, so yearOfEra is the same
             field = fields.yearOfEra;
             fields.yearOfEra = new DelegatedDateTimeField(
-                fields.year, DateTimeFieldType.yearOfEra());
+                fields.year, fields.eras, DateTimeFieldType.yearOfEra());
             
             // julian chrono removed zero, but we need to put it back
             field = fields.weekyear;
@@ -230,7 +235,8 @@ protected void assemble(Fields fields) {
             
             field = new OffsetDateTimeField(fields.yearOfEra, 99);
             fields.centuryOfEra = new DividedDateTimeField(
-                field, DateTimeFieldType.centuryOfEra(), 100);
+                field, fields.eras, DateTimeFieldType.centuryOfEra(), 100);
+            fields.centuries = fields.centuryOfEra.getDurationField();
             
             field = new RemainderDateTimeField(
                 (DividedDateTimeField) fields.centuryOfEra);
@@ -238,7 +244,7 @@ protected void assemble(Fields fields) {
                 field, DateTimeFieldType.yearOfCentury(), 1);
             
             field = new RemainderDateTimeField(
-                fields.weekyear, DateTimeFieldType.weekyearOfCentury(), 100);
+                fields.weekyear, fields.centuries, DateTimeFieldType.weekyearOfCentury(), 100);
             fields.weekyearOfCentury = new OffsetDateTimeField(
                 field, DateTimeFieldType.weekyearOfCentury(), 1);
             
diff --git a/src/main/java/org/joda/time/chrono/GJChronology.java b/src/main/java/org/joda/time/chrono/GJChronology.java
index c5ecda0bc..1cc03a473 100644
--- a/src/main/java/org/joda/time/chrono/GJChronology.java
+++ b/src/main/java/org/joda/time/chrono/GJChronology.java
@@ -530,23 +530,6 @@ protected void assemble(Fields fields) {
             fields.era = new CutoverField(julian.era(), fields.era, iCutoverMillis);
         }
 
-        // DayOfYear and weekOfWeekyear require special handling since cutover
-        // year has fewer days and weeks. Extend the cutover to the start of
-        // the next year or weekyear. This keeps the sequence unbroken during
-        // the cutover year.
-
-        {
-            long cutover = gregorian.year().roundCeiling(iCutoverMillis);
-            fields.dayOfYear = new CutoverField(
-                julian.dayOfYear(), fields.dayOfYear, cutover);
-        }
-
-        {
-            long cutover = gregorian.weekyear().roundCeiling(iCutoverMillis);
-            fields.weekOfWeekyear = new CutoverField(
-                julian.weekOfWeekyear(), fields.weekOfWeekyear, cutover, true);
-        }
-
         // These fields are special because they have imprecise durations. The
         // family of addition methods need special attention. Override affected
         // duration fields as well.
@@ -556,22 +539,40 @@ protected void assemble(Fields fields) {
             fields.years = fields.year.getDurationField();
             fields.yearOfEra = new ImpreciseCutoverField(
                 julian.yearOfEra(), fields.yearOfEra, fields.years, iCutoverMillis);
-            fields.yearOfCentury = new ImpreciseCutoverField(
-                julian.yearOfCentury(), fields.yearOfCentury, fields.years, iCutoverMillis);
             
             fields.centuryOfEra = new ImpreciseCutoverField(
                 julian.centuryOfEra(), fields.centuryOfEra, iCutoverMillis);
             fields.centuries = fields.centuryOfEra.getDurationField();
             
+            fields.yearOfCentury = new ImpreciseCutoverField(
+                julian.yearOfCentury(), fields.yearOfCentury, fields.years, fields.centuries, iCutoverMillis);
+            
             fields.monthOfYear = new ImpreciseCutoverField(
-                julian.monthOfYear(), fields.monthOfYear, iCutoverMillis);
+                julian.monthOfYear(), fields.monthOfYear, null, fields.years, iCutoverMillis);
             fields.months = fields.monthOfYear.getDurationField();
             
             fields.weekyear = new ImpreciseCutoverField(
                 julian.weekyear(), fields.weekyear, null, iCutoverMillis, true);
-            fields.weekyearOfCentury = new ImpreciseCutoverField(
-                julian.weekyearOfCentury(), fields.weekyearOfCentury, fields.weekyears, iCutoverMillis);
             fields.weekyears = fields.weekyear.getDurationField();
+            fields.weekyearOfCentury = new ImpreciseCutoverField(
+                julian.weekyearOfCentury(), fields.weekyearOfCentury, fields.weekyears, fields.centuries, iCutoverMillis);
+        }
+
+        // DayOfYear and weekOfWeekyear require special handling since cutover
+        // year has fewer days and weeks. Extend the cutover to the start of
+        // the next year or weekyear. This keeps the sequence unbroken during
+        // the cutover year.
+
+        {
+            long cutover = gregorian.year().roundCeiling(iCutoverMillis);
+            fields.dayOfYear = new CutoverField(
+                julian.dayOfYear(), fields.dayOfYear, fields.years, cutover, false);
+        }
+
+        {
+            long cutover = gregorian.weekyear().roundCeiling(iCutoverMillis);
+            fields.weekOfWeekyear = new CutoverField(
+                julian.weekOfWeekyear(), fields.weekOfWeekyear, fields.weekyears, cutover, true);
         }
 
         // These fields require basic cutover support, except they must link to
@@ -634,6 +635,18 @@ long gregorianToJulianByWeekyear(long instant) {
          */
         CutoverField(DateTimeField julianField, DateTimeField gregorianField,
                      long cutoverMillis, boolean convertByWeekyear) {
+            this(julianField, gregorianField, null, cutoverMillis, convertByWeekyear);
+        }
+
+        /**
+         * @param julianField field from the chronology used before the cutover instant
+         * @param gregorianField field from the chronology used at and after the cutover
+         * @param rangeField  the range field
+         * @param cutoverMillis  the millis of the cutover
+         * @param convertByWeekyear
+         */
+        CutoverField(DateTimeField julianField, DateTimeField gregorianField,
+                     DurationField rangeField, long cutoverMillis, boolean convertByWeekyear) {
             super(gregorianField.getType());
             iJulianField = julianField;
             iGregorianField = gregorianField;
@@ -642,10 +655,11 @@ long gregorianToJulianByWeekyear(long instant) {
             // Although average length of Julian and Gregorian years differ,
             // use the Gregorian duration field because it is more accurate.
             iDurationField = gregorianField.getDurationField();
-
-            DurationField rangeField = gregorianField.getRangeDurationField();
             if (rangeField == null) {
-                rangeField = julianField.getRangeDurationField();
+                rangeField = gregorianField.getRangeDurationField();
+                if (rangeField == null) {
+                    rangeField = julianField.getRangeDurationField();
+                }
             }
             iRangeDurationField = rangeField;
         }
@@ -960,6 +974,18 @@ protected long gregorianToJulian(long instant) {
             this(julianField, gregorianField, durationField, cutoverMillis, false);
         }
 
+        /**
+         * Uses shared duration fields rather than creating a new one.
+         *
+         * @param durationField shared duration field
+         */
+        ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,
+                              DurationField durationField, DurationField rangeDurationField, long cutoverMillis)
+        {
+            this(julianField, gregorianField, durationField, cutoverMillis, false);
+            iRangeDurationField = rangeDurationField;
+        }
+
         /**
          * Uses a shared duration field rather than creating a new one.
          *
diff --git a/src/main/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java b/src/main/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java
index 0466b8f0b..6ddde9a5b 100644
--- a/src/main/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java
+++ b/src/main/java/org/joda/time/chrono/GJYearOfEraDateTimeField.java
@@ -17,6 +17,7 @@
 
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeFieldType;
+import org.joda.time.DurationField;
 import org.joda.time.ReadablePartial;
 import org.joda.time.field.DecoratedDateTimeField;
 import org.joda.time.field.FieldUtils;
@@ -42,6 +43,11 @@
         iChronology = chronology;
     }
 
+    @Override
+    public DurationField getRangeDurationField() {
+        return iChronology.eras();
+    }
+
     public int get(long instant) {
         int year = getWrappedField().get(instant);
         if (year <= 0) {
diff --git a/src/main/java/org/joda/time/chrono/ISOChronology.java b/src/main/java/org/joda/time/chrono/ISOChronology.java
index 94847beff..075dd7bd0 100644
--- a/src/main/java/org/joda/time/chrono/ISOChronology.java
+++ b/src/main/java/org/joda/time/chrono/ISOChronology.java
@@ -170,12 +170,12 @@ protected void assemble(Fields fields) {
             // Use zero based century and year of century.
             fields.centuryOfEra = new DividedDateTimeField(
                 ISOYearOfEraDateTimeField.INSTANCE, DateTimeFieldType.centuryOfEra(), 100);
+            fields.centuries = fields.centuryOfEra.getDurationField();
+            
             fields.yearOfCentury = new RemainderDateTimeField(
                 (DividedDateTimeField) fields.centuryOfEra, DateTimeFieldType.yearOfCentury());
             fields.weekyearOfCentury = new RemainderDateTimeField(
-                (DividedDateTimeField) fields.centuryOfEra, DateTimeFieldType.weekyearOfCentury());
-
-            fields.centuries = fields.centuryOfEra.getDurationField();
+                (DividedDateTimeField) fields.centuryOfEra, fields.weekyears, DateTimeFieldType.weekyearOfCentury());
         }
     }
 
diff --git a/src/main/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java b/src/main/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java
index 95b42ca9a..aba1a89d3 100644
--- a/src/main/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java
+++ b/src/main/java/org/joda/time/chrono/ISOYearOfEraDateTimeField.java
@@ -17,6 +17,7 @@
 
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeFieldType;
+import org.joda.time.DurationField;
 import org.joda.time.ReadablePartial;
 import org.joda.time.field.DecoratedDateTimeField;
 import org.joda.time.field.FieldUtils;
@@ -47,6 +48,11 @@ private ISOYearOfEraDateTimeField() {
         super(GregorianChronology.getInstanceUTC().year(), DateTimeFieldType.yearOfEra());
     }
 
+    @Override
+    public DurationField getRangeDurationField() {
+        return GregorianChronology.getInstanceUTC().eras();
+    }
+
     public int get(long instant) {
         int year = getWrappedField().get(instant);
         return year < 0 ? -year : year;
diff --git a/src/main/java/org/joda/time/chrono/ZonedChronology.java b/src/main/java/org/joda/time/chrono/ZonedChronology.java
index 1eb99b6f6..c7c2da693 100644
--- a/src/main/java/org/joda/time/chrono/ZonedChronology.java
+++ b/src/main/java/org/joda/time/chrono/ZonedChronology.java
@@ -360,6 +360,23 @@ private int getOffsetFromLocalToSubtract(long instant) {
         private long addOffset(long instant) {
             return iZone.convertUTCToLocal(instant);
         }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj) {
+                return true;
+            } else if (obj instanceof ZonedDurationField) {
+                ZonedDurationField other = (ZonedDurationField) obj;
+                return iField.equals(other.iField) &&
+                       iZone.equals(other.iZone);
+            }
+            return false;
+        }
+
+        @Override
+        public int hashCode() {
+            return iField.hashCode() ^ iZone.hashCode();
+        }
     }
 
     /**
@@ -595,6 +612,25 @@ private int getOffsetToAdd(long instant) {
             }
             return offset;
         }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj) {
+                return true;
+            } else if (obj instanceof ZonedDateTimeField) {
+                ZonedDateTimeField other = (ZonedDateTimeField) obj;
+                return iField.equals(other.iField) &&
+                       iZone.equals(other.iZone) &&
+                       iDurationField.equals(other.iDurationField) &&
+                       iRangeDurationField.equals(other.iRangeDurationField);
+            }
+            return false;
+        }
+
+        @Override
+        public int hashCode() {
+            return iField.hashCode() ^ iZone.hashCode();
+        }
     }
 
 }
diff --git a/src/main/java/org/joda/time/field/DelegatedDateTimeField.java b/src/main/java/org/joda/time/field/DelegatedDateTimeField.java
index f2ee406a4..a5b70607e 100644
--- a/src/main/java/org/joda/time/field/DelegatedDateTimeField.java
+++ b/src/main/java/org/joda/time/field/DelegatedDateTimeField.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2005 Stephen Colebourne
+ *  Copyright 2001-2013 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -38,9 +38,11 @@
     /** Serialization version */
     private static final long serialVersionUID = -4730164440214502503L;
 
-    /** The DateTimeField being wrapped */
+    /** The DateTimeField being wrapped. */
     private final DateTimeField iField;
-    /** The override field type */
+    /** The range duration. */
+    private final DurationField iRangeDurationField;
+    /** The override field type. */
     private final DateTimeFieldType iType;
 
     /**
@@ -59,11 +61,23 @@ public DelegatedDateTimeField(DateTimeField field) {
      * @param type  the field type override
      */
     public DelegatedDateTimeField(DateTimeField field, DateTimeFieldType type) {
+        this(field, null, type);
+    }
+
+    /**
+     * Constructor.
+     * 
+     * @param field  the field being decorated
+     * @param rangeField  the range field, null to derive
+     * @param type  the field type override
+     */
+    public DelegatedDateTimeField(DateTimeField field, DurationField rangeField, DateTimeFieldType type) {
         super();
         if (field == null) {
             throw new IllegalArgumentException("The field must not be null");
         }
         iField = field;
+        iRangeDurationField = rangeField;
         iType = (type == null ? field.getType() : type);
     }
 
@@ -193,6 +207,9 @@ public DurationField getDurationField() {
     }
 
     public DurationField getRangeDurationField() {
+        if (iRangeDurationField != null) {
+            return iRangeDurationField;
+        }
         return iField.getRangeDurationField();
     }
 
diff --git a/src/main/java/org/joda/time/field/DividedDateTimeField.java b/src/main/java/org/joda/time/field/DividedDateTimeField.java
index 6a477b2b4..9a30dc902 100644
--- a/src/main/java/org/joda/time/field/DividedDateTimeField.java
+++ b/src/main/java/org/joda/time/field/DividedDateTimeField.java
@@ -40,6 +40,7 @@
     // Shared with RemainderDateTimeField.
     final int iDivisor;
     final DurationField iDurationField;
+    final DurationField iRangeDurationField;
 
     private final int iMin;
     private final int iMax;
@@ -54,12 +55,24 @@
      */
     public DividedDateTimeField(DateTimeField field,
                                 DateTimeFieldType type, int divisor) {
+        this(field, field.getRangeDurationField(), type, divisor);
+    }
+
+    /**
+     * Constructor.
+     * 
+     * @param field  the field to wrap, like "year()".
+     * @param rangeField  the range field, null to derive
+     * @param type  the field type this field will actually use
+     * @param divisor  divisor, such as 100 years in a century
+     * @throws IllegalArgumentException if divisor is less than two
+     */
+    public DividedDateTimeField(DateTimeField field, DurationField rangeField,
+                                DateTimeFieldType type, int divisor) {
         super(field, type);
-                
         if (divisor < 2) {
             throw new IllegalArgumentException("The divisor must be at least 2");
         }
-
         DurationField unitField = field.getDurationField();
         if (unitField == null) {
             iDurationField = null;
@@ -67,15 +80,12 @@ public DividedDateTimeField(DateTimeField field,
             iDurationField = new ScaledDurationField(
                 unitField, type.getDurationType(), divisor);
         }
-
+        iRangeDurationField = rangeField;
         iDivisor = divisor;
-
         int i = field.getMinimumValue();
         int min = (i >= 0) ? i / divisor : ((i + 1) / divisor - 1);
-
         int j = field.getMaximumValue();
         int max = (j >= 0) ? j / divisor : ((j + 1) / divisor - 1);
-
         iMin = min;
         iMax = max;
     }
@@ -88,21 +98,39 @@ public DividedDateTimeField(DateTimeField field,
      * @param type  the field type this field will actually use
      */
     public DividedDateTimeField(RemainderDateTimeField remainderField, DateTimeFieldType type) {
+        this(remainderField, null, type);
+    }
+
+    /**
+     * Construct a DividedDateTimeField that compliments the given
+     * RemainderDateTimeField.
+     *
+     * @param remainderField  complimentary remainder field, like "yearOfCentury()".
+     * @param rangeField  the range field, null to derive
+     * @param type  the field type this field will actually use
+     */
+    public DividedDateTimeField(RemainderDateTimeField remainderField, DurationField rangeField, DateTimeFieldType type) {
         super(remainderField.getWrappedField(), type);
         int divisor = iDivisor = remainderField.iDivisor;
         iDurationField = remainderField.iRangeField;
-
+        iRangeDurationField = rangeField;
         DateTimeField field = getWrappedField();
         int i = field.getMinimumValue();
         int min = (i >= 0) ? i / divisor : ((i + 1) / divisor - 1);
-
         int j = field.getMaximumValue();
         int max = (j >= 0) ? j / divisor : ((j + 1) / divisor - 1);
-
         iMin = min;
         iMax = max;
     }
 
+    @Override
+    public DurationField getRangeDurationField() {
+        if (iRangeDurationField != null) {
+            return iRangeDurationField;
+        }
+        return super.getRangeDurationField();
+    }
+
     /**
      * Get the amount of scaled units from the specified time instant.
      * 
diff --git a/src/main/java/org/joda/time/field/RemainderDateTimeField.java b/src/main/java/org/joda/time/field/RemainderDateTimeField.java
index d45aefd08..30a835afb 100644
--- a/src/main/java/org/joda/time/field/RemainderDateTimeField.java
+++ b/src/main/java/org/joda/time/field/RemainderDateTimeField.java
@@ -38,6 +38,7 @@
 
     // Shared with DividedDateTimeField.
     final int iDivisor;
+    final DurationField iDurationField;
     final DurationField iRangeField;
 
     /**
@@ -63,7 +64,27 @@ public RemainderDateTimeField(DateTimeField field,
             iRangeField = new ScaledDurationField(
                 rangeField, type.getRangeDurationType(), divisor);
         }
+        iDurationField = field.getDurationField();
+        iDivisor = divisor;
+    }
 
+    /**
+     * Constructor.
+     * 
+     * @param field  the field to wrap, like "year()".
+     * @param rangeField  the range field
+     * @param type  the field type this field actually uses
+     * @param divisor  divisor, such as 100 years in a century
+     * @throws IllegalArgumentException if divisor is less than two
+     */
+    public RemainderDateTimeField(DateTimeField field, DurationField rangeField,
+                                  DateTimeFieldType type, int divisor) {
+        super(field, type);
+        if (divisor < 2) {
+            throw new IllegalArgumentException("The divisor must be at least 2");
+        }
+        iRangeField = rangeField;
+        iDurationField = field.getDurationField();
         iDivisor = divisor;
     }
 
@@ -85,8 +106,22 @@ public RemainderDateTimeField(DividedDateTimeField dividedField) {
      * @param type  the field type this field actually uses
      */
     public RemainderDateTimeField(DividedDateTimeField dividedField, DateTimeFieldType type) {
+        this(dividedField, dividedField.getWrappedField().getDurationField(), type);
+    }
+
+    /**
+     * Construct a RemainderDateTimeField that compliments the given
+     * DividedDateTimeField.
+     * This constructor allows the duration field to be set.
+     *
+     * @param dividedField  complimentary divided field, like "century()".
+     * @param durationField  the duration field
+     * @param type  the field type this field actually uses
+     */
+    public RemainderDateTimeField(DividedDateTimeField dividedField, DurationField durationField, DateTimeFieldType type) {
         super(dividedField.getWrappedField(), type);
         iDivisor = dividedField.iDivisor;
+        iDurationField = durationField;
         iRangeField = dividedField.iDurationField;
     }
 
@@ -133,6 +168,11 @@ public long set(long instant, int value) {
         return getWrappedField().set(instant, divided * iDivisor + value);
     }
 
+    @Override
+    public DurationField getDurationField() {
+        return iDurationField;
+    }
+
     /**
      * Returns a scaled version of the wrapped field's unit duration field.
      */
diff --git a/src/test/java/org/joda/time/TestDateMidnight_Properties.java b/src/test/java/org/joda/time/TestDateMidnight_Properties.java
index 50a77406a..b49a79081 100644
--- a/src/test/java/org/joda/time/TestDateMidnight_Properties.java
+++ b/src/test/java/org/joda/time/TestDateMidnight_Properties.java
@@ -136,7 +136,7 @@ public void testPropertyGetYearOfEra() {
         assertEquals("2004", test.yearOfEra().getAsShortText());
         assertEquals("2004", test.yearOfEra().getAsShortText(Locale.FRENCH));
         assertEquals(test.getChronology().years(), test.yearOfEra().getDurationField());
-        assertEquals(null, test.yearOfEra().getRangeDurationField());
+        assertEquals(test.getChronology().eras(), test.yearOfEra().getRangeDurationField());
         assertEquals(9, test.yearOfEra().getMaximumTextLength(null));
         assertEquals(9, test.yearOfEra().getMaximumShortTextLength(null));
     }
@@ -154,7 +154,7 @@ public void testPropertyGetCenturyOfEra() {
         assertEquals("20", test.centuryOfEra().getAsShortText());
         assertEquals("20", test.centuryOfEra().getAsShortText(Locale.FRENCH));
         assertEquals(test.getChronology().centuries(), test.centuryOfEra().getDurationField());
-        assertEquals(null, test.centuryOfEra().getRangeDurationField());
+        assertEquals(test.getChronology().eras(), test.centuryOfEra().getRangeDurationField());
         assertEquals(7, test.centuryOfEra().getMaximumTextLength(null));
         assertEquals(7, test.centuryOfEra().getMaximumShortTextLength(null));
     }
diff --git a/src/test/java/org/joda/time/TestDateTime_Properties.java b/src/test/java/org/joda/time/TestDateTime_Properties.java
index 891e8a416..57cab7a64 100644
--- a/src/test/java/org/joda/time/TestDateTime_Properties.java
+++ b/src/test/java/org/joda/time/TestDateTime_Properties.java
@@ -141,7 +141,7 @@ public void testPropertyGetYearOfEra() {
         assertEquals("2004", test.yearOfEra().getAsShortText());
         assertEquals("2004", test.yearOfEra().getAsShortText(Locale.FRENCH));
         assertEquals(test.getChronology().years(), test.yearOfEra().getDurationField());
-        assertEquals(null, test.yearOfEra().getRangeDurationField());
+        assertEquals(test.getChronology().eras(), test.yearOfEra().getRangeDurationField());
         assertEquals(9, test.yearOfEra().getMaximumTextLength(null));
         assertEquals(9, test.yearOfEra().getMaximumShortTextLength(null));
     }
@@ -160,7 +160,7 @@ public void testPropertyGetCenturyOfEra() {
         assertEquals("20", test.centuryOfEra().getAsShortText());
         assertEquals("20", test.centuryOfEra().getAsShortText(Locale.FRENCH));
         assertEquals(test.getChronology().centuries(), test.centuryOfEra().getDurationField());
-        assertEquals(null, test.centuryOfEra().getRangeDurationField());
+        assertEquals(test.getChronology().eras(), test.centuryOfEra().getRangeDurationField());
         assertEquals(7, test.centuryOfEra().getMaximumTextLength(null));
         assertEquals(7, test.centuryOfEra().getMaximumShortTextLength(null));
     }
diff --git a/src/test/java/org/joda/time/TestMutableDateTime_Properties.java b/src/test/java/org/joda/time/TestMutableDateTime_Properties.java
index 40fab3ed9..37d623529 100644
--- a/src/test/java/org/joda/time/TestMutableDateTime_Properties.java
+++ b/src/test/java/org/joda/time/TestMutableDateTime_Properties.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2005 Stephen Colebourne
+ *  Copyright 2001-2013 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -127,7 +127,7 @@ public void testPropertyGetYearOfEra() {
         assertEquals("2004", test.yearOfEra().getAsShortText());
         assertEquals("2004", test.yearOfEra().getAsShortText(Locale.FRENCH));
         assertEquals(test.getChronology().years(), test.yearOfEra().getDurationField());
-        assertEquals(null, test.yearOfEra().getRangeDurationField());
+        assertEquals(test.getChronology().eras(), test.yearOfEra().getRangeDurationField());
         assertEquals(9, test.yearOfEra().getMaximumTextLength(null));
         assertEquals(9, test.yearOfEra().getMaximumShortTextLength(null));
     }
@@ -144,7 +144,7 @@ public void testPropertyGetCenturyOfEra() {
         assertEquals("20", test.centuryOfEra().getAsShortText());
         assertEquals("20", test.centuryOfEra().getAsShortText(Locale.FRENCH));
         assertEquals(test.getChronology().centuries(), test.centuryOfEra().getDurationField());
-        assertEquals(null, test.centuryOfEra().getRangeDurationField());
+        assertEquals(test.getChronology().eras(), test.centuryOfEra().getRangeDurationField());
         assertEquals(7, test.centuryOfEra().getMaximumTextLength(null));
         assertEquals(7, test.centuryOfEra().getMaximumShortTextLength(null));
     }
diff --git a/src/test/java/org/joda/time/chrono/TestBuddhistChronology.java b/src/test/java/org/joda/time/chrono/TestBuddhistChronology.java
index fba1bfc5b..665d6784e 100644
--- a/src/test/java/org/joda/time/chrono/TestBuddhistChronology.java
+++ b/src/test/java/org/joda/time/chrono/TestBuddhistChronology.java
@@ -237,6 +237,32 @@ public void testDateFields() {
         assertEquals(true, buddhist.dayOfYear().isSupported());
         assertEquals(true, buddhist.dayOfMonth().isSupported());
         assertEquals(true, buddhist.dayOfWeek().isSupported());
+        
+        assertEquals(buddhist.eras(), buddhist.era().getDurationField());
+        assertEquals(buddhist.centuries(), buddhist.centuryOfEra().getDurationField());
+        assertEquals(buddhist.years(), buddhist.yearOfCentury().getDurationField());
+        assertEquals(buddhist.years(), buddhist.yearOfEra().getDurationField());
+        assertEquals(buddhist.years(), buddhist.year().getDurationField());
+        assertEquals(buddhist.months(), buddhist.monthOfYear().getDurationField());
+        assertEquals(buddhist.weekyears(), buddhist.weekyearOfCentury().getDurationField());
+        assertEquals(buddhist.weekyears(), buddhist.weekyear().getDurationField());
+        assertEquals(buddhist.weeks(), buddhist.weekOfWeekyear().getDurationField());
+        assertEquals(buddhist.days(), buddhist.dayOfYear().getDurationField());
+        assertEquals(buddhist.days(), buddhist.dayOfMonth().getDurationField());
+        assertEquals(buddhist.days(), buddhist.dayOfWeek().getDurationField());
+        
+        assertEquals(null, buddhist.era().getRangeDurationField());
+        assertEquals(buddhist.eras(), buddhist.centuryOfEra().getRangeDurationField());
+        assertEquals(buddhist.centuries(), buddhist.yearOfCentury().getRangeDurationField());
+        assertEquals(buddhist.eras(), buddhist.yearOfEra().getRangeDurationField());
+        assertEquals(null, buddhist.year().getRangeDurationField());
+        assertEquals(buddhist.years(), buddhist.monthOfYear().getRangeDurationField());
+        assertEquals(buddhist.centuries(), buddhist.weekyearOfCentury().getRangeDurationField());
+        assertEquals(null, buddhist.weekyear().getRangeDurationField());
+        assertEquals(buddhist.weekyears(), buddhist.weekOfWeekyear().getRangeDurationField());
+        assertEquals(buddhist.years(), buddhist.dayOfYear().getRangeDurationField());
+        assertEquals(buddhist.months(), buddhist.dayOfMonth().getRangeDurationField());
+        assertEquals(buddhist.weeks(), buddhist.dayOfWeek().getRangeDurationField());
     }
 
     public void testTimeFields() {
diff --git a/src/test/java/org/joda/time/chrono/TestCopticChronology.java b/src/test/java/org/joda/time/chrono/TestCopticChronology.java
index 023d82397..f3c6c3099 100644
--- a/src/test/java/org/joda/time/chrono/TestCopticChronology.java
+++ b/src/test/java/org/joda/time/chrono/TestCopticChronology.java
@@ -240,6 +240,32 @@ public void testDateFields() {
         assertEquals(true, coptic.dayOfYear().isSupported());
         assertEquals(true, coptic.dayOfMonth().isSupported());
         assertEquals(true, coptic.dayOfWeek().isSupported());
+        
+        assertEquals(coptic.eras(), coptic.era().getDurationField());
+        assertEquals(coptic.centuries(), coptic.centuryOfEra().getDurationField());
+        assertEquals(coptic.years(), coptic.yearOfCentury().getDurationField());
+        assertEquals(coptic.years(), coptic.yearOfEra().getDurationField());
+        assertEquals(coptic.years(), coptic.year().getDurationField());
+        assertEquals(coptic.months(), coptic.monthOfYear().getDurationField());
+        assertEquals(coptic.weekyears(), coptic.weekyearOfCentury().getDurationField());
+        assertEquals(coptic.weekyears(), coptic.weekyear().getDurationField());
+        assertEquals(coptic.weeks(), coptic.weekOfWeekyear().getDurationField());
+        assertEquals(coptic.days(), coptic.dayOfYear().getDurationField());
+        assertEquals(coptic.days(), coptic.dayOfMonth().getDurationField());
+        assertEquals(coptic.days(), coptic.dayOfWeek().getDurationField());
+        
+        assertEquals(null, coptic.era().getRangeDurationField());
+        assertEquals(coptic.eras(), coptic.centuryOfEra().getRangeDurationField());
+        assertEquals(coptic.centuries(), coptic.yearOfCentury().getRangeDurationField());
+        assertEquals(coptic.eras(), coptic.yearOfEra().getRangeDurationField());
+        assertEquals(null, coptic.year().getRangeDurationField());
+        assertEquals(coptic.years(), coptic.monthOfYear().getRangeDurationField());
+        assertEquals(coptic.centuries(), coptic.weekyearOfCentury().getRangeDurationField());
+        assertEquals(null, coptic.weekyear().getRangeDurationField());
+        assertEquals(coptic.weekyears(), coptic.weekOfWeekyear().getRangeDurationField());
+        assertEquals(coptic.years(), coptic.dayOfYear().getRangeDurationField());
+        assertEquals(coptic.months(), coptic.dayOfMonth().getRangeDurationField());
+        assertEquals(coptic.weeks(), coptic.dayOfWeek().getRangeDurationField());
     }
 
     public void testTimeFields() {
diff --git a/src/test/java/org/joda/time/chrono/TestEthiopicChronology.java b/src/test/java/org/joda/time/chrono/TestEthiopicChronology.java
index 1f5a1285d..814d02b20 100644
--- a/src/test/java/org/joda/time/chrono/TestEthiopicChronology.java
+++ b/src/test/java/org/joda/time/chrono/TestEthiopicChronology.java
@@ -240,6 +240,32 @@ public void testDateFields() {
         assertEquals(true, ethiopic.dayOfYear().isSupported());
         assertEquals(true, ethiopic.dayOfMonth().isSupported());
         assertEquals(true, ethiopic.dayOfWeek().isSupported());
+        
+        assertEquals(ethiopic.eras(), ethiopic.era().getDurationField());
+        assertEquals(ethiopic.centuries(), ethiopic.centuryOfEra().getDurationField());
+        assertEquals(ethiopic.years(), ethiopic.yearOfCentury().getDurationField());
+        assertEquals(ethiopic.years(), ethiopic.yearOfEra().getDurationField());
+        assertEquals(ethiopic.years(), ethiopic.year().getDurationField());
+        assertEquals(ethiopic.months(), ethiopic.monthOfYear().getDurationField());
+        assertEquals(ethiopic.weekyears(), ethiopic.weekyearOfCentury().getDurationField());
+        assertEquals(ethiopic.weekyears(), ethiopic.weekyear().getDurationField());
+        assertEquals(ethiopic.weeks(), ethiopic.weekOfWeekyear().getDurationField());
+        assertEquals(ethiopic.days(), ethiopic.dayOfYear().getDurationField());
+        assertEquals(ethiopic.days(), ethiopic.dayOfMonth().getDurationField());
+        assertEquals(ethiopic.days(), ethiopic.dayOfWeek().getDurationField());
+        
+        assertEquals(null, ethiopic.era().getRangeDurationField());
+        assertEquals(ethiopic.eras(), ethiopic.centuryOfEra().getRangeDurationField());
+        assertEquals(ethiopic.centuries(), ethiopic.yearOfCentury().getRangeDurationField());
+        assertEquals(ethiopic.eras(), ethiopic.yearOfEra().getRangeDurationField());
+        assertEquals(null, ethiopic.year().getRangeDurationField());
+        assertEquals(ethiopic.years(), ethiopic.monthOfYear().getRangeDurationField());
+        assertEquals(ethiopic.centuries(), ethiopic.weekyearOfCentury().getRangeDurationField());
+        assertEquals(null, ethiopic.weekyear().getRangeDurationField());
+        assertEquals(ethiopic.weekyears(), ethiopic.weekOfWeekyear().getRangeDurationField());
+        assertEquals(ethiopic.years(), ethiopic.dayOfYear().getRangeDurationField());
+        assertEquals(ethiopic.months(), ethiopic.dayOfMonth().getRangeDurationField());
+        assertEquals(ethiopic.weeks(), ethiopic.dayOfWeek().getRangeDurationField());
     }
 
     public void testTimeFields() {
diff --git a/src/test/java/org/joda/time/chrono/TestGJChronology.java b/src/test/java/org/joda/time/chrono/TestGJChronology.java
index d0e8ddfde..de30994c9 100644
--- a/src/test/java/org/joda/time/chrono/TestGJChronology.java
+++ b/src/test/java/org/joda/time/chrono/TestGJChronology.java
@@ -290,6 +290,32 @@ public void testDateFields() {
         assertEquals(true, gj.dayOfYear().isSupported());
         assertEquals(true, gj.dayOfMonth().isSupported());
         assertEquals(true, gj.dayOfWeek().isSupported());
+        
+        assertEquals(gj.eras(), gj.era().getDurationField());
+        assertEquals(gj.centuries(), gj.centuryOfEra().getDurationField());
+        assertEquals(gj.years(), gj.yearOfCentury().getDurationField());
+        assertEquals(gj.years(), gj.yearOfEra().getDurationField());
+        assertEquals(gj.years(), gj.year().getDurationField());
+        assertEquals(gj.months(), gj.monthOfYear().getDurationField());
+        assertEquals(gj.weekyears(), gj.weekyearOfCentury().getDurationField());
+        assertEquals(gj.weekyears(), gj.weekyear().getDurationField());
+        assertEquals(gj.weeks(), gj.weekOfWeekyear().getDurationField());
+        assertEquals(gj.days(), gj.dayOfYear().getDurationField());
+        assertEquals(gj.days(), gj.dayOfMonth().getDurationField());
+        assertEquals(gj.days(), gj.dayOfWeek().getDurationField());
+        
+        assertEquals(null, gj.era().getRangeDurationField());
+        assertEquals(gj.eras(), gj.centuryOfEra().getRangeDurationField());
+        assertEquals(gj.centuries(), gj.yearOfCentury().getRangeDurationField());
+        assertEquals(gj.eras(), gj.yearOfEra().getRangeDurationField());
+        assertEquals(null, gj.year().getRangeDurationField());
+        assertEquals(gj.years(), gj.monthOfYear().getRangeDurationField());
+        assertEquals(gj.centuries(), gj.weekyearOfCentury().getRangeDurationField());
+        assertEquals(null, gj.weekyear().getRangeDurationField());
+        assertEquals(gj.weekyears(), gj.weekOfWeekyear().getRangeDurationField());
+        assertEquals(gj.years(), gj.dayOfYear().getRangeDurationField());
+        assertEquals(gj.months(), gj.dayOfMonth().getRangeDurationField());
+        assertEquals(gj.weeks(), gj.dayOfWeek().getRangeDurationField());
     }
 
     public void testTimeFields() {
diff --git a/src/test/java/org/joda/time/chrono/TestGregorianChronology.java b/src/test/java/org/joda/time/chrono/TestGregorianChronology.java
index d1a32b42c..098b08af2 100644
--- a/src/test/java/org/joda/time/chrono/TestGregorianChronology.java
+++ b/src/test/java/org/joda/time/chrono/TestGregorianChronology.java
@@ -246,6 +246,32 @@ public void testDateFields() {
         assertEquals(true, greg.dayOfYear().isSupported());
         assertEquals(true, greg.dayOfMonth().isSupported());
         assertEquals(true, greg.dayOfWeek().isSupported());
+        
+        assertEquals(greg.eras(), greg.era().getDurationField());
+        assertEquals(greg.centuries(), greg.centuryOfEra().getDurationField());
+        assertEquals(greg.years(), greg.yearOfCentury().getDurationField());
+        assertEquals(greg.years(), greg.yearOfEra().getDurationField());
+        assertEquals(greg.years(), greg.year().getDurationField());
+        assertEquals(greg.months(), greg.monthOfYear().getDurationField());
+        assertEquals(greg.weekyears(), greg.weekyearOfCentury().getDurationField());
+        assertEquals(greg.weekyears(), greg.weekyear().getDurationField());
+        assertEquals(greg.weeks(), greg.weekOfWeekyear().getDurationField());
+        assertEquals(greg.days(), greg.dayOfYear().getDurationField());
+        assertEquals(greg.days(), greg.dayOfMonth().getDurationField());
+        assertEquals(greg.days(), greg.dayOfWeek().getDurationField());
+        
+        assertEquals(null, greg.era().getRangeDurationField());
+        assertEquals(greg.eras(), greg.centuryOfEra().getRangeDurationField());
+        assertEquals(greg.centuries(), greg.yearOfCentury().getRangeDurationField());
+        assertEquals(greg.eras(), greg.yearOfEra().getRangeDurationField());
+        assertEquals(null, greg.year().getRangeDurationField());
+        assertEquals(greg.years(), greg.monthOfYear().getRangeDurationField());
+        assertEquals(greg.centuries(), greg.weekyearOfCentury().getRangeDurationField());
+        assertEquals(null, greg.weekyear().getRangeDurationField());
+        assertEquals(greg.weekyears(), greg.weekOfWeekyear().getRangeDurationField());
+        assertEquals(greg.years(), greg.dayOfYear().getRangeDurationField());
+        assertEquals(greg.months(), greg.dayOfMonth().getRangeDurationField());
+        assertEquals(greg.weeks(), greg.dayOfWeek().getRangeDurationField());
     }
 
     public void testTimeFields() {
diff --git a/src/test/java/org/joda/time/chrono/TestISOChronology.java b/src/test/java/org/joda/time/chrono/TestISOChronology.java
index b4cf0e695..e6b04bae1 100644
--- a/src/test/java/org/joda/time/chrono/TestISOChronology.java
+++ b/src/test/java/org/joda/time/chrono/TestISOChronology.java
@@ -250,6 +250,32 @@ public void testDateFields() {
         assertEquals(true, iso.dayOfYear().isSupported());
         assertEquals(true, iso.dayOfMonth().isSupported());
         assertEquals(true, iso.dayOfWeek().isSupported());
+        
+        assertEquals(iso.eras(), iso.era().getDurationField());
+        assertEquals(iso.centuries(), iso.centuryOfEra().getDurationField());
+        assertEquals(iso.years(), iso.yearOfCentury().getDurationField());
+        assertEquals(iso.years(), iso.yearOfEra().getDurationField());
+        assertEquals(iso.years(), iso.year().getDurationField());
+        assertEquals(iso.months(), iso.monthOfYear().getDurationField());
+        assertEquals(iso.weekyears(), iso.weekyearOfCentury().getDurationField());
+        assertEquals(iso.weekyears(), iso.weekyear().getDurationField());
+        assertEquals(iso.weeks(), iso.weekOfWeekyear().getDurationField());
+        assertEquals(iso.days(), iso.dayOfYear().getDurationField());
+        assertEquals(iso.days(), iso.dayOfMonth().getDurationField());
+        assertEquals(iso.days(), iso.dayOfWeek().getDurationField());
+        
+        assertEquals(null, iso.era().getRangeDurationField());
+        assertEquals(iso.eras(), iso.centuryOfEra().getRangeDurationField());
+        assertEquals(iso.centuries(), iso.yearOfCentury().getRangeDurationField());
+        assertEquals(iso.eras(), iso.yearOfEra().getRangeDurationField());
+        assertEquals(null, iso.year().getRangeDurationField());
+        assertEquals(iso.years(), iso.monthOfYear().getRangeDurationField());
+        assertEquals(iso.centuries(), iso.weekyearOfCentury().getRangeDurationField());
+        assertEquals(null, iso.weekyear().getRangeDurationField());
+        assertEquals(iso.weekyears(), iso.weekOfWeekyear().getRangeDurationField());
+        assertEquals(iso.years(), iso.dayOfYear().getRangeDurationField());
+        assertEquals(iso.months(), iso.dayOfMonth().getRangeDurationField());
+        assertEquals(iso.weeks(), iso.dayOfWeek().getRangeDurationField());
     }
 
     public void testTimeFields() {
diff --git a/src/test/java/org/joda/time/chrono/TestIslamicChronology.java b/src/test/java/org/joda/time/chrono/TestIslamicChronology.java
index fa1b6b884..f2a2bfbd8 100644
--- a/src/test/java/org/joda/time/chrono/TestIslamicChronology.java
+++ b/src/test/java/org/joda/time/chrono/TestIslamicChronology.java
@@ -237,6 +237,32 @@ public void testDateFields() {
         assertEquals(true, islamic.dayOfYear().isSupported());
         assertEquals(true, islamic.dayOfMonth().isSupported());
         assertEquals(true, islamic.dayOfWeek().isSupported());
+        
+        assertEquals(islamic.eras(), islamic.era().getDurationField());
+        assertEquals(islamic.centuries(), islamic.centuryOfEra().getDurationField());
+        assertEquals(islamic.years(), islamic.yearOfCentury().getDurationField());
+        assertEquals(islamic.years(), islamic.yearOfEra().getDurationField());
+        assertEquals(islamic.years(), islamic.year().getDurationField());
+        assertEquals(islamic.months(), islamic.monthOfYear().getDurationField());
+        assertEquals(islamic.weekyears(), islamic.weekyearOfCentury().getDurationField());
+        assertEquals(islamic.weekyears(), islamic.weekyear().getDurationField());
+        assertEquals(islamic.weeks(), islamic.weekOfWeekyear().getDurationField());
+        assertEquals(islamic.days(), islamic.dayOfYear().getDurationField());
+        assertEquals(islamic.days(), islamic.dayOfMonth().getDurationField());
+        assertEquals(islamic.days(), islamic.dayOfWeek().getDurationField());
+        
+        assertEquals(null, islamic.era().getRangeDurationField());
+        assertEquals(islamic.eras(), islamic.centuryOfEra().getRangeDurationField());
+        assertEquals(islamic.centuries(), islamic.yearOfCentury().getRangeDurationField());
+        assertEquals(islamic.eras(), islamic.yearOfEra().getRangeDurationField());
+        assertEquals(null, islamic.year().getRangeDurationField());
+        assertEquals(islamic.years(), islamic.monthOfYear().getRangeDurationField());
+        assertEquals(islamic.centuries(), islamic.weekyearOfCentury().getRangeDurationField());
+        assertEquals(null, islamic.weekyear().getRangeDurationField());
+        assertEquals(islamic.weekyears(), islamic.weekOfWeekyear().getRangeDurationField());
+        assertEquals(islamic.years(), islamic.dayOfYear().getRangeDurationField());
+        assertEquals(islamic.months(), islamic.dayOfMonth().getRangeDurationField());
+        assertEquals(islamic.weeks(), islamic.dayOfWeek().getRangeDurationField());
     }
 
     public void testTimeFields() {
diff --git a/src/test/java/org/joda/time/chrono/TestJulianChronology.java b/src/test/java/org/joda/time/chrono/TestJulianChronology.java
index ac98a891b..1f9479a1e 100644
--- a/src/test/java/org/joda/time/chrono/TestJulianChronology.java
+++ b/src/test/java/org/joda/time/chrono/TestJulianChronology.java
@@ -242,6 +242,32 @@ public void testDateFields() {
         assertEquals(true, julian.dayOfYear().isSupported());
         assertEquals(true, julian.dayOfMonth().isSupported());
         assertEquals(true, julian.dayOfWeek().isSupported());
+        
+        assertEquals(julian.eras(), julian.era().getDurationField());
+        assertEquals(julian.centuries(), julian.centuryOfEra().getDurationField());
+        assertEquals(julian.years(), julian.yearOfCentury().getDurationField());
+        assertEquals(julian.years(), julian.yearOfEra().getDurationField());
+        assertEquals(julian.years(), julian.year().getDurationField());
+        assertEquals(julian.months(), julian.monthOfYear().getDurationField());
+        assertEquals(julian.weekyears(), julian.weekyearOfCentury().getDurationField());
+        assertEquals(julian.weekyears(), julian.weekyear().getDurationField());
+        assertEquals(julian.weeks(), julian.weekOfWeekyear().getDurationField());
+        assertEquals(julian.days(), julian.dayOfYear().getDurationField());
+        assertEquals(julian.days(), julian.dayOfMonth().getDurationField());
+        assertEquals(julian.days(), julian.dayOfWeek().getDurationField());
+        
+        assertEquals(null, julian.era().getRangeDurationField());
+        assertEquals(julian.eras(), julian.centuryOfEra().getRangeDurationField());
+        assertEquals(julian.centuries(), julian.yearOfCentury().getRangeDurationField());
+        assertEquals(julian.eras(), julian.yearOfEra().getRangeDurationField());
+        assertEquals(null, julian.year().getRangeDurationField());
+        assertEquals(julian.years(), julian.monthOfYear().getRangeDurationField());
+        assertEquals(julian.centuries(), julian.weekyearOfCentury().getRangeDurationField());
+        assertEquals(null, julian.weekyear().getRangeDurationField());
+        assertEquals(julian.weekyears(), julian.weekOfWeekyear().getRangeDurationField());
+        assertEquals(julian.years(), julian.dayOfYear().getRangeDurationField());
+        assertEquals(julian.months(), julian.dayOfMonth().getRangeDurationField());
+        assertEquals(julian.weeks(), julian.dayOfWeek().getRangeDurationField());
     }
 
     public void testTimeFields() {

From bcb044669b4d1f8d334861ccbd169924d6ef3b54 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Wed, 27 Nov 2013 12:22:25 +0000
Subject: [PATCH 35/86] Fix NPE in DateTimeUtils.isContiguous with weird
 partials [#89]

Fixes #89
---
 RELEASE-NOTES.txt                              | 3 +++
 src/main/java/org/joda/time/DateTimeUtils.java | 4 ++--
 2 files changed, 5 insertions(+), 2 deletions(-)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index d8817cc77..69ff24bc6 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -57,6 +57,9 @@ Bug fixes since 2.3
   A slew of tests were added and a variety of bugs fixed
   This affects DateTimeField.getDurationField() and DateTimeField.getRangeDurationField()
 
+- DateTimeUtils.isContiguous(ReadablePartial) [#89]
+  The isContiguous() method could throw a NullPointerException when evaluating weird partials
+
 - Period.normalizedStandard(PeriodType) [#79]
   Fix handling of PeriodType when either years or months missing
 
diff --git a/src/main/java/org/joda/time/DateTimeUtils.java b/src/main/java/org/joda/time/DateTimeUtils.java
index 4059c543d..391cafd71 100644
--- a/src/main/java/org/joda/time/DateTimeUtils.java
+++ b/src/main/java/org/joda/time/DateTimeUtils.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2012 Stephen Colebourne
+ *  Copyright 2001-2013 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -370,7 +370,7 @@ public static final boolean isContiguous(ReadablePartial partial) {
         for (int i = 0; i < partial.size(); i++) {
             DateTimeField loopField = partial.getField(i);
             if (i > 0) {
-                if (loopField.getRangeDurationField().getType() != lastType) {
+                if (loopField.getRangeDurationField() == null || loopField.getRangeDurationField().getType() != lastType) {
                     return false;
                 }
             }

From 3ba9ba799b3261b7332a467a88be142c83b298fd Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Wed, 27 Nov 2013 12:23:24 +0000
Subject: [PATCH 36/86] Prevent creation of invalid partials via
 Partial.with(DateTimeFieldType,int)

Validation in this method was not as thorough as that in the constructor
This allowed invalid partials to be created
Fixes #88
---
 RELEASE-NOTES.txt                                        | 4 ++++
 src/main/java/org/joda/time/Partial.java                 | 7 ++++---
 src/test/java/org/joda/time/TestPartial_Basics.java      | 9 +++++++++
 .../java/org/joda/time/TestPartial_Constructors.java     | 9 +++++++++
 4 files changed, 26 insertions(+), 3 deletions(-)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 69ff24bc6..64b87dcaf 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -63,6 +63,10 @@ Bug fixes since 2.3
 - Period.normalizedStandard(PeriodType) [#79]
   Fix handling of PeriodType when either years or months missing
 
+- Partial.with(DateTimeFieldType,int) [#88]
+  Validation in this method was not as thorough as that in the constructor
+  This allowed invalid partials to be created
+
 - Better Javadoc for parsing of numbers in format patterns [#60]
 
 - Remove uncaughtException calls [#59]
diff --git a/src/main/java/org/joda/time/Partial.java b/src/main/java/org/joda/time/Partial.java
index aaf0a0fd5..8e8e60348 100644
--- a/src/main/java/org/joda/time/Partial.java
+++ b/src/main/java/org/joda/time/Partial.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2009 Stephen Colebourne
+ *  Copyright 2001-2013 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -459,8 +459,9 @@ public Partial with(DateTimeFieldType fieldType, int value) {
             newValues[i] = value;
             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
-            
-            Partial newPartial = new Partial(iChronology, newTypes, newValues);
+            // use public constructor to ensure full validation
+            // this isn't overly efficient, but is safe
+            Partial newPartial = new Partial(newTypes, newValues, iChronology);
             iChronology.validate(newPartial, newValues);
             return newPartial;
         }
diff --git a/src/test/java/org/joda/time/TestPartial_Basics.java b/src/test/java/org/joda/time/TestPartial_Basics.java
index 715d2c19d..ceaa1500d 100644
--- a/src/test/java/org/joda/time/TestPartial_Basics.java
+++ b/src/test/java/org/joda/time/TestPartial_Basics.java
@@ -357,6 +357,15 @@ public void testWith2() {
         check(test, 10, 20);
     }
 
+    public void testWith3() {
+        Partial test = createHourMinPartial();
+        try {
+            test.with(DateTimeFieldType.clockhourOfDay(), 6);
+            fail();
+        } catch (IllegalArgumentException ex) {}
+        check(test, 10, 20);
+    }
+
     public void testWith3a() {
         Partial test = createHourMinPartial();
         Partial result = test.with(DateTimeFieldType.secondOfMinute(), 15);
diff --git a/src/test/java/org/joda/time/TestPartial_Constructors.java b/src/test/java/org/joda/time/TestPartial_Constructors.java
index f302fa580..9a91bfadd 100644
--- a/src/test/java/org/joda/time/TestPartial_Constructors.java
+++ b/src/test/java/org/joda/time/TestPartial_Constructors.java
@@ -345,6 +345,15 @@ public void testConstructorEx8_TypeArray_intArray() throws Throwable {
         } catch (IllegalArgumentException ex) {
             assertMessageContains(ex, "must not", "duplicate");
         }
+        
+        types = new DateTimeFieldType[] {
+            DateTimeFieldType.dayOfMonth(), DateTimeFieldType.clockhourOfDay(), DateTimeFieldType.hourOfDay() };
+        try {
+            new Partial(types, values);
+            fail();
+        } catch (IllegalArgumentException ex) {
+            assertMessageContains(ex, "must not", "duplicate");
+        }
     }
 
     /**

From 8d109fe1a999a11b4557536dd96f9210460a5936 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Wed, 27 Nov 2013 12:35:00 +0000
Subject: [PATCH 37/86] Adding zero no longer changes the offset during DST
 overlap

Fixes #77
---
 RELEASE-NOTES.txt                             |   6 +
 .../java/org/joda/time/MutableDateTime.java   |  43 ++++--
 .../joda/time/TestMutableDateTime_Adds.java   | 138 +++++++++++++++++-
 .../joda/time/TestMutableDateTime_Sets.java   |  47 +++++-
 4 files changed, 219 insertions(+), 15 deletions(-)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 64b87dcaf..0cad3156a 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -43,6 +43,8 @@ Semantic compatible - Yes, except
 - DateTimeField duration fields have been fixed
   For example, yearOfEra() now has a range of eras() rather than null
   The DurationField instances now compare using equals() correctly
+- MutableDateTime.add(DateTimeFieldType,int), addDays(int) and friends [#77]
+  Adding zero will no longer change the offset during DST overlap in autumn/fall
 
 
 Deprecations since 2.3
@@ -67,6 +69,10 @@ Bug fixes since 2.3
   Validation in this method was not as thorough as that in the constructor
   This allowed invalid partials to be created
 
+- MutableDateTime.add(DateTimeFieldType,int), addDays(int) and friends [#77]
+  Adding zero to a MutableDateTime used to change the offset during DST overlap in autumn/fall
+  This is now fixed to not change the offset
+
 - Better Javadoc for parsing of numbers in format patterns [#60]
 
 - Remove uncaughtException calls [#59]
diff --git a/src/main/java/org/joda/time/MutableDateTime.java b/src/main/java/org/joda/time/MutableDateTime.java
index 237b25604..9aa8602ac 100644
--- a/src/main/java/org/joda/time/MutableDateTime.java
+++ b/src/main/java/org/joda/time/MutableDateTime.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2010 Stephen Colebourne
+ *  Copyright 2001-2013 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -470,7 +470,6 @@ public void setMillis(long instant) {
                 instant = iRoundingField.roundHalfEven(instant);
                 break;
         }
-
         super.setMillis(instant);
     }
 
@@ -637,7 +636,9 @@ public void add(DurationFieldType type, int amount) {
         if (type == null) {
             throw new IllegalArgumentException("Field must not be null");
         }
-        setMillis(type.getField(getChronology()).add(getMillis(), amount));
+        if (amount != 0) {
+            setMillis(type.getField(getChronology()).add(getMillis(), amount));
+        }
     }
 
     //-----------------------------------------------------------------------
@@ -658,7 +659,9 @@ public void setYear(final int year) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addYears(final int years) {
-        setMillis(getChronology().years().add(getMillis(), years));
+        if (years != 0) {
+            setMillis(getChronology().years().add(getMillis(), years));
+        }
     }
 
     //-----------------------------------------------------------------------
@@ -679,7 +682,9 @@ public void setWeekyear(final int weekyear) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addWeekyears(final int weekyears) {
-        setMillis(getChronology().weekyears().add(getMillis(), weekyears));
+        if (weekyears != 0) {
+            setMillis(getChronology().weekyears().add(getMillis(), weekyears));
+        }
     }
 
     //-----------------------------------------------------------------------
@@ -700,7 +705,9 @@ public void setMonthOfYear(final int monthOfYear) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addMonths(final int months) {
-        setMillis(getChronology().months().add(getMillis(), months));
+        if (months != 0) {
+            setMillis(getChronology().months().add(getMillis(), months));
+        }
     }
 
     //-----------------------------------------------------------------------
@@ -721,7 +728,9 @@ public void setWeekOfWeekyear(final int weekOfWeekyear) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addWeeks(final int weeks) {
-        setMillis(getChronology().weeks().add(getMillis(), weeks));
+        if (weeks != 0) {
+            setMillis(getChronology().weeks().add(getMillis(), weeks));
+        }
     }
 
     //-----------------------------------------------------------------------
@@ -762,7 +771,9 @@ public void setDayOfWeek(final int dayOfWeek) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addDays(final int days) {
-        setMillis(getChronology().days().add(getMillis(), days));
+        if (days != 0) {
+            setMillis(getChronology().days().add(getMillis(), days));
+        }
     }
 
     //-----------------------------------------------------------------------
@@ -783,7 +794,9 @@ public void setHourOfDay(final int hourOfDay) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addHours(final int hours) {
-        setMillis(getChronology().hours().add(getMillis(), hours));
+        if (hours != 0) {
+            setMillis(getChronology().hours().add(getMillis(), hours));
+        }
     }
     
     //-----------------------------------------------------------------------
@@ -814,7 +827,9 @@ public void setMinuteOfHour(final int minuteOfHour) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addMinutes(final int minutes) {
-        setMillis(getChronology().minutes().add(getMillis(), minutes));
+        if (minutes != 0) {
+            setMillis(getChronology().minutes().add(getMillis(), minutes));
+        }
     }
 
     //-----------------------------------------------------------------------
@@ -845,7 +860,9 @@ public void setSecondOfMinute(final int secondOfMinute) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addSeconds(final int seconds) {
-        setMillis(getChronology().seconds().add(getMillis(), seconds));
+        if (seconds != 0) {
+            setMillis(getChronology().seconds().add(getMillis(), seconds));
+        }
     }
 
     //-----------------------------------------------------------------------
@@ -878,7 +895,9 @@ public void setMillisOfSecond(final int millisOfSecond) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addMillis(final int millis) {
-        setMillis(getChronology().millis().add(getMillis(), millis));
+        if (millis != 0) {
+            setMillis(getChronology().millis().add(getMillis(), millis));
+        }
     }
 
     //-----------------------------------------------------------------------
diff --git a/src/test/java/org/joda/time/TestMutableDateTime_Adds.java b/src/test/java/org/joda/time/TestMutableDateTime_Adds.java
index a10e75ddf..97228fc6d 100644
--- a/src/test/java/org/joda/time/TestMutableDateTime_Adds.java
+++ b/src/test/java/org/joda/time/TestMutableDateTime_Adds.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2005 Stephen Colebourne
+ *  Copyright 2001-2013 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -32,7 +32,6 @@
     // Test in 2002/03 as time zones are more well known
     // (before the late 90's they were all over the place)
 
-    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");
     private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");
     
     long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 
@@ -173,6 +172,21 @@ public void testAdd_DurationFieldType_int1() {
         assertEquals(2010, test.getYear());
     }
 
+    public void testAdd_DurationFieldType_int_dstOverlapSummer_addZero() {
+        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin"));
+        assertEquals("2011-10-30T02:30:00.000+02:00", test.toString());
+        test.add(DurationFieldType.years(), 0);
+        assertEquals("2011-10-30T02:30:00.000+02:00", test.toString());
+    }
+
+    public void testAdd_DurationFieldType_int_dstOverlapWinter_addZero() {
+        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin"));
+        test.addHours(1);
+        assertEquals("2011-10-30T02:30:00.000+01:00", test.toString());
+        test.add(DurationFieldType.years(), 0);
+        assertEquals("2011-10-30T02:30:00.000+01:00", test.toString());
+    }
+
     public void testAdd_DurationFieldType_int2() {
         MutableDateTime test = new MutableDateTime(TEST_TIME1);
         try {
@@ -198,6 +212,21 @@ public void testAddYears_int1() {
         assertEquals("2010-06-09T05:06:07.008+01:00", test.toString());
     }
 
+    public void testAddYears_int_dstOverlapSummer_addZero() {
+        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin"));
+        assertEquals("2011-10-30T02:30:00.000+02:00", test.toString());
+        test.addYears(0);
+        assertEquals("2011-10-30T02:30:00.000+02:00", test.toString());
+    }
+
+    public void testAddYears_int_dstOverlapWinter_addZero() {
+        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin"));
+        test.addHours(1);
+        assertEquals("2011-10-30T02:30:00.000+01:00", test.toString());
+        test.addYears(0);
+        assertEquals("2011-10-30T02:30:00.000+01:00", test.toString());
+    }
+
     //-----------------------------------------------------------------------
     public void testAddMonths_int1() {
         MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);
@@ -205,6 +234,21 @@ public void testAddMonths_int1() {
         assertEquals("2002-12-09T05:06:07.008Z", test.toString());
     }
 
+    public void testAddMonths_int_dstOverlapSummer_addZero() {
+        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin"));
+        assertEquals("2011-10-30T02:30:00.000+02:00", test.toString());
+        test.addMonths(0);
+        assertEquals("2011-10-30T02:30:00.000+02:00", test.toString());
+    }
+
+    public void testAddMonths_int_dstOverlapWinter_addZero() {
+        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin"));
+        test.addHours(1);
+        assertEquals("2011-10-30T02:30:00.000+01:00", test.toString());
+        test.addMonths(0);
+        assertEquals("2011-10-30T02:30:00.000+01:00", test.toString());
+    }
+
     //-----------------------------------------------------------------------
     public void testAddDays_int1() {
         MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);
@@ -212,6 +256,21 @@ public void testAddDays_int1() {
         assertEquals("2002-06-26T05:06:07.008+01:00", test.toString());
     }
 
+    public void testAddDays_int_dstOverlapSummer_addZero() {
+        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin"));
+        assertEquals("2011-10-30T02:30:00.000+02:00", test.toString());
+        test.addDays(0);
+        assertEquals("2011-10-30T02:30:00.000+02:00", test.toString());
+    }
+
+    public void testAddDays_int_dstOverlapWinter_addZero() {
+        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin"));
+        test.addHours(1);
+        assertEquals("2011-10-30T02:30:00.000+01:00", test.toString());
+        test.addDays(0);
+        assertEquals("2011-10-30T02:30:00.000+01:00", test.toString());
+    }
+
     //-----------------------------------------------------------------------
     public void testAddWeekyears_int1() {
         MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);
@@ -226,6 +285,21 @@ public void testAddWeeks_int1() {
         assertEquals("2002-01-13T05:06:07.008Z", test.toString());
     }
 
+    public void testAddWeeks_int_dstOverlapSummer_addZero() {
+        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin"));
+        assertEquals("2011-10-30T02:30:00.000+02:00", test.toString());
+        test.addWeeks(0);
+        assertEquals("2011-10-30T02:30:00.000+02:00", test.toString());
+    }
+
+    public void testAddWeeks_int_dstOverlapWinter_addZero() {
+        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin"));
+        test.addHours(1);
+        assertEquals("2011-10-30T02:30:00.000+01:00", test.toString());
+        test.addWeeks(0);
+        assertEquals("2011-10-30T02:30:00.000+01:00", test.toString());
+    }
+
     //-----------------------------------------------------------------------
     public void testAddHours_int1() {
         MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);
@@ -233,6 +307,21 @@ public void testAddHours_int1() {
         assertEquals("2002-06-09T18:06:07.008+01:00", test.toString());
     }
 
+    public void testAddHours_int_dstOverlapSummer_addZero() {
+        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin"));
+        assertEquals("2011-10-30T02:30:00.000+02:00", test.toString());
+        test.addHours(0);
+        assertEquals("2011-10-30T02:30:00.000+02:00", test.toString());
+    }
+
+    public void testAddHours_int_dstOverlapWinter_addZero() {
+        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin"));
+        test.addHours(1);
+        assertEquals("2011-10-30T02:30:00.000+01:00", test.toString());
+        test.addHours(0);
+        assertEquals("2011-10-30T02:30:00.000+01:00", test.toString());
+    }
+
     //-----------------------------------------------------------------------
     public void testAddMinutes_int1() {
         MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);
@@ -240,6 +329,21 @@ public void testAddMinutes_int1() {
         assertEquals("2002-06-09T05:19:07.008+01:00", test.toString());
     }
 
+    public void testAddMinutes_int_dstOverlapSummer_addZero() {
+        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin"));
+        assertEquals("2011-10-30T02:30:00.000+02:00", test.toString());
+        test.addMinutes(0);
+        assertEquals("2011-10-30T02:30:00.000+02:00", test.toString());
+    }
+
+    public void testAddMinutes_int_dstOverlapWinter_addZero() {
+        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin"));
+        test.addHours(1);
+        assertEquals("2011-10-30T02:30:00.000+01:00", test.toString());
+        test.addMinutes(0);
+        assertEquals("2011-10-30T02:30:00.000+01:00", test.toString());
+    }
+
     //-----------------------------------------------------------------------
     public void testAddSeconds_int1() {
         MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);
@@ -247,6 +351,21 @@ public void testAddSeconds_int1() {
         assertEquals("2002-06-09T05:06:20.008+01:00", test.toString());
     }
 
+    public void testAddSeconds_int_dstOverlapSummer_addZero() {
+        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin"));
+        assertEquals("2011-10-30T02:30:00.000+02:00", test.toString());
+        test.addSeconds(0);
+        assertEquals("2011-10-30T02:30:00.000+02:00", test.toString());
+    }
+
+    public void testAddSeconds_int_dstOverlapWinter_addZero() {
+        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin"));
+        test.addHours(1);
+        assertEquals("2011-10-30T02:30:00.000+01:00", test.toString());
+        test.addSeconds(0);
+        assertEquals("2011-10-30T02:30:00.000+01:00", test.toString());
+    }
+
     //-----------------------------------------------------------------------
     public void testAddMillis_int1() {
         MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);
@@ -254,4 +373,19 @@ public void testAddMillis_int1() {
         assertEquals("2002-06-09T05:06:07.021+01:00", test.toString());
     }
 
+    public void testAddMillis_int_dstOverlapSummer_addZero() {
+        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin"));
+        assertEquals("2011-10-30T02:30:00.000+02:00", test.toString());
+        test.addMillis(0);
+        assertEquals("2011-10-30T02:30:00.000+02:00", test.toString());
+    }
+
+    public void testAddMillis_int_dstOverlapWinter_addZero() {
+        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin"));
+        test.addHours(1);
+        assertEquals("2011-10-30T02:30:00.000+01:00", test.toString());
+        test.addMillis(0);
+        assertEquals("2011-10-30T02:30:00.000+01:00", test.toString());
+    }
+
 }
diff --git a/src/test/java/org/joda/time/TestMutableDateTime_Sets.java b/src/test/java/org/joda/time/TestMutableDateTime_Sets.java
index 00e6abfb2..aab5bf38e 100644
--- a/src/test/java/org/joda/time/TestMutableDateTime_Sets.java
+++ b/src/test/java/org/joda/time/TestMutableDateTime_Sets.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2005 Stephen Colebourne
+ *  Copyright 2001-2013 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -427,6 +427,21 @@ public void testSetMonthOfYear_int1() {
         assertEquals("2002-12-09T05:06:07.008Z", test.toString());
     }
 
+    public void testSetMonthOfYear_int_dstOverlapSummer_addZero() {
+        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin"));
+        assertEquals("2011-10-30T02:30:00.000+02:00", test.toString());
+        test.setMonthOfYear(10);
+        assertEquals("2011-10-30T02:30:00.000+02:00", test.toString());
+    }
+
+    public void testSetMonthOfYear_int_dstOverlapWinter_addZero() {
+        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin"));
+        test.addHours(1);
+        assertEquals("2011-10-30T02:30:00.000+01:00", test.toString());
+        test.setMonthOfYear(10);
+        assertEquals("2011-10-30T02:30:00.000+01:00", test.toString());
+    }
+
     public void testSetMonthOfYear_int2() {
         MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);
         try {
@@ -452,6 +467,21 @@ public void testSetDayOfMonth_int2() {
         assertEquals("2002-06-09T05:06:07.008+01:00", test.toString());
     }
 
+    public void testSetDayOfMonth_int_dstOverlapSummer_addZero() {
+        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin"));
+        assertEquals("2011-10-30T02:30:00.000+02:00", test.toString());
+        test.setDayOfMonth(30);
+        assertEquals("2011-10-30T02:30:00.000+02:00", test.toString());
+    }
+
+    public void testSetDayOfMonth_int_dstOverlapWinter_addZero() {
+        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin"));
+        test.addHours(1);
+        assertEquals("2011-10-30T02:30:00.000+01:00", test.toString());
+        test.setDayOfMonth(30);
+        assertEquals("2011-10-30T02:30:00.000+01:00", test.toString());
+    }
+
     //-----------------------------------------------------------------------
     public void testSetDayOfYear_int1() {
         MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);
@@ -459,6 +489,21 @@ public void testSetDayOfYear_int1() {
         assertEquals("2002-01-03T05:06:07.008Z", test.toString());
     }
 
+    public void testSetDayOfYear_int_dstOverlapSummer_addZero() {
+        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin"));
+        assertEquals("2011-10-30T02:30:00.000+02:00", test.toString());
+        test.setDayOfYear(303);
+        assertEquals("2011-10-30T02:30:00.000+02:00", test.toString());
+    }
+
+    public void testSetDayOfYear_int_dstOverlapWinter_addZero() {
+        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID("Europe/Berlin"));
+        test.addHours(1);
+        assertEquals("2011-10-30T02:30:00.000+01:00", test.toString());
+        test.setDayOfYear(303);
+        assertEquals("2011-10-30T02:30:00.000+01:00", test.toString());
+    }
+
     public void testSetDayOfYear_int2() {
         MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);
         try {

From 8612f9e5b88c1bea933ef9ab1e431f5db3006b48 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Mon, 2 Dec 2013 19:14:41 +0000
Subject: [PATCH 38/86] Fix NPE in Partial.with()

Also ensure unsupported duration fields are compared properly
Fixes #93
---
 RELEASE-NOTES.txt                             |  2 +-
 src/main/java/org/joda/time/Partial.java      | 11 ++++++---
 .../time/field/UnsupportedDurationField.java  |  3 +++
 .../org/joda/time/TestPartial_Basics.java     | 24 +++++++++++++++++++
 4 files changed, 36 insertions(+), 4 deletions(-)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 0cad3156a..2a7f9b5e5 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -53,7 +53,7 @@ Deprecations since 2.3
 
 Bug fixes since 2.3
 -------------------
-- DateTimeField.getDurationField() / DateTimeField.getRangeDurationField() [#92]
+- DateTimeField.getDurationField() / DateTimeField.getRangeDurationField() [#92,#93]
   Previously some of the complex cases were wrong, notably around centuries and eras
   For example, yearOfEra() returned a range of null when it should be eras()
   A slew of tests were added and a variety of bugs fixed
diff --git a/src/main/java/org/joda/time/Partial.java b/src/main/java/org/joda/time/Partial.java
index 8e8e60348..3b84fdc6b 100644
--- a/src/main/java/org/joda/time/Partial.java
+++ b/src/main/java/org/joda/time/Partial.java
@@ -215,13 +215,14 @@ public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
             if (i > 0) {
                 int compare = lastUnitField.compareTo(loopUnitField);
-                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {
+                if (compare < 0) {
                     throw new IllegalArgumentException("Types array must be in order largest-smallest: " +
                             types[i - 1].getName() + " < " + loopType.getName());
                 } else if (compare == 0) {
                     if (types[i - 1].getRangeDurationType() == null) {
                         if (loopType.getRangeDurationType() == null) {
-                            throw new IllegalArgumentException("Types array must not contain duplicate: " + loopType.getName());
+                            throw new IllegalArgumentException("Types array must not contain duplicate: " +
+                                            types[i - 1].getName() + " and " + loopType.getName());
                         }
                     } else {
                         if (loopType.getRangeDurationType() == null) {
@@ -235,7 +236,8 @@ public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
                                     types[i - 1].getName() + " < " + loopType.getName());
                         }
                         if (lastRangeField.compareTo(loopRangeField) == 0) {
-                            throw new IllegalArgumentException("Types array must not contain duplicate: " + loopType.getName());
+                            throw new IllegalArgumentException("Types array must not contain duplicate: " +
+                                            types[i - 1].getName() + " and " + loopType.getName());
                         }
                     }
                 }
@@ -444,6 +446,9 @@ public Partial with(DateTimeFieldType fieldType, int value) {
                         if (compare > 0) {
                             break;
                         } else if (compare == 0) {
+                            if (fieldType.getRangeDurationType() == null) {
+                                break;
+                            }
                             DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                             DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                             if (rangeField.compareTo(loopRangeField) > 0) {
diff --git a/src/main/java/org/joda/time/field/UnsupportedDurationField.java b/src/main/java/org/joda/time/field/UnsupportedDurationField.java
index bf44e013a..7e0ce57ae 100644
--- a/src/main/java/org/joda/time/field/UnsupportedDurationField.java
+++ b/src/main/java/org/joda/time/field/UnsupportedDurationField.java
@@ -224,6 +224,9 @@ public long getUnitMillis() {
      * @return zero always
      */
     public int compareTo(DurationField durationField) {
+        if (durationField.isSupported()) {
+            return 1;
+        }
         return 0;
     }
 
diff --git a/src/test/java/org/joda/time/TestPartial_Basics.java b/src/test/java/org/joda/time/TestPartial_Basics.java
index ceaa1500d..5c154a380 100644
--- a/src/test/java/org/joda/time/TestPartial_Basics.java
+++ b/src/test/java/org/joda/time/TestPartial_Basics.java
@@ -448,6 +448,30 @@ public void testWith4() {
         assertSame(test, result);
     }
 
+    public void testWith_baseHasNoRange() {
+        Partial test = new Partial(DateTimeFieldType.year(), 1);
+        Partial result = test.with(DateTimeFieldType.hourOfDay(), 10);
+        assertEquals(2, result.size());
+        assertEquals(0, result.indexOf(DateTimeFieldType.year()));
+        assertEquals(1, result.indexOf(DateTimeFieldType.hourOfDay()));
+    }
+
+    public void testWith_argHasNoRange() {
+        Partial test = new Partial(DateTimeFieldType.hourOfDay(), 1);
+        Partial result = test.with(DateTimeFieldType.year(), 10);
+        assertEquals(2, result.size());
+        assertEquals(0, result.indexOf(DateTimeFieldType.year()));
+        assertEquals(1, result.indexOf(DateTimeFieldType.hourOfDay()));
+    }
+
+    public void testWith_baseAndArgHaveNoRange() {
+        Partial test = new Partial(DateTimeFieldType.year(), 1);
+        Partial result = test.with(DateTimeFieldType.era(), 1);
+        assertEquals(2, result.size());
+        assertEquals(0, result.indexOf(DateTimeFieldType.era()));
+        assertEquals(1, result.indexOf(DateTimeFieldType.year()));
+    }
+
     //-----------------------------------------------------------------------
     public void testWithout1() {
         Partial test = createHourMinPartial();

From 9a62b06be5d0df8e833ff8583398cca386608cac Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Mon, 2 Dec 2013 21:11:47 +0000
Subject: [PATCH 39/86] Fix NPE in Partial.with()

Also ensure unsupported duration fields are compared properly
Fixes #93
---
 src/main/java/org/joda/time/Partial.java              | 11 ++++++++++-
 .../org/joda/time/field/UnsupportedDurationField.java |  3 ---
 2 files changed, 10 insertions(+), 4 deletions(-)

diff --git a/src/main/java/org/joda/time/Partial.java b/src/main/java/org/joda/time/Partial.java
index 3b84fdc6b..6ff277183 100644
--- a/src/main/java/org/joda/time/Partial.java
+++ b/src/main/java/org/joda/time/Partial.java
@@ -214,11 +214,20 @@ public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
             DateTimeFieldType loopType = types[i];
             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
             if (i > 0) {
+                if (loopUnitField.isSupported() == false) {
+                    if (lastUnitField.isSupported()) {
+                        throw new IllegalArgumentException("Types array must be in order largest-smallest: " +
+                                        types[i - 1].getName() + " < " + loopType.getName());
+                    } else {
+                        throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " +
+                                        types[i - 1].getName() + " and " + loopType.getName());
+                    }
+                }
                 int compare = lastUnitField.compareTo(loopUnitField);
                 if (compare < 0) {
                     throw new IllegalArgumentException("Types array must be in order largest-smallest: " +
                             types[i - 1].getName() + " < " + loopType.getName());
-                } else if (compare == 0) {
+                } else if (compare == 0 && lastUnitField.equals(loopUnitField)) {
                     if (types[i - 1].getRangeDurationType() == null) {
                         if (loopType.getRangeDurationType() == null) {
                             throw new IllegalArgumentException("Types array must not contain duplicate: " +
diff --git a/src/main/java/org/joda/time/field/UnsupportedDurationField.java b/src/main/java/org/joda/time/field/UnsupportedDurationField.java
index 7e0ce57ae..bf44e013a 100644
--- a/src/main/java/org/joda/time/field/UnsupportedDurationField.java
+++ b/src/main/java/org/joda/time/field/UnsupportedDurationField.java
@@ -224,9 +224,6 @@ public long getUnitMillis() {
      * @return zero always
      */
     public int compareTo(DurationField durationField) {
-        if (durationField.isSupported()) {
-            return 1;
-        }
         return 0;
     }
 

From 4058d725e2b886e429233aa02bc45c3acf374471 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Wed, 4 Dec 2013 14:11:39 +0000
Subject: [PATCH 40/86] Avoid another NPE in Partial.with

Fixes #95
---
 RELEASE-NOTES.txt                        | 2 +-
 src/main/java/org/joda/time/Partial.java | 3 +++
 2 files changed, 4 insertions(+), 1 deletion(-)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 2a7f9b5e5..dc3c38117 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -53,7 +53,7 @@ Deprecations since 2.3
 
 Bug fixes since 2.3
 -------------------
-- DateTimeField.getDurationField() / DateTimeField.getRangeDurationField() [#92,#93]
+- DateTimeField.getDurationField() / DateTimeField.getRangeDurationField() [#92,#93,#95]
   Previously some of the complex cases were wrong, notably around centuries and eras
   For example, yearOfEra() returned a range of null when it should be eras()
   A slew of tests were added and a variety of bugs fixed
diff --git a/src/main/java/org/joda/time/Partial.java b/src/main/java/org/joda/time/Partial.java
index 6ff277183..6e29af9a7 100644
--- a/src/main/java/org/joda/time/Partial.java
+++ b/src/main/java/org/joda/time/Partial.java
@@ -458,6 +458,9 @@ public Partial with(DateTimeFieldType fieldType, int value) {
                             if (fieldType.getRangeDurationType() == null) {
                                 break;
                             }
+                            if (loopType.getRangeDurationType() == null) {
+                                continue;
+                            }
                             DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                             DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                             if (rangeField.compareTo(loopRangeField) > 0) {

From 39fff6f157f9ed92cdae32680129ceb74288eb0f Mon Sep 17 00:00:00 2001
From: Rowan Hill <rowan.hill@softwire.com>
Date: Tue, 10 Dec 2013 00:27:15 +0000
Subject: [PATCH 41/86] Tiny typo fixes

---
 src/main/java/org/joda/time/Partial.java               | 2 +-
 src/main/java/org/joda/time/format/DateTimeFormat.java | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/main/java/org/joda/time/Partial.java b/src/main/java/org/joda/time/Partial.java
index 6e29af9a7..cd4383bdc 100644
--- a/src/main/java/org/joda/time/Partial.java
+++ b/src/main/java/org/joda/time/Partial.java
@@ -369,7 +369,7 @@ public DateTimeFieldType getFieldType(int index) {
 
     //-----------------------------------------------------------------------
     /**
-     * Gets the value of the field at the specifed index.
+     * Gets the value of the field at the specified index.
      * 
      * @param index  the index
      * @return the value
diff --git a/src/main/java/org/joda/time/format/DateTimeFormat.java b/src/main/java/org/joda/time/format/DateTimeFormat.java
index 4558eb74d..3f117f4a2 100644
--- a/src/main/java/org/joda/time/format/DateTimeFormat.java
+++ b/src/main/java/org/joda/time/format/DateTimeFormat.java
@@ -159,7 +159,7 @@
         @Override
         protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {
             return size() > PATTERN_CACHE_SIZE;
-        };
+        }
     };
 
     /** Maps patterns to formatters, patterns don't vary by locale. */

From 8754b711247cf0dee21281f7c64306118cf70d61 Mon Sep 17 00:00:00 2001
From: Keith Amling <amling@palantir.com>
Date: Wed, 18 Dec 2013 16:32:32 -0800
Subject: [PATCH 42/86] Avoid contention in/on cParseCache.

---
 .../time/format/DateTimeFormatterBuilder.java | 78 +++++++++----------
 1 file changed, 39 insertions(+), 39 deletions(-)

diff --git a/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java b/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java
index 8f76f06e2..a74fe6709 100644
--- a/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java
+++ b/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java
@@ -15,9 +15,11 @@
  */
 package org.joda.time.format;
 
+import java.util.concurrent.ConcurrentHashMap;
 import java.io.IOException;
 import java.io.Writer;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
@@ -1746,7 +1748,7 @@ private int getTwoDigitYear(ReadablePartial partial) {
             implements DateTimePrinter, DateTimeParser {
 
         private static Map<Locale, Map<DateTimeFieldType, Object[]>> cParseCache =
-                    new HashMap<Locale, Map<DateTimeFieldType, Object[]>>();
+                    new ConcurrentHashMap<Locale, Map<DateTimeFieldType, Object[]>>();
         private final DateTimeFieldType iFieldType;
         private final boolean iShort;
 
@@ -1829,46 +1831,44 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
             // bug 1788282
             Set<String> validValues = null;
             int maxLength = 0;
-            synchronized (cParseCache) {
-                Map<DateTimeFieldType, Object[]> innerMap = cParseCache.get(locale);
-                if (innerMap == null) {
-                    innerMap = new HashMap<DateTimeFieldType, Object[]>();
-                    cParseCache.put(locale, innerMap);
+            Map<DateTimeFieldType, Object[]> innerMap = cParseCache.get(locale);
+            if (innerMap == null) {
+                innerMap = new ConcurrentHashMap<DateTimeFieldType, Object[]>();
+                cParseCache.put(locale, innerMap);
+            }
+            Object[] array = innerMap.get(iFieldType);
+            if (array == null) {
+                validValues = Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>(32));
+                MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC);
+                Property property = dt.property(iFieldType);
+                int min = property.getMinimumValueOverall();
+                int max = property.getMaximumValueOverall();
+                if (max - min > 32) {  // protect against invalid fields
+                    return ~position;
                 }
-                Object[] array = innerMap.get(iFieldType);
-                if (array == null) {
-                    validValues = new HashSet<String>(32);
-                    MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC);
-                    Property property = dt.property(iFieldType);
-                    int min = property.getMinimumValueOverall();
-                    int max = property.getMaximumValueOverall();
-                    if (max - min > 32) {  // protect against invalid fields
-                        return ~position;
-                    }
-                    maxLength = property.getMaximumTextLength(locale);
-                    for (int i = min; i <= max; i++) {
-                        property.set(i);
-                        validValues.add(property.getAsShortText(locale));
-                        validValues.add(property.getAsShortText(locale).toLowerCase(locale));
-                        validValues.add(property.getAsShortText(locale).toUpperCase(locale));
-                        validValues.add(property.getAsText(locale));
-                        validValues.add(property.getAsText(locale).toLowerCase(locale));
-                        validValues.add(property.getAsText(locale).toUpperCase(locale));
-                    }
-                    if ("en".equals(locale.getLanguage()) && iFieldType == DateTimeFieldType.era()) {
-                        // hack to support for parsing "BCE" and "CE" if the language is English
-                        validValues.add("BCE");
-                        validValues.add("bce");
-                        validValues.add("CE");
-                        validValues.add("ce");
-                        maxLength = 3;
-                    }
-                    array = new Object[] {validValues, Integer.valueOf(maxLength)};
-                    innerMap.put(iFieldType, array);
-                } else {
-                    validValues = (Set<String>) array[0];
-                    maxLength = ((Integer) array[1]).intValue();
+                maxLength = property.getMaximumTextLength(locale);
+                for (int i = min; i <= max; i++) {
+                    property.set(i);
+                    validValues.add(property.getAsShortText(locale));
+                    validValues.add(property.getAsShortText(locale).toLowerCase(locale));
+                    validValues.add(property.getAsShortText(locale).toUpperCase(locale));
+                    validValues.add(property.getAsText(locale));
+                    validValues.add(property.getAsText(locale).toLowerCase(locale));
+                    validValues.add(property.getAsText(locale).toUpperCase(locale));
                 }
+                if ("en".equals(locale.getLanguage()) && iFieldType == DateTimeFieldType.era()) {
+                    // hack to support for parsing "BCE" and "CE" if the language is English
+                    validValues.add("BCE");
+                    validValues.add("bce");
+                    validValues.add("CE");
+                    validValues.add("ce");
+                    maxLength = 3;
+                }
+                array = new Object[] {validValues, Integer.valueOf(maxLength)};
+                innerMap.put(iFieldType, array);
+            } else {
+                validValues = (Set<String>) array[0];
+                maxLength = ((Integer) array[1]).intValue();
             }
             // match the longest string first using our knowledge of the max length
             int limit = Math.min(text.length(), position + maxLength);

From a25bf149a001e4b2d69e01f03376e698c760fc02 Mon Sep 17 00:00:00 2001
From: Jorge Perez Alvarez <jperezalv@gmail.com>
Date: Tue, 31 Dec 2013 13:34:49 +0100
Subject: [PATCH 43/86] ZoneInfoProvider.getZone(String) throws a
 ClassCastException in some Android implementations of the String class.

String.equals(SoftReference<?>) throws a ClassCastException. Reordering the code checks first the instanceof case and only then calls the .equals() method with an object of a different type.
---
 src/main/java/org/joda/time/tz/ZoneInfoProvider.java | 8 +++-----
 1 file changed, 3 insertions(+), 5 deletions(-)

diff --git a/src/main/java/org/joda/time/tz/ZoneInfoProvider.java b/src/main/java/org/joda/time/tz/ZoneInfoProvider.java
index 455880887..3e0e980e7 100644
--- a/src/main/java/org/joda/time/tz/ZoneInfoProvider.java
+++ b/src/main/java/org/joda/time/tz/ZoneInfoProvider.java
@@ -141,11 +141,6 @@ public DateTimeZone getZone(String id) {
             return null;
         }
 
-        if (id.equals(obj)) {
-            // Load zone data for the first time.
-            return loadZoneData(id);
-        }
-
         if (obj instanceof SoftReference<?>) {
             @SuppressWarnings("unchecked")
             SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj;
@@ -155,6 +150,9 @@ public DateTimeZone getZone(String id) {
             }
             // Reference cleared; load data again.
             return loadZoneData(id);
+        } else if (id.equals(obj)) {
+            // Load zone data for the first time.
+            return loadZoneData(id);
         }
 
         // If this point is reached, mapping must link to another.

From 2789373df58beac42b26425ace5f4728df842f20 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 19 Jan 2014 14:28:54 +0000
Subject: [PATCH 44/86] Fixup pull request

---
 pom.xml | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/pom.xml b/pom.xml
index 15ded7e4a..bd030c89e 100644
--- a/pom.xml
+++ b/pom.xml
@@ -93,6 +93,10 @@
       <name>haguenau</name>
       <url>https://github.com/haguenau</url>
     </contributor>
+    <contributor>
+      <name>Rowan Hill</name>
+      <url>https://github.com/rowanhill</url>
+    </contributor>
     <contributor>
       <name>Vsevolod Ivanov</name>
       <url>https://github.com/seva-ask</url>

From bd8522f7976a256ffe0f85203fb1e6fe60c22b6b Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 19 Jan 2014 14:28:54 +0000
Subject: [PATCH 45/86] Fix DataNuclues related link

Fixes JodaOrg/jodaorg.github.io#1
---
 src/site/xdoc/related.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/site/xdoc/related.xml b/src/site/xdoc/related.xml
index 647d57cf4..bdef4477f 100644
--- a/src/site/xdoc/related.xml
+++ b/src/site/xdoc/related.xml
@@ -28,7 +28,7 @@ Support for working and non-working days, plus how to calculate and resolve holi
 Provides classes to handle calculation of holidays.</li>
 <li><a href="http://code.google.com/p/google-rfc-2445/">Recurrance (RFC 2445)</a>
 Support for the RFC2445 recurrence specification, as found in iCal.</li>
-<li><a href="http://www.datanucleus.org/plugins/store.types.jodatime.html">DataNucleus support</a>
+<li><a href="https://github.com/datanucleus/datanucleus-jodatime">DataNucleus support</a>
 A library providing persistence via the DataNucleus platform.</li>
 <li><a href="http://blog.bdoughan.com/2011/05/jaxb-and-joda-time-dates-and-times.html">JAXB</a>
 Notes on Joda-Time and JAXB.</li>

From e46064ee90fca28a92c0f51f10c94b40bc8af2d2 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 19 Jan 2014 15:06:37 +0000
Subject: [PATCH 46/86] DateTime/MutableDateTime constructors taking millis now
 validate

Previously, new DateTime(Long.MAX_VALUE) would be accepted, now it will be rejected
This ensures that the maximum/minimum year are respected
Fixes #100
---
 RELEASE-NOTES.txt                             |  4 +++
 .../java/org/joda/time/base/BaseDateTime.java |  4 +++
 .../joda/time/TestDateTime_Constructors.java  | 30 +++++++++++++++++++
 3 files changed, 38 insertions(+)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index dc3c38117..581a20b6d 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -73,6 +73,10 @@ Bug fixes since 2.3
   Adding zero to a MutableDateTime used to change the offset during DST overlap in autumn/fall
   This is now fixed to not change the offset
 
+- DateTime/MutableDateTime constructors taking millis now validate [#100]
+  Previously, new DateTime(Long.MAX_VALUE) would be accepted, now it will be rejected
+  This ensures that the maximum/minimum year are respected
+
 - Better Javadoc for parsing of numbers in format patterns [#60]
 
 - Remove uncaughtException calls [#59]
diff --git a/src/main/java/org/joda/time/base/BaseDateTime.java b/src/main/java/org/joda/time/base/BaseDateTime.java
index ccb73cfbc..4b00e77cb 100644
--- a/src/main/java/org/joda/time/base/BaseDateTime.java
+++ b/src/main/java/org/joda/time/base/BaseDateTime.java
@@ -124,6 +124,10 @@ public BaseDateTime(long instant, Chronology chronology) {
         super();
         iChronology = checkChronology(chronology);
         iMillis = checkInstant(instant, iChronology);
+        // validate not over maximum
+        if (iChronology.year().isSupported()) {
+            iChronology.year().set(iMillis, iChronology.year().get(iMillis));
+        }
     }
 
     //-----------------------------------------------------------------------
diff --git a/src/test/java/org/joda/time/TestDateTime_Constructors.java b/src/test/java/org/joda/time/TestDateTime_Constructors.java
index 72ffdab09..ffff26f22 100644
--- a/src/test/java/org/joda/time/TestDateTime_Constructors.java
+++ b/src/test/java/org/joda/time/TestDateTime_Constructors.java
@@ -228,6 +228,36 @@ public void testConstructor_long2() throws Throwable {
         assertEquals(TEST_TIME2, test.getMillis());
     }
 
+    /**
+     * Test constructor (long)
+     */
+    public void testConstructor_long_max() throws Throwable {
+        DateTime dt = new DateTime(292278993, 12, 31, 23, 59, 59, 999);
+        DateTime test = new DateTime(dt.getMillis());
+        assertEquals(dt, test);
+        try {
+            new DateTime(dt.getMillis() + 1);
+            fail();
+        } catch (IllegalFieldValueException ex) {
+            // expected
+        }
+    }
+
+    /**
+     * Test constructor (long)
+     */
+    public void testConstructor_long_min() throws Throwable {
+        DateTime dt = new DateTime(-292275054, 1, 1, 0, 0);
+        DateTime test = new DateTime(dt.getMillis());
+        assertEquals(dt, test);
+        try {
+            new DateTime(dt.getMillis() - 1);
+            fail();
+        } catch (IllegalFieldValueException ex) {
+            // expected
+        }
+    }
+
     /**
      * Test constructor (long, DateTimeZone)
      */

From 5a7bd39f3044bf1c1678d85744c12315e3441967 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Mon, 20 Jan 2014 17:24:06 +0000
Subject: [PATCH 47/86] Fixup pull request

---
 RELEASE-NOTES.txt | 4 ++++
 pom.xml           | 4 ++++
 2 files changed, 8 insertions(+)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 581a20b6d..7aaa8ded7 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -77,6 +77,10 @@ Bug fixes since 2.3
   Previously, new DateTime(Long.MAX_VALUE) would be accepted, now it will be rejected
   This ensures that the maximum/minimum year are respected
 
+- Handle broken Android implementations better [#103]
+  Apparently some Android implementations throw ClassCastException when comparing different types
+  Thats dumb and wrong but the change to handle it is harmless
+
 - Better Javadoc for parsing of numbers in format patterns [#60]
 
 - Remove uncaughtException calls [#59]
diff --git a/pom.xml b/pom.xml
index bd030c89e..a2096553a 100644
--- a/pom.xml
+++ b/pom.xml
@@ -142,6 +142,10 @@
     <contributor>
       <name>Julen Parra</name>
     </contributor>
+    <contributor>
+      <name>Jorge Perez</name>
+      <url>https://github.com/jperezalv</url>
+    </contributor>
     <contributor>
       <name>Michael Plump</name>
     </contributor>

From 34c0780202dde5d65e346ffe9f02d890352a9c37 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Mon, 20 Jan 2014 17:55:53 +0000
Subject: [PATCH 48/86] Ensure isLeap() returns correct result for day fields

day-of-month and day-of-year should report leap days
Fixes #110
---
 RELEASE-NOTES.txt                             |  3 +++
 .../org/joda/time/chrono/BasicChronology.java | 12 +++++++++-
 .../chrono/BasicDayOfMonthDateTimeField.java  |  7 +++++-
 .../chrono/BasicDayOfYearDateTimeField.java   |  7 +++++-
 .../joda/time/chrono/BasicGJChronology.java   |  7 +++++-
 .../joda/time/chrono/CopticChronology.java    |  8 ++++++-
 .../joda/time/chrono/EthiopicChronology.java  |  8 ++++++-
 .../time/chrono/TestCopticChronology.java     | 22 +++++++++++++++++--
 .../time/chrono/TestEthiopicChronology.java   | 20 ++++++++++++++++-
 .../joda/time/chrono/TestGJChronology.java    | 21 +++++++++++++++++-
 .../time/chrono/TestGregorianChronology.java  | 21 +++++++++++++++++-
 .../joda/time/chrono/TestISOChronology.java   | 21 +++++++++++++++++-
 .../time/chrono/TestJulianChronology.java     | 22 ++++++++++++++++++-
 .../time/chrono/gj/TestGJDayOfMonthField.java |  7 +++++-
 .../time/chrono/gj/TestGJDayOfYearField.java  |  7 +++++-
 15 files changed, 178 insertions(+), 15 deletions(-)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 7aaa8ded7..150eea0ca 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -77,6 +77,9 @@ Bug fixes since 2.3
   Previously, new DateTime(Long.MAX_VALUE) would be accepted, now it will be rejected
   This ensures that the maximum/minimum year are respected
 
+- Ensure isLeap() returns correct result for day fields [#110]
+  Day-of-month and day-of-year fields should report leap days
+
 - Handle broken Android implementations better [#103]
   Apparently some Android implementations throw ClassCastException when comparing different types
   Thats dumb and wrong but the change to handle it is harmless
diff --git a/src/main/java/org/joda/time/chrono/BasicChronology.java b/src/main/java/org/joda/time/chrono/BasicChronology.java
index 63f394aee..d3442485f 100644
--- a/src/main/java/org/joda/time/chrono/BasicChronology.java
+++ b/src/main/java/org/joda/time/chrono/BasicChronology.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2013 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -631,6 +631,16 @@ long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) {
      */
     abstract boolean isLeapYear(int year);
 
+    /**
+     * Is the specified instant a leap day?
+     * 
+     * @param instant  the instant to test
+     * @return true if leap, default is false
+     */
+    boolean isLeapDay(long instant) {
+        return false;
+    }
+
     /**
      * Gets the number of days in the specified month and year.
      * 
diff --git a/src/main/java/org/joda/time/chrono/BasicDayOfMonthDateTimeField.java b/src/main/java/org/joda/time/chrono/BasicDayOfMonthDateTimeField.java
index 29a1e4e21..415aaab6d 100644
--- a/src/main/java/org/joda/time/chrono/BasicDayOfMonthDateTimeField.java
+++ b/src/main/java/org/joda/time/chrono/BasicDayOfMonthDateTimeField.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2013 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -97,6 +97,11 @@ protected int getMaximumValueForSet(long instant, int value) {
         return iChronology.getDaysInMonthMaxForSet(instant, value);
     }
 
+    @Override
+    public boolean isLeap(long instant) {
+        return iChronology.isLeapDay(instant);
+    }
+
     /**
      * Serialization singleton
      */
diff --git a/src/main/java/org/joda/time/chrono/BasicDayOfYearDateTimeField.java b/src/main/java/org/joda/time/chrono/BasicDayOfYearDateTimeField.java
index 2315ca2c6..814b74088 100644
--- a/src/main/java/org/joda/time/chrono/BasicDayOfYearDateTimeField.java
+++ b/src/main/java/org/joda/time/chrono/BasicDayOfYearDateTimeField.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2013 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -94,6 +94,11 @@ protected int getMaximumValueForSet(long instant, int value) {
         return (value > maxLessOne || value < 1) ? getMaximumValue(instant) : maxLessOne;
     }
 
+    @Override
+    public boolean isLeap(long instant) {
+        return iChronology.isLeapDay(instant);
+    }
+
     /**
      * Serialization singleton
      */
diff --git a/src/main/java/org/joda/time/chrono/BasicGJChronology.java b/src/main/java/org/joda/time/chrono/BasicGJChronology.java
index 5b651e5d9..e3636c624 100644
--- a/src/main/java/org/joda/time/chrono/BasicGJChronology.java
+++ b/src/main/java/org/joda/time/chrono/BasicGJChronology.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2005 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -76,6 +76,11 @@
     }
 
     //-----------------------------------------------------------------------
+    @Override
+    boolean isLeapDay(long instant) {
+        return dayOfMonth().get(instant) == 29 && monthOfYear().isLeap(instant);
+    }
+
     int getMonthOfYear(long millis, int year) {
         // Perform a binary search to get the month. To make it go even faster,
         // compare using ints instead of longs. The number of milliseconds per
diff --git a/src/main/java/org/joda/time/chrono/CopticChronology.java b/src/main/java/org/joda/time/chrono/CopticChronology.java
index 7e6cfc473..1d6ee6fe5 100644
--- a/src/main/java/org/joda/time/chrono/CopticChronology.java
+++ b/src/main/java/org/joda/time/chrono/CopticChronology.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2009 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -200,6 +200,12 @@ public Chronology withZone(DateTimeZone zone) {
         return getInstance(zone);
     }
 
+    //-----------------------------------------------------------------------
+    @Override
+    boolean isLeapDay(long instant) {
+        return dayOfMonth().get(instant) == 6 && monthOfYear().isLeap(instant);
+    }
+
     //-----------------------------------------------------------------------
     long calculateFirstDayOfYearMillis(int year) {
         // Java epoch is 1970-01-01 Gregorian which is 1686-04-23 Coptic.
diff --git a/src/main/java/org/joda/time/chrono/EthiopicChronology.java b/src/main/java/org/joda/time/chrono/EthiopicChronology.java
index 44b8edf3e..22ccd34d8 100644
--- a/src/main/java/org/joda/time/chrono/EthiopicChronology.java
+++ b/src/main/java/org/joda/time/chrono/EthiopicChronology.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2009 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -198,6 +198,12 @@ public Chronology withZone(DateTimeZone zone) {
         return getInstance(zone);
     }
 
+    //-----------------------------------------------------------------------
+    @Override
+    boolean isLeapDay(long instant) {
+        return dayOfMonth().get(instant) == 6 && monthOfYear().isLeap(instant);
+    }
+
     //-----------------------------------------------------------------------
     long calculateFirstDayOfYearMillis(int year) {
         // Java epoch is 1970-01-01 Gregorian which is 1962-04-23 Ethiopic.
diff --git a/src/test/java/org/joda/time/chrono/TestCopticChronology.java b/src/test/java/org/joda/time/chrono/TestCopticChronology.java
index f3c6c3099..008393a03 100644
--- a/src/test/java/org/joda/time/chrono/TestCopticChronology.java
+++ b/src/test/java/org/joda/time/chrono/TestCopticChronology.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2013 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -23,13 +23,13 @@
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTime;
+import org.joda.time.DateTime.Property;
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeField;
 import org.joda.time.DateTimeUtils;
 import org.joda.time.DateTimeZone;
 import org.joda.time.DurationField;
 import org.joda.time.DurationFieldType;
-import org.joda.time.DateTime.Property;
 
 /**
  * This class is a Junit unit test for CopticChronology.
@@ -576,4 +576,22 @@ public void testDurationMonth() {
         assertEquals(dt01.getMillis(), fld.add(dt11.getMillis(), 3L));
     }
 
+    public void testLeap_5_13() {
+        Chronology chrono = CopticChronology.getInstance();
+        DateTime dt = new DateTime(3, 13, 5, 0, 0, chrono);
+        assertEquals(true, dt.year().isLeap());
+        assertEquals(true, dt.monthOfYear().isLeap());
+        assertEquals(false, dt.dayOfMonth().isLeap());
+        assertEquals(false, dt.dayOfYear().isLeap());
+    }
+
+    public void testLeap_6_13() {
+        Chronology chrono = CopticChronology.getInstance();
+        DateTime dt = new DateTime(3, 13, 6, 0, 0, chrono);
+        assertEquals(true, dt.year().isLeap());
+        assertEquals(true, dt.monthOfYear().isLeap());
+        assertEquals(true, dt.dayOfMonth().isLeap());
+        assertEquals(true, dt.dayOfYear().isLeap());
+    }
+
 }
diff --git a/src/test/java/org/joda/time/chrono/TestEthiopicChronology.java b/src/test/java/org/joda/time/chrono/TestEthiopicChronology.java
index 814d02b20..f7ee2b2e0 100644
--- a/src/test/java/org/joda/time/chrono/TestEthiopicChronology.java
+++ b/src/test/java/org/joda/time/chrono/TestEthiopicChronology.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2013 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -576,4 +576,22 @@ public void testDurationMonth() {
         assertEquals(dt01.getMillis(), fld.add(dt11.getMillis(), 3L));
     }
 
+    public void testLeap_5_13() {
+        Chronology chrono = EthiopicChronology.getInstance();
+        DateTime dt = new DateTime(3, 13, 5, 0, 0, chrono);
+        assertEquals(true, dt.year().isLeap());
+        assertEquals(true, dt.monthOfYear().isLeap());
+        assertEquals(false, dt.dayOfMonth().isLeap());
+        assertEquals(false, dt.dayOfYear().isLeap());
+    }
+
+    public void testLeap_6_13() {
+        Chronology chrono = EthiopicChronology.getInstance();
+        DateTime dt = new DateTime(3, 13, 6, 0, 0, chrono);
+        assertEquals(true, dt.year().isLeap());
+        assertEquals(true, dt.monthOfYear().isLeap());
+        assertEquals(true, dt.dayOfMonth().isLeap());
+        assertEquals(true, dt.dayOfYear().isLeap());
+    }
+
 }
diff --git a/src/test/java/org/joda/time/chrono/TestGJChronology.java b/src/test/java/org/joda/time/chrono/TestGJChronology.java
index de30994c9..9892af6f6 100644
--- a/src/test/java/org/joda/time/chrono/TestGJChronology.java
+++ b/src/test/java/org/joda/time/chrono/TestGJChronology.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2013 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -21,6 +21,7 @@
 import junit.framework.TestCase;
 import junit.framework.TestSuite;
 
+import org.joda.time.Chronology;
 import org.joda.time.DateMidnight;
 import org.joda.time.DateTime;
 import org.joda.time.DateTimeConstants;
@@ -541,4 +542,22 @@ public void testLeapYearRulesConstructionInvalid() {
         }
     }
 
+    public void testLeap_28feb() {
+        Chronology chrono = GJChronology.getInstance();
+        DateTime dt = new DateTime(2012, 2, 28, 0, 0, chrono);
+        assertEquals(true, dt.year().isLeap());
+        assertEquals(true, dt.monthOfYear().isLeap());
+        assertEquals(false, dt.dayOfMonth().isLeap());
+        assertEquals(false, dt.dayOfYear().isLeap());
+    }
+
+    public void testLeap_29feb() {
+        Chronology chrono = GJChronology.getInstance();
+        DateTime dt = new DateTime(2012, 2, 29, 0, 0, chrono);
+        assertEquals(true, dt.year().isLeap());
+        assertEquals(true, dt.monthOfYear().isLeap());
+        assertEquals(true, dt.dayOfMonth().isLeap());
+        assertEquals(true, dt.dayOfYear().isLeap());
+    }
+
 }
diff --git a/src/test/java/org/joda/time/chrono/TestGregorianChronology.java b/src/test/java/org/joda/time/chrono/TestGregorianChronology.java
index 098b08af2..31fd50432 100644
--- a/src/test/java/org/joda/time/chrono/TestGregorianChronology.java
+++ b/src/test/java/org/joda/time/chrono/TestGregorianChronology.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2013 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -23,6 +23,7 @@
 
 import org.joda.time.Chronology;
 import org.joda.time.DateMidnight;
+import org.joda.time.DateTime;
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeUtils;
 import org.joda.time.DateTimeZone;
@@ -309,4 +310,22 @@ public void testMaximumValue() {
         assertEquals(28, chrono.dayOfMonth().getMaximumValue(dm1.getMillis()));
     }
 
+    public void testLeap_28feb() {
+        Chronology chrono = GregorianChronology.getInstance();
+        DateTime dt = new DateTime(2012, 2, 28, 0, 0, chrono);
+        assertEquals(true, dt.year().isLeap());
+        assertEquals(true, dt.monthOfYear().isLeap());
+        assertEquals(false, dt.dayOfMonth().isLeap());
+        assertEquals(false, dt.dayOfYear().isLeap());
+    }
+
+    public void testLeap_29feb() {
+        Chronology chrono = GregorianChronology.getInstance();
+        DateTime dt = new DateTime(2012, 2, 29, 0, 0, chrono);
+        assertEquals(true, dt.year().isLeap());
+        assertEquals(true, dt.monthOfYear().isLeap());
+        assertEquals(true, dt.dayOfMonth().isLeap());
+        assertEquals(true, dt.dayOfYear().isLeap());
+    }
+
 }
diff --git a/src/test/java/org/joda/time/chrono/TestISOChronology.java b/src/test/java/org/joda/time/chrono/TestISOChronology.java
index e6b04bae1..886c0ce7f 100644
--- a/src/test/java/org/joda/time/chrono/TestISOChronology.java
+++ b/src/test/java/org/joda/time/chrono/TestISOChronology.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2013 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -21,6 +21,7 @@
 import junit.framework.TestCase;
 import junit.framework.TestSuite;
 
+import org.joda.time.Chronology;
 import org.joda.time.DateMidnight;
 import org.joda.time.DateTime;
 import org.joda.time.DateTimeConstants;
@@ -453,4 +454,22 @@ public void testMaximumValue() {
         }
     }
 
+    public void testLeap_28feb() {
+        Chronology chrono = ISOChronology.getInstance();
+        DateTime dt = new DateTime(2012, 2, 28, 0, 0, chrono);
+        assertEquals(true, dt.year().isLeap());
+        assertEquals(true, dt.monthOfYear().isLeap());
+        assertEquals(false, dt.dayOfMonth().isLeap());
+        assertEquals(false, dt.dayOfYear().isLeap());
+    }
+
+    public void testLeap_29feb() {
+        Chronology chrono = ISOChronology.getInstance();
+        DateTime dt = new DateTime(2012, 2, 29, 0, 0, chrono);
+        assertEquals(true, dt.year().isLeap());
+        assertEquals(true, dt.monthOfYear().isLeap());
+        assertEquals(true, dt.dayOfMonth().isLeap());
+        assertEquals(true, dt.dayOfYear().isLeap());
+    }
+
 }
diff --git a/src/test/java/org/joda/time/chrono/TestJulianChronology.java b/src/test/java/org/joda/time/chrono/TestJulianChronology.java
index 1f9479a1e..97f78a078 100644
--- a/src/test/java/org/joda/time/chrono/TestJulianChronology.java
+++ b/src/test/java/org/joda/time/chrono/TestJulianChronology.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2013 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -21,6 +21,8 @@
 import junit.framework.TestCase;
 import junit.framework.TestSuite;
 
+import org.joda.time.Chronology;
+import org.joda.time.DateTime;
 import org.joda.time.DateTimeConstants;
 import org.joda.time.DateTimeUtils;
 import org.joda.time.DateTimeZone;
@@ -297,4 +299,22 @@ public void testTimeFields() {
         assertEquals(true, julian.millisOfSecond().isSupported());
     }
 
+    public void testLeap_28feb() {
+        Chronology chrono = JulianChronology.getInstance();
+        DateTime dt = new DateTime(2012, 2, 28, 0, 0, chrono);
+        assertEquals(true, dt.year().isLeap());
+        assertEquals(true, dt.monthOfYear().isLeap());
+        assertEquals(false, dt.dayOfMonth().isLeap());
+        assertEquals(false, dt.dayOfYear().isLeap());
+    }
+
+    public void testLeap_29feb() {
+        Chronology chrono = JulianChronology.getInstance();
+        DateTime dt = new DateTime(2012, 2, 29, 0, 0, chrono);
+        assertEquals(true, dt.year().isLeap());
+        assertEquals(true, dt.monthOfYear().isLeap());
+        assertEquals(true, dt.dayOfMonth().isLeap());
+        assertEquals(true, dt.dayOfYear().isLeap());
+    }
+
 }
diff --git a/src/test/java/org/joda/time/chrono/gj/TestGJDayOfMonthField.java b/src/test/java/org/joda/time/chrono/gj/TestGJDayOfMonthField.java
index 5fb2ce97d..36c347e75 100644
--- a/src/test/java/org/joda/time/chrono/gj/TestGJDayOfMonthField.java
+++ b/src/test/java/org/joda/time/chrono/gj/TestGJDayOfMonthField.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2005 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -64,4 +64,9 @@ public int getMaximumValue(long millis) {
     public long roundFloor(long millis) {
         return iChronology.getDateOnlyMillis(millis);
     }
+
+    @Override
+    public boolean isLeap(long instant) {
+        return get(instant) == 29 && iChronology.monthOfYear().isLeap(instant);
+    }
 }
diff --git a/src/test/java/org/joda/time/chrono/gj/TestGJDayOfYearField.java b/src/test/java/org/joda/time/chrono/gj/TestGJDayOfYearField.java
index 7204ca782..8fa93163b 100644
--- a/src/test/java/org/joda/time/chrono/gj/TestGJDayOfYearField.java
+++ b/src/test/java/org/joda/time/chrono/gj/TestGJDayOfYearField.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2005 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -60,4 +60,9 @@ public int getMaximumValue(long millis) {
     public long roundFloor(long millis) {
         return iChronology.getDateOnlyMillis(millis);
     }
+
+    @Override
+    public boolean isLeap(long instant) {
+        return iChronology.dayOfMonth().isLeap(instant);
+    }
 }

From d6e89413dd1f67986c6257178359442123881485 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Mon, 20 Jan 2014 18:29:35 +0000
Subject: [PATCH 49/86] Fixup pull request - make it work on JDK 5

---
 RELEASE-NOTES.txt                             |  2 +
 pom.xml                                       |  4 ++
 .../time/format/DateTimeFormatterBuilder.java | 37 +++++++++----------
 3 files changed, 23 insertions(+), 20 deletions(-)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 150eea0ca..ab26ef779 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -84,6 +84,8 @@ Bug fixes since 2.3
   Apparently some Android implementations throw ClassCastException when comparing different types
   Thats dumb and wrong but the change to handle it is harmless
 
+- Better concurrency in parsing [#101]
+
 - Better Javadoc for parsing of numbers in format patterns [#60]
 
 - Remove uncaughtException calls [#59]
diff --git a/pom.xml b/pom.xml
index a2096553a..9e298e9cd 100644
--- a/pom.xml
+++ b/pom.xml
@@ -139,6 +139,10 @@
     <contributor>
       <name>Blair Martin</name>
     </contributor>
+    <contributor>
+      <name>Amling Palantir</name>
+      <url>https://github.com/AmlingPalantir</url>
+    </contributor>
     <contributor>
       <name>Julen Parra</name>
     </contributor>
diff --git a/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java b/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java
index a74fe6709..f447ab538 100644
--- a/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java
+++ b/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2011 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -15,17 +15,14 @@
  */
 package org.joda.time.format;
 
-import java.util.concurrent.ConcurrentHashMap;
 import java.io.IOException;
 import java.io.Writer;
 import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeConstants;
@@ -34,8 +31,8 @@
 import org.joda.time.DateTimeUtils;
 import org.joda.time.DateTimeZone;
 import org.joda.time.MutableDateTime;
-import org.joda.time.ReadablePartial;
 import org.joda.time.MutableDateTime.Property;
+import org.joda.time.ReadablePartial;
 import org.joda.time.field.MillisDurationField;
 import org.joda.time.field.PreciseDateTimeField;
 
@@ -1829,7 +1826,7 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
             Locale locale = bucket.getLocale();
             // handle languages which might have non ASCII A-Z or punctuation
             // bug 1788282
-            Set<String> validValues = null;
+            Map<String, Boolean> validValues = null;
             int maxLength = 0;
             Map<DateTimeFieldType, Object[]> innerMap = cParseCache.get(locale);
             if (innerMap == null) {
@@ -1838,7 +1835,7 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
             }
             Object[] array = innerMap.get(iFieldType);
             if (array == null) {
-                validValues = Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>(32));
+                validValues = new ConcurrentHashMap<String, Boolean>(32);  // use map as no concurrent Set
                 MutableDateTime dt = new MutableDateTime(0L, DateTimeZone.UTC);
                 Property property = dt.property(iFieldType);
                 int min = property.getMinimumValueOverall();
@@ -1849,32 +1846,32 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
                 maxLength = property.getMaximumTextLength(locale);
                 for (int i = min; i <= max; i++) {
                     property.set(i);
-                    validValues.add(property.getAsShortText(locale));
-                    validValues.add(property.getAsShortText(locale).toLowerCase(locale));
-                    validValues.add(property.getAsShortText(locale).toUpperCase(locale));
-                    validValues.add(property.getAsText(locale));
-                    validValues.add(property.getAsText(locale).toLowerCase(locale));
-                    validValues.add(property.getAsText(locale).toUpperCase(locale));
+                    validValues.put(property.getAsShortText(locale), Boolean.TRUE);
+                    validValues.put(property.getAsShortText(locale).toLowerCase(locale), Boolean.TRUE);
+                    validValues.put(property.getAsShortText(locale).toUpperCase(locale), Boolean.TRUE);
+                    validValues.put(property.getAsText(locale), Boolean.TRUE);
+                    validValues.put(property.getAsText(locale).toLowerCase(locale), Boolean.TRUE);
+                    validValues.put(property.getAsText(locale).toUpperCase(locale), Boolean.TRUE);
                 }
                 if ("en".equals(locale.getLanguage()) && iFieldType == DateTimeFieldType.era()) {
                     // hack to support for parsing "BCE" and "CE" if the language is English
-                    validValues.add("BCE");
-                    validValues.add("bce");
-                    validValues.add("CE");
-                    validValues.add("ce");
+                    validValues.put("BCE", Boolean.TRUE);
+                    validValues.put("bce", Boolean.TRUE);
+                    validValues.put("CE", Boolean.TRUE);
+                    validValues.put("ce", Boolean.TRUE);
                     maxLength = 3;
                 }
                 array = new Object[] {validValues, Integer.valueOf(maxLength)};
                 innerMap.put(iFieldType, array);
             } else {
-                validValues = (Set<String>) array[0];
+                validValues = (Map<String, Boolean>) array[0];
                 maxLength = ((Integer) array[1]).intValue();
             }
             // match the longest string first using our knowledge of the max length
             int limit = Math.min(text.length(), position + maxLength);
             for (int i = limit; i > position; i--) {
                 String match = text.substring(position, i);
-                if (validValues.contains(match)) {
+                if (validValues.containsKey(match)) {
                     bucket.saveField(iFieldType, match, locale);
                     return i;
                 }

From c3ef36272bddbb08854a4a5939a611668ea68450 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Mon, 27 Jan 2014 18:53:42 +0000
Subject: [PATCH 50/86] Upgrade to site-maven-plugin v0.9

---
 pom.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/pom.xml b/pom.xml
index 9e298e9cd..8d535b88b 100644
--- a/pom.xml
+++ b/pom.xml
@@ -360,7 +360,7 @@
       <plugin>
         <groupId>com.github.github</groupId>
         <artifactId>site-maven-plugin</artifactId>
-        <version>0.8</version>
+        <version>0.98</version>
         <executions>
           <execution>
             <id>github-site</id>

From a402cb2f7a00eeef07e0070ecdf27fe81793d701 Mon Sep 17 00:00:00 2001
From: Fabian Lange <lange.fabian@gmail.com>
Date: Wed, 12 Feb 2014 19:55:17 +0100
Subject: [PATCH 51/86] Adds Appendable support, uses StringBuilder instead of
 StringBuffer #120

---
 .../org/joda/time/format/DateTimeFormat.java  |  11 +
 .../joda/time/format/DateTimeFormatter.java   |  58 +++-
 .../time/format/DateTimeFormatterBuilder.java | 313 ++++++++++++++----
 .../org/joda/time/format/DateTimePrinter.java |  27 +-
 .../org/joda/time/format/FormatUtils.java     | 131 ++++++--
 5 files changed, 429 insertions(+), 111 deletions(-)

diff --git a/src/main/java/org/joda/time/format/DateTimeFormat.java b/src/main/java/org/joda/time/format/DateTimeFormat.java
index 3f117f4a2..4b10e14fd 100644
--- a/src/main/java/org/joda/time/format/DateTimeFormat.java
+++ b/src/main/java/org/joda/time/format/DateTimeFormat.java
@@ -825,6 +825,13 @@ public void printTo(
             p.printTo(out, instant, chrono, displayOffset, displayZone, locale);
         }
 
+        public void printTo(
+                Appendable appenadble, long instant, Chronology chrono,
+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
+            DateTimePrinter p = getFormatter(locale).getPrinter();
+            p.printTo(appenadble, instant, chrono, displayOffset, displayZone, locale);
+        }
+
         public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
             DateTimePrinter p = getFormatter(locale).getPrinter();
             p.printTo(buf, partial, locale);
@@ -835,6 +842,10 @@ public void printTo(Writer out, ReadablePartial partial, Locale locale) throws I
             p.printTo(out, partial, locale);
         }
 
+        public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
+            DateTimePrinter p = getFormatter(locale).getPrinter();
+            p.printTo(appendable, partial, locale);
+        }
         public int estimateParsedLength() {
             return 40;  // guess
         }
diff --git a/src/main/java/org/joda/time/format/DateTimeFormatter.java b/src/main/java/org/joda/time/format/DateTimeFormatter.java
index 16cc6fdef..768822a4b 100644
--- a/src/main/java/org/joda/time/format/DateTimeFormatter.java
+++ b/src/main/java/org/joda/time/format/DateTimeFormatter.java
@@ -250,7 +250,7 @@ public boolean isOffsetParsed() {
      * Returns a new formatter that will use the specified chronology in
      * preference to that of the printed object, or ISO on a parse.
      * <p>
-     * When printing, this chronolgy will be used in preference to the chronology
+     * When printing, this chronology will be used in preference to the chronology
      * from the datetime that would otherwise be used.
      * <p>
      * When parsing, this chronology will be set on the parsed datetime.
@@ -491,7 +491,9 @@ public void printTo(Writer out, ReadableInstant instant) throws IOException {
      * @since 2.0
      */
     public void printTo(Appendable appendable, ReadableInstant instant) throws IOException {
-        appendable.append(print(instant));
+        long millis = DateTimeUtils.getInstantMillis(instant);
+        Chronology chrono = DateTimeUtils.getInstantChronology(instant);
+        printTo(appendable, millis, chrono);
     }
 
     //-----------------------------------------------------------------------
@@ -526,7 +528,7 @@ public void printTo(Writer out, long instant) throws IOException {
      * @since 2.0
      */
     public void printTo(Appendable appendable, long instant) throws IOException {
-        appendable.append(print(instant));
+        printTo(appendable, instant, null);
     }
 
     //-----------------------------------------------------------------------
@@ -575,37 +577,49 @@ public void printTo(Writer out, ReadablePartial partial) throws IOException {
      * @since 2.0
      */
     public void printTo(Appendable appendable, ReadablePartial partial) throws IOException {
-        appendable.append(print(partial));
+        DateTimePrinter printer = requirePrinter();
+        if (partial == null) {
+            throw new IllegalArgumentException("The partial must not be null");
+        }
+        printer.printTo(appendable, partial, iLocale);
     }
 
     //-----------------------------------------------------------------------
     /**
      * Prints a ReadableInstant to a String.
      * <p>
-     * This method will use the override zone and the override chronololgy if
+     * This method will use the override zone and the override chronology if
      * they are set. Otherwise it will use the chronology and zone of the instant.
      *
      * @param instant  instant to format, null means now
      * @return the printed result
      */
     public String print(ReadableInstant instant) {
-        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
-        printTo(buf, instant);
+        StringBuilder buf = new StringBuilder(requirePrinter().estimatePrintedLength());
+        try {
+            printTo(buf, instant);
+        } catch (IOException e) {
+            // StringBuilder does not throw IOException
+        }
         return buf.toString();
     }
 
     /**
      * Prints a millisecond instant to a String.
      * <p>
-     * This method will use the override zone and the override chronololgy if
+     * This method will use the override zone and the override chronology if
      * they are set. Otherwise it will use the ISO chronology and default zone.
      *
      * @param instant  millis since 1970-01-01T00:00:00Z
      * @return the printed result
      */
     public String print(long instant) {
-        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
-        printTo(buf, instant);
+        StringBuilder buf = new StringBuilder(requirePrinter().estimatePrintedLength());
+        try {
+            printTo(buf, instant);
+        } catch (IOException e) {
+            // StringBuilder does not throw IOException
+        }
         return buf.toString();
     }
 
@@ -619,12 +633,24 @@ public String print(long instant) {
      * @return the printed result
      */
     public String print(ReadablePartial partial) {
-        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
-        printTo(buf, partial);
-        return buf.toString();
+        StringBuilder builder = new StringBuilder(requirePrinter().estimatePrintedLength());
+        try {
+            printTo(builder, partial);
+        } catch (IOException e) {
+            // StringBuilder does not throw IOException
+        }
+        return builder.toString();
     }
 
     private void printTo(StringBuffer buf, long instant, Chronology chrono) {
+        try {
+            printTo((Appendable)buf, instant, chrono);
+        } catch (IOException e) {
+            // StringBuffer does not throw IOException
+        }
+    }
+
+    private void printTo(Writer out, long instant, Chronology chrono) throws IOException {
         DateTimePrinter printer = requirePrinter();
         chrono = selectChronology(chrono);
         // Shift instant into local time (UTC) to avoid excessive offset
@@ -638,10 +664,10 @@ private void printTo(StringBuffer buf, long instant, Chronology chrono) {
             offset = 0;
             adjustedInstant = instant;
         }
-        printer.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);
+        printer.printTo(out, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);
     }
 
-    private void printTo(Writer buf, long instant, Chronology chrono) throws IOException {
+    private void printTo(Appendable appendable, long instant, Chronology chrono) throws IOException {
         DateTimePrinter printer = requirePrinter();
         chrono = selectChronology(chrono);
         // Shift instant into local time (UTC) to avoid excessive offset
@@ -655,7 +681,7 @@ private void printTo(Writer buf, long instant, Chronology chrono) throws IOExcep
             offset = 0;
             adjustedInstant = instant;
         }
-        printer.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);
+        printer.printTo(appendable, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);
     }
 
     /**
diff --git a/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java b/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java
index f447ab538..1ef97b2c3 100644
--- a/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java
+++ b/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java
@@ -1190,6 +1190,12 @@ static void appendUnknownString(StringBuffer buf, int len) {
         }
     }
 
+    static void appendUnknownString(Appendable appendable, int len) throws IOException {
+        for (int i = len; --i >= 0;) {
+            appendable.append('\ufffd');
+        }
+    }
+
     static void printUnknownString(Writer out, int len) throws IOException {
         for (int i = len; --i >= 0;) {
             out.write('\ufffd');
@@ -1223,6 +1229,12 @@ public void printTo(
             out.write(iValue);
         }
 
+        public void printTo(
+                Appendable appendable, long instant, Chronology chrono,
+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
+            appendable.append(iValue);
+        }
+
         public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
             buf.append(iValue);
         }
@@ -1231,6 +1243,10 @@ public void printTo(Writer out, ReadablePartial partial, Locale locale) throws I
             out.write(iValue);
         }
 
+        public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
+            appendable.append(iValue);
+        }
+
         public int estimateParsedLength() {
             return 1;
         }
@@ -1286,6 +1302,12 @@ public void printTo(
             out.write(iValue);
         }
 
+        public void printTo(
+                Appendable appendable, long instant, Chronology chrono,
+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
+            appendable.append(iValue);
+        }
+
         public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
             buf.append(iValue);
         }
@@ -1294,6 +1316,10 @@ public void printTo(Writer out, ReadablePartial partial, Locale locale) throws I
             out.write(iValue);
         }
 
+        public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
+            appendable.append(iValue);
+        }
+
         public int estimateParsedLength() {
             return iValue.length();
         }
@@ -1408,10 +1434,9 @@ public void printTo(
                 StringBuffer buf, long instant, Chronology chrono,
                 int displayOffset, DateTimeZone displayZone, Locale locale) {
             try {
-                DateTimeField field = iFieldType.getField(chrono);
-                FormatUtils.appendUnpaddedInteger(buf, field.get(instant));
-            } catch (RuntimeException e) {
-                buf.append('\ufffd');
+                printTo((Appendable)buf, instant, chrono, displayOffset, displayZone, locale);
+            } catch (IOException e) {
+                // StringBuffer does not throw IOException
             }
         }
 
@@ -1426,27 +1451,46 @@ public void printTo(
             }
         }
 
+        public void printTo(
+                Appendable appendable, long instant, Chronology chrono,
+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
+            try {
+                DateTimeField field = iFieldType.getField(chrono);
+                FormatUtils.appendUnpaddedInteger(appendable, field.get(instant));
+            } catch (RuntimeException e) {
+                appendable.append('\ufffd');
+            }
+        }
+
         public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
+            try {
+                printTo((Appendable)buf, partial, locale);
+            } catch (IOException e) {
+                // StringBuffer does not throw IOException
+            }
+        }
+
+        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
             if (partial.isSupported(iFieldType)) {
                 try {
-                    FormatUtils.appendUnpaddedInteger(buf, partial.get(iFieldType));
+                    FormatUtils.writeUnpaddedInteger(out, partial.get(iFieldType));
                 } catch (RuntimeException e) {
-                    buf.append('\ufffd');
+                    out.write('\ufffd');
                 }
             } else {
-                buf.append('\ufffd');
+                out.write('\ufffd');
             }
         }
 
-        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
+        public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
             if (partial.isSupported(iFieldType)) {
                 try {
-                    FormatUtils.writeUnpaddedInteger(out, partial.get(iFieldType));
+                    FormatUtils.appendUnpaddedInteger(appendable, partial.get(iFieldType));
                 } catch (RuntimeException e) {
-                    out.write('\ufffd');
+                    appendable.append('\ufffd');
                 }
             } else {
-                out.write('\ufffd');
+                appendable.append('\ufffd');
             }
         }
     }
@@ -1471,10 +1515,9 @@ public void printTo(
                 StringBuffer buf, long instant, Chronology chrono,
                 int displayOffset, DateTimeZone displayZone, Locale locale) {
             try {
-                DateTimeField field = iFieldType.getField(chrono);
-                FormatUtils.appendPaddedInteger(buf, field.get(instant), iMinPrintedDigits);
-            } catch (RuntimeException e) {
-                appendUnknownString(buf, iMinPrintedDigits);
+                printTo((Appendable)buf, instant, chrono, displayOffset, displayZone, locale);
+            } catch (IOException e) {
+                // StringBuffer does not throw IOException
             }
         }
 
@@ -1489,27 +1532,46 @@ public void printTo(
             }
         }
 
+        public void printTo(
+                Appendable appendable, long instant, Chronology chrono,
+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
+            try {
+                DateTimeField field = iFieldType.getField(chrono);
+                FormatUtils.appendPaddedInteger(appendable, field.get(instant), iMinPrintedDigits);
+            } catch (RuntimeException e) {
+                appendUnknownString(appendable, iMinPrintedDigits);
+            }
+        }
+
         public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
+            try {
+                printTo((Appendable)buf, partial, locale);
+            } catch (IOException e) {
+                // StringBuffer does not throw IOException
+            }
+        }
+
+        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
             if (partial.isSupported(iFieldType)) {
                 try {
-                    FormatUtils.appendPaddedInteger(buf, partial.get(iFieldType), iMinPrintedDigits);
+                    FormatUtils.writePaddedInteger(out, partial.get(iFieldType), iMinPrintedDigits);
                 } catch (RuntimeException e) {
-                    appendUnknownString(buf, iMinPrintedDigits);
+                    printUnknownString(out, iMinPrintedDigits);
                 }
             } else {
-                appendUnknownString(buf, iMinPrintedDigits);
+                printUnknownString(out, iMinPrintedDigits);
             }
         }
 
-        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
+        public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
             if (partial.isSupported(iFieldType)) {
                 try {
-                    FormatUtils.writePaddedInteger(out, partial.get(iFieldType), iMinPrintedDigits);
+                    FormatUtils.appendPaddedInteger(appendable, partial.get(iFieldType), iMinPrintedDigits);
                 } catch (RuntimeException e) {
-                    printUnknownString(out, iMinPrintedDigits);
+                    appendUnknownString(appendable, iMinPrintedDigits);
                 }
             } else {
-                printUnknownString(out, iMinPrintedDigits);
+                appendUnknownString(appendable, iMinPrintedDigits);
             }
         }
     }
@@ -1694,6 +1756,18 @@ public void printTo(
             }
         }
 
+        public void printTo(
+                Appendable appendable, long instant, Chronology chrono,
+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
+            int year = getTwoDigitYear(instant, chrono);
+            if (year < 0) {
+                appendable.append('\ufffd');
+                appendable.append('\ufffd');
+            } else {
+                FormatUtils.appendPaddedInteger(appendable, year, 2);
+            }
+        }
+
         private int getTwoDigitYear(long instant, Chronology chrono) {
             try {
                 int year = iType.getField(chrono).get(instant);
@@ -1726,6 +1800,16 @@ public void printTo(Writer out, ReadablePartial partial, Locale locale) throws I
             }
         }
 
+        public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
+            int year = getTwoDigitYear(partial);
+            if (year < 0) {
+                appendable.append('\ufffd');
+                appendable.append('\ufffd');
+            } else {
+                FormatUtils.appendPaddedInteger(appendable, year, 2);
+            }
+        }
+
         private int getTwoDigitYear(ReadablePartial partial) {
             if (partial.isSupported(iType)) {
                 try {
@@ -1779,6 +1863,16 @@ public void printTo(
             }
         }
 
+        public void printTo(
+                Appendable appendable, long instant, Chronology chrono,
+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
+            try {
+                appendable.append(print(instant, chrono, locale));
+            } catch (RuntimeException e) {
+                appendable.append('\ufffd');
+            }
+        }
+
         public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
             try {
                 buf.append(print(partial, locale));
@@ -1795,6 +1889,14 @@ public void printTo(Writer out, ReadablePartial partial, Locale locale) throws I
             }
         }
 
+        public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
+            try {
+                appendable.append(print(partial, locale));
+            } catch (RuntimeException e) {
+                appendable.append('\ufffd');
+            }
+        }
+
         private String print(long instant, Chronology chrono, Locale locale) {
             DateTimeField field = iFieldType.getField(chrono);
             if (iShort) {
@@ -1909,7 +2011,7 @@ public void printTo(
             try {
                 printTo(buf, null, instant, chrono);
             } catch (IOException e) {
-                // Not gonna happen.
+                // StringBuffer does not throw IOException
             }
         }
 
@@ -1919,6 +2021,12 @@ public void printTo(
             printTo(null, out, instant, chrono);
         }
 
+        public void printTo(
+                Appendable appendable, long instant, Chronology chrono,
+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
+            printTo(appendable, null, instant, chrono);
+        }
+
         public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
             // removed check whether field is supported, as input field is typically
             // secondOfDay which is unsupported by TimeOfDay
@@ -1926,7 +2034,7 @@ public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
             try {
                 printTo(buf, null, millis, partial.getChronology());
             } catch (IOException e) {
-                // Not gonna happen.
+                // StringBuffer does not throw IOException
             }
         }
 
@@ -1937,7 +2045,14 @@ public void printTo(Writer out, ReadablePartial partial, Locale locale) throws I
             printTo(null, out, millis, partial.getChronology());
         }
 
-        protected void printTo(StringBuffer buf, Writer out, long instant, Chronology chrono)
+        public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
+            // removed check whether field is supported, as input field is typically
+            // secondOfDay which is unsupported by TimeOfDay
+            long millis = partial.getChronology().set(partial, 0L);
+            printTo(appendable, null , millis, partial.getChronology());
+        }
+
+        protected void printTo(Appendable appendable, Writer out, long instant, Chronology chrono)
             throws IOException
         {
             DateTimeField field = iFieldType.getField(chrono);
@@ -1947,8 +2062,8 @@ protected void printTo(StringBuffer buf, Writer out, long instant, Chronology ch
             try {
                 fraction = field.remainder(instant);
             } catch (RuntimeException e) {
-                if (buf != null) {
-                    appendUnknownString(buf, minDigits);
+                if (appendable != null) {
+                    appendUnknownString(appendable, minDigits);
                 } else {
                     printUnknownString(out, minDigits);
                 }
@@ -1956,9 +2071,9 @@ protected void printTo(StringBuffer buf, Writer out, long instant, Chronology ch
             }
 
             if (fraction == 0) {
-                if (buf != null) {
+                if (appendable != null) {
                     while (--minDigits >= 0) {
-                        buf.append('0');
+                        appendable.append('0');
                     }
                 } else {
                     while (--minDigits >= 0) {
@@ -1982,8 +2097,8 @@ protected void printTo(StringBuffer buf, Writer out, long instant, Chronology ch
             int length = str.length();
             int digits = maxDigits;
             while (length < digits) {
-                if (buf != null) {
-                    buf.append('0');
+                if (appendable != null) {
+                    appendable.append('0');
                 } else {
                     out.write('0');
                 }
@@ -2001,9 +2116,9 @@ protected void printTo(StringBuffer buf, Writer out, long instant, Chronology ch
                     length--;
                 }
                 if (length < str.length()) {
-                    if (buf != null) {
+                    if (appendable != null) {
                         for (int i=0; i<length; i++) {
-                            buf.append(str.charAt(i));
+                            appendable.append(str.charAt(i));
                         }
                     } else {
                         for (int i=0; i<length; i++) {
@@ -2014,8 +2129,8 @@ protected void printTo(StringBuffer buf, Writer out, long instant, Chronology ch
                 }
             }
 
-            if (buf != null) {
-                buf.append(str);
+            if (appendable != null) {
+                appendable.append(str);
             } else {
                 out.write(str);
             }
@@ -2140,123 +2255,133 @@ public int estimatePrintedLength() {
             }
             return est;
         }
-        
+
         public void printTo(
                 StringBuffer buf, long instant, Chronology chrono,
                 int displayOffset, DateTimeZone displayZone, Locale locale) {
+            try {
+                printTo((Appendable) buf, instant, chrono, displayOffset, displayZone, locale);
+            } catch (IOException e) {
+                // StringBuffer does not throw IOException
+            }
+        }
+
+        public void printTo(
+                Writer out, long instant, Chronology chrono,
+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
             if (displayZone == null) {
                 return;  // no zone
             }
             if (displayOffset == 0 && iZeroOffsetPrintText != null) {
-                buf.append(iZeroOffsetPrintText);
+                out.write(iZeroOffsetPrintText);
                 return;
             }
             if (displayOffset >= 0) {
-                buf.append('+');
+                out.write('+');
             } else {
-                buf.append('-');
+                out.write('-');
                 displayOffset = -displayOffset;
             }
 
             int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR;
-            FormatUtils.appendPaddedInteger(buf, hours, 2);
+            FormatUtils.writePaddedInteger(out, hours, 2);
             if (iMaxFields == 1) {
                 return;
             }
             displayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;
-            if (displayOffset == 0 && iMinFields <= 1) {
+            if (displayOffset == 0 && iMinFields == 1) {
                 return;
             }
 
             int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE;
             if (iShowSeparators) {
-                buf.append(':');
+                out.write(':');
             }
-            FormatUtils.appendPaddedInteger(buf, minutes, 2);
+            FormatUtils.writePaddedInteger(out, minutes, 2);
             if (iMaxFields == 2) {
                 return;
             }
             displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;
-            if (displayOffset == 0 && iMinFields <= 2) {
+            if (displayOffset == 0 && iMinFields == 2) {
                 return;
             }
 
             int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND;
             if (iShowSeparators) {
-                buf.append(':');
+                out.write(':');
             }
-            FormatUtils.appendPaddedInteger(buf, seconds, 2);
+            FormatUtils.writePaddedInteger(out, seconds, 2);
             if (iMaxFields == 3) {
                 return;
             }
             displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;
-            if (displayOffset == 0 && iMinFields <= 3) {
+            if (displayOffset == 0 && iMinFields == 3) {
                 return;
             }
 
             if (iShowSeparators) {
-                buf.append('.');
+                out.write('.');
             }
-            FormatUtils.appendPaddedInteger(buf, displayOffset, 3);
+            FormatUtils.writePaddedInteger(out, displayOffset, 3);
         }
-        
+
         public void printTo(
-                Writer out, long instant, Chronology chrono,
+                Appendable buf, long instant, Chronology chrono,
                 int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
             if (displayZone == null) {
                 return;  // no zone
             }
             if (displayOffset == 0 && iZeroOffsetPrintText != null) {
-                out.write(iZeroOffsetPrintText);
+                buf.append(iZeroOffsetPrintText);
                 return;
             }
             if (displayOffset >= 0) {
-                out.write('+');
+                buf.append('+');
             } else {
-                out.write('-');
+                buf.append('-');
                 displayOffset = -displayOffset;
             }
 
             int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR;
-            FormatUtils.writePaddedInteger(out, hours, 2);
+            FormatUtils.appendPaddedInteger(buf, hours, 2);
             if (iMaxFields == 1) {
                 return;
             }
             displayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;
-            if (displayOffset == 0 && iMinFields == 1) {
+            if (displayOffset == 0 && iMinFields <= 1) {
                 return;
             }
 
             int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE;
             if (iShowSeparators) {
-                out.write(':');
+                buf.append(':');
             }
-            FormatUtils.writePaddedInteger(out, minutes, 2);
+            FormatUtils.appendPaddedInteger(buf, minutes, 2);
             if (iMaxFields == 2) {
                 return;
             }
             displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;
-            if (displayOffset == 0 && iMinFields == 2) {
+            if (displayOffset == 0 && iMinFields <= 2) {
                 return;
             }
 
             int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND;
             if (iShowSeparators) {
-                out.write(':');
+                buf.append(':');
             }
-            FormatUtils.writePaddedInteger(out, seconds, 2);
+            FormatUtils.appendPaddedInteger(buf, seconds, 2);
             if (iMaxFields == 3) {
                 return;
             }
             displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;
-            if (displayOffset == 0 && iMinFields == 3) {
+            if (displayOffset == 0 && iMinFields <= 3) {
                 return;
             }
 
             if (iShowSeparators) {
-                out.write('.');
+                buf.append('.');
             }
-            FormatUtils.writePaddedInteger(out, displayOffset, 3);
+            FormatUtils.appendPaddedInteger(buf, displayOffset, 3);
         }
 
         public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
@@ -2267,6 +2392,10 @@ public void printTo(Writer out, ReadablePartial partial, Locale locale) throws I
             // no zone info
         }
 
+        public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
+            // no zone info
+        }
+
         public int estimateParsedLength() {
             return estimatePrintedLength();
         }
@@ -2492,6 +2621,12 @@ public void printTo(
             out.write(print(instant - displayOffset, displayZone, locale));
         }
 
+        public void printTo(
+                Appendable appendable, long instant, Chronology chrono,
+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
+            appendable.append(print(instant - displayOffset, displayZone, locale));
+        }
+
         private String print(long instant, DateTimeZone displayZone, Locale locale) {
             if (displayZone == null) {
                 return "";  // no zone
@@ -2513,6 +2648,10 @@ public void printTo(Writer out, ReadablePartial partial, Locale locale) throws I
             // no zone info
         }
 
+        public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
+            // no zone info
+        }
+
         public int estimateParsedLength() {
             return (iType == SHORT_NAME ? 4 : 20);
         }
@@ -2568,6 +2707,12 @@ public void printTo(
             out.write(displayZone != null ? displayZone.getID() : "");
         }
 
+        public void printTo(
+                Appendable appendable, long instant, Chronology chrono,
+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
+            appendable.append(displayZone != null ? displayZone.getID() : "");
+        }
+
         public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
             // no zone info
         }
@@ -2576,6 +2721,10 @@ public void printTo(Writer out, ReadablePartial partial, Locale locale) throws I
             // no zone info
         }
 
+        public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
+            // no zone info
+        }
+
         public int estimateParsedLength() {
             return MAX_LENGTH;
         }
@@ -2689,6 +2838,25 @@ public void printTo(
             }
         }
 
+        public void printTo(
+                Appendable appendable, long instant, Chronology chrono,
+                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
+            DateTimePrinter[] elements = iPrinters;
+            if (elements == null) {
+                throw new UnsupportedOperationException();
+            }
+
+            if (locale == null) {
+                // Guard against default locale changing concurrently.
+                locale = Locale.getDefault();
+            }
+
+            int len = elements.length;
+            for (int i = 0; i < len; i++) {
+                elements[i].printTo(appendable, instant, chrono, displayOffset, displayZone, locale);
+            }
+        }
+
         public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
             DateTimePrinter[] elements = iPrinters;
             if (elements == null) {
@@ -2723,6 +2891,23 @@ public void printTo(Writer out, ReadablePartial partial, Locale locale) throws I
             }
         }
 
+        public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
+            DateTimePrinter[] elements = iPrinters;
+            if (elements == null) {
+                throw new UnsupportedOperationException();
+            }
+
+            if (locale == null) {
+                // Guard against default locale changing concurrently.
+                locale = Locale.getDefault();
+            }
+
+            int len = elements.length;
+            for (int i=0; i<len; i++) {
+                elements[i].printTo(appendable, partial, locale);
+            }
+        }
+
         public int estimateParsedLength() {
             return iParsedLengthEstimate;
         }
diff --git a/src/main/java/org/joda/time/format/DateTimePrinter.java b/src/main/java/org/joda/time/format/DateTimePrinter.java
index 46d36b429..5a3687f6b 100644
--- a/src/main/java/org/joda/time/format/DateTimePrinter.java
+++ b/src/main/java/org/joda/time/format/DateTimePrinter.java
@@ -71,7 +71,7 @@ void printTo(StringBuffer buf, long instant, Chronology chrono,
      * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
      * using the given Chronology.
      *
-     * @param out  formatted instant is written out
+     * @param out  formatted instant is written out, not null
      * @param instant  millis since 1970-01-01T00:00:00Z
      * @param chrono  the chronology to use, not null
      * @param displayOffset  if a time zone offset is printed, force it to use
@@ -82,6 +82,21 @@ void printTo(StringBuffer buf, long instant, Chronology chrono,
     void printTo(Writer out, long instant, Chronology chrono,
                  int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException;
 
+    /**
+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
+     * using the given Chronology.
+     *
+     * @param appendable  formatted instant is appended to, not null
+     * @param instant  millis since 1970-01-01T00:00:00Z
+     * @param chrono  the chronology to use, not null
+     * @param displayOffset  if a time zone offset is printed, force it to use
+     * this millisecond value
+     * @param displayZone  the time zone to use, null means local time
+     * @param locale  the locale to use, null means default locale
+      * @since 2.4
+     */
+    void printTo(Appendable appendable, long instant, Chronology chrono,
+                 int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException;
     //-----------------------------------------------------------------------
     /**
      * Prints a ReadablePartial.
@@ -101,4 +116,14 @@ void printTo(Writer out, long instant, Chronology chrono,
      */
     void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException;
 
+    /**
+     * Prints a ReadablePartial.
+     *
+     * @param appendable  formatted instant is appended to, not null
+     * @param partial  partial to format, not null
+     * @param locale  the locale to use, null means default locale
+     * @since 2.4
+     */
+    void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException;
+
 }
diff --git a/src/main/java/org/joda/time/format/FormatUtils.java b/src/main/java/org/joda/time/format/FormatUtils.java
index dba143162..5bd32cbfb 100644
--- a/src/main/java/org/joda/time/format/FormatUtils.java
+++ b/src/main/java/org/joda/time/format/FormatUtils.java
@@ -44,37 +44,56 @@ private FormatUtils() {
      *
      * @param buf receives integer converted to a string
      * @param value value to convert to a string
-     * @param size minumum amount of digits to append
+     * @param size minimum amount of digits to append
      */
     public static void appendPaddedInteger(StringBuffer buf, int value, int size) {
+        try {
+            appendPaddedInteger((Appendable)buf, value, size);
+        } catch (IOException e) {
+            // StringBuffer does not throw IOException
+        }
+    }
+
+    /**
+     * Converts an integer to a string, prepended with a variable amount of '0'
+     * pad characters, and appends it to the given appendable.
+     *
+     * <p>This method is optimized for converting small values to strings.
+     *
+     * @param appenadble receives integer converted to a string
+     * @param value value to convert to a string
+     * @param size minimum amount of digits to append
+     * @since 2.4
+     */
+    public static void appendPaddedInteger(Appendable appenadble, int value, int size) throws IOException {
         if (value < 0) {
-            buf.append('-');
+            appenadble.append('-');
             if (value != Integer.MIN_VALUE) {
                 value = -value;
             } else {
                 for (; size > 10; size--) {
-                    buf.append('0');
+                    appenadble.append('0');
                 }
-                buf.append("" + -(long)Integer.MIN_VALUE);
+                appenadble.append("" + -(long)Integer.MIN_VALUE);
                 return;
             }
         }
         if (value < 10) {
             for (; size > 1; size--) {
-                buf.append('0');
+                appenadble.append('0');
             }
-            buf.append((char)(value + '0'));
+            appenadble.append((char)(value + '0'));
         } else if (value < 100) {
             for (; size > 2; size--) {
-                buf.append('0');
+                appenadble.append('0');
             }
             // Calculate value div/mod by 10 without using two expensive
             // division operations. (2 ^ 27) / 10 = 13421772. Add one to
             // value to correct rounding error.
             int d = ((value + 1) * 13421772) >> 27;
-            buf.append((char) (d + '0'));
+            appenadble.append((char) (d + '0'));
             // Append remainder by calculating (value - d * 10).
-            buf.append((char) (value - (d << 3) - (d << 1) + '0'));
+            appenadble.append((char) (value - (d << 3) - (d << 1) + '0'));
         } else {
             int digits;
             if (value < 1000) {
@@ -85,12 +104,12 @@ public static void appendPaddedInteger(StringBuffer buf, int value, int size) {
                 digits = (int)(Math.log(value) / LOG_10) + 1;
             }
             for (; size > digits; size--) {
-                buf.append('0');
+                appenadble.append('0');
             }
-            buf.append(Integer.toString(value));
+            appenadble.append(Integer.toString(value));
         }
     }
-
+    
     /**
      * Converts an integer to a string, prepended with a variable amount of '0'
      * pad characters, and appends it to the given buffer.
@@ -99,32 +118,51 @@ public static void appendPaddedInteger(StringBuffer buf, int value, int size) {
      *
      * @param buf receives integer converted to a string
      * @param value value to convert to a string
-     * @param size minumum amount of digits to append
+     * @param size minimum amount of digits to append
      */
     public static void appendPaddedInteger(StringBuffer buf, long value, int size) {
+        try {
+            appendPaddedInteger((Appendable)buf, value, size);
+        } catch (IOException e) {
+            // StringBuffer does not throw IOException
+        }
+    }
+
+    /**
+     * Converts an integer to a string, prepended with a variable amount of '0'
+     * pad characters, and appends it to the given buffer.
+     *
+     * <p>This method is optimized for converting small values to strings.
+     *
+     * @param appendable receives integer converted to a string
+     * @param value value to convert to a string
+     * @param size minimum amount of digits to append
+     * @since 2.4
+     */
+    public static void appendPaddedInteger(Appendable appendable, long value, int size) throws IOException {
         int intValue = (int)value;
         if (intValue == value) {
-            appendPaddedInteger(buf, intValue, size);
+            appendPaddedInteger(appendable, intValue, size);
         } else if (size <= 19) {
-            buf.append(Long.toString(value));
+            appendable.append(Long.toString(value));
         } else {
             if (value < 0) {
-                buf.append('-');
+                appendable.append('-');
                 if (value != Long.MIN_VALUE) {
                     value = -value;
                 } else {
                     for (; size > 19; size--) {
-                        buf.append('0');
+                        appendable.append('0');
                     }
-                    buf.append("9223372036854775808");
+                    appendable.append("9223372036854775808");
                     return;
                 }
             }
             int digits = (int)(Math.log(value) / LOG_10) + 1;
             for (; size > digits; size--) {
-                buf.append('0');
+                appendable.append('0');
             }
-            buf.append(Long.toString(value));
+            appendable.append(Long.toString(value));
         }
     }
 
@@ -136,7 +174,7 @@ public static void appendPaddedInteger(StringBuffer buf, long value, int size) {
      *
      * @param out receives integer converted to a string
      * @param value value to convert to a string
-     * @param size minumum amount of digits to append
+     * @param size minimum amount of digits to append
      */
     public static void writePaddedInteger(Writer out, int value, int size)
         throws IOException
@@ -193,7 +231,7 @@ public static void writePaddedInteger(Writer out, int value, int size)
      *
      * @param out receives integer converted to a string
      * @param value value to convert to a string
-     * @param size minumum amount of digits to append
+     * @param size minimum amount of digits to append
      */
     public static void writePaddedInteger(Writer out, long value, int size)
         throws IOException
@@ -233,27 +271,44 @@ public static void writePaddedInteger(Writer out, long value, int size)
      * @param value value to convert to a string
      */
     public static void appendUnpaddedInteger(StringBuffer buf, int value) {
+        try {
+            appendUnpaddedInteger((Appendable) buf, value);
+        } catch (IOException e) {
+            // StringBuffer do not throw IOException
+        }
+    }
+
+    /**
+     * Converts an integer to a string, and appends it to the given appendable.
+     *
+     * <p>This method is optimized for converting small values to strings.
+     *
+     * @param appendable receives integer converted to a string
+     * @param value value to convert to a string
+     * @since 2.4
+     */
+    public static void appendUnpaddedInteger(Appendable appendable, int value) throws IOException {
         if (value < 0) {
-            buf.append('-');
+            appendable.append('-');
             if (value != Integer.MIN_VALUE) {
                 value = -value;
             } else {
-                buf.append("" + -(long)Integer.MIN_VALUE);
+                appendable.append("" + -(long)Integer.MIN_VALUE);
                 return;
             }
         }
         if (value < 10) {
-            buf.append((char)(value + '0'));
+            appendable.append((char)(value + '0'));
         } else if (value < 100) {
             // Calculate value div/mod by 10 without using two expensive
             // division operations. (2 ^ 27) / 10 = 13421772. Add one to
             // value to correct rounding error.
             int d = ((value + 1) * 13421772) >> 27;
-            buf.append((char) (d + '0'));
+            appendable.append((char) (d + '0'));
             // Append remainder by calculating (value - d * 10).
-            buf.append((char) (value - (d << 3) - (d << 1) + '0'));
+            appendable.append((char) (value - (d << 3) - (d << 1) + '0'));
         } else {
-            buf.append(Integer.toString(value));
+            appendable.append(Integer.toString(value));
         }
     }
 
@@ -266,11 +321,27 @@ public static void appendUnpaddedInteger(StringBuffer buf, int value) {
      * @param value value to convert to a string
      */
     public static void appendUnpaddedInteger(StringBuffer buf, long value) {
+        try {
+            appendUnpaddedInteger((Appendable) buf, value);
+        } catch (IOException e) {
+            // StringBuffer do not throw IOException
+        }
+    }
+
+    /**
+     * Converts an integer to a string, and appends it to the given appendable.
+     *
+     * <p>This method is optimized for converting small values to strings.
+     *
+     * @param appendable receives integer converted to a string
+     * @param value value to convert to a string
+     */
+    public static void appendUnpaddedInteger(Appendable appendable, long value) throws IOException {
         int intValue = (int)value;
         if (intValue == value) {
-            appendUnpaddedInteger(buf, intValue);
+            appendUnpaddedInteger(appendable, intValue);
         } else {
-            buf.append(Long.toString(value));
+            appendable.append(Long.toString(value));
         }
     }
 

From 1929527baf0463a29ec594a2095079421caa54ef Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Thu, 13 Feb 2014 10:56:51 +0000
Subject: [PATCH 52/86] Ensure time-zone offset print methods have same code

Testing revealed no difference in behaviour
Fixes #122
---
 .../time/format/DateTimeFormatterBuilder.java |  6 +-
 .../format/TestDateTimeFormatterBuilder.java  | 90 +++++++++++++++++++
 2 files changed, 93 insertions(+), 3 deletions(-)

diff --git a/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java b/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java
index f447ab538..71e992813 100644
--- a/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java
+++ b/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java
@@ -2223,7 +2223,7 @@ public void printTo(
                 return;
             }
             displayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;
-            if (displayOffset == 0 && iMinFields == 1) {
+            if (displayOffset == 0 && iMinFields <= 1) {
                 return;
             }
 
@@ -2236,7 +2236,7 @@ public void printTo(
                 return;
             }
             displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;
-            if (displayOffset == 0 && iMinFields == 2) {
+            if (displayOffset == 0 && iMinFields <= 2) {
                 return;
             }
 
@@ -2249,7 +2249,7 @@ public void printTo(
                 return;
             }
             displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;
-            if (displayOffset == 0 && iMinFields == 3) {
+            if (displayOffset == 0 && iMinFields <= 3) {
                 return;
             }
 
diff --git a/src/test/java/org/joda/time/format/TestDateTimeFormatterBuilder.java b/src/test/java/org/joda/time/format/TestDateTimeFormatterBuilder.java
index 0c5fffcea..602bac959 100644
--- a/src/test/java/org/joda/time/format/TestDateTimeFormatterBuilder.java
+++ b/src/test/java/org/joda/time/format/TestDateTimeFormatterBuilder.java
@@ -15,10 +15,13 @@
  */
 package org.joda.time.format;
 
+import java.io.IOException;
+import java.io.StringWriter;
 import java.util.LinkedHashMap;
 import java.util.Locale;
 import java.util.Map;
 
+import junit.framework.AssertionFailedError;
 import junit.framework.TestCase;
 import junit.framework.TestSuite;
 
@@ -40,6 +43,8 @@
     private static final DateTimeZone TOKYO = DateTimeZone.forID("Asia/Tokyo");
     private static final DateTimeZone NEW_YORK = DateTimeZone.forID("America/New_York");
     private static final DateTimeZone LOS_ANGELES = DateTimeZone.forID("America/Los_Angeles");
+    private static final DateTimeZone OFFSET_0200 = DateTimeZone.forID("+02:00");
+    private static final DateTimeZone OFFSET_023012 = DateTimeZone.forID("+02:30:12");
 
     public static void main(String[] args) {
         junit.textui.TestRunner.run(suite());
@@ -312,6 +317,78 @@ public void test_appendFixedSignedDecimal() {
         }
     }
 
+    //-----------------------------------------------------------------------
+    public void test_appendTimeZoneOffset_parse() {
+        for (int i = 1; i <= 4; i++) {
+            for (int j = i; j <= 4; j++) {
+                DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();
+                bld.appendTimeZoneOffset("Z", true, i, j);
+                DateTimeFormatter f = bld.toFormatter();
+                // parse
+                assertEquals(OFFSET_0200, f.withOffsetParsed().parseDateTime("+02").getZone());
+                assertEquals(OFFSET_0200, f.withOffsetParsed().parseDateTime("+02:00").getZone());
+                assertEquals(OFFSET_0200, f.withOffsetParsed().parseDateTime("+02:00:00").getZone());
+                assertEquals(OFFSET_0200, f.withOffsetParsed().parseDateTime("+02:00:00.000").getZone());
+            }
+        }
+    }
+
+    public void test_appendTimeZoneOffset_print_min1max1() throws IOException {
+        DateTimeFormatter f = new DateTimeFormatterBuilder().appendTimeZoneOffset("Z", true, 1, 1).toFormatter();
+        assertPrint("+02", f, new DateTime(2007, 3, 4, 0, 0, 0, OFFSET_0200));
+        assertPrint("+02", f, new DateTime(2007, 3, 4, 0, 0, 0, OFFSET_023012));
+    }
+
+    public void test_appendTimeZoneOffset_print_min1max2() throws IOException {
+        DateTimeFormatter f = new DateTimeFormatterBuilder().appendTimeZoneOffset("Z", true, 1, 2).toFormatter();
+        assertPrint("+02", f, new DateTime(2007, 3, 4, 0, 0, 0, OFFSET_0200));
+        assertPrint("+02:30", f, new DateTime(2007, 3, 4, 0, 0, 0, OFFSET_023012));
+    }
+
+    public void test_appendTimeZoneOffset_print_min1max3() throws IOException {
+        DateTimeFormatter f = new DateTimeFormatterBuilder().appendTimeZoneOffset("Z", true, 1, 3).toFormatter();
+        assertPrint("+02", f, new DateTime(2007, 3, 4, 0, 0, 0, OFFSET_0200));
+        assertPrint("+02:30:12", f, new DateTime(2007, 3, 4, 0, 0, 0, OFFSET_023012));
+    }
+
+    public void test_appendTimeZoneOffset_print_min2max2() throws IOException {
+        DateTimeFormatter f = new DateTimeFormatterBuilder().appendTimeZoneOffset("Z", true, 2, 2).toFormatter();
+        assertPrint("+02:00", f, new DateTime(2007, 3, 4, 0, 0, 0, OFFSET_0200));
+        assertPrint("+02:30", f, new DateTime(2007, 3, 4, 0, 0, 0, OFFSET_023012));
+    }
+
+    public void test_appendTimeZoneOffset_print_min2max3() throws IOException {
+        DateTimeFormatter f = new DateTimeFormatterBuilder().appendTimeZoneOffset("Z", true, 2, 3).toFormatter();
+        assertPrint("+02:00", f, new DateTime(2007, 3, 4, 0, 0, 0, OFFSET_0200));
+        assertPrint("+02:30:12", f, new DateTime(2007, 3, 4, 0, 0, 0, OFFSET_023012));
+    }
+
+    public void test_appendTimeZoneOffset_print_min3max3() throws IOException {
+        DateTimeFormatter f = new DateTimeFormatterBuilder().appendTimeZoneOffset("Z", true, 3, 3).toFormatter();
+        assertPrint("+02:00:00", f, new DateTime(2007, 3, 4, 0, 0, 0, OFFSET_0200));
+        assertPrint("+02:30:12", f, new DateTime(2007, 3, 4, 0, 0, 0, OFFSET_023012));
+    }
+
+    public void test_appendTimeZoneOffset_invalidText() {
+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();
+        bld.appendTimeZoneOffset("Z", true, 1, 1);
+        DateTimeFormatter f = bld.toFormatter();
+        try {
+            f.parseDateTime("Nonsense");
+            fail();
+        } catch (IllegalArgumentException e) {
+        }
+    }
+
+    public void test_appendTimeZoneOffset_zeroMinInvalid() {
+        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();
+        try {
+            bld.appendTimeZoneOffset("Z", true, 0, 2);
+            fail();
+        } catch (IllegalArgumentException e) {
+        }
+    }
+
     //-----------------------------------------------------------------------
     public void test_appendTimeZoneId() {
         DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();
@@ -591,4 +668,17 @@ public void test_printParseLongNameWithLookup() {
         }
     }
 
+    private static void assertPrint(String expected, DateTimeFormatter f, DateTime dt) {
+        assertEquals(expected, f.print(dt));
+        StringWriter out = new StringWriter();
+        try {
+            f.printTo(out, dt);
+        } catch (IOException ex) {
+            AssertionFailedError failure = new AssertionFailedError();
+            failure.initCause(ex);
+            throw failure;
+        }
+        assertEquals(expected, out.toString());
+    }
+
 }

From f36072e1168bf0ad648678402a7a8366d1d420fc Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Thu, 13 Feb 2014 12:25:08 +0000
Subject: [PATCH 53/86] Support Appendable throughout printing

Ensure that Appendable can be used efficiently in printing
Fixes #120
Fixes #121
Fixes #122
---
 RELEASE-NOTES.txt                             |   4 +
 .../org/joda/time/format/DateTimeFormat.java  |  36 +-
 .../joda/time/format/DateTimeFormatter.java   | 110 ++--
 .../time/format/DateTimeFormatterBuilder.java | 533 ++----------------
 .../org/joda/time/format/DateTimePrinter.java |  27 +-
 .../DateTimePrinterInternalPrinter.java       |  89 +++
 .../org/joda/time/format/FormatUtils.java     |   4 +-
 .../org/joda/time/format/InternalPrinter.java |  68 +++
 .../InternalPrinterDateTimePrinter.java       | 106 ++++
 .../time/format/TestDateTimeFormatStyle.java  |   7 +-
 .../time/format/TestDateTimeFormatter.java    |   4 +-
 11 files changed, 373 insertions(+), 615 deletions(-)
 create mode 100644 src/main/java/org/joda/time/format/DateTimePrinterInternalPrinter.java
 create mode 100644 src/main/java/org/joda/time/format/InternalPrinter.java
 create mode 100644 src/main/java/org/joda/time/format/InternalPrinterDateTimePrinter.java

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index ab26ef779..33d969867 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -25,6 +25,10 @@ Enhancements since 2.3
   Remove unnecessary volatile on instance variable [#68]
   LocalDate hash code meets criteria of the racy single-check idiom
 
+- Support Appendable throughout printing
+  Ensure that Appendable can be used efficiently in printing [#120, #121, #122]
+  No API change
+
 
 Compatibility with 2.3
 ----------------------
diff --git a/src/main/java/org/joda/time/format/DateTimeFormat.java b/src/main/java/org/joda/time/format/DateTimeFormat.java
index 4b10e14fd..bdc9d68b7 100644
--- a/src/main/java/org/joda/time/format/DateTimeFormat.java
+++ b/src/main/java/org/joda/time/format/DateTimeFormat.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2013 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -16,7 +16,6 @@
 package org.joda.time.format;
 
 import java.io.IOException;
-import java.io.Writer;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
 import java.util.HashMap;
@@ -231,7 +230,7 @@ public static String patternForStyle(String style, Locale locale) {
             locale = Locale.getDefault();
         }
         // Not pretty, but it works.
-        return ((StyleFormatter) formatter.getPrinter()).getPattern(locale);
+        return ((StyleFormatter) formatter.getPrinter0()).getPattern(locale);
     }
 
     //-----------------------------------------------------------------------
@@ -792,7 +791,7 @@ private static int selectStyle(char ch) {
 
     //-----------------------------------------------------------------------
     static class StyleFormatter
-            implements DateTimePrinter, DateTimeParser {
+            implements InternalPrinter, DateTimeParser {
 
         private static final Map<String, DateTimeFormatter> cCache = new HashMap<String, DateTimeFormatter>();  // manual sync
         
@@ -811,41 +810,18 @@ public int estimatePrintedLength() {
             return 40;  // guess
         }
 
-        public void printTo(
-                StringBuffer buf, long instant, Chronology chrono,
-                int displayOffset, DateTimeZone displayZone, Locale locale) {
-            DateTimePrinter p = getFormatter(locale).getPrinter();
-            p.printTo(buf, instant, chrono, displayOffset, displayZone, locale);
-        }
-
-        public void printTo(
-                Writer out, long instant, Chronology chrono,
-                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
-            DateTimePrinter p = getFormatter(locale).getPrinter();
-            p.printTo(out, instant, chrono, displayOffset, displayZone, locale);
-        }
-
         public void printTo(
                 Appendable appenadble, long instant, Chronology chrono,
                 int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
-            DateTimePrinter p = getFormatter(locale).getPrinter();
+            InternalPrinter p = getFormatter(locale).getPrinter0();
             p.printTo(appenadble, instant, chrono, displayOffset, displayZone, locale);
         }
 
-        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
-            DateTimePrinter p = getFormatter(locale).getPrinter();
-            p.printTo(buf, partial, locale);
-        }
-
-        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
-            DateTimePrinter p = getFormatter(locale).getPrinter();
-            p.printTo(out, partial, locale);
-        }
-
         public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
-            DateTimePrinter p = getFormatter(locale).getPrinter();
+            InternalPrinter p = getFormatter(locale).getPrinter0();
             p.printTo(appendable, partial, locale);
         }
+
         public int estimateParsedLength() {
             return 40;  // guess
         }
diff --git a/src/main/java/org/joda/time/format/DateTimeFormatter.java b/src/main/java/org/joda/time/format/DateTimeFormatter.java
index 768822a4b..8693bc31e 100644
--- a/src/main/java/org/joda/time/format/DateTimeFormatter.java
+++ b/src/main/java/org/joda/time/format/DateTimeFormatter.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2013 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -90,7 +90,7 @@
 public class DateTimeFormatter {
 
     /** The internal printer used to output the datetime. */
-    private final DateTimePrinter iPrinter;
+    private final InternalPrinter iPrinter;
     /** The internal parser used to output the datetime. */
     private final DateTimeParser iParser;
     /** The locale to use for printing and parsing. */
@@ -115,6 +115,18 @@
      */
     public DateTimeFormatter(
             DateTimePrinter printer, DateTimeParser parser) {
+        this(DateTimePrinterInternalPrinter.of(printer), parser);
+    }
+
+    /**
+     * Creates a new formatter, however you will normally use the factory
+     * or the builder.
+     * 
+     * @param printer  the internal printer, null if cannot print
+     * @param parser  the internal parser, null if cannot parse
+     */
+    DateTimeFormatter(
+            InternalPrinter printer, DateTimeParser parser) {
         super();
         iPrinter = printer;
         iParser = parser;
@@ -130,7 +142,7 @@ public DateTimeFormatter(
      * Constructor.
      */
     private DateTimeFormatter(
-            DateTimePrinter printer, DateTimeParser parser,
+            InternalPrinter printer, DateTimeParser parser,
             Locale locale, boolean offsetParsed,
             Chronology chrono, DateTimeZone zone,
             Integer pivotYear, int defaultYear) {
@@ -161,6 +173,15 @@ public boolean isPrinter() {
      * @return the internal printer; is null if printing not supported
      */
     public DateTimePrinter getPrinter() {
+        return InternalPrinterDateTimePrinter.of(iPrinter);
+    }
+
+    /**
+     * Gets the internal printer object that performs the real printing work.
+     * 
+     * @return the internal printer; is null if printing not supported
+     */
+    InternalPrinter getPrinter0() {
         return iPrinter;
     }
 
@@ -466,9 +487,11 @@ public int getDefaultYear() {
      * @param instant  instant to format, null means now
      */
     public void printTo(StringBuffer buf, ReadableInstant instant) {
-        long millis = DateTimeUtils.getInstantMillis(instant);
-        Chronology chrono = DateTimeUtils.getInstantChronology(instant);
-        printTo(buf, millis, chrono);
+        try {
+            printTo((Appendable) buf, instant);
+        } catch (IOException ex) {
+            // StringBuffer does not throw IOException
+        }
     }
 
     /**
@@ -478,9 +501,7 @@ public void printTo(StringBuffer buf, ReadableInstant instant) {
      * @param instant  instant to format, null means now
      */
     public void printTo(Writer out, ReadableInstant instant) throws IOException {
-        long millis = DateTimeUtils.getInstantMillis(instant);
-        Chronology chrono = DateTimeUtils.getInstantChronology(instant);
-        printTo(out, millis, chrono);
+        printTo((Appendable) out, instant);
     }
 
     /**
@@ -505,7 +526,11 @@ public void printTo(Appendable appendable, ReadableInstant instant) throws IOExc
      * @param instant  millis since 1970-01-01T00:00:00Z
      */
     public void printTo(StringBuffer buf, long instant) {
-        printTo(buf, instant, null);
+        try {
+            printTo((Appendable) buf, instant);
+        } catch (IOException ex) {
+            // StringBuffer does not throw IOException
+        }
     }
 
     /**
@@ -516,7 +541,7 @@ public void printTo(StringBuffer buf, long instant) {
      * @param instant  millis since 1970-01-01T00:00:00Z
      */
     public void printTo(Writer out, long instant) throws IOException {
-        printTo(out, instant, null);
+        printTo((Appendable) out, instant);
     }
 
     /**
@@ -542,11 +567,11 @@ public void printTo(Appendable appendable, long instant) throws IOException {
      * @param partial  partial to format
      */
     public void printTo(StringBuffer buf, ReadablePartial partial) {
-        DateTimePrinter printer = requirePrinter();
-        if (partial == null) {
-            throw new IllegalArgumentException("The partial must not be null");
+        try {
+            printTo((Appendable) buf, partial);
+        } catch (IOException ex) {
+            // StringBuffer does not throw IOException
         }
-        printer.printTo(buf, partial, iLocale);
     }
 
     /**
@@ -559,11 +584,7 @@ public void printTo(StringBuffer buf, ReadablePartial partial) {
      * @param partial  partial to format
      */
     public void printTo(Writer out, ReadablePartial partial) throws IOException {
-        DateTimePrinter printer = requirePrinter();
-        if (partial == null) {
-            throw new IllegalArgumentException("The partial must not be null");
-        }
-        printer.printTo(out, partial, iLocale);
+        printTo((Appendable) out, partial);
     }
 
     /**
@@ -577,7 +598,7 @@ public void printTo(Writer out, ReadablePartial partial) throws IOException {
      * @since 2.0
      */
     public void printTo(Appendable appendable, ReadablePartial partial) throws IOException {
-        DateTimePrinter printer = requirePrinter();
+        InternalPrinter printer = requirePrinter();
         if (partial == null) {
             throw new IllegalArgumentException("The partial must not be null");
         }
@@ -597,8 +618,8 @@ public void printTo(Appendable appendable, ReadablePartial partial) throws IOExc
     public String print(ReadableInstant instant) {
         StringBuilder buf = new StringBuilder(requirePrinter().estimatePrintedLength());
         try {
-            printTo(buf, instant);
-        } catch (IOException e) {
+            printTo((Appendable) buf, instant);
+        } catch (IOException ex) {
             // StringBuilder does not throw IOException
         }
         return buf.toString();
@@ -616,8 +637,8 @@ public String print(ReadableInstant instant) {
     public String print(long instant) {
         StringBuilder buf = new StringBuilder(requirePrinter().estimatePrintedLength());
         try {
-            printTo(buf, instant);
-        } catch (IOException e) {
+            printTo((Appendable) buf, instant);
+        } catch (IOException ex) {
             // StringBuilder does not throw IOException
         }
         return buf.toString();
@@ -633,42 +654,17 @@ public String print(long instant) {
      * @return the printed result
      */
     public String print(ReadablePartial partial) {
-        StringBuilder builder = new StringBuilder(requirePrinter().estimatePrintedLength());
+        StringBuilder buf = new StringBuilder(requirePrinter().estimatePrintedLength());
         try {
-            printTo(builder, partial);
-        } catch (IOException e) {
+            printTo((Appendable) buf, partial);
+        } catch (IOException ex) {
             // StringBuilder does not throw IOException
         }
-        return builder.toString();
-    }
-
-    private void printTo(StringBuffer buf, long instant, Chronology chrono) {
-        try {
-            printTo((Appendable)buf, instant, chrono);
-        } catch (IOException e) {
-            // StringBuffer does not throw IOException
-        }
-    }
-
-    private void printTo(Writer out, long instant, Chronology chrono) throws IOException {
-        DateTimePrinter printer = requirePrinter();
-        chrono = selectChronology(chrono);
-        // Shift instant into local time (UTC) to avoid excessive offset
-        // calculations when printing multiple fields in a composite printer.
-        DateTimeZone zone = chrono.getZone();
-        int offset = zone.getOffset(instant);
-        long adjustedInstant = instant + offset;
-        if ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {
-            // Time zone offset overflow, so revert to UTC.
-            zone = DateTimeZone.UTC;
-            offset = 0;
-            adjustedInstant = instant;
-        }
-        printer.printTo(out, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);
+        return buf.toString();
     }
 
     private void printTo(Appendable appendable, long instant, Chronology chrono) throws IOException {
-        DateTimePrinter printer = requirePrinter();
+        InternalPrinter printer = requirePrinter();
         chrono = selectChronology(chrono);
         // Shift instant into local time (UTC) to avoid excessive offset
         // calculations when printing multiple fields in a composite printer.
@@ -689,8 +685,8 @@ private void printTo(Appendable appendable, long instant, Chronology chrono) thr
      * 
      * @throws UnsupportedOperationException if printing is not supported
      */
-    private DateTimePrinter requirePrinter() {
-        DateTimePrinter printer = iPrinter;
+    private InternalPrinter requirePrinter() {
+        InternalPrinter printer = iPrinter;
         if (printer == null) {
             throw new UnsupportedOperationException("Printing not supported");
         }
diff --git a/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java b/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java
index 1ef97b2c3..bdf21d8d9 100644
--- a/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java
+++ b/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java
@@ -16,7 +16,6 @@
 package org.joda.time.format;
 
 import java.io.IOException;
-import java.io.Writer;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Locale;
@@ -102,9 +101,9 @@ public DateTimeFormatterBuilder() {
      */
     public DateTimeFormatter toFormatter() {
         Object f = getFormatter();
-        DateTimePrinter printer = null;
+        InternalPrinter printer = null;
         if (isPrinter(f)) {
-            printer = (DateTimePrinter) f;
+            printer = (InternalPrinter) f;
         }
         DateTimeParser parser = null;
         if (isParser(f)) {
@@ -131,7 +130,8 @@ public DateTimeFormatter toFormatter() {
     public DateTimePrinter toPrinter() {
         Object f = getFormatter();
         if (isPrinter(f)) {
-            return (DateTimePrinter) f;
+            InternalPrinter ip = (InternalPrinter) f;
+            return InternalPrinterDateTimePrinter.of(ip);
         }
         throw new UnsupportedOperationException("Printing is not supported");
     }
@@ -216,7 +216,7 @@ public DateTimeFormatterBuilder append(DateTimeFormatter formatter) {
         if (formatter == null) {
             throw new IllegalArgumentException("No formatter supplied");
         }
-        return append0(formatter.getPrinter(), formatter.getParser());
+        return append0(formatter.getPrinter0(), formatter.getParser());
     }
 
     /**
@@ -235,7 +235,7 @@ public DateTimeFormatterBuilder append(DateTimeFormatter formatter) {
      */
     public DateTimeFormatterBuilder append(DateTimePrinter printer) {
         checkPrinter(printer);
-        return append0(printer, null);
+        return append0(DateTimePrinterInternalPrinter.of(printer), null);
     }
 
     /**
@@ -274,7 +274,7 @@ public DateTimeFormatterBuilder append(DateTimeParser parser) {
     public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser parser) {
         checkPrinter(printer);
         checkParser(parser);
-        return append0(printer, parser);
+        return append0(DateTimePrinterInternalPrinter.of(printer), parser);
     }
 
     /**
@@ -312,7 +312,7 @@ public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[]
             if (parsers[0] == null) {
                 throw new IllegalArgumentException("No parser supplied");
             }
-            return append0(printer, parsers[0]);
+            return append0(DateTimePrinterInternalPrinter.of(printer), parsers[0]);
         }
 
         DateTimeParser[] copyOfParsers = new DateTimeParser[length];
@@ -324,7 +324,7 @@ public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[]
         }
         copyOfParsers[i] = parsers[i];
 
-        return append0(printer, new MatchingParser(copyOfParsers));
+        return append0(DateTimePrinterInternalPrinter.of(printer), new MatchingParser(copyOfParsers));
     }
 
     /**
@@ -378,7 +378,7 @@ private DateTimeFormatterBuilder append0(Object element) {
     }
 
     private DateTimeFormatterBuilder append0(
-            DateTimePrinter printer, DateTimeParser parser) {
+            InternalPrinter printer, DateTimeParser parser) {
         iFormatter = null;
         iElementPairs.add(printer);
         iElementPairs.add(parser);
@@ -1161,7 +1161,7 @@ private Object getFormatter() {
     }
 
     private boolean isPrinter(Object f) {
-        if (f instanceof DateTimePrinter) {
+        if (f instanceof InternalPrinter) {
             if (f instanceof Composite) {
                 return ((Composite)f).isPrinter();
             }
@@ -1184,27 +1184,15 @@ private boolean isFormatter(Object f) {
         return (isPrinter(f) || isParser(f));
     }
 
-    static void appendUnknownString(StringBuffer buf, int len) {
-        for (int i = len; --i >= 0;) {
-            buf.append('\ufffd');
-        }
-    }
-
     static void appendUnknownString(Appendable appendable, int len) throws IOException {
         for (int i = len; --i >= 0;) {
             appendable.append('\ufffd');
         }
     }
 
-    static void printUnknownString(Writer out, int len) throws IOException {
-        for (int i = len; --i >= 0;) {
-            out.write('\ufffd');
-        }
-    }
-
     //-----------------------------------------------------------------------
     static class CharacterLiteral
-            implements DateTimePrinter, DateTimeParser {
+            implements InternalPrinter, DateTimeParser {
 
         private final char iValue;
 
@@ -1217,32 +1205,12 @@ public int estimatePrintedLength() {
             return 1;
         }
 
-        public void printTo(
-                StringBuffer buf, long instant, Chronology chrono,
-                int displayOffset, DateTimeZone displayZone, Locale locale) {
-            buf.append(iValue);
-        }
-
-        public void printTo(
-                Writer out, long instant, Chronology chrono,
-                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
-            out.write(iValue);
-        }
-
         public void printTo(
                 Appendable appendable, long instant, Chronology chrono,
                 int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
             appendable.append(iValue);
         }
 
-        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
-            buf.append(iValue);
-        }
-
-        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
-            out.write(iValue);
-        }
-
         public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
             appendable.append(iValue);
         }
@@ -1277,7 +1245,7 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
 
     //-----------------------------------------------------------------------
     static class StringLiteral
-            implements DateTimePrinter, DateTimeParser {
+            implements InternalPrinter, DateTimeParser {
 
         private final String iValue;
 
@@ -1290,32 +1258,12 @@ public int estimatePrintedLength() {
             return iValue.length();
         }
 
-        public void printTo(
-                StringBuffer buf, long instant, Chronology chrono,
-                int displayOffset, DateTimeZone displayZone, Locale locale) {
-            buf.append(iValue);
-        }
-
-        public void printTo(
-                Writer out, long instant, Chronology chrono,
-                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
-            out.write(iValue);
-        }
-
         public void printTo(
                 Appendable appendable, long instant, Chronology chrono,
                 int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
             appendable.append(iValue);
         }
 
-        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
-            buf.append(iValue);
-        }
-
-        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
-            out.write(iValue);
-        }
-
         public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
             appendable.append(iValue);
         }
@@ -1334,7 +1282,7 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
 
     //-----------------------------------------------------------------------
     static abstract class NumberFormatter
-            implements DateTimePrinter, DateTimeParser {
+            implements InternalPrinter, DateTimeParser {
         protected final DateTimeFieldType iFieldType;
         protected final int iMaxParsedDigits;
         protected final boolean iSigned;
@@ -1430,27 +1378,6 @@ public int estimatePrintedLength() {
             return iMaxParsedDigits;
         }
 
-        public void printTo(
-                StringBuffer buf, long instant, Chronology chrono,
-                int displayOffset, DateTimeZone displayZone, Locale locale) {
-            try {
-                printTo((Appendable)buf, instant, chrono, displayOffset, displayZone, locale);
-            } catch (IOException e) {
-                // StringBuffer does not throw IOException
-            }
-        }
-
-        public void printTo(
-                Writer out, long instant, Chronology chrono,
-                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
-            try {
-                DateTimeField field = iFieldType.getField(chrono);
-                FormatUtils.writeUnpaddedInteger(out, field.get(instant));
-            } catch (RuntimeException e) {
-                out.write('\ufffd');
-            }
-        }
-
         public void printTo(
                 Appendable appendable, long instant, Chronology chrono,
                 int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
@@ -1462,26 +1389,6 @@ public void printTo(
             }
         }
 
-        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
-            try {
-                printTo((Appendable)buf, partial, locale);
-            } catch (IOException e) {
-                // StringBuffer does not throw IOException
-            }
-        }
-
-        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
-            if (partial.isSupported(iFieldType)) {
-                try {
-                    FormatUtils.writeUnpaddedInteger(out, partial.get(iFieldType));
-                } catch (RuntimeException e) {
-                    out.write('\ufffd');
-                }
-            } else {
-                out.write('\ufffd');
-            }
-        }
-
         public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
             if (partial.isSupported(iFieldType)) {
                 try {
@@ -1511,27 +1418,6 @@ public int estimatePrintedLength() {
             return iMaxParsedDigits;
         }
 
-        public void printTo(
-                StringBuffer buf, long instant, Chronology chrono,
-                int displayOffset, DateTimeZone displayZone, Locale locale) {
-            try {
-                printTo((Appendable)buf, instant, chrono, displayOffset, displayZone, locale);
-            } catch (IOException e) {
-                // StringBuffer does not throw IOException
-            }
-        }
-
-        public void printTo(
-                Writer out, long instant, Chronology chrono,
-                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
-            try {
-                DateTimeField field = iFieldType.getField(chrono);
-                FormatUtils.writePaddedInteger(out, field.get(instant), iMinPrintedDigits);
-            } catch (RuntimeException e) {
-                printUnknownString(out, iMinPrintedDigits);
-            }
-        }
-
         public void printTo(
                 Appendable appendable, long instant, Chronology chrono,
                 int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
@@ -1543,26 +1429,6 @@ public void printTo(
             }
         }
 
-        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
-            try {
-                printTo((Appendable)buf, partial, locale);
-            } catch (IOException e) {
-                // StringBuffer does not throw IOException
-            }
-        }
-
-        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
-            if (partial.isSupported(iFieldType)) {
-                try {
-                    FormatUtils.writePaddedInteger(out, partial.get(iFieldType), iMinPrintedDigits);
-                } catch (RuntimeException e) {
-                    printUnknownString(out, iMinPrintedDigits);
-                }
-            } else {
-                printUnknownString(out, iMinPrintedDigits);
-            }
-        }
-
         public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
             if (partial.isSupported(iFieldType)) {
                 try {
@@ -1610,7 +1476,7 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
 
     //-----------------------------------------------------------------------
     static class TwoDigitYear
-            implements DateTimePrinter, DateTimeParser {
+            implements InternalPrinter, DateTimeParser {
 
         /** The field to print/parse. */
         private final DateTimeFieldType iType;
@@ -1732,30 +1598,6 @@ public int estimatePrintedLength() {
             return 2;
         }
 
-        public void printTo(
-                StringBuffer buf, long instant, Chronology chrono,
-                int displayOffset, DateTimeZone displayZone, Locale locale) {
-            int year = getTwoDigitYear(instant, chrono);
-            if (year < 0) {
-                buf.append('\ufffd');
-                buf.append('\ufffd');
-            } else {
-                FormatUtils.appendPaddedInteger(buf, year, 2);
-            }
-        }
-
-        public void printTo(
-                Writer out, long instant, Chronology chrono,
-                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
-            int year = getTwoDigitYear(instant, chrono);
-            if (year < 0) {
-                out.write('\ufffd');
-                out.write('\ufffd');
-            } else {
-                FormatUtils.writePaddedInteger(out, year, 2);
-            }
-        }
-
         public void printTo(
                 Appendable appendable, long instant, Chronology chrono,
                 int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
@@ -1780,26 +1622,6 @@ private int getTwoDigitYear(long instant, Chronology chrono) {
             }
         }
 
-        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
-            int year = getTwoDigitYear(partial);
-            if (year < 0) {
-                buf.append('\ufffd');
-                buf.append('\ufffd');
-            } else {
-                FormatUtils.appendPaddedInteger(buf, year, 2);
-            }
-        }
-
-        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
-            int year = getTwoDigitYear(partial);
-            if (year < 0) {
-                out.write('\ufffd');
-                out.write('\ufffd');
-            } else {
-                FormatUtils.writePaddedInteger(out, year, 2);
-            }
-        }
-
         public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
             int year = getTwoDigitYear(partial);
             if (year < 0) {
@@ -1826,7 +1648,7 @@ private int getTwoDigitYear(ReadablePartial partial) {
 
     //-----------------------------------------------------------------------
     static class TextField
-            implements DateTimePrinter, DateTimeParser {
+            implements InternalPrinter, DateTimeParser {
 
         private static Map<Locale, Map<DateTimeFieldType, Object[]>> cParseCache =
                     new ConcurrentHashMap<Locale, Map<DateTimeFieldType, Object[]>>();
@@ -1843,26 +1665,6 @@ public int estimatePrintedLength() {
             return iShort ? 6 : 20;
         }
 
-        public void printTo(
-                StringBuffer buf, long instant, Chronology chrono,
-                int displayOffset, DateTimeZone displayZone, Locale locale) {
-            try {
-                buf.append(print(instant, chrono, locale));
-            } catch (RuntimeException e) {
-                buf.append('\ufffd');
-            }
-        }
-
-        public void printTo(
-                Writer out, long instant, Chronology chrono,
-                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
-            try {
-                out.write(print(instant, chrono, locale));
-            } catch (RuntimeException e) {
-                out.write('\ufffd');
-            }
-        }
-
         public void printTo(
                 Appendable appendable, long instant, Chronology chrono,
                 int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
@@ -1873,22 +1675,6 @@ public void printTo(
             }
         }
 
-        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
-            try {
-                buf.append(print(partial, locale));
-            } catch (RuntimeException e) {
-                buf.append('\ufffd');
-            }
-        }
-
-        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
-            try {
-                out.write(print(partial, locale));
-            } catch (RuntimeException e) {
-                out.write('\ufffd');
-            }
-        }
-
         public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
             try {
                 appendable.append(print(partial, locale));
@@ -1984,7 +1770,7 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
 
     //-----------------------------------------------------------------------
     static class Fraction
-            implements DateTimePrinter, DateTimeParser {
+            implements InternalPrinter, DateTimeParser {
 
         private final DateTimeFieldType iFieldType;
         protected int iMinDigits;
@@ -2005,54 +1791,20 @@ public int estimatePrintedLength() {
             return iMaxDigits;
         }
 
-        public void printTo(
-                StringBuffer buf, long instant, Chronology chrono,
-                int displayOffset, DateTimeZone displayZone, Locale locale) {
-            try {
-                printTo(buf, null, instant, chrono);
-            } catch (IOException e) {
-                // StringBuffer does not throw IOException
-            }
-        }
-
-        public void printTo(
-                Writer out, long instant, Chronology chrono,
-                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
-            printTo(null, out, instant, chrono);
-        }
-
         public void printTo(
                 Appendable appendable, long instant, Chronology chrono,
                 int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
-            printTo(appendable, null, instant, chrono);
-        }
-
-        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
-            // removed check whether field is supported, as input field is typically
-            // secondOfDay which is unsupported by TimeOfDay
-            long millis = partial.getChronology().set(partial, 0L);
-            try {
-                printTo(buf, null, millis, partial.getChronology());
-            } catch (IOException e) {
-                // StringBuffer does not throw IOException
-            }
-        }
-
-        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
-            // removed check whether field is supported, as input field is typically
-            // secondOfDay which is unsupported by TimeOfDay
-            long millis = partial.getChronology().set(partial, 0L);
-            printTo(null, out, millis, partial.getChronology());
+            printTo(appendable, instant, chrono);
         }
 
         public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
             // removed check whether field is supported, as input field is typically
             // secondOfDay which is unsupported by TimeOfDay
             long millis = partial.getChronology().set(partial, 0L);
-            printTo(appendable, null , millis, partial.getChronology());
+            printTo(appendable, millis, partial.getChronology());
         }
 
-        protected void printTo(Appendable appendable, Writer out, long instant, Chronology chrono)
+        protected void printTo(Appendable appendable, long instant, Chronology chrono)
             throws IOException
         {
             DateTimeField field = iFieldType.getField(chrono);
@@ -2062,23 +1814,13 @@ protected void printTo(Appendable appendable, Writer out, long instant, Chronolo
             try {
                 fraction = field.remainder(instant);
             } catch (RuntimeException e) {
-                if (appendable != null) {
-                    appendUnknownString(appendable, minDigits);
-                } else {
-                    printUnknownString(out, minDigits);
-                }
+                appendUnknownString(appendable, minDigits);
                 return;
             }
 
             if (fraction == 0) {
-                if (appendable != null) {
-                    while (--minDigits >= 0) {
-                        appendable.append('0');
-                    }
-                } else {
-                    while (--minDigits >= 0) {
-                        out.write('0');
-                    }
+                while (--minDigits >= 0) {
+                    appendable.append('0');
                 }
                 return;
             }
@@ -2097,11 +1839,7 @@ protected void printTo(Appendable appendable, Writer out, long instant, Chronolo
             int length = str.length();
             int digits = maxDigits;
             while (length < digits) {
-                if (appendable != null) {
-                    appendable.append('0');
-                } else {
-                    out.write('0');
-                }
+                appendable.append('0');
                 minDigits--;
                 digits--;
             }
@@ -2116,24 +1854,14 @@ protected void printTo(Appendable appendable, Writer out, long instant, Chronolo
                     length--;
                 }
                 if (length < str.length()) {
-                    if (appendable != null) {
-                        for (int i=0; i<length; i++) {
-                            appendable.append(str.charAt(i));
-                        }
-                    } else {
-                        for (int i=0; i<length; i++) {
-                            out.write(str.charAt(i));
-                        }
+                    for (int i=0; i<length; i++) {
+                        appendable.append(str.charAt(i));
                     }
                     return;
                 }
             }
 
-            if (appendable != null) {
-                appendable.append(str);
-            } else {
-                out.write(str);
-            }
+            appendable.append(str);
         }
         
         private long[] getFractionData(long fraction, DateTimeField field) {
@@ -2218,7 +1946,7 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
 
     //-----------------------------------------------------------------------
     static class TimeZoneOffset
-            implements DateTimePrinter, DateTimeParser {
+            implements InternalPrinter, DateTimeParser {
 
         private final String iZeroOffsetPrintText;
         private final String iZeroOffsetParseText;
@@ -2256,75 +1984,6 @@ public int estimatePrintedLength() {
             return est;
         }
 
-        public void printTo(
-                StringBuffer buf, long instant, Chronology chrono,
-                int displayOffset, DateTimeZone displayZone, Locale locale) {
-            try {
-                printTo((Appendable) buf, instant, chrono, displayOffset, displayZone, locale);
-            } catch (IOException e) {
-                // StringBuffer does not throw IOException
-            }
-        }
-
-        public void printTo(
-                Writer out, long instant, Chronology chrono,
-                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
-            if (displayZone == null) {
-                return;  // no zone
-            }
-            if (displayOffset == 0 && iZeroOffsetPrintText != null) {
-                out.write(iZeroOffsetPrintText);
-                return;
-            }
-            if (displayOffset >= 0) {
-                out.write('+');
-            } else {
-                out.write('-');
-                displayOffset = -displayOffset;
-            }
-
-            int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR;
-            FormatUtils.writePaddedInteger(out, hours, 2);
-            if (iMaxFields == 1) {
-                return;
-            }
-            displayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;
-            if (displayOffset == 0 && iMinFields == 1) {
-                return;
-            }
-
-            int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE;
-            if (iShowSeparators) {
-                out.write(':');
-            }
-            FormatUtils.writePaddedInteger(out, minutes, 2);
-            if (iMaxFields == 2) {
-                return;
-            }
-            displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;
-            if (displayOffset == 0 && iMinFields == 2) {
-                return;
-            }
-
-            int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND;
-            if (iShowSeparators) {
-                out.write(':');
-            }
-            FormatUtils.writePaddedInteger(out, seconds, 2);
-            if (iMaxFields == 3) {
-                return;
-            }
-            displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;
-            if (displayOffset == 0 && iMinFields == 3) {
-                return;
-            }
-
-            if (iShowSeparators) {
-                out.write('.');
-            }
-            FormatUtils.writePaddedInteger(out, displayOffset, 3);
-        }
-
         public void printTo(
                 Appendable buf, long instant, Chronology chrono,
                 int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
@@ -2384,14 +2043,6 @@ public void printTo(
             FormatUtils.appendPaddedInteger(buf, displayOffset, 3);
         }
 
-        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
-            // no zone info
-        }
-
-        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
-            // no zone info
-        }
-
         public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
             // no zone info
         }
@@ -2591,7 +2242,7 @@ private int digitCount(String text, int position, int amount) {
 
     //-----------------------------------------------------------------------
     static class TimeZoneName
-            implements DateTimePrinter, DateTimeParser {
+            implements InternalPrinter, DateTimeParser {
 
         static final int LONG_NAME = 0;
         static final int SHORT_NAME = 1;
@@ -2609,18 +2260,6 @@ public int estimatePrintedLength() {
             return (iType == SHORT_NAME ? 4 : 20);
         }
 
-        public void printTo(
-                StringBuffer buf, long instant, Chronology chrono,
-                int displayOffset, DateTimeZone displayZone, Locale locale) {
-            buf.append(print(instant - displayOffset, displayZone, locale));
-        }
-
-        public void printTo(
-                Writer out, long instant, Chronology chrono,
-                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
-            out.write(print(instant - displayOffset, displayZone, locale));
-        }
-
         public void printTo(
                 Appendable appendable, long instant, Chronology chrono,
                 int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
@@ -2640,14 +2279,6 @@ private String print(long instant, DateTimeZone displayZone, Locale locale) {
             return "";
         }
 
-        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
-            // no zone info
-        }
-
-        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
-            // no zone info
-        }
-
         public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
             // no zone info
         }
@@ -2678,7 +2309,7 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
 
     //-----------------------------------------------------------------------
     static enum TimeZoneId
-            implements DateTimePrinter, DateTimeParser {
+            implements InternalPrinter, DateTimeParser {
 
         INSTANCE;
         static final Set<String> ALL_IDS = DateTimeZone.getAvailableIDs();
@@ -2695,32 +2326,12 @@ public int estimatePrintedLength() {
             return MAX_LENGTH;
         }
 
-        public void printTo(
-                StringBuffer buf, long instant, Chronology chrono,
-                int displayOffset, DateTimeZone displayZone, Locale locale) {
-            buf.append(displayZone != null ? displayZone.getID() : "");
-        }
-
-        public void printTo(
-                Writer out, long instant, Chronology chrono,
-                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
-            out.write(displayZone != null ? displayZone.getID() : "");
-        }
-
         public void printTo(
                 Appendable appendable, long instant, Chronology chrono,
                 int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
             appendable.append(displayZone != null ? displayZone.getID() : "");
         }
 
-        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
-            // no zone info
-        }
-
-        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
-            // no zone info
-        }
-
         public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
             // no zone info
         }
@@ -2749,9 +2360,9 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
 
     //-----------------------------------------------------------------------
     static class Composite
-            implements DateTimePrinter, DateTimeParser {
+            implements InternalPrinter, DateTimeParser {
 
-        private final DateTimePrinter[] iPrinters;
+        private final InternalPrinter[] iPrinters;
         private final DateTimeParser[] iParsers;
 
         private final int iPrintedLengthEstimate;
@@ -2770,10 +2381,10 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
                 iPrintedLengthEstimate = 0;
             } else {
                 int size = printerList.size();
-                iPrinters = new DateTimePrinter[size];
+                iPrinters = new InternalPrinter[size];
                 int printEst = 0;
                 for (int i=0; i<size; i++) {
-                    DateTimePrinter printer = (DateTimePrinter) printerList.get(i);
+                    InternalPrinter printer = (InternalPrinter) printerList.get(i);
                     printEst += printer.estimatePrintedLength();
                     iPrinters[i] = printer;
                 }
@@ -2800,48 +2411,10 @@ public int estimatePrintedLength() {
             return iPrintedLengthEstimate;
         }
 
-        public void printTo(
-                StringBuffer buf, long instant, Chronology chrono,
-                int displayOffset, DateTimeZone displayZone, Locale locale) {
-            DateTimePrinter[] elements = iPrinters;
-            if (elements == null) {
-                throw new UnsupportedOperationException();
-            }
-
-            if (locale == null) {
-                // Guard against default locale changing concurrently.
-                locale = Locale.getDefault();
-            }
-
-            int len = elements.length;
-            for (int i = 0; i < len; i++) {
-                elements[i].printTo(buf, instant, chrono, displayOffset, displayZone, locale);
-            }
-        }
-
-        public void printTo(
-                Writer out, long instant, Chronology chrono,
-                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
-            DateTimePrinter[] elements = iPrinters;
-            if (elements == null) {
-                throw new UnsupportedOperationException();
-            }
-
-            if (locale == null) {
-                // Guard against default locale changing concurrently.
-                locale = Locale.getDefault();
-            }
-
-            int len = elements.length;
-            for (int i = 0; i < len; i++) {
-                elements[i].printTo(out, instant, chrono, displayOffset, displayZone, locale);
-            }
-        }
-
         public void printTo(
                 Appendable appendable, long instant, Chronology chrono,
                 int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
-            DateTimePrinter[] elements = iPrinters;
+            InternalPrinter[] elements = iPrinters;
             if (elements == null) {
                 throw new UnsupportedOperationException();
             }
@@ -2857,42 +2430,8 @@ public void printTo(
             }
         }
 
-        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
-            DateTimePrinter[] elements = iPrinters;
-            if (elements == null) {
-                throw new UnsupportedOperationException();
-            }
-
-            if (locale == null) {
-                // Guard against default locale changing concurrently.
-                locale = Locale.getDefault();
-            }
-
-            int len = elements.length;
-            for (int i=0; i<len; i++) {
-                elements[i].printTo(buf, partial, locale);
-            }
-        }
-
-        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
-            DateTimePrinter[] elements = iPrinters;
-            if (elements == null) {
-                throw new UnsupportedOperationException();
-            }
-
-            if (locale == null) {
-                // Guard against default locale changing concurrently.
-                locale = Locale.getDefault();
-            }
-
-            int len = elements.length;
-            for (int i=0; i<len; i++) {
-                elements[i].printTo(out, partial, locale);
-            }
-        }
-
         public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
-            DateTimePrinter[] elements = iPrinters;
+            InternalPrinter[] elements = iPrinters;
             if (elements == null) {
                 throw new UnsupportedOperationException();
             }
diff --git a/src/main/java/org/joda/time/format/DateTimePrinter.java b/src/main/java/org/joda/time/format/DateTimePrinter.java
index 5a3687f6b..c2e80493a 100644
--- a/src/main/java/org/joda/time/format/DateTimePrinter.java
+++ b/src/main/java/org/joda/time/format/DateTimePrinter.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2005 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -82,21 +82,6 @@ void printTo(StringBuffer buf, long instant, Chronology chrono,
     void printTo(Writer out, long instant, Chronology chrono,
                  int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException;
 
-    /**
-     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
-     * using the given Chronology.
-     *
-     * @param appendable  formatted instant is appended to, not null
-     * @param instant  millis since 1970-01-01T00:00:00Z
-     * @param chrono  the chronology to use, not null
-     * @param displayOffset  if a time zone offset is printed, force it to use
-     * this millisecond value
-     * @param displayZone  the time zone to use, null means local time
-     * @param locale  the locale to use, null means default locale
-      * @since 2.4
-     */
-    void printTo(Appendable appendable, long instant, Chronology chrono,
-                 int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException;
     //-----------------------------------------------------------------------
     /**
      * Prints a ReadablePartial.
@@ -116,14 +101,4 @@ void printTo(Appendable appendable, long instant, Chronology chrono,
      */
     void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException;
 
-    /**
-     * Prints a ReadablePartial.
-     *
-     * @param appendable  formatted instant is appended to, not null
-     * @param partial  partial to format, not null
-     * @param locale  the locale to use, null means default locale
-     * @since 2.4
-     */
-    void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException;
-
 }
diff --git a/src/main/java/org/joda/time/format/DateTimePrinterInternalPrinter.java b/src/main/java/org/joda/time/format/DateTimePrinterInternalPrinter.java
new file mode 100644
index 000000000..6b6c6f30e
--- /dev/null
+++ b/src/main/java/org/joda/time/format/DateTimePrinterInternalPrinter.java
@@ -0,0 +1,89 @@
+/*
+ *  Copyright 2001-2014 Stephen Colebourne
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.joda.time.format;
+
+import java.io.IOException;
+import java.io.Writer;
+import java.util.Locale;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeZone;
+import org.joda.time.ReadablePartial;
+
+/**
+ * Adapter between old and new printer interface.
+ *
+ * @author Stephen Colebourne
+ * @since 2.4
+ */
+class DateTimePrinterInternalPrinter implements InternalPrinter {
+    
+    private final DateTimePrinter underlying;
+
+    static InternalPrinter of(DateTimePrinter underlying) {
+        if (underlying instanceof InternalPrinterDateTimePrinter) {
+            return (InternalPrinter) underlying;
+        }
+        if (underlying == null) {
+            return null;
+        }
+        return new DateTimePrinterInternalPrinter(underlying);
+    }
+
+    private DateTimePrinterInternalPrinter(DateTimePrinter underlying) {
+        this.underlying = underlying;
+    }
+
+    //-----------------------------------------------------------------------
+    DateTimePrinter getUnderlying() {
+        return underlying;
+    }
+
+    //-----------------------------------------------------------------------
+    public int estimatePrintedLength() {
+        return underlying.estimatePrintedLength();
+    }
+
+    public void printTo(Appendable appendable, long instant, Chronology chrono, int displayOffset,
+                    DateTimeZone displayZone, Locale locale) throws IOException {
+        if (appendable instanceof StringBuffer) {
+            StringBuffer buf = (StringBuffer) appendable;
+            underlying.printTo(buf, instant, chrono, displayOffset, displayZone, locale);
+        }
+        if (appendable instanceof Writer) {
+            Writer out = (Writer) appendable;
+            underlying.printTo(out, instant, chrono, displayOffset, displayZone, locale);
+        }
+        StringBuffer buf = new StringBuffer(estimatePrintedLength());
+        underlying.printTo(buf, instant, chrono, displayOffset, displayZone, locale);
+        appendable.append(buf);
+    }
+
+    public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
+        if (appendable instanceof StringBuffer) {
+            StringBuffer buf = (StringBuffer) appendable;
+            underlying.printTo(buf, partial, locale);
+        }
+        if (appendable instanceof Writer) {
+            Writer out = (Writer) appendable;
+            underlying.printTo(out, partial, locale);
+        }
+        StringBuffer buf = new StringBuffer(estimatePrintedLength());
+        underlying.printTo(buf, partial, locale);
+        appendable.append(buf);
+    }
+
+}
diff --git a/src/main/java/org/joda/time/format/FormatUtils.java b/src/main/java/org/joda/time/format/FormatUtils.java
index 5bd32cbfb..291221956 100644
--- a/src/main/java/org/joda/time/format/FormatUtils.java
+++ b/src/main/java/org/joda/time/format/FormatUtils.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2005 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -109,7 +109,7 @@ public static void appendPaddedInteger(Appendable appenadble, int value, int siz
             appenadble.append(Integer.toString(value));
         }
     }
-    
+
     /**
      * Converts an integer to a string, prepended with a variable amount of '0'
      * pad characters, and appends it to the given buffer.
diff --git a/src/main/java/org/joda/time/format/InternalPrinter.java b/src/main/java/org/joda/time/format/InternalPrinter.java
new file mode 100644
index 000000000..8613cb3ae
--- /dev/null
+++ b/src/main/java/org/joda/time/format/InternalPrinter.java
@@ -0,0 +1,68 @@
+/*
+ *  Copyright 2001-2014 Stephen Colebourne
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.joda.time.format;
+
+import java.io.IOException;
+import java.util.Locale;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeZone;
+import org.joda.time.ReadablePartial;
+
+/**
+ * Internal interface for creating textual representations of datetimes.
+ * <p>
+ * This has been separated from {@link DateTimePrinter} to avoid code duplication.
+ *
+ * @author Stephen Colebourne
+ * @since 2.4
+ */
+interface InternalPrinter {
+
+    /**
+     * Returns the expected maximum number of characters produced.
+     * The actual amount should rarely exceed this estimate.
+     * 
+     * @return the estimated length
+     */
+    int estimatePrintedLength();
+
+    //-----------------------------------------------------------------------
+    /**
+     * Prints an instant from milliseconds since 1970-01-01T00:00:00Z,
+     * using the given Chronology.
+     *
+     * @param appendable  formatted instant is appended to, not null
+     * @param instant  millis since 1970-01-01T00:00:00Z
+     * @param chrono  the chronology to use, not null
+     * @param displayOffset  if a time zone offset is printed, force it to use
+     * this millisecond value
+     * @param displayZone  the time zone to use, null means local time
+     * @param locale  the locale to use, null means default locale
+     */
+    void printTo(Appendable appendable, long instant, Chronology chrono,
+                 int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException;
+
+    /**
+     * Prints a ReadablePartial.
+     *
+     * @param appendable  formatted instant is appended to, not null
+     * @param partial  partial to format, not null
+     * @param locale  the locale to use, null means default locale
+     */
+    void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException;
+
+}
diff --git a/src/main/java/org/joda/time/format/InternalPrinterDateTimePrinter.java b/src/main/java/org/joda/time/format/InternalPrinterDateTimePrinter.java
new file mode 100644
index 000000000..fbd3d3b22
--- /dev/null
+++ b/src/main/java/org/joda/time/format/InternalPrinterDateTimePrinter.java
@@ -0,0 +1,106 @@
+/*
+ *  Copyright 2001-2014 Stephen Colebourne
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.joda.time.format;
+
+import java.io.IOException;
+import java.io.Writer;
+import java.util.Locale;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeZone;
+import org.joda.time.ReadablePartial;
+
+/**
+ * Adapter between old and new printer interface.
+ *
+ * @author Stephen Colebourne
+ * @since 2.4
+ */
+class InternalPrinterDateTimePrinter implements DateTimePrinter, InternalPrinter {
+    
+    private final InternalPrinter underlying;
+
+    static DateTimePrinter of(InternalPrinter underlying) {
+        if (underlying instanceof DateTimePrinterInternalPrinter) {
+            return ((DateTimePrinterInternalPrinter) underlying).getUnderlying();
+        }
+        if (underlying instanceof DateTimePrinter) {
+            return (DateTimePrinter) underlying;
+        }
+        if (underlying == null) {
+            return null;
+        }
+        return new InternalPrinterDateTimePrinter(underlying);
+    }
+
+    private InternalPrinterDateTimePrinter(InternalPrinter underlying) {
+        this.underlying = underlying;
+    }
+
+    //-----------------------------------------------------------------------
+    public int estimatePrintedLength() {
+        return underlying.estimatePrintedLength();
+    }
+
+    public void printTo(StringBuffer buf, long instant, Chronology chrono,
+                    int displayOffset, DateTimeZone displayZone, Locale locale) {
+        try {
+            underlying.printTo(buf, instant, chrono, displayOffset, displayZone, locale);
+        } catch (IOException ex) {
+            // StringBuffer does not throw IOException
+        }
+    }
+
+    public void printTo(Writer out, long instant, Chronology chrono,
+                    int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
+        underlying.printTo(out, instant, chrono, displayOffset, displayZone, locale);
+    }
+
+    public void printTo(Appendable appendable, long instant, Chronology chrono, int displayOffset,
+                    DateTimeZone displayZone, Locale locale) throws IOException {
+        underlying.printTo(appendable, instant, chrono, displayOffset, displayZone, locale);
+    }
+
+    public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
+        try {
+            underlying.printTo(buf, partial, locale);
+        } catch (IOException ex) {
+            // StringBuffer does not throw IOException
+        }
+    }
+
+    public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
+        underlying.printTo(out, partial, locale);
+    }
+
+    public void printTo(Appendable appendable, ReadablePartial partial, Locale locale) throws IOException {
+        underlying.printTo(appendable, partial, locale);
+    }
+
+    //-----------------------------------------------------------------------
+    @Override
+    public boolean equals(Object obj) {
+        if (obj == this) {
+            return true;
+        }
+        if (obj instanceof InternalPrinterDateTimePrinter) {
+            InternalPrinterDateTimePrinter other = (InternalPrinterDateTimePrinter) obj;
+            return underlying.equals(other.underlying);
+        }
+        return false;
+    }
+
+}
diff --git a/src/test/java/org/joda/time/format/TestDateTimeFormatStyle.java b/src/test/java/org/joda/time/format/TestDateTimeFormatStyle.java
index 282010b01..5b143f97c 100644
--- a/src/test/java/org/joda/time/format/TestDateTimeFormatStyle.java
+++ b/src/test/java/org/joda/time/format/TestDateTimeFormatStyle.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2005 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -367,4 +367,9 @@ public void testForStyle_mediumFullDateTime() throws Exception {
         assertEquals(expect, f.withLocale(FRANCE).print(dt));
     }
 
+    public void test_patternForStyle() throws Exception {
+        String format = DateTimeFormat.patternForStyle("MF", UK);
+        assertNotNull(format);
+    }
+
 }
diff --git a/src/test/java/org/joda/time/format/TestDateTimeFormatter.java b/src/test/java/org/joda/time/format/TestDateTimeFormatter.java
index 5d104df27..9d6df3e94 100644
--- a/src/test/java/org/joda/time/format/TestDateTimeFormatter.java
+++ b/src/test/java/org/joda/time/format/TestDateTimeFormatter.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2011 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -348,7 +348,7 @@ public void testPrinterParserMethods() {
             fail();
         } catch (UnsupportedOperationException ex) {}
         
-        f2 = new DateTimeFormatter(null, f.getParser());
+        f2 = new DateTimeFormatter((InternalPrinter) null, f.getParser());
         assertEquals(null, f2.getPrinter());
         assertEquals(f.getParser(), f2.getParser());
         assertEquals(false, f2.isPrinter());

From f17223a4974f3e55097456441d7386735c97ffd6 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Thu, 13 Feb 2014 12:30:29 +0000
Subject: [PATCH 54/86] Bump clirr comparison version

---
 pom.xml | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/pom.xml b/pom.xml
index 8d535b88b..16e8ec9c3 100644
--- a/pom.xml
+++ b/pom.xml
@@ -385,7 +385,7 @@
         <artifactId>clirr-maven-plugin</artifactId>
         <version>2.3</version>
         <configuration>
-          <comparisonVersion>2.2</comparisonVersion>
+          <comparisonVersion>2.3</comparisonVersion>
           <minSeverity>info</minSeverity>
           <logResults>true</logResults>
         </configuration>

From 0ddd67dd5c03bc6957e819ea1e72be1bc60b69f3 Mon Sep 17 00:00:00 2001
From: Fabian Lange <lange.fabian@gmail.com>
Date: Mon, 17 Feb 2014 09:44:59 +0100
Subject: [PATCH 55/86] Avoid locking as much as possible related to Chronology
 caching.

All Chronology classes used synchronising on the chronology cache, which
leads to degraded performance once the cache has a high hit ratio.
This patch narrows the synchronised path onto the updating part by using
ConcurrentHashMap. The remaining synchronisation ensures identity and
prevents lost updates, which might be acceptable but are not strictly
backwards compatible.
---
 .../joda/time/chrono/BuddhistChronology.java  | 27 ++++-----
 .../joda/time/chrono/CopticChronology.java    | 59 +++++++++---------
 .../joda/time/chrono/EthiopicChronology.java  | 60 ++++++++++---------
 .../joda/time/chrono/GregorianChronology.java | 47 ++++++++-------
 .../org/joda/time/chrono/ISOChronology.java   | 16 ++---
 .../joda/time/chrono/IslamicChronology.java   | 51 +++++++++-------
 .../joda/time/chrono/JulianChronology.java    | 47 ++++++++-------
 7 files changed, 166 insertions(+), 141 deletions(-)

diff --git a/src/main/java/org/joda/time/chrono/BuddhistChronology.java b/src/main/java/org/joda/time/chrono/BuddhistChronology.java
index fc6a1ec43..21cb0e3c0 100644
--- a/src/main/java/org/joda/time/chrono/BuddhistChronology.java
+++ b/src/main/java/org/joda/time/chrono/BuddhistChronology.java
@@ -15,8 +15,7 @@
  */
 package org.joda.time.chrono;
 
-import java.util.HashMap;
-import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTime;
@@ -70,7 +69,7 @@
     private static final int BUDDHIST_OFFSET = 543;
 
     /** Cache of zone to chronology */
-    private static final Map<DateTimeZone, BuddhistChronology> cCache = new HashMap<DateTimeZone, BuddhistChronology>();
+    private static final ConcurrentHashMap<DateTimeZone, BuddhistChronology> cCache = new ConcurrentHashMap<DateTimeZone, BuddhistChronology>();
 
     /** UTC instance of the chronology */
     private static final BuddhistChronology INSTANCE_UTC = getInstance(DateTimeZone.UTC);
@@ -102,20 +101,20 @@ public static BuddhistChronology getInstance() {
      *
      * @param zone  the time zone to use, null is default
      */
-    public static synchronized BuddhistChronology getInstance(DateTimeZone zone) {
+    public static BuddhistChronology getInstance(DateTimeZone zone) {
         if (zone == null) {
             zone = DateTimeZone.getDefault();
         }
-        BuddhistChronology chrono;
-        synchronized (cCache) {
-            chrono = cCache.get(zone);
-            if (chrono == null) {
-                // First create without a lower limit.
-                chrono = new BuddhistChronology(GJChronology.getInstance(zone, null), null);
-                // Impose lower limit and make another BuddhistChronology.
-                DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);
-                chrono = new BuddhistChronology(LimitChronology.getInstance(chrono, lowerLimit, null), "");
-                cCache.put(zone, chrono);
+        BuddhistChronology chrono = cCache.get(zone);
+        if (chrono == null) {
+            // First create without a lower limit.
+            chrono = new BuddhistChronology(GJChronology.getInstance(zone, null), null);
+            // Impose lower limit and make another BuddhistChronology.
+            DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);
+            chrono = new BuddhistChronology(LimitChronology.getInstance(chrono, lowerLimit, null), "");
+            BuddhistChronology oldChrono = cCache.putIfAbsent(zone, chrono);
+            if (oldChrono != null) {
+                chrono = oldChrono;
             }
         }
         return chrono;
diff --git a/src/main/java/org/joda/time/chrono/CopticChronology.java b/src/main/java/org/joda/time/chrono/CopticChronology.java
index 1d6ee6fe5..c4ee6558e 100644
--- a/src/main/java/org/joda/time/chrono/CopticChronology.java
+++ b/src/main/java/org/joda/time/chrono/CopticChronology.java
@@ -15,8 +15,7 @@
  */
 package org.joda.time.chrono;
 
-import java.util.HashMap;
-import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTime;
@@ -69,7 +68,7 @@
     private static final int MAX_YEAR = 292272708;
 
     /** Cache of zone to chronology arrays */
-    private static final Map<DateTimeZone, CopticChronology[]> cCache = new HashMap<DateTimeZone, CopticChronology[]>();
+    private static final ConcurrentHashMap<DateTimeZone, CopticChronology[]> cCache = new ConcurrentHashMap<DateTimeZone, CopticChronology[]>();
 
     /** Singleton instance of a UTC CopticChronology */
     private static final CopticChronology INSTANCE_UTC;
@@ -120,33 +119,39 @@ public static CopticChronology getInstance(DateTimeZone zone, int minDaysInFirst
             zone = DateTimeZone.getDefault();
         }
         CopticChronology chrono;
-        synchronized (cCache) {
-            CopticChronology[] chronos = cCache.get(zone);
-            if (chronos == null) {
-                chronos = new CopticChronology[7];
-                cCache.put(zone, chronos);
+        CopticChronology[] chronos = cCache.get(zone);
+        if (chronos == null) {
+            chronos = new CopticChronology[7];
+            CopticChronology[] oldChronos = cCache.putIfAbsent(zone, chronos);
+            if (oldChronos != null) {
+                chronos = oldChronos;
             }
-            try {
+        }
+        try {
+            chrono = chronos[minDaysInFirstWeek - 1];
+        } catch (ArrayIndexOutOfBoundsException e) {
+            throw new IllegalArgumentException
+                ("Invalid min days in first week: " + minDaysInFirstWeek);
+        }
+        if (chrono == null) {
+            synchronized (chronos) {
                 chrono = chronos[minDaysInFirstWeek - 1];
-            } catch (ArrayIndexOutOfBoundsException e) {
-                throw new IllegalArgumentException
-                    ("Invalid min days in first week: " + minDaysInFirstWeek);
-            }
-            if (chrono == null) {
-                if (zone == DateTimeZone.UTC) {
-                    // First create without a lower limit.
-                    chrono = new CopticChronology(null, null, minDaysInFirstWeek);
-                    // Impose lower limit and make another CopticChronology.
-                    DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);
-                    chrono = new CopticChronology
-                        (LimitChronology.getInstance(chrono, lowerLimit, null),
-                         null, minDaysInFirstWeek);
-                } else {
-                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);
-                    chrono = new CopticChronology
-                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);
+                if (chrono == null) {
+                    if (zone == DateTimeZone.UTC) {
+                        // First create without a lower limit.
+                        chrono = new CopticChronology(null, null, minDaysInFirstWeek);
+                        // Impose lower limit and make another CopticChronology.
+                        DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);
+                        chrono = new CopticChronology
+                            (LimitChronology.getInstance(chrono, lowerLimit, null),
+                             null, minDaysInFirstWeek);
+                    } else {
+                        chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);
+                        chrono = new CopticChronology
+                            (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);
+                    }
+                    chronos[minDaysInFirstWeek - 1] = chrono;
                 }
-                chronos[minDaysInFirstWeek - 1] = chrono;
             }
         }
         return chrono;
diff --git a/src/main/java/org/joda/time/chrono/EthiopicChronology.java b/src/main/java/org/joda/time/chrono/EthiopicChronology.java
index 22ccd34d8..e4feaaa80 100644
--- a/src/main/java/org/joda/time/chrono/EthiopicChronology.java
+++ b/src/main/java/org/joda/time/chrono/EthiopicChronology.java
@@ -15,8 +15,7 @@
  */
 package org.joda.time.chrono;
 
-import java.util.HashMap;
-import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTime;
@@ -69,7 +68,7 @@
     private static final int MAX_YEAR = 292272984;
 
     /** Cache of zone to chronology arrays */
-    private static final Map<DateTimeZone, EthiopicChronology[]> cCache = new HashMap<DateTimeZone, EthiopicChronology[]>();
+    private static final ConcurrentHashMap<DateTimeZone, EthiopicChronology[]> cCache = new ConcurrentHashMap<DateTimeZone, EthiopicChronology[]>();
 
     /** Singleton instance of a UTC EthiopicChronology */
     private static final EthiopicChronology INSTANCE_UTC;
@@ -120,33 +119,40 @@ public static EthiopicChronology getInstance(DateTimeZone zone, int minDaysInFir
             zone = DateTimeZone.getDefault();
         }
         EthiopicChronology chrono;
-        synchronized (cCache) {
-            EthiopicChronology[] chronos = cCache.get(zone);
-            if (chronos == null) {
-                chronos = new EthiopicChronology[7];
-                cCache.put(zone, chronos);
+        EthiopicChronology[] chronos = cCache.get(zone);
+        if (chronos == null) {
+            chronos = new EthiopicChronology[7];
+            EthiopicChronology[] oldChronos = cCache.putIfAbsent(zone, chronos);
+            if (oldChronos != null) {
+                chronos = oldChronos;
             }
-            try {
+        }
+        try {
+            chrono = chronos[minDaysInFirstWeek - 1];
+        } catch (ArrayIndexOutOfBoundsException e) {
+            throw new IllegalArgumentException
+                ("Invalid min days in first week: " + minDaysInFirstWeek);
+        }
+
+        if (chrono == null) {
+            synchronized (chronos) {
                 chrono = chronos[minDaysInFirstWeek - 1];
-            } catch (ArrayIndexOutOfBoundsException e) {
-                throw new IllegalArgumentException
-                    ("Invalid min days in first week: " + minDaysInFirstWeek);
-            }
-            if (chrono == null) {
-                if (zone == DateTimeZone.UTC) {
-                    // First create without a lower limit.
-                    chrono = new EthiopicChronology(null, null, minDaysInFirstWeek);
-                    // Impose lower limit and make another EthiopicChronology.
-                    DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);
-                    chrono = new EthiopicChronology
-                        (LimitChronology.getInstance(chrono, lowerLimit, null),
-                         null, minDaysInFirstWeek);
-                } else {
-                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);
-                    chrono = new EthiopicChronology
-                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);
+                if (chrono == null) {
+                    if (zone == DateTimeZone.UTC) {
+                        // First create without a lower limit.
+                        chrono = new EthiopicChronology(null, null, minDaysInFirstWeek);
+                        // Impose lower limit and make another EthiopicChronology.
+                        DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);
+                        chrono = new EthiopicChronology
+                            (LimitChronology.getInstance(chrono, lowerLimit, null),
+                             null, minDaysInFirstWeek);
+                    } else {
+                        chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);
+                        chrono = new EthiopicChronology
+                            (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);
+                    }
+                    chronos[minDaysInFirstWeek - 1] = chrono;
                 }
-                chronos[minDaysInFirstWeek - 1] = chrono;
             }
         }
         return chrono;
diff --git a/src/main/java/org/joda/time/chrono/GregorianChronology.java b/src/main/java/org/joda/time/chrono/GregorianChronology.java
index d67e51768..d1066bb9f 100644
--- a/src/main/java/org/joda/time/chrono/GregorianChronology.java
+++ b/src/main/java/org/joda/time/chrono/GregorianChronology.java
@@ -15,8 +15,7 @@
  */
 package org.joda.time.chrono;
 
-import java.util.HashMap;
-import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeConstants;
@@ -65,7 +64,7 @@
     private static final GregorianChronology INSTANCE_UTC;
 
     /** Cache of zone to chronology arrays */
-    private static final Map<DateTimeZone, GregorianChronology[]> cCache = new HashMap<DateTimeZone, GregorianChronology[]>();
+    private static final ConcurrentHashMap<DateTimeZone, GregorianChronology[]> cCache = new ConcurrentHashMap<DateTimeZone, GregorianChronology[]>();
 
     static {
         INSTANCE_UTC = getInstance(DateTimeZone.UTC);
@@ -112,27 +111,33 @@ public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFi
             zone = DateTimeZone.getDefault();
         }
         GregorianChronology chrono;
-        synchronized (cCache) {
-            GregorianChronology[] chronos = cCache.get(zone);
-            if (chronos == null) {
-                chronos = new GregorianChronology[7];
-                cCache.put(zone, chronos);
+        GregorianChronology[] chronos = cCache.get(zone);
+        if (chronos == null) {
+            chronos = new GregorianChronology[7];
+            GregorianChronology[] oldChronos = cCache.putIfAbsent(zone, chronos);
+            if (oldChronos != null) {
+                chronos = oldChronos;
             }
-            try {
+        }
+        try {
+            chrono = chronos[minDaysInFirstWeek - 1];
+        } catch (ArrayIndexOutOfBoundsException e) {
+            throw new IllegalArgumentException
+                ("Invalid min days in first week: " + minDaysInFirstWeek);
+        }
+        if (chrono == null) {
+            synchronized (chronos) {
                 chrono = chronos[minDaysInFirstWeek - 1];
-            } catch (ArrayIndexOutOfBoundsException e) {
-                throw new IllegalArgumentException
-                    ("Invalid min days in first week: " + minDaysInFirstWeek);
-            }
-            if (chrono == null) {
-                if (zone == DateTimeZone.UTC) {
-                    chrono = new GregorianChronology(null, null, minDaysInFirstWeek);
-                } else {
-                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);
-                    chrono = new GregorianChronology
-                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);
+                if (chrono == null) {
+                    if (zone == DateTimeZone.UTC) {
+                        chrono = new GregorianChronology(null, null, minDaysInFirstWeek);
+                    } else {
+                        chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);
+                        chrono = new GregorianChronology
+                            (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);
+                    }
+                    chronos[minDaysInFirstWeek - 1] = chrono;
                 }
-                chronos[minDaysInFirstWeek - 1] = chrono;
             }
         }
         return chrono;
diff --git a/src/main/java/org/joda/time/chrono/ISOChronology.java b/src/main/java/org/joda/time/chrono/ISOChronology.java
index 075dd7bd0..4d3525b5c 100644
--- a/src/main/java/org/joda/time/chrono/ISOChronology.java
+++ b/src/main/java/org/joda/time/chrono/ISOChronology.java
@@ -19,8 +19,7 @@
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
-import java.util.HashMap;
-import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeFieldType;
@@ -60,7 +59,7 @@
     private static final ISOChronology[] cFastCache;
 
     /** Cache of zone to chronology */
-    private static final Map<DateTimeZone, ISOChronology> cCache = new HashMap<DateTimeZone, ISOChronology>();
+    private static final ConcurrentHashMap<DateTimeZone, ISOChronology> cCache = new ConcurrentHashMap<DateTimeZone, ISOChronology>();
     static {
         cFastCache = new ISOChronology[FAST_CACHE_SIZE];
         INSTANCE_UTC = new ISOChronology(GregorianChronology.getInstanceUTC());
@@ -101,11 +100,12 @@ public static ISOChronology getInstance(DateTimeZone zone) {
         if (chrono != null && chrono.getZone() == zone) {
             return chrono;
         }
-        synchronized (cCache) {
-            chrono = cCache.get(zone);
-            if (chrono == null) {
-                chrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));
-                cCache.put(zone, chrono);
+        chrono = cCache.get(zone);
+        if (chrono == null) {
+            chrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));
+            ISOChronology oldChrono = cCache.putIfAbsent(zone, chrono);
+            if (oldChrono != null) {
+                chrono = oldChrono;
             }
         }
         cFastCache[index] = chrono;
diff --git a/src/main/java/org/joda/time/chrono/IslamicChronology.java b/src/main/java/org/joda/time/chrono/IslamicChronology.java
index 9a5dcc853..f4c20de9c 100644
--- a/src/main/java/org/joda/time/chrono/IslamicChronology.java
+++ b/src/main/java/org/joda/time/chrono/IslamicChronology.java
@@ -16,8 +16,7 @@
 package org.joda.time.chrono;
 
 import java.io.Serializable;
-import java.util.HashMap;
-import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTime;
@@ -139,7 +138,7 @@
     private static final long MILLIS_PER_CYCLE = ((19L * 354L + 11L * 355L) * DateTimeConstants.MILLIS_PER_DAY);
 
     /** Cache of zone to chronology arrays */
-    private static final Map<DateTimeZone, IslamicChronology[]> cCache = new HashMap<DateTimeZone, IslamicChronology[]>();
+    private static final ConcurrentHashMap<DateTimeZone, IslamicChronology[]> cCache = new ConcurrentHashMap<DateTimeZone, IslamicChronology[]>();
 
     /** Singleton instance of a UTC IslamicChronology */
     private static final IslamicChronology INSTANCE_UTC;
@@ -193,28 +192,34 @@ public static IslamicChronology getInstance(DateTimeZone zone, LeapYearPatternTy
             zone = DateTimeZone.getDefault();
         }
         IslamicChronology chrono;
-        synchronized (cCache) {
-            IslamicChronology[] chronos = cCache.get(zone);
-            if (chronos == null) {
-                chronos = new IslamicChronology[4];
-                cCache.put(zone, chronos);
+        IslamicChronology[] chronos = cCache.get(zone);
+        if (chronos == null) {
+            chronos = new IslamicChronology[4];
+            IslamicChronology[] oldChronos = cCache.putIfAbsent(zone, chronos);
+            if (oldChronos != null) {
+                chronos = oldChronos;
             }
-            chrono = chronos[leapYears.index];
-            if (chrono == null) {
-                if (zone == DateTimeZone.UTC) {
-                    // First create without a lower limit.
-                    chrono = new IslamicChronology(null, null, leapYears);
-                    // Impose lower limit and make another IslamicChronology.
-                    DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);
-                    chrono = new IslamicChronology(
-                        LimitChronology.getInstance(chrono, lowerLimit, null),
-                         null, leapYears);
-                } else {
-                    chrono = getInstance(DateTimeZone.UTC, leapYears);
-                    chrono = new IslamicChronology
-                        (ZonedChronology.getInstance(chrono, zone), null, leapYears);
+        }
+        chrono = chronos[leapYears.index];
+        if (chrono == null) {
+            synchronized (chronos) {
+                chrono = chronos[leapYears.index];
+                if (chrono == null) {
+                    if (zone == DateTimeZone.UTC) {
+                        // First create without a lower limit.
+                        chrono = new IslamicChronology(null, null, leapYears);
+                        // Impose lower limit and make another IslamicChronology.
+                        DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);
+                        chrono = new IslamicChronology(
+                            LimitChronology.getInstance(chrono, lowerLimit, null),
+                             null, leapYears);
+                    } else {
+                        chrono = getInstance(DateTimeZone.UTC, leapYears);
+                        chrono = new IslamicChronology
+                            (ZonedChronology.getInstance(chrono, zone), null, leapYears);
+                    }
+                    chronos[leapYears.index] = chrono;
                 }
-                chronos[leapYears.index] = chrono;
             }
         }
         return chrono;
diff --git a/src/main/java/org/joda/time/chrono/JulianChronology.java b/src/main/java/org/joda/time/chrono/JulianChronology.java
index 3433e1951..6c0ec0134 100644
--- a/src/main/java/org/joda/time/chrono/JulianChronology.java
+++ b/src/main/java/org/joda/time/chrono/JulianChronology.java
@@ -15,8 +15,7 @@
  */
 package org.joda.time.chrono;
 
-import java.util.HashMap;
-import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeConstants;
@@ -68,7 +67,7 @@
     private static final JulianChronology INSTANCE_UTC;
 
     /** Cache of zone to chronology arrays */
-    private static final Map<DateTimeZone, JulianChronology[]> cCache = new HashMap<DateTimeZone, JulianChronology[]>();
+    private static final ConcurrentHashMap<DateTimeZone, JulianChronology[]> cCache = new ConcurrentHashMap<DateTimeZone, JulianChronology[]>();
 
     static {
         INSTANCE_UTC = getInstance(DateTimeZone.UTC);
@@ -126,27 +125,33 @@ public static JulianChronology getInstance(DateTimeZone zone, int minDaysInFirst
             zone = DateTimeZone.getDefault();
         }
         JulianChronology chrono;
-        synchronized (cCache) {
-            JulianChronology[] chronos = cCache.get(zone);
-            if (chronos == null) {
-                chronos = new JulianChronology[7];
-                cCache.put(zone, chronos);
+        JulianChronology[] chronos = cCache.get(zone);
+        if (chronos == null) {
+            chronos = new JulianChronology[7];
+            JulianChronology[] oldChronos = cCache.putIfAbsent(zone, chronos);
+            if (oldChronos != null) {
+                chronos = oldChronos;
             }
-            try {
+        }
+        try {
+            chrono = chronos[minDaysInFirstWeek - 1];
+        } catch (ArrayIndexOutOfBoundsException e) {
+            throw new IllegalArgumentException
+                ("Invalid min days in first week: " + minDaysInFirstWeek);
+        }
+        if (chrono == null) {
+            synchronized (chronos) {
                 chrono = chronos[minDaysInFirstWeek - 1];
-            } catch (ArrayIndexOutOfBoundsException e) {
-                throw new IllegalArgumentException
-                    ("Invalid min days in first week: " + minDaysInFirstWeek);
-            }
-            if (chrono == null) {
-                if (zone == DateTimeZone.UTC) {
-                    chrono = new JulianChronology(null, null, minDaysInFirstWeek);
-                } else {
-                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);
-                    chrono = new JulianChronology
-                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);
+                if (chrono == null) {
+                    if (zone == DateTimeZone.UTC) {
+                        chrono = new JulianChronology(null, null, minDaysInFirstWeek);
+                    } else {
+                        chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);
+                        chrono = new JulianChronology
+                            (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);
+                    }
+                    chronos[minDaysInFirstWeek - 1] = chrono;
                 }
-                chronos[minDaysInFirstWeek - 1] = chrono;
             }
         }
         return chrono;

From e04ba6a833a3ce388f41b5d34d4a110e6d8d3383 Mon Sep 17 00:00:00 2001
From: Fabian Lange <lange.fabian@gmail.com>
Date: Mon, 17 Feb 2014 18:02:42 +0100
Subject: [PATCH 56/86] Simplified Cache Lookup of GJChronologies.

This commit replaces the cache lookup using only the zone and then
iterating over the ArrayList donating possible candidates with a single
cache access. For this purpose a temporary cache key is instantiated.

In the cache hit case this code will produce a temporary GJCacheKey
object and then return the GJChronology, as compared to previous, where
the code was forced synchronised, an ArrayList iteration was performed
and an Instant was checked for equality.
---
 .../java/org/joda/time/chrono/GJCacheKey.java | 62 +++++++++++++++++++
 .../org/joda/time/chrono/GJChronology.java    | 32 +++-------
 2 files changed, 72 insertions(+), 22 deletions(-)
 create mode 100644 src/main/java/org/joda/time/chrono/GJCacheKey.java

diff --git a/src/main/java/org/joda/time/chrono/GJCacheKey.java b/src/main/java/org/joda/time/chrono/GJCacheKey.java
new file mode 100644
index 000000000..66195ee57
--- /dev/null
+++ b/src/main/java/org/joda/time/chrono/GJCacheKey.java
@@ -0,0 +1,62 @@
+package org.joda.time.chrono;
+
+import org.joda.time.DateTimeZone;
+import org.joda.time.Instant;
+
+/**
+ * For internal usage in GJChronology only. 
+ */
+class GJCacheKey {
+    private final DateTimeZone zone;
+    private final Instant cutoverInstant;
+    private final int minDaysInFirstWeek;
+
+    GJCacheKey(DateTimeZone zone, Instant cutoverInstant, int minDaysInFirstWeek) {
+        this.zone = zone;
+        this.cutoverInstant = cutoverInstant;
+        this.minDaysInFirstWeek = minDaysInFirstWeek;
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + ((cutoverInstant == null) ? 0 : cutoverInstant.hashCode());
+        result = prime * result + minDaysInFirstWeek;
+        result = prime * result + ((zone == null) ? 0 : zone.hashCode());
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null) {
+            return false;
+        }
+        if (!(obj instanceof GJCacheKey)) {
+            return false;
+        }
+        GJCacheKey other = (GJCacheKey) obj;
+        if (cutoverInstant == null) {
+            if (other.cutoverInstant != null) {
+                return false;
+            }
+        } else if (!cutoverInstant.equals(other.cutoverInstant)) {
+            return false;
+        }
+        if (minDaysInFirstWeek != other.minDaysInFirstWeek) {
+            return false;
+        }
+        if (zone == null) {
+            if (other.zone != null) {
+                return false;
+            }
+        } else if (!zone.equals(other.zone)) {
+            return false;
+        }
+        return true;
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/org/joda/time/chrono/GJChronology.java b/src/main/java/org/joda/time/chrono/GJChronology.java
index 1cc03a473..ce3865418 100644
--- a/src/main/java/org/joda/time/chrono/GJChronology.java
+++ b/src/main/java/org/joda/time/chrono/GJChronology.java
@@ -15,10 +15,8 @@
  */
 package org.joda.time.chrono;
 
-import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.Locale;
-import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTimeField;
@@ -106,7 +104,7 @@ private static long convertByWeekyear(final long instant, Chronology from, Chron
     static final Instant DEFAULT_CUTOVER = new Instant(-12219292800000L);
 
     /** Cache of zone to chronology list */
-    private static final Map<DateTimeZone, ArrayList<GJChronology>> cCache = new HashMap<DateTimeZone, ArrayList<GJChronology>>();
+    private static final ConcurrentHashMap<GJCacheKey, GJChronology> cCache = new ConcurrentHashMap<GJCacheKey, GJChronology>();
 
     /**
      * Factory method returns instances of the default GJ cutover
@@ -182,7 +180,7 @@ public static GJChronology getInstance(
      * @param gregorianCutover  the cutover to use, null means default
      * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4
      */
-    public static synchronized GJChronology getInstance(
+    public static GJChronology getInstance(
             DateTimeZone zone,
             ReadableInstant gregorianCutover,
             int minDaysInFirstWeek) {
@@ -199,22 +197,9 @@ public static synchronized GJChronology getInstance(
             }
         }
 
-        GJChronology chrono;
-        synchronized (cCache) {
-            ArrayList<GJChronology> chronos = cCache.get(zone);
-            if (chronos == null) {
-                chronos = new ArrayList<GJChronology>(2);
-                cCache.put(zone, chronos);
-            } else {
-                for (int i = chronos.size(); --i >= 0;) {
-                    chrono = chronos.get(i);
-                    if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&
-                        cutoverInstant.equals(chrono.getGregorianCutover())) {
-                        
-                        return chrono;
-                    }
-                }
-            }
+        GJCacheKey cacheKey = new GJCacheKey(zone, cutoverInstant, minDaysInFirstWeek);
+        GJChronology chrono = cCache.get(cacheKey);
+        if (chrono == null) {
             if (zone == DateTimeZone.UTC) {
                 chrono = new GJChronology
                     (JulianChronology.getInstance(zone, minDaysInFirstWeek),
@@ -228,7 +213,10 @@ public static synchronized GJChronology getInstance(
                      chrono.iGregorianChronology,
                      chrono.iCutoverInstant);
             }
-            chronos.add(chrono);
+            GJChronology oldChrono = cCache.putIfAbsent(cacheKey, chrono);
+            if (oldChrono != null) {
+                chrono = oldChrono;
+            }
         }
         return chrono;
     }

From 199980566f918317cf7819adb4084e5a8d157114 Mon Sep 17 00:00:00 2001
From: Fabian Lange <lange.fabian@gmail.com>
Date: Tue, 18 Feb 2014 14:04:20 +0100
Subject: [PATCH 57/86] only synchronize the write to STLYE_CACHE as the update
 will be atomic.

---
 .../java/org/joda/time/format/DateTimeFormat.java  | 14 ++++++++------
 1 file changed, 8 insertions(+), 6 deletions(-)

diff --git a/src/main/java/org/joda/time/format/DateTimeFormat.java b/src/main/java/org/joda/time/format/DateTimeFormat.java
index bdc9d68b7..488de46ab 100644
--- a/src/main/java/org/joda/time/format/DateTimeFormat.java
+++ b/src/main/java/org/joda/time/format/DateTimeFormat.java
@@ -738,12 +738,14 @@ private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int
         if (index >= STYLE_CACHE.length) {
             return createDateTimeFormatter(dateStyle, timeStyle);
         }
-        DateTimeFormatter f = null;
-        synchronized (STYLE_CACHE) {
-            f = STYLE_CACHE[index];
-            if (f == null) {
-                f = createDateTimeFormatter(dateStyle, timeStyle);
-                STYLE_CACHE[index] = f;
+        DateTimeFormatter f = STYLE_CACHE[index];
+        if (f == null) {
+            synchronized (STYLE_CACHE) {
+                f = STYLE_CACHE[index];
+                if (f == null) {
+                    f = createDateTimeFormatter(dateStyle, timeStyle);
+                    STYLE_CACHE[index] = f;
+                }
             }
         }
         return f;

From 3b8cdbbdb9b006c1ec42e72216651655147730bd Mon Sep 17 00:00:00 2001
From: Fabian Lange <lange.fabian@gmail.com>
Date: Tue, 18 Feb 2014 14:08:06 +0100
Subject: [PATCH 58/86] Using ConcurrentHashMaps rather than synchronized Maps.

---
 .../org/joda/time/format/DateTimeFormat.java  | 37 ++++++++-----------
 1 file changed, 16 insertions(+), 21 deletions(-)

diff --git a/src/main/java/org/joda/time/format/DateTimeFormat.java b/src/main/java/org/joda/time/format/DateTimeFormat.java
index 488de46ab..72a307488 100644
--- a/src/main/java/org/joda/time/format/DateTimeFormat.java
+++ b/src/main/java/org/joda/time/format/DateTimeFormat.java
@@ -18,10 +18,8 @@
 import java.io.IOException;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
-import java.util.HashMap;
-import java.util.LinkedHashMap;
 import java.util.Locale;
-import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTime;
@@ -152,14 +150,8 @@
     /** Maximum size of the pattern cache. */
     private static final int PATTERN_CACHE_SIZE = 500;
 
-    /** Maps patterns to formatters via LRU, patterns don't vary by locale. */
-    private static final Map<String, DateTimeFormatter> PATTERN_CACHE = new LinkedHashMap<String, DateTimeFormatter>(7) {
-        private static final long serialVersionUID = 23L;
-        @Override
-        protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {
-            return size() > PATTERN_CACHE_SIZE;
-        }
-    };
+    /** Maps patterns to formatters, patterns don't vary by locale. Size capped at PATTERN_CACHE_SIZE*/
+    private static final ConcurrentHashMap<String, DateTimeFormatter> PATTERN_CACHE = new ConcurrentHashMap<String, DateTimeFormatter>();
 
     /** Maps patterns to formatters, patterns don't vary by locale. */
     private static final DateTimeFormatter[] STYLE_CACHE = new DateTimeFormatter[25];
@@ -690,15 +682,18 @@ private static DateTimeFormatter createFormatterForPattern(String pattern) {
         if (pattern == null || pattern.length() == 0) {
             throw new IllegalArgumentException("Invalid pattern specification");
         }
-        DateTimeFormatter formatter = null;
-        synchronized (PATTERN_CACHE) {
-            formatter = PATTERN_CACHE.get(pattern);
+        DateTimeFormatter formatter = PATTERN_CACHE.get(pattern);
             if (formatter == null) {
                 DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();
                 parsePatternTo(builder, pattern);
                 formatter = builder.toFormatter();
-
-                PATTERN_CACHE.put(pattern, formatter);
+            if (PATTERN_CACHE.size() < PATTERN_CACHE_SIZE) {
+                // the size check is not locked against concurrent access,
+                // but is accepted to be slightly off in contention scenarios.
+                DateTimeFormatter oldFormatter = PATTERN_CACHE.putIfAbsent(pattern, formatter);
+                if (oldFormatter != null) {
+                    formatter = oldFormatter;
+                }
             }
         }
         return formatter;
@@ -795,7 +790,7 @@ private static int selectStyle(char ch) {
     static class StyleFormatter
             implements InternalPrinter, DateTimeParser {
 
-        private static final Map<String, DateTimeFormatter> cCache = new HashMap<String, DateTimeFormatter>();  // manual sync
+        private static final ConcurrentHashMap<String, DateTimeFormatter> cCache = new ConcurrentHashMap<String, DateTimeFormatter>();
         
         private final int iDateStyle;
         private final int iTimeStyle;
@@ -837,12 +832,12 @@ private DateTimeFormatter getFormatter(Locale locale) {
             locale = (locale == null ? Locale.getDefault() : locale);
             String key = Integer.toString(iType + (iDateStyle << 4) + (iTimeStyle << 8)) + locale.toString();
             DateTimeFormatter f = null;
-            synchronized (cCache) {
                 f = cCache.get(key);
                 if (f == null) {
-                    String pattern = getPattern(locale);
-                    f = DateTimeFormat.forPattern(pattern);
-                    cCache.put(key, f);
+                f = DateTimeFormat.forPattern(getPattern(locale));
+                DateTimeFormatter oldFormatter = cCache.putIfAbsent(key, f);
+                if (oldFormatter != null) {
+                    f = oldFormatter;
                 }
             }
             return f;

From 45877a6f25b25b307b390f120b67b9dcd68295e5 Mon Sep 17 00:00:00 2001
From: Fabian Lange <lange.fabian@gmail.com>
Date: Tue, 18 Feb 2014 14:09:57 +0100
Subject: [PATCH 59/86] using custom key for looking up from the StyleFormatter
 cache.

Previously a String was created from the ints, and a locale.toString was
invoked (which is a pretty heavy operation).
Now we use a custom key which is based on the same ints and locale, but
does not need to calculate a string out of it.
---
 .../org/joda/time/format/DateTimeFormat.java  | 62 ++++++++++++++++---
 1 file changed, 53 insertions(+), 9 deletions(-)

diff --git a/src/main/java/org/joda/time/format/DateTimeFormat.java b/src/main/java/org/joda/time/format/DateTimeFormat.java
index 72a307488..927c9d96e 100644
--- a/src/main/java/org/joda/time/format/DateTimeFormat.java
+++ b/src/main/java/org/joda/time/format/DateTimeFormat.java
@@ -683,10 +683,10 @@ private static DateTimeFormatter createFormatterForPattern(String pattern) {
             throw new IllegalArgumentException("Invalid pattern specification");
         }
         DateTimeFormatter formatter = PATTERN_CACHE.get(pattern);
-            if (formatter == null) {
-                DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();
-                parsePatternTo(builder, pattern);
-                formatter = builder.toFormatter();
+        if (formatter == null) {
+            DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();
+            parsePatternTo(builder, pattern);
+            formatter = builder.toFormatter();
             if (PATTERN_CACHE.size() < PATTERN_CACHE_SIZE) {
                 // the size check is not locked against concurrent access,
                 // but is accepted to be slightly off in contention scenarios.
@@ -790,7 +790,7 @@ private static int selectStyle(char ch) {
     static class StyleFormatter
             implements InternalPrinter, DateTimeParser {
 
-        private static final ConcurrentHashMap<String, DateTimeFormatter> cCache = new ConcurrentHashMap<String, DateTimeFormatter>();
+        private static final ConcurrentHashMap<StyleFormatterCacheKey, DateTimeFormatter> cCache = new ConcurrentHashMap<StyleFormatterCacheKey, DateTimeFormatter>();
         
         private final int iDateStyle;
         private final int iTimeStyle;
@@ -830,10 +830,9 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
 
         private DateTimeFormatter getFormatter(Locale locale) {
             locale = (locale == null ? Locale.getDefault() : locale);
-            String key = Integer.toString(iType + (iDateStyle << 4) + (iTimeStyle << 8)) + locale.toString();
-            DateTimeFormatter f = null;
-                f = cCache.get(key);
-                if (f == null) {
+            StyleFormatterCacheKey key = new StyleFormatterCacheKey(iType, iDateStyle, iTimeStyle, locale);
+            DateTimeFormatter f = cCache.get(key);
+            if (f == null) {
                 f = DateTimeFormat.forPattern(getPattern(locale));
                 DateTimeFormatter oldFormatter = cCache.putIfAbsent(key, f);
                 if (oldFormatter != null) {
@@ -863,4 +862,49 @@ String getPattern(Locale locale) {
         }
     }
 
+    static class StyleFormatterCacheKey {
+        private final int combinedTypeAndStyle;
+        private final Locale locale;
+
+        public StyleFormatterCacheKey(int iType, int iDateStyle,
+                int iTimeStyle, Locale locale) {
+            this.locale = locale;
+            // keeping old key generation logic of shifting type and style
+            this.combinedTypeAndStyle = iType + (iDateStyle << 4) + (iTimeStyle << 8);
+        }
+
+        @Override
+        public int hashCode() {
+            final int prime = 31;
+            int result = 1;
+            result = prime * result + combinedTypeAndStyle;
+            result = prime * result + ((locale == null) ? 0 : locale.hashCode());
+            return result;
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (this == obj) {
+                return true;
+            }
+            if (obj == null) {
+                return false;
+            }
+            if (!(obj instanceof StyleFormatterCacheKey)) {
+                return false;
+            }
+            StyleFormatterCacheKey other = (StyleFormatterCacheKey) obj;
+            if (combinedTypeAndStyle != other.combinedTypeAndStyle) {
+                return false;
+            }
+            if (locale == null) {
+                if (other.locale != null) {
+                    return false;
+                }
+            } else if (!locale.equals(other.locale)) {
+                return false;
+            }
+            return true;
+        }
+    }
 }

From 5806938f132cd805f14996a0b8d048f02b3d56eb Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Tue, 4 Mar 2014 15:32:38 +0000
Subject: [PATCH 60/86] Update website and pom

---
 pom.xml                         | 65 ++++++++++++++++-----------------
 src/site/resources/css/site.css |  2 -
 src/site/site.xml               |  2 +-
 3 files changed, 33 insertions(+), 36 deletions(-)

diff --git a/pom.xml b/pom.xml
index 16e8ec9c3..a1d19cf6e 100644
--- a/pom.xml
+++ b/pom.xml
@@ -31,9 +31,8 @@
   <!-- ==================================================================== -->
   <developers>
     <developer>
-      <id>scolebourne</id>
+      <id>jodastephen</id>
       <name>Stephen Colebourne</name>
-      <email></email>
       <roles>
         <role>Project Lead</role>
       </roles>
@@ -357,10 +356,10 @@
           <skipDeploy>true</skipDeploy>
         </configuration>
       </plugin>
-      <plugin>
+      <plugin><!-- invoke with mvn site-deploy -->
         <groupId>com.github.github</groupId>
         <artifactId>site-maven-plugin</artifactId>
-        <version>0.98</version>
+        <version>0.9</version>
         <executions>
           <execution>
             <id>github-site</id>
@@ -507,30 +506,30 @@
         </plugin>
         <!--This plugin's configuration is used to store Eclipse m2e settings only. It has no influence on the Maven build itself.-->
         <plugin>
-        	<groupId>org.eclipse.m2e</groupId>
-        	<artifactId>lifecycle-mapping</artifactId>
-        	<version>1.0.0</version>
-        	<configuration>
-        		<lifecycleMappingMetadata>
-        			<pluginExecutions>
-        				<pluginExecution>
-        					<pluginExecutionFilter>
-        						<groupId>org.codehaus.mojo</groupId>
-        						<artifactId>
-        							exec-maven-plugin
-        						</artifactId>
-        						<versionRange>[1.2.1,)</versionRange>
-        						<goals>
-        							<goal>java</goal>
-        						</goals>
-        					</pluginExecutionFilter>
-        					<action>
-        						<ignore></ignore>
-        					</action>
-        				</pluginExecution>
-        			</pluginExecutions>
-        		</lifecycleMappingMetadata>
-        	</configuration>
+          <groupId>org.eclipse.m2e</groupId>
+          <artifactId>lifecycle-mapping</artifactId>
+          <version>1.0.0</version>
+          <configuration>
+            <lifecycleMappingMetadata>
+              <pluginExecutions>
+                <pluginExecution>
+                  <pluginExecutionFilter>
+                    <groupId>org.codehaus.mojo</groupId>
+                    <artifactId>
+                      exec-maven-plugin
+                    </artifactId>
+                    <versionRange>[1.2.1,)</versionRange>
+                    <goals>
+                      <goal>java</goal>
+                    </goals>
+                  </pluginExecutionFilter>
+                  <action>
+                    <ignore></ignore>
+                  </action>
+                </pluginExecution>
+              </pluginExecutions>
+            </lifecycleMappingMetadata>
+          </configuration>
         </plugin>
       </plugins>
     </pluginManagement>
@@ -686,13 +685,13 @@
     <!-- Plugin version numbers -->
     <maven-assembly-plugin.version>2.4</maven-assembly-plugin.version>
     <maven-changes-plugin.version>2.9</maven-changes-plugin.version>
-    <maven-checkstyle-plugin.version>2.10</maven-checkstyle-plugin.version>
+    <maven-checkstyle-plugin.version>2.11</maven-checkstyle-plugin.version>
     <maven-clean-plugin.version>2.5</maven-clean-plugin.version>
     <maven-compiler-plugin.version>3.1</maven-compiler-plugin.version>
-    <maven-deploy-plugin.version>2.7</maven-deploy-plugin.version>
+    <maven-deploy-plugin.version>2.8.1</maven-deploy-plugin.version>
     <maven-dependency-plugin.version>2.8</maven-dependency-plugin.version>
     <maven-gpg-plugin.version>1.4</maven-gpg-plugin.version>
-    <maven-install-plugin.version>2.4</maven-install-plugin.version>
+    <maven-install-plugin.version>2.5.1</maven-install-plugin.version>
     <maven-jar-plugin.version>2.4</maven-jar-plugin.version>
     <maven-javadoc-plugin.version>2.9.1</maven-javadoc-plugin.version>
     <maven-jxr-plugin.version>2.3</maven-jxr-plugin.version>
@@ -703,8 +702,8 @@
     <maven-resources-plugin.version>2.6</maven-resources-plugin.version>
     <maven-site-plugin.version>3.3</maven-site-plugin.version>
     <maven-source-plugin.version>2.2.1</maven-source-plugin.version>
-    <maven-surefire-plugin.version>2.15</maven-surefire-plugin.version>
-    <maven-surefire-report-plugin.version>2.15</maven-surefire-report-plugin.version>
+    <maven-surefire-plugin.version>2.16</maven-surefire-plugin.version>
+    <maven-surefire-report-plugin.version>2.16</maven-surefire-report-plugin.version>
     <maven-toolchains-plugin.version>1.0</maven-toolchains-plugin.version>
     <!-- Properties for maven-compiler-plugin -->
     <maven.compiler.compilerVersion>1.5</maven.compiler.compilerVersion>
diff --git a/src/site/resources/css/site.css b/src/site/resources/css/site.css
index 18f03863c..89f79bf15 100644
--- a/src/site/resources/css/site.css
+++ b/src/site/resources/css/site.css
@@ -57,8 +57,6 @@ p, ul {
 #bannerLeft, #bannerRight {
   font-size: 30px;
   color:black;
-  background-color:white;
-  border: 1px solid #999;
   padding: 0px 5px;
 }
 #banner a:hover {
diff --git a/src/site/site.xml b/src/site/site.xml
index d51b26522..a0290bdd8 100644
--- a/src/site/site.xml
+++ b/src/site/site.xml
@@ -55,12 +55,12 @@
       <item name="GitHub" href="https://github.com/JodaOrg/joda-time"/>
       <item name="Bugs/Issues" href="https://github.com/JodaOrg/joda-time/issues"/>
       <item name="Test results" href="surefire-report.html"/>
-      <item name="Sourceforge" href="http://sourceforge.net/projects/joda-time/"/>
     </menu>
 
     <menu name="Joda">
       <item name="Joda home" href="http://www.joda.org"/>
       <item name="Beans" href="http://www.joda.org/joda-beans/"/>
+      <item name="Collect" href="http://www.joda.org/joda-collect/"/>
       <item name="Convert" href="http://www.joda.org/joda-convert/"/>
       <item name="Money" href="http://www.joda.org/joda-money/"/>
       <item name="Primitives" href="http://www.joda.org/joda-primitives/"/>

From 7385f322966dac2b1e1c843d0192085df648c497 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Thu, 20 Mar 2014 14:57:38 +0000
Subject: [PATCH 61/86] Increased performance of chrnology lookup

Fixes #126
---
 RELEASE-NOTES.txt | 3 +++
 pom.xml           | 4 ++++
 2 files changed, 7 insertions(+)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 33d969867..41e5c352f 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -29,6 +29,9 @@ Enhancements since 2.3
   Ensure that Appendable can be used efficiently in printing [#120, #121, #122]
   No API change
 
+- Increased performance of chrnology lookup [#126]
+  No API change
+
 
 Compatibility with 2.3
 ----------------------
diff --git a/pom.xml b/pom.xml
index a1d19cf6e..03bf6957b 100644
--- a/pom.xml
+++ b/pom.xml
@@ -107,6 +107,10 @@
       <name>Martin Kneissl</name>
       <url>https://github.com/mkneissl</url>
     </contributor>
+    <contributor>
+      <name>Fabian Lange</name>
+      <url>https://github.com/CodingFabian</url>
+    </contributor>
     <contributor>
       <name>Vidar Larsen</name>
       <url>https://github.com/vlarsen</url>

From b7ddebdf7a76ba1bc86a456152dddb7d893d0bb6 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Thu, 20 Mar 2014 15:41:22 +0000
Subject: [PATCH 62/86] Adjust pull request to use AtomicReferenceArray

Fixes #129, #127
---
 RELEASE-NOTES.txt                             |  5 +++-
 .../org/joda/time/format/DateTimeFormat.java  | 23 ++++++++-----------
 2 files changed, 14 insertions(+), 14 deletions(-)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 41e5c352f..bbc977d84 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -29,7 +29,10 @@ Enhancements since 2.3
   Ensure that Appendable can be used efficiently in printing [#120, #121, #122]
   No API change
 
-- Increased performance of chrnology lookup [#126]
+- Increased performance of chronology lookup [#126]
+  No API change
+
+- Increased performance of formatter lookup [#127,#129]
   No API change
 
 
diff --git a/src/main/java/org/joda/time/format/DateTimeFormat.java b/src/main/java/org/joda/time/format/DateTimeFormat.java
index 927c9d96e..e04879abe 100644
--- a/src/main/java/org/joda/time/format/DateTimeFormat.java
+++ b/src/main/java/org/joda/time/format/DateTimeFormat.java
@@ -20,6 +20,7 @@
 import java.text.SimpleDateFormat;
 import java.util.Locale;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicReferenceArray;
 
 import org.joda.time.Chronology;
 import org.joda.time.DateTime;
@@ -149,12 +150,10 @@
 
     /** Maximum size of the pattern cache. */
     private static final int PATTERN_CACHE_SIZE = 500;
-
     /** Maps patterns to formatters, patterns don't vary by locale. Size capped at PATTERN_CACHE_SIZE*/
     private static final ConcurrentHashMap<String, DateTimeFormatter> PATTERN_CACHE = new ConcurrentHashMap<String, DateTimeFormatter>();
-
     /** Maps patterns to formatters, patterns don't vary by locale. */
-    private static final DateTimeFormatter[] STYLE_CACHE = new DateTimeFormatter[25];
+    private static final AtomicReferenceArray<DateTimeFormatter> STYLE_CACHE = new AtomicReferenceArray<DateTimeFormatter>(25);
 
     //-----------------------------------------------------------------------
     /**
@@ -728,26 +727,24 @@ private static DateTimeFormatter createFormatterForStyle(String style) {
      * @return the formatter
      */
     private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle) {
-        int index = ((dateStyle << 2) + dateStyle) + timeStyle;
+        int index = ((dateStyle << 2) + dateStyle) + timeStyle;  // (dateStyle * 5 + timeStyle);
         // Should never happen but do a double check...
-        if (index >= STYLE_CACHE.length) {
+        if (index >= STYLE_CACHE.length()) {
             return createDateTimeFormatter(dateStyle, timeStyle);
         }
-        DateTimeFormatter f = STYLE_CACHE[index];
+        DateTimeFormatter f = STYLE_CACHE.get(index);
         if (f == null) {
-            synchronized (STYLE_CACHE) {
-                f = STYLE_CACHE[index];
-                if (f == null) {
-                    f = createDateTimeFormatter(dateStyle, timeStyle);
-                    STYLE_CACHE[index] = f;
-                }
+            f = createDateTimeFormatter(dateStyle, timeStyle);
+            if (STYLE_CACHE.compareAndSet(index, null, f) == false) {
+                f = STYLE_CACHE.get(index);
             }
         }
         return f;
     }
-    
+
     /**
      * Creates a formatter for the specified style.
+     * 
      * @param dateStyle  the date style
      * @param timeStyle  the time style
      * @return the formatter

From 38794869c3f3efc568ee37f7ba02639337f755be Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Thu, 20 Mar 2014 15:51:36 +0000
Subject: [PATCH 63/86] Update headers

---
 .../org/joda/time/chrono/BuddhistChronology.java  |  2 +-
 .../java/org/joda/time/chrono/GJCacheKey.java     | 15 +++++++++++++++
 .../java/org/joda/time/chrono/GJChronology.java   |  2 +-
 .../org/joda/time/chrono/GregorianChronology.java |  2 +-
 .../java/org/joda/time/chrono/ISOChronology.java  |  2 +-
 .../org/joda/time/chrono/IslamicChronology.java   |  2 +-
 .../org/joda/time/chrono/JulianChronology.java    |  2 +-
 7 files changed, 21 insertions(+), 6 deletions(-)

diff --git a/src/main/java/org/joda/time/chrono/BuddhistChronology.java b/src/main/java/org/joda/time/chrono/BuddhistChronology.java
index 21cb0e3c0..124764de8 100644
--- a/src/main/java/org/joda/time/chrono/BuddhistChronology.java
+++ b/src/main/java/org/joda/time/chrono/BuddhistChronology.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2013 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
diff --git a/src/main/java/org/joda/time/chrono/GJCacheKey.java b/src/main/java/org/joda/time/chrono/GJCacheKey.java
index 66195ee57..18174bf6c 100644
--- a/src/main/java/org/joda/time/chrono/GJCacheKey.java
+++ b/src/main/java/org/joda/time/chrono/GJCacheKey.java
@@ -1,3 +1,18 @@
+/*
+ *  Copyright 2001-2014 Stephen Colebourne
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
 package org.joda.time.chrono;
 
 import org.joda.time.DateTimeZone;
diff --git a/src/main/java/org/joda/time/chrono/GJChronology.java b/src/main/java/org/joda/time/chrono/GJChronology.java
index ce3865418..0b6069f5a 100644
--- a/src/main/java/org/joda/time/chrono/GJChronology.java
+++ b/src/main/java/org/joda/time/chrono/GJChronology.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2013 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
diff --git a/src/main/java/org/joda/time/chrono/GregorianChronology.java b/src/main/java/org/joda/time/chrono/GregorianChronology.java
index d1066bb9f..526a71e64 100644
--- a/src/main/java/org/joda/time/chrono/GregorianChronology.java
+++ b/src/main/java/org/joda/time/chrono/GregorianChronology.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2009 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
diff --git a/src/main/java/org/joda/time/chrono/ISOChronology.java b/src/main/java/org/joda/time/chrono/ISOChronology.java
index 4d3525b5c..08b3d08d0 100644
--- a/src/main/java/org/joda/time/chrono/ISOChronology.java
+++ b/src/main/java/org/joda/time/chrono/ISOChronology.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2013 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
diff --git a/src/main/java/org/joda/time/chrono/IslamicChronology.java b/src/main/java/org/joda/time/chrono/IslamicChronology.java
index f4c20de9c..8630349cd 100644
--- a/src/main/java/org/joda/time/chrono/IslamicChronology.java
+++ b/src/main/java/org/joda/time/chrono/IslamicChronology.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2013 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
diff --git a/src/main/java/org/joda/time/chrono/JulianChronology.java b/src/main/java/org/joda/time/chrono/JulianChronology.java
index 6c0ec0134..de8fe1d17 100644
--- a/src/main/java/org/joda/time/chrono/JulianChronology.java
+++ b/src/main/java/org/joda/time/chrono/JulianChronology.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2009 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.

From 1ba2af6d66813b45008db6bb9b0a039afdcf6774 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Thu, 20 Mar 2014 16:00:42 +0000
Subject: [PATCH 64/86] Handle weird TimeZone implementations with null ID

Calling DateTimeZone.forTimeZone() would break if the ID was null
Fixes #133
---
 RELEASE-NOTES.txt                             |  3 ++
 src/main/java/org/joda/time/DateTimeZone.java |  7 +++-
 .../java/org/joda/time/TestDateTimeZone.java  | 38 ++++++++++++++++++-
 3 files changed, 45 insertions(+), 3 deletions(-)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index bbc977d84..d400fcea7 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -90,6 +90,9 @@ Bug fixes since 2.3
 - Ensure isLeap() returns correct result for day fields [#110]
   Day-of-month and day-of-year fields should report leap days
 
+- Handle weird TimeZone implementations with null ID [#133]
+  Calling DateTimeZone.forTimeZone() would break if the ID was null
+
 - Handle broken Android implementations better [#103]
   Apparently some Android implementations throw ClassCastException when comparing different types
   Thats dumb and wrong but the change to handle it is harmless
diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java
index 19fbc8648..a8d815e62 100644
--- a/src/main/java/org/joda/time/DateTimeZone.java
+++ b/src/main/java/org/joda/time/DateTimeZone.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2013 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -331,6 +331,9 @@ public static DateTimeZone forTimeZone(TimeZone zone) {
             return getDefault();
         }
         final String id = zone.getID();
+        if (id == null) {
+            throw new IllegalArgumentException("The TimeZone id must not be null");
+        }
         if (id.equals("UTC")) {
             return DateTimeZone.UTC;
         }
@@ -350,7 +353,7 @@ public static DateTimeZone forTimeZone(TimeZone zone) {
 
         // Support GMT+/-hh:mm formats
         if (convId == null) {
-            convId = zone.getID();
+            convId = id;
             if (convId.startsWith("GMT+") || convId.startsWith("GMT-")) {
                 convId = convId.substring(3);
                 int offset = parseOffset(convId);
diff --git a/src/test/java/org/joda/time/TestDateTimeZone.java b/src/test/java/org/joda/time/TestDateTimeZone.java
index d5d31f7cf..04f64df64 100644
--- a/src/test/java/org/joda/time/TestDateTimeZone.java
+++ b/src/test/java/org/joda/time/TestDateTimeZone.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2013 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -29,6 +29,7 @@
 import java.security.Policy;
 import java.security.ProtectionDomain;
 import java.text.DateFormatSymbols;
+import java.util.Date;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
 import java.util.Locale;
@@ -392,6 +393,41 @@ public void testForTimeZone_TimeZone() {
         assertEquals("America/New_York", zone.getID());
     }
 
+    public void testFromTimeZoneInvalid() throws Exception {
+        TimeZone jdkZone = new TimeZone() {
+            private static final long serialVersionUID = 1L;
+            @Override
+            public String getID() {
+                return null;
+            }
+            @Override
+            public int getOffset(int era, int year, int month, int day, int dayOfWeek, int milliseconds) {
+                return 0;
+            }
+            @Override
+            public void setRawOffset(int offsetMillis) {
+            }
+            @Override
+            public int getRawOffset() {
+                return 0;
+            }
+            @Override
+            public boolean useDaylightTime() {
+                return false;
+            }
+            @Override
+            public boolean inDaylightTime(Date date) {
+                return false;
+            }
+        };
+        try {
+            DateTimeZone.forTimeZone(jdkZone);
+            fail();
+        } catch (IllegalArgumentException ex) {
+            // expected
+        }
+    }
+
     public void testTimeZoneConversion() {
         TimeZone jdkTimeZone = TimeZone.getTimeZone("GMT-10");
         assertEquals("GMT-10:00", jdkTimeZone.getID());

From cadc571096b653109913af6fef1e6a59f2983036 Mon Sep 17 00:00:00 2001
From: Craig Gidney <craig.gidney@gmail.com>
Date: Mon, 31 Mar 2014 11:16:26 -0400
Subject: [PATCH 65/86] Added missing words in ReadableDuration's javadoc

---
 src/main/java/org/joda/time/ReadableDuration.java | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/main/java/org/joda/time/ReadableDuration.java b/src/main/java/org/joda/time/ReadableDuration.java
index 60c71adb2..ce5801f12 100644
--- a/src/main/java/org/joda/time/ReadableDuration.java
+++ b/src/main/java/org/joda/time/ReadableDuration.java
@@ -95,7 +95,7 @@
      * Is the length of this duration equal to the duration passed in.
      *
      * @param duration  another duration to compare to, null means zero milliseconds
-     * @return true if this duration is equal to than the duration passed in
+     * @return true if this duration is equal to the duration passed in
      */
     boolean isEqual(ReadableDuration duration);
 
@@ -103,7 +103,7 @@
      * Is the length of this duration longer than the duration passed in.
      *
      * @param duration  another duration to compare to, null means zero milliseconds
-     * @return true if this duration is equal to than the duration passed in
+     * @return true if this duration is equal to or greater than the duration passed in
      */
     boolean isLongerThan(ReadableDuration duration);
 
@@ -111,7 +111,7 @@
      * Is the length of this duration shorter than the duration passed in.
      *
      * @param duration  another duration to compare to, null means zero milliseconds
-     * @return true if this duration is equal to than the duration passed in
+     * @return true if this duration is equal to or less than the duration passed in
      */
     boolean isShorterThan(ReadableDuration duration);
 

From 4e6229f498ab47eb577173642cada45e1cc6daee Mon Sep 17 00:00:00 2001
From: Craig Gidney <craig.gidney@gmail.com>
Date: Mon, 31 Mar 2014 21:22:30 -0400
Subject: [PATCH 66/86] Removing incorrect 'equal to'

---
 src/main/java/org/joda/time/ReadableDuration.java | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/main/java/org/joda/time/ReadableDuration.java b/src/main/java/org/joda/time/ReadableDuration.java
index ce5801f12..06b8b8b44 100644
--- a/src/main/java/org/joda/time/ReadableDuration.java
+++ b/src/main/java/org/joda/time/ReadableDuration.java
@@ -103,7 +103,7 @@
      * Is the length of this duration longer than the duration passed in.
      *
      * @param duration  another duration to compare to, null means zero milliseconds
-     * @return true if this duration is equal to or greater than the duration passed in
+     * @return true if this duration is greater than the duration passed in
      */
     boolean isLongerThan(ReadableDuration duration);
 
@@ -111,7 +111,7 @@
      * Is the length of this duration shorter than the duration passed in.
      *
      * @param duration  another duration to compare to, null means zero milliseconds
-     * @return true if this duration is equal to or less than the duration passed in
+     * @return true if this duration is less than the duration passed in
      */
     boolean isShorterThan(ReadableDuration duration);
 

From fcf264d737af5a37d45c6c5c9802487ce53c8de8 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Wed, 2 Apr 2014 11:11:44 +0100
Subject: [PATCH 67/86] Fix Javadoc for ReadableDuration

See #137
---
 RELEASE-NOTES.txt | 2 ++
 pom.xml           | 4 ++++
 2 files changed, 6 insertions(+)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index d400fcea7..56c1cacfe 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -114,6 +114,8 @@ Bug fixes since 2.3
 
 - Better Javadoc for DateTimeFormat fraction of second [#62]
 
+- Fix Javadoc for ReadableDuration [#137]
+
 
 Scala
 --------
diff --git a/pom.xml b/pom.xml
index 03bf6957b..52f47b375 100644
--- a/pom.xml
+++ b/pom.xml
@@ -88,6 +88,10 @@
     <contributor>
       <name>Sean Geoghegan</name>
     </contributor>
+    <contributor>
+      <name>Craig Gidney</name>
+      <url>https://github.com/Strilanc</url>
+    </contributor>
     <contributor>
       <name>haguenau</name>
       <url>https://github.com/haguenau</url>

From 634066471f2941eddfcca3ed2a62c9d254cabccb Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 3 May 2014 09:33:09 +0100
Subject: [PATCH 68/86] Remove ISOChronology fast cache

My testing suggests it has no or negative benefit at this point
Synchronized block it defended was recently removed in #126
See #105
---
 RELEASE-NOTES.txt                             |  2 +-
 .../org/joda/time/chrono/ISOChronology.java   | 16 +---
 src/test/java/org/joda/time/MockZone.java     | 25 ++++-
 .../joda/time/chrono/ThreadContention.java    | 94 +++++++++++++++++++
 4 files changed, 120 insertions(+), 17 deletions(-)
 create mode 100644 src/test/java/org/joda/time/chrono/ThreadContention.java

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 56c1cacfe..d68f4e4ff 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -29,7 +29,7 @@ Enhancements since 2.3
   Ensure that Appendable can be used efficiently in printing [#120, #121, #122]
   No API change
 
-- Increased performance of chronology lookup [#126]
+- Increased performance of chronology lookup [#126,#105]
   No API change
 
 - Increased performance of formatter lookup [#127,#129]
diff --git a/src/main/java/org/joda/time/chrono/ISOChronology.java b/src/main/java/org/joda/time/chrono/ISOChronology.java
index 08b3d08d0..af70fc4a6 100644
--- a/src/main/java/org/joda/time/chrono/ISOChronology.java
+++ b/src/main/java/org/joda/time/chrono/ISOChronology.java
@@ -46,22 +46,16 @@
  * @since 1.0
  */
 public final class ISOChronology extends AssembledChronology {
-    
+
     /** Serialization lock */
     private static final long serialVersionUID = -6212696554273812441L;
 
     /** Singleton instance of a UTC ISOChronology */
     private static final ISOChronology INSTANCE_UTC;
-        
-    private static final int FAST_CACHE_SIZE = 64;
-
-    /** Fast cache of zone to chronology */
-    private static final ISOChronology[] cFastCache;
 
     /** Cache of zone to chronology */
     private static final ConcurrentHashMap<DateTimeZone, ISOChronology> cCache = new ConcurrentHashMap<DateTimeZone, ISOChronology>();
     static {
-        cFastCache = new ISOChronology[FAST_CACHE_SIZE];
         INSTANCE_UTC = new ISOChronology(GregorianChronology.getInstanceUTC());
         cCache.put(DateTimeZone.UTC, INSTANCE_UTC);
     }
@@ -95,12 +89,7 @@ public static ISOChronology getInstance(DateTimeZone zone) {
         if (zone == null) {
             zone = DateTimeZone.getDefault();
         }
-        int index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);
-        ISOChronology chrono = cFastCache[index];
-        if (chrono != null && chrono.getZone() == zone) {
-            return chrono;
-        }
-        chrono = cCache.get(zone);
+        ISOChronology chrono = cCache.get(zone);
         if (chrono == null) {
             chrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));
             ISOChronology oldChrono = cCache.putIfAbsent(zone, chrono);
@@ -108,7 +97,6 @@ public static ISOChronology getInstance(DateTimeZone zone) {
                 chrono = oldChrono;
             }
         }
-        cFastCache[index] = chrono;
         return chrono;
     }
 
diff --git a/src/test/java/org/joda/time/MockZone.java b/src/test/java/org/joda/time/MockZone.java
index bc3621eb8..766015130 100644
--- a/src/test/java/org/joda/time/MockZone.java
+++ b/src/test/java/org/joda/time/MockZone.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2007 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -52,7 +52,28 @@ public String getNameKey(long instant) {
         return null;
     }
 
-    public boolean equals(Object object) {
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj instanceof MockZone) {
+            MockZone other = (MockZone) obj;
+            return (sizeMillis == other.sizeMillis) &&
+                (transition != other.transition) &&
+                (winterOffset != other.winterOffset);
+        }
         return false;
     }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = super.hashCode();
+        result = prime * result + sizeMillis;
+        result = prime * result + (int) (transition ^ (transition >>> 32));
+        result = prime * result + winterOffset;
+        return result;
+    }
+
 }
diff --git a/src/test/java/org/joda/time/chrono/ThreadContention.java b/src/test/java/org/joda/time/chrono/ThreadContention.java
new file mode 100644
index 000000000..5f25086a3
--- /dev/null
+++ b/src/test/java/org/joda/time/chrono/ThreadContention.java
@@ -0,0 +1,94 @@
+/*
+ *  Copyright 2001-2014 Stephen Colebourne
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.joda.time.chrono;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+
+import junit.framework.Assert;
+
+import org.joda.time.DateTimeZone;
+
+/**
+ * This class is a testing class for threading.
+ */
+public class ThreadContention {
+
+    public static void main(String[] args) {
+        multiThreadZones();
+        singleThreadZones();
+    }
+
+    //-------------------------------------------------------------------------
+    private static void multiThreadZones() {
+        final CountDownLatch latch = new CountDownLatch(1);
+        final List<DateTimeZone> zones = createZones();
+        List<Runnable> runnables = new ArrayList<Runnable>();
+        for (int i = 0; i < 100; i++) { 
+            Runnable r = new Runnable() {
+                public void run() {
+                    try {
+                        latch.await();
+                        List<DateTimeZone> shuffled = new ArrayList<DateTimeZone>(zones);
+                        Collections.shuffle(shuffled);
+                        String name = Thread.currentThread().getName();
+                        for (int j = 0; j < 100; j++) { 
+                            for (DateTimeZone zn : shuffled) {
+                                ISOChronology chrono = ISOChronology.getInstance(zn);
+                                Assert.assertEquals(zn, chrono.getZone());
+                            }
+                        }
+                      System.out.println("Finished: " + name);
+                        
+                    } catch (Exception ex) {
+                        ex.printStackTrace();
+                        System.exit(1);
+                    }
+                }
+            };
+            new Thread(r).start();
+            runnables.add(r);
+        }
+        latch.countDown();
+    }
+
+    private static void singleThreadZones() {
+        List<DateTimeZone> zones = createZones();
+        List<DateTimeZone> shuffled = new ArrayList<DateTimeZone>(zones);
+        Collections.shuffle(shuffled);
+        long start = System.nanoTime();
+        int count = 0;
+        for (int j = 0; j < 10000; j++) { 
+            for (DateTimeZone zn : shuffled) {
+                ISOChronology chrono = ISOChronology.getInstance(zn);
+                count = count + chrono.getZone().getID().length();
+            }
+        }
+        long end = System.nanoTime();
+        System.out.println("Finished " + count + " " + (end - start) / 1000000);
+    }
+
+    private static List<DateTimeZone> createZones() {
+        final List<DateTimeZone> zones = new ArrayList<DateTimeZone>();
+        for (final String zone : DateTimeZone.getAvailableIDs()) {
+            zones.add(DateTimeZone.forID(zone));
+        }
+        return zones;
+    }
+
+}

From 17b9af5a4455dbac76cf21e2cc7261c678361ae5 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 3 May 2014 09:56:32 +0100
Subject: [PATCH 69/86] Increased performance of symbols lookup

Cache was never used
Weak map seems like overkill
Fixes #143
---
 RELEASE-NOTES.txt                             |  3 +
 .../org/joda/time/chrono/GJLocaleSymbols.java | 40 +++++------
 .../joda/time/chrono/ThreadContention.java    | 72 +++++++++++++++++++
 3 files changed, 92 insertions(+), 23 deletions(-)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index d68f4e4ff..57ccac506 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -35,6 +35,9 @@ Enhancements since 2.3
 - Increased performance of formatter lookup [#127,#129]
   No API change
 
+- Increased performance of symbols lookup [#143]
+  No API change
+
 
 Compatibility with 2.3
 ----------------------
diff --git a/src/main/java/org/joda/time/chrono/GJLocaleSymbols.java b/src/main/java/org/joda/time/chrono/GJLocaleSymbols.java
index 2c8fa154f..137c7414f 100644
--- a/src/main/java/org/joda/time/chrono/GJLocaleSymbols.java
+++ b/src/main/java/org/joda/time/chrono/GJLocaleSymbols.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2009 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -15,11 +15,11 @@
  */
 package org.joda.time.chrono;
 
-import java.lang.ref.WeakReference;
 import java.text.DateFormatSymbols;
 import java.util.Locale;
 import java.util.TreeMap;
-import java.util.WeakHashMap;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 import org.joda.time.DateTimeFieldType;
 import org.joda.time.DateTimeUtils;
@@ -32,29 +32,27 @@
  * @since 1.0
  */
 class GJLocaleSymbols {
-    private static final int FAST_CACHE_SIZE = 64;
 
-    private static final GJLocaleSymbols[] cFastCache = new GJLocaleSymbols[FAST_CACHE_SIZE];
+    private static ConcurrentMap<Locale, GJLocaleSymbols> cCache = new ConcurrentHashMap<Locale, GJLocaleSymbols>();
 
-    private static WeakHashMap<Locale, GJLocaleSymbols> cCache = new WeakHashMap<Locale, GJLocaleSymbols>();
-
-    public static GJLocaleSymbols forLocale(Locale locale) {
+    /**
+     * Obtains the symbols for a locale.
+     * 
+     * @param locale  the locale, null returns default
+     * @return the symbols, not null
+     */
+    static GJLocaleSymbols forLocale(Locale locale) {
         if (locale == null) {
             locale = Locale.getDefault();
         }
-        int index = System.identityHashCode(locale) & (FAST_CACHE_SIZE - 1);
-        GJLocaleSymbols symbols = cFastCache[index];
-        if (symbols != null && symbols.iLocale.get() == locale) {
-            return symbols;
-        }
-        synchronized (cCache) {
-            symbols = cCache.get(locale);
-            if (symbols == null) {
-                symbols = new GJLocaleSymbols(locale);
-                cCache.put(locale, symbols);
+        GJLocaleSymbols symbols = cCache.get(locale);
+        if (symbols == null) {
+            symbols = new GJLocaleSymbols(locale);
+            GJLocaleSymbols oldSymbols = cCache.putIfAbsent(locale, symbols);
+            if (oldSymbols != null) {
+                symbols = oldSymbols;
             }
         }
-        cFastCache[index] = symbols;
         return symbols;
     }
 
@@ -103,8 +101,6 @@ private static int maxLength(String[] a) {
         return max;
     }
 
-    private final WeakReference<Locale> iLocale;
-
     private final String[] iEras;
     private final String[] iDaysOfWeek;
     private final String[] iShortDaysOfWeek;
@@ -127,8 +123,6 @@ private static int maxLength(String[] a) {
      * @param locale must not be null
      */
     private GJLocaleSymbols(Locale locale) {
-        iLocale = new WeakReference<Locale>(locale);
-        
         DateFormatSymbols dfs = DateTimeUtils.getDateFormatSymbols(locale);
         
         iEras = dfs.getEras();
diff --git a/src/test/java/org/joda/time/chrono/ThreadContention.java b/src/test/java/org/joda/time/chrono/ThreadContention.java
index 5f25086a3..7de1e2257 100644
--- a/src/test/java/org/joda/time/chrono/ThreadContention.java
+++ b/src/test/java/org/joda/time/chrono/ThreadContention.java
@@ -16,8 +16,10 @@
 package org.joda.time.chrono;
 
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
+import java.util.Locale;
 import java.util.concurrent.CountDownLatch;
 
 import junit.framework.Assert;
@@ -30,10 +32,80 @@
 public class ThreadContention {
 
     public static void main(String[] args) {
+        multiThreadGJLocale();
+        singleThreadGJLocale2();
+        singleThreadGJLocale();
         multiThreadZones();
         singleThreadZones();
     }
 
+    //-------------------------------------------------------------------------
+    private static void multiThreadGJLocale() {
+        final CountDownLatch latch = new CountDownLatch(1);
+        final List<Locale> locales = createLocales();
+        List<Runnable> runnables = new ArrayList<Runnable>();
+        for (int i = 0; i < 100; i++) { 
+            Runnable r = new Runnable() {
+                public void run() {
+                    try {
+                        latch.await();
+                        List<Locale> shuffled = new ArrayList<Locale>(locales);
+                        Collections.shuffle(shuffled);
+                        String name = Thread.currentThread().getName();
+                        for (int j = 0; j < 100; j++) { 
+                            for (Locale locale : shuffled) {
+                                GJLocaleSymbols symbols = GJLocaleSymbols.forLocale(locale);
+                                Assert.assertEquals(GJLocaleSymbols.class, symbols.getClass());
+                            }
+                        }
+                      System.out.println("Finished: " + name);
+                        
+                    } catch (Exception ex) {
+                        ex.printStackTrace();
+                        System.exit(1);
+                    }
+                }
+            };
+            new Thread(r).start();
+            runnables.add(r);
+        }
+        latch.countDown();
+    }
+
+    private static void singleThreadGJLocale() {
+        List<Locale> locales = createLocales();
+        List<Locale> shuffled = new ArrayList<Locale>(locales);
+        Collections.shuffle(shuffled);
+        long start = System.nanoTime();
+        int count = 0;
+        for (int j = 0; j < 10000; j++) { 
+            for (Locale locale : shuffled) {
+                GJLocaleSymbols symbols = GJLocaleSymbols.forLocale(locale);
+                count = count + symbols.getDayOfWeekMaxShortTextLength();
+            }
+        }
+        long end = System.nanoTime();
+        System.out.println("Finished " + count + " " + (end - start) / 1000000);
+    }
+
+    private static void singleThreadGJLocale2() {
+        List<Locale> locales = createLocales();
+        List<Locale> shuffled = new ArrayList<Locale>(locales);
+        Collections.shuffle(shuffled);
+        long start = System.nanoTime();
+        int count = 0;
+        for (int j = 0; j < 1000000; j++) { 
+            GJLocaleSymbols symbols = GJLocaleSymbols.forLocale(Locale.US);
+            count = count + symbols.getDayOfWeekMaxShortTextLength() + symbols.hashCode();
+        }
+        long end = System.nanoTime();
+        System.out.println("Finished " + count + " " + (end - start) / 1000000);
+    }
+
+    private static List<Locale> createLocales() {
+        return Arrays.asList(Locale.getAvailableLocales());
+    }
+
     //-------------------------------------------------------------------------
     private static void multiThreadZones() {
         final CountDownLatch latch = new CountDownLatch(1);

From ece149201b73df13b3a40e46f2ab4c26aa81c633 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 3 May 2014 09:57:58 +0100
Subject: [PATCH 70/86] Use appropriate variable names

These fields are not constants
---
 .../org/joda/time/format/DateTimeFormat.java   | 18 +++++++++---------
 1 file changed, 9 insertions(+), 9 deletions(-)

diff --git a/src/main/java/org/joda/time/format/DateTimeFormat.java b/src/main/java/org/joda/time/format/DateTimeFormat.java
index e04879abe..e7c050fc9 100644
--- a/src/main/java/org/joda/time/format/DateTimeFormat.java
+++ b/src/main/java/org/joda/time/format/DateTimeFormat.java
@@ -151,9 +151,9 @@
     /** Maximum size of the pattern cache. */
     private static final int PATTERN_CACHE_SIZE = 500;
     /** Maps patterns to formatters, patterns don't vary by locale. Size capped at PATTERN_CACHE_SIZE*/
-    private static final ConcurrentHashMap<String, DateTimeFormatter> PATTERN_CACHE = new ConcurrentHashMap<String, DateTimeFormatter>();
+    private static final ConcurrentHashMap<String, DateTimeFormatter> cPatternCache = new ConcurrentHashMap<String, DateTimeFormatter>();
     /** Maps patterns to formatters, patterns don't vary by locale. */
-    private static final AtomicReferenceArray<DateTimeFormatter> STYLE_CACHE = new AtomicReferenceArray<DateTimeFormatter>(25);
+    private static final AtomicReferenceArray<DateTimeFormatter> cStyleCache = new AtomicReferenceArray<DateTimeFormatter>(25);
 
     //-----------------------------------------------------------------------
     /**
@@ -681,15 +681,15 @@ private static DateTimeFormatter createFormatterForPattern(String pattern) {
         if (pattern == null || pattern.length() == 0) {
             throw new IllegalArgumentException("Invalid pattern specification");
         }
-        DateTimeFormatter formatter = PATTERN_CACHE.get(pattern);
+        DateTimeFormatter formatter = cPatternCache.get(pattern);
         if (formatter == null) {
             DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();
             parsePatternTo(builder, pattern);
             formatter = builder.toFormatter();
-            if (PATTERN_CACHE.size() < PATTERN_CACHE_SIZE) {
+            if (cPatternCache.size() < PATTERN_CACHE_SIZE) {
                 // the size check is not locked against concurrent access,
                 // but is accepted to be slightly off in contention scenarios.
-                DateTimeFormatter oldFormatter = PATTERN_CACHE.putIfAbsent(pattern, formatter);
+                DateTimeFormatter oldFormatter = cPatternCache.putIfAbsent(pattern, formatter);
                 if (oldFormatter != null) {
                     formatter = oldFormatter;
                 }
@@ -729,14 +729,14 @@ private static DateTimeFormatter createFormatterForStyle(String style) {
     private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle) {
         int index = ((dateStyle << 2) + dateStyle) + timeStyle;  // (dateStyle * 5 + timeStyle);
         // Should never happen but do a double check...
-        if (index >= STYLE_CACHE.length()) {
+        if (index >= cStyleCache.length()) {
             return createDateTimeFormatter(dateStyle, timeStyle);
         }
-        DateTimeFormatter f = STYLE_CACHE.get(index);
+        DateTimeFormatter f = cStyleCache.get(index);
         if (f == null) {
             f = createDateTimeFormatter(dateStyle, timeStyle);
-            if (STYLE_CACHE.compareAndSet(index, null, f) == false) {
-                f = STYLE_CACHE.get(index);
+            if (cStyleCache.compareAndSet(index, null, f) == false) {
+                f = cStyleCache.get(index);
             }
         }
         return f;

From 6f157ae0dd7d524cf8eeae2a5da0f62080b686a0 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 3 May 2014 11:02:27 +0100
Subject: [PATCH 71/86] Enhance Javadoc for parse and toString

Fixes #142
---
 RELEASE-NOTES.txt                             |  2 ++
 src/main/java/org/joda/time/DateTime.java     | 20 +++++++++++++++++--
 .../java/org/joda/time/MutableDateTime.java   | 13 +-----------
 .../org/joda/time/base/AbstractDateTime.java  | 20 ++++++++++++++++++-
 .../org/joda/time/base/AbstractInstant.java   |  6 +++---
 .../joda/time/TestDateTime_Constructors.java  | 15 ++++++++++++++
 6 files changed, 58 insertions(+), 18 deletions(-)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 57ccac506..6dd6bac30 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -117,6 +117,8 @@ Bug fixes since 2.3
 
 - Better Javadoc for DateTimeFormat fraction of second [#62]
 
+- Better Javadoc for DateTime toString and parse [#142]
+
 - Fix Javadoc for ReadableDuration [#137]
 
 
diff --git a/src/main/java/org/joda/time/DateTime.java b/src/main/java/org/joda/time/DateTime.java
index bb879a981..14117b22b 100644
--- a/src/main/java/org/joda/time/DateTime.java
+++ b/src/main/java/org/joda/time/DateTime.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2013 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -123,7 +123,23 @@ public static DateTime now(Chronology chronology) {
     /**
      * Parses a {@code DateTime} from the specified string.
      * <p>
-     * This uses {@link ISODateTimeFormat#dateTimeParser()}.
+     * This uses {@link ISODateTimeFormat#dateTimeParser().withOffsetParsed()}
+     * which is different to passing a {@code String} to the constructor.
+     * <p>
+     * Sometimes this method and {@code new DateTime(str)} return different results.
+     * This can be confusing as the different is not visible in {@link #toString()}.
+     * <p>
+     * When passed a date-time string without an offset, such as '2010-06-30T01:20',
+     * both the constructor and this method use the default time-zone.
+     * As such, {@code DateTime.parse("2010-06-30T01:20")} and
+     * {@code new DateTime("2010-06-30T01:20"))} are equal.
+     * <p>
+     * However, when this method is passed a date-time string with an offset,
+     * the offset is directly parsed and stored.
+     * As such, {@code DateTime.parse("2010-06-30T01:20+02:00")} and
+     * {@code new DateTime("2010-06-30T01:20+02:00"))} are NOT equal.
+     * The object produced via this method has a zone of {@code DateTimeZone.forOffsetHours(1)}.
+     * The object produced via the constructor has a zone of {@code DateTimeZone.getDefault()}.
      * 
      * @param str  the string to parse, not null
      * @since 2.0
diff --git a/src/main/java/org/joda/time/MutableDateTime.java b/src/main/java/org/joda/time/MutableDateTime.java
index 9aa8602ac..681331673 100644
--- a/src/main/java/org/joda/time/MutableDateTime.java
+++ b/src/main/java/org/joda/time/MutableDateTime.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2013 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -22,7 +22,6 @@
 import java.util.Locale;
 
 import org.joda.convert.FromString;
-import org.joda.convert.ToString;
 import org.joda.time.base.BaseDateTime;
 import org.joda.time.chrono.ISOChronology;
 import org.joda.time.field.AbstractReadableInstantFieldProperty;
@@ -1239,16 +1238,6 @@ public Object clone() {
         }
     }
 
-    /**
-     * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZZ).
-     * 
-     * @return ISO8601 time formatted string.
-     */
-    @ToString
-    public String toString() {
-        return ISODateTimeFormat.dateTime().print(this);
-    }
-
     /**
      * MutableDateTime.Property binds a MutableDateTime to a
      * DateTimeField allowing powerful datetime functionality to be easily
diff --git a/src/main/java/org/joda/time/base/AbstractDateTime.java b/src/main/java/org/joda/time/base/AbstractDateTime.java
index 7825df73a..0c0069f30 100644
--- a/src/main/java/org/joda/time/base/AbstractDateTime.java
+++ b/src/main/java/org/joda/time/base/AbstractDateTime.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2011 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -19,6 +19,7 @@
 import java.util.GregorianCalendar;
 import java.util.Locale;
 
+import org.joda.convert.ToString;
 import org.joda.time.DateTimeFieldType;
 import org.joda.time.DateTimeZone;
 import org.joda.time.ReadableDateTime;
@@ -298,10 +299,26 @@ public GregorianCalendar toGregorianCalendar() {
     }
 
     //-----------------------------------------------------------------------
+    /**
+     * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZZ).
+     * <p>
+     * Note that this method does not output the chronology or time-zone.
+     * This can be confusing, as the equals and hashCode methods use both
+     * chronology and time-zone. If two objects are not {@code equal} but have the
+     * same {@code toString} then either the chronology or time-zone differs.
+     * 
+     * @return ISO8601 time formatted string, not null
+     */
+    @ToString
+    public String toString() {
+        return super.toString();
+    }
+
     /**
      * Output the instant using the specified format pattern.
      *
      * @param pattern  the pattern specification, null means use <code>toString</code>
+     * @return the formatted string, not null
      * @see  org.joda.time.format.DateTimeFormat
      */
     public String toString(String pattern) {
@@ -316,6 +333,7 @@ public String toString(String pattern) {
      *
      * @param pattern  the pattern specification, null means use <code>toString</code>
      * @param locale  Locale to use, null means default
+     * @return the formatted string, not null
      * @see  org.joda.time.format.DateTimeFormat
      */
     public String toString(String pattern, Locale locale) throws IllegalArgumentException {
diff --git a/src/main/java/org/joda/time/base/AbstractInstant.java b/src/main/java/org/joda/time/base/AbstractInstant.java
index 4f010f2a0..e78154253 100644
--- a/src/main/java/org/joda/time/base/AbstractInstant.java
+++ b/src/main/java/org/joda/time/base/AbstractInstant.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2010 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -417,7 +417,7 @@ public boolean isEqual(ReadableInstant instant) {
     /**
      * Output the date time in ISO8601 format (yyyy-MM-ddTHH:mm:ss.SSSZZ).
      * 
-     * @return ISO8601 time formatted string.
+     * @return ISO8601 time formatted string, not null
      */
     @ToString
     public String toString() {
@@ -429,7 +429,7 @@ public String toString() {
      * Uses the specified formatter to convert this partial to a String.
      *
      * @param formatter  the formatter to use, null means use <code>toString()</code>.
-     * @return the formatted string
+     * @return the formatted string, not null
      * @since 1.1
      */
     public String toString(DateTimeFormatter formatter) {
diff --git a/src/test/java/org/joda/time/TestDateTime_Constructors.java b/src/test/java/org/joda/time/TestDateTime_Constructors.java
index ffff26f22..24f2b1d06 100644
--- a/src/test/java/org/joda/time/TestDateTime_Constructors.java
+++ b/src/test/java/org/joda/time/TestDateTime_Constructors.java
@@ -158,6 +158,21 @@ public void testParse_noFormatter() throws Throwable {
         assertEquals(new DateTime(2010, 1, 2, 14, 50, ISOChronology.getInstance(LONDON)), DateTime.parse("2010-002T14:50"));
     }
 
+    public void testParse_noFormatter_vs_constructor_noOffset() throws Throwable {
+        DateTime parsed = DateTime.parse("2010-06-30T01:20");
+        DateTime constructed = new DateTime("2010-06-30T01:20");
+        assertEquals(constructed, parsed);
+        assertEquals(DateTimeZone.getDefault(), constructed.getZone());
+        assertEquals(DateTimeZone.getDefault(), parsed.getZone());
+    }
+
+    public void testParse_noFormatter_vs_constructor_correctOffset() throws Throwable {
+        DateTime parsed = DateTime.parse("2010-06-30T01:20+01:00");
+        DateTime constructed = new DateTime("2010-06-30T01:20+01:00");
+        assertEquals(DateTimeZone.getDefault(), constructed.getZone());
+        assertEquals(DateTimeZone.forOffsetHours(1), parsed.getZone());
+    }
+
     public void testParse_formatter() throws Throwable {
         DateTimeFormatter f = DateTimeFormat.forPattern("yyyy--dd MM HH").withChronology(ISOChronology.getInstance(PARIS));
         assertEquals(new DateTime(2010, 6, 30, 13, 0, ISOChronology.getInstance(PARIS)), DateTime.parse("2010--30 06 13", f));

From ec4c7b5fe0d7e52ccd43090bf2f8eb651f74b5db Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Tue, 6 May 2014 23:26:40 +0100
Subject: [PATCH 72/86] Avoid creating Partials with order weekyear-year

Define year as greater than weekyear
Fixes #96
Fixes #98
---
 RELEASE-NOTES.txt                             |  3 ++
 src/main/java/org/joda/time/Partial.java      | 50 ++++++++++++-------
 .../joda/time/TestPartial_Constructors.java   | 46 +++++++++++++++--
 3 files changed, 78 insertions(+), 21 deletions(-)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 6dd6bac30..9783116e8 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -93,6 +93,9 @@ Bug fixes since 2.3
 - Ensure isLeap() returns correct result for day fields [#110]
   Day-of-month and day-of-year fields should report leap days
 
+- Insist that year > weekyear when creating Partial [#96,#98]
+  As these compare equal code previously allowed either order
+
 - Handle weird TimeZone implementations with null ID [#133]
   Calling DateTimeZone.forTimeZone() would break if the ID was null
 
diff --git a/src/main/java/org/joda/time/Partial.java b/src/main/java/org/joda/time/Partial.java
index cd4383bdc..a97311651 100644
--- a/src/main/java/org/joda/time/Partial.java
+++ b/src/main/java/org/joda/time/Partial.java
@@ -164,6 +164,8 @@ public Partial(DateTimeFieldType type, int value, Chronology chronology) {
     /**
      * Constructs a Partial with the specified fields and values.
      * The fields must be specified in the order largest to smallest.
+     * For year and weekyear fields with equal duration, year is defined
+     * as being larger than weekyear.
      * <p>
      * The constructor uses the specified chronology.
      * 
@@ -178,6 +180,8 @@ public Partial(DateTimeFieldType[] types, int[] values) {
     /**
      * Constructs a Partial with the specified fields and values.
      * The fields must be specified in the order largest to smallest.
+     * For year and weekyear fields with equal duration, year is defined
+     * as being larger than weekyear.
      * <p>
      * The constructor uses the specified chronology.
      * 
@@ -227,26 +231,36 @@ public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
                 if (compare < 0) {
                     throw new IllegalArgumentException("Types array must be in order largest-smallest: " +
                             types[i - 1].getName() + " < " + loopType.getName());
-                } else if (compare == 0 && lastUnitField.equals(loopUnitField)) {
-                    if (types[i - 1].getRangeDurationType() == null) {
-                        if (loopType.getRangeDurationType() == null) {
-                            throw new IllegalArgumentException("Types array must not contain duplicate: " +
-                                            types[i - 1].getName() + " and " + loopType.getName());
+                } else if (compare == 0) {
+                    if (lastUnitField.equals(loopUnitField)) {
+                        DurationFieldType lastRangeType = types[i - 1].getRangeDurationType();
+                        DurationFieldType loopRangeType = loopType.getRangeDurationType();
+                        if (lastRangeType == null) {
+                            if (loopRangeType == null) {
+                                throw new IllegalArgumentException("Types array must not contain duplicate: " +
+                                                types[i - 1].getName() + " and " + loopType.getName());
+                            }
+                        } else {
+                            if (loopRangeType == null) {
+                                throw new IllegalArgumentException("Types array must be in order largest-smallest: " +
+                                        types[i - 1].getName() + " < " + loopType.getName());
+                            }
+                            DurationField lastRangeField = lastRangeType.getField(iChronology);
+                            DurationField loopRangeField = loopRangeType.getField(iChronology);
+                            if (lastRangeField.compareTo(loopRangeField) < 0) {
+                                throw new IllegalArgumentException("Types array must be in order largest-smallest: " +
+                                        types[i - 1].getName() + " < " + loopType.getName());
+                            }
+                            if (lastRangeField.compareTo(loopRangeField) == 0) {
+                                throw new IllegalArgumentException("Types array must not contain duplicate: " +
+                                                types[i - 1].getName() + " and " + loopType.getName());
+                            }
                         }
                     } else {
-                        if (loopType.getRangeDurationType() == null) {
-                            throw new IllegalArgumentException("Types array must be in order largest-smallest: " +
-                                    types[i - 1].getName() + " < " + loopType.getName());
-                        }
-                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);
-                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
-                        if (lastRangeField.compareTo(loopRangeField) < 0) {
-                            throw new IllegalArgumentException("Types array must be in order largest-smallest: " +
-                                    types[i - 1].getName() + " < " + loopType.getName());
-                        }
-                        if (lastRangeField.compareTo(loopRangeField) == 0) {
-                            throw new IllegalArgumentException("Types array must not contain duplicate: " +
-                                            types[i - 1].getName() + " and " + loopType.getName());
+                        if (lastUnitField.isSupported() && lastUnitField.getType() != DurationFieldType.YEARS_TYPE) {
+                            throw new IllegalArgumentException("Types array must be in order largest-smallest," +
+                                            " for year-based fields, years is defined as being largest: " +
+                                            types[i - 1].getName() + " < " + loopType.getName());
                         }
                     }
                 }
diff --git a/src/test/java/org/joda/time/TestPartial_Constructors.java b/src/test/java/org/joda/time/TestPartial_Constructors.java
index 9a91bfadd..8d5e2027e 100644
--- a/src/test/java/org/joda/time/TestPartial_Constructors.java
+++ b/src/test/java/org/joda/time/TestPartial_Constructors.java
@@ -189,6 +189,28 @@ public void testConstructor_TypeArray_intArray() throws Throwable {
         assertEquals(true, Arrays.equals(test.getValues(), values));
     }
 
+    /**
+     * Test constructor
+     */
+    public void testConstructor_TypeArray_intArray_year_weekyear() throws Throwable {
+        DateTimeFieldType[] types = new DateTimeFieldType[] {
+            DateTimeFieldType.year(),
+            DateTimeFieldType.weekyear()
+        };
+        int[] values = new int[] {2005, 2006};
+        Partial test = new Partial(types, values);
+        assertEquals(ISO_UTC, test.getChronology());
+        assertEquals(2, test.size());
+        assertEquals(2005, test.getValue(0));
+        assertEquals(2005, test.get(DateTimeFieldType.year()));
+        assertEquals(true, test.isSupported(DateTimeFieldType.year()));
+        assertEquals(2006, test.getValue(1));
+        assertEquals(2006, test.get(DateTimeFieldType.weekyear()));
+        assertEquals(true, test.isSupported(DateTimeFieldType.weekyear()));
+        assertEquals(true, Arrays.equals(test.getFieldTypes(), types));
+        assertEquals(true, Arrays.equals(test.getValues(), values));
+    }
+
     /**
      * Test constructor
      */
@@ -257,7 +279,7 @@ public void testConstructorEx6_TypeArray_intArray() throws Throwable {
     /**
      * Test constructor
      */
-    public void testConstructorEx7_TypeArray_intArray() throws Throwable {
+    public void testConstructorEx7_TypeArray_intArray_inOrder() throws Throwable {
         int[] values = new int[] {1, 1, 1};
         DateTimeFieldType[] types = new DateTimeFieldType[] {
             DateTimeFieldType.dayOfMonth(), DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };
@@ -312,12 +334,30 @@ public void testConstructorEx7_TypeArray_intArray() throws Throwable {
         } catch (IllegalArgumentException ex) {
             assertMessageContains(ex, "must be in order", "largest-smallest");
         }
+        
+        types = new DateTimeFieldType[] {
+            DateTimeFieldType.weekyear(), DateTimeFieldType.yearOfCentury(), DateTimeFieldType.dayOfMonth() };
+        try {
+            new Partial(types, values);
+            fail();
+        } catch (IllegalArgumentException ex) {
+            assertMessageContains(ex, "must be in order", "largest-smallest");
+        }
+        
+        types = new DateTimeFieldType[] {
+            DateTimeFieldType.weekyear(), DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth() };
+        try {
+            new Partial(types, values);
+            fail();
+        } catch (IllegalArgumentException ex) {
+            assertMessageContains(ex, "must be in order", "largest-smallest");
+        }
     }
 
     /**
      * Test constructor
      */
-    public void testConstructorEx8_TypeArray_intArray() throws Throwable {
+    public void testConstructorEx8_TypeArray_intArray_duplicate() throws Throwable {
         int[] values = new int[] {1, 1, 1};
         DateTimeFieldType[] types = new DateTimeFieldType[] {
             DateTimeFieldType.era(), DateTimeFieldType.year(), DateTimeFieldType.year() };
@@ -367,7 +407,7 @@ public void testConstructorEx9_TypeArray_intArray() throws Throwable {
             new Partial(types, values);
             fail();
         } catch (IllegalArgumentException ex) {
-            // expected
+            assertMessageContains(ex, "Value 0");
         }
     }
 

From c38ff0f986664b7d195d62391ff23f3f4e6139bd Mon Sep 17 00:00:00 2001
From: vrozkovec <vit.rozkovec@gmail.com>
Date: Thu, 29 May 2014 17:15:42 +0200
Subject: [PATCH 73/86] fixed javadoc description

---
 src/main/java/org/joda/time/Interval.java | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/src/main/java/org/joda/time/Interval.java b/src/main/java/org/joda/time/Interval.java
index b2aa61b23..c3983d413 100644
--- a/src/main/java/org/joda/time/Interval.java
+++ b/src/main/java/org/joda/time/Interval.java
@@ -432,8 +432,8 @@ public Interval withDurationAfterStart(ReadableDuration duration) {
     /**
      * Creates a new interval with the specified duration before the end instant.
      *
-     * @param duration  the duration to add to the start to get the new end instant, null means zero
-     * @return an interval with the start from this interval and a calculated end
+     * @param duration  the duration to subtract from the end to get the new start instant, null means zero
+     * @return an interval with the end from this interval and a calculated start
      * @throws IllegalArgumentException if the duration is negative
      */
     public Interval withDurationBeforeEnd(ReadableDuration duration) {
@@ -468,8 +468,8 @@ public Interval withPeriodAfterStart(ReadablePeriod period) {
     /**
      * Creates a new interval with the specified period before the end instant.
      *
-     * @param period  the period to add to the start to get the new end instant, null means zero
-     * @return an interval with the start from this interval and a calculated end
+     * @param period the duration to subtract from the end to get the new start instant, null means zero
+     * @return an interval with the end from this interval and a calculated start
      * @throws IllegalArgumentException if the period is negative
      */
     public Interval withPeriodBeforeEnd(ReadablePeriod period) {

From 3a2fe0a8f85e96efc9543306786bdb372d4c4be2 Mon Sep 17 00:00:00 2001
From: vrozkovec <vit.rozkovec@gmail.com>
Date: Thu, 29 May 2014 17:16:55 +0200
Subject: [PATCH 74/86] fixed javadoc

---
 src/main/java/org/joda/time/Interval.java | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/main/java/org/joda/time/Interval.java b/src/main/java/org/joda/time/Interval.java
index c3983d413..99397eba3 100644
--- a/src/main/java/org/joda/time/Interval.java
+++ b/src/main/java/org/joda/time/Interval.java
@@ -468,7 +468,7 @@ public Interval withPeriodAfterStart(ReadablePeriod period) {
     /**
      * Creates a new interval with the specified period before the end instant.
      *
-     * @param period the duration to subtract from the end to get the new start instant, null means zero
+     * @param period the period to subtract from the end to get the new start instant, null means zero
      * @return an interval with the end from this interval and a calculated start
      * @throws IllegalArgumentException if the period is negative
      */

From 002c7b49fcfddbd305b55ca77306eda37ec76ebe Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Wed, 7 May 2014 23:28:52 +0100
Subject: [PATCH 75/86] Test DateTimeParserBucket

See #111
---
 .../time/format/DateTimeParserBucket.java     |  15 +-
 .../java/org/joda/time/format/TestAll.java    |   3 +-
 .../time/format/TestDateTimeParserBucket.java | 246 ++++++++++++++++++
 3 files changed, 257 insertions(+), 7 deletions(-)
 create mode 100644 src/test/java/org/joda/time/format/TestDateTimeParserBucket.java

diff --git a/src/main/java/org/joda/time/format/DateTimeParserBucket.java b/src/main/java/org/joda/time/format/DateTimeParserBucket.java
index 93dfaa78a..1832b4676 100644
--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java
+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2013 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -57,18 +57,19 @@
 
     /** The chronology to use for parsing. */
     private final Chronology iChrono;
+    /** The initial millis. */
     private final long iMillis;
-    
+    /** The locale to use for parsing. */
+    private final Locale iLocale;
+    /** Used for parsing month/day without year. */
+    private final int iDefaultYear;
+
     /** The parsed zone, initialised to formatter zone. */
     private DateTimeZone iZone;
     /** The parsed offset. */
     private Integer iOffset;
-    /** The locale to use for parsing. */
-    private Locale iLocale;
     /** Used for parsing two-digit years. */
     private Integer iPivotYear;
-    /** Used for parsing month/day without year. */
-    private int iDefaultYear;
 
     private SavedField[] iSavedFields = new SavedField[8];
     private int iSavedFieldsCount;
@@ -113,6 +114,7 @@ public DateTimeParserBucket(long instantLocal, Chronology chrono, Locale locale,
      * @param chrono  the chronology to use
      * @param locale  the locale to use
      * @param pivotYear  the pivot year to use when parsing two-digit years
+     * @param defaultYear  the default year to use when parsing month-day
      * @since 2.0
      */
     public DateTimeParserBucket(long instantLocal, Chronology chrono,
@@ -441,6 +443,7 @@ private static void sort(SavedField[] array, int high) {
         
         boolean restoreState(DateTimeParserBucket enclosing) {
             if (enclosing != DateTimeParserBucket.this) {
+                // block SavedState from a different bucket
                 return false;
             }
             enclosing.iZone = this.iZone;
diff --git a/src/test/java/org/joda/time/format/TestAll.java b/src/test/java/org/joda/time/format/TestAll.java
index 534e170d5..00ea401fe 100644
--- a/src/test/java/org/joda/time/format/TestAll.java
+++ b/src/test/java/org/joda/time/format/TestAll.java
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2001-2006 Stephen Colebourne
+ *  Copyright 2001-2014 Stephen Colebourne
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
  *  you may not use this file except in compliance with the License.
@@ -38,6 +38,7 @@ public static Test suite() {
         suite.addTest(TestDateTimeFormatter.suite());
         suite.addTest(TestDateTimeFormat.suite());
         suite.addTest(TestDateTimeFormatStyle.suite());
+        suite.addTest(TestDateTimeParserBucket.suite());
         suite.addTest(TestISODateTimeFormat.suite());
         suite.addTest(TestISODateTimeFormat_Fields.suite());
         suite.addTest(TestISODateTimeFormatParsing.suite());
diff --git a/src/test/java/org/joda/time/format/TestDateTimeParserBucket.java b/src/test/java/org/joda/time/format/TestDateTimeParserBucket.java
new file mode 100644
index 000000000..892576e9b
--- /dev/null
+++ b/src/test/java/org/joda/time/format/TestDateTimeParserBucket.java
@@ -0,0 +1,246 @@
+/*
+ *  Copyright 2001-2014 Stephen Colebourne
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.joda.time.format;
+
+import java.util.Locale;
+
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+import org.joda.time.Chronology;
+import org.joda.time.DateTimeFieldType;
+import org.joda.time.DateTimeZone;
+import org.joda.time.chrono.BuddhistChronology;
+import org.joda.time.chrono.ISOChronology;
+
+/**
+ * Test.
+ */
+public class TestDateTimeParserBucket extends TestCase {
+
+    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");
+    private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");
+    private static final Chronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC();
+    private static final Chronology BUDDHIST_PARIS = BuddhistChronology.getInstance(PARIS);
+    private static final Chronology ISO_0400 = ISOChronology.getInstance(DateTimeZone.forOffsetHours(4));
+    private static final int MILLIS_PER_HOUR = 3600000;
+    private static final int MILLIS_PER_MINUTE = 60000;
+    private static final int OFFSET_0400 = 4 * MILLIS_PER_HOUR;
+    private static final Locale LOCALE = Locale.CANADA;
+
+    public static void main(String[] args) {
+        junit.textui.TestRunner.run(suite());
+    }
+
+    public static TestSuite suite() {
+        return new TestSuite(TestDateTimeParserBucket.class);
+    }
+
+    public TestDateTimeParserBucket(String name) {
+        super(name);
+    }
+
+    //-----------------------------------------------------------------------
+    @SuppressWarnings("deprecation")
+    public void testConstructor_3arg() {
+        DateTimeParserBucket test = new DateTimeParserBucket(100, BUDDHIST_PARIS, LOCALE);
+        assertEquals(BUDDHIST_UTC, test.getChronology());
+        assertEquals(LOCALE, test.getLocale());
+        assertEquals(null, test.getPivotYear());
+        assertEquals(null, test.getOffsetInteger());
+        assertEquals(PARIS, test.getZone());
+    }
+
+    @SuppressWarnings("deprecation")
+    public void testConstructor_4arg() {
+        DateTimeParserBucket test = new DateTimeParserBucket(100, BUDDHIST_PARIS, LOCALE, 2010);
+        assertEquals(BUDDHIST_UTC, test.getChronology());
+        assertEquals(LOCALE, test.getLocale());
+        assertEquals((Integer) 2010, test.getPivotYear());
+        assertEquals(null, test.getOffsetInteger());
+        assertEquals(PARIS, test.getZone());
+    }
+
+    public void testConstructor_5arg() {
+        DateTimeParserBucket test = new DateTimeParserBucket(100, BUDDHIST_PARIS, LOCALE, 2010, 2001);
+        assertEquals(BUDDHIST_UTC, test.getChronology());
+        assertEquals(LOCALE, test.getLocale());
+        assertEquals((Integer) 2010, test.getPivotYear());
+        assertEquals(null, test.getOffsetInteger());
+        assertEquals(PARIS, test.getZone());
+    }
+
+    public void testSetPivotYear() {
+        DateTimeParserBucket test = new DateTimeParserBucket(100, BUDDHIST_PARIS, LOCALE, 2010, 2001);
+        assertEquals((Integer) 2010, test.getPivotYear());
+        test.setPivotYear(null);
+        assertEquals(null, test.getPivotYear());
+        test.setPivotYear(2030);
+        assertEquals((Integer) 2030, test.getPivotYear());
+    }
+
+    public void testSetOffset() {
+        DateTimeParserBucket test = new DateTimeParserBucket(100, BUDDHIST_PARIS, LOCALE, 2010, 2001);
+        assertEquals(null, test.getOffsetInteger());
+        test.setOffset((Integer) 1000);
+        assertEquals((Integer) 1000, test.getOffsetInteger());
+        test.setOffset(null);
+        assertEquals(null, test.getOffsetInteger());
+    }
+
+    public void testSetZone() {
+        DateTimeParserBucket test = new DateTimeParserBucket(100, BUDDHIST_PARIS, LOCALE, 2010, 2001);
+        assertEquals(PARIS, test.getZone());
+        test.setZone(LONDON);
+        assertEquals(LONDON, test.getZone());
+    }
+
+    public void testCompute() {
+        DateTimeParserBucket test = new DateTimeParserBucket(100, ISO_0400, LOCALE, 2000, 2000);
+        assertEquals(100 - OFFSET_0400, test.computeMillis());
+        assertEquals(100 - OFFSET_0400, test.computeMillis(false));
+        // note that computeMillis(true) differs depending on whether fields are saved or not
+        assertEquals(100 - OFFSET_0400, test.computeMillis(true));
+    }
+
+    public void testSaveCompute() {
+        DateTimeParserBucket test = new DateTimeParserBucket(100, ISO_0400, LOCALE, 2000, 2000);
+        test.saveField(DateTimeFieldType.hourOfDay(), 2);
+        assertEquals(2 * MILLIS_PER_HOUR + 100 - OFFSET_0400, test.computeMillis());
+        assertEquals(2 * MILLIS_PER_HOUR + 100 - OFFSET_0400, test.computeMillis(false));
+        test.saveField(DateTimeFieldType.hourOfDay(), 5);
+        assertEquals(5 * MILLIS_PER_HOUR + 100 - OFFSET_0400, test.computeMillis(false));
+        assertEquals(5 * MILLIS_PER_HOUR - OFFSET_0400, test.computeMillis(true));
+        assertEquals(5 * MILLIS_PER_HOUR + 100 - OFFSET_0400, test.computeMillis(false));
+    }
+
+    public void testSaveRestoreState() {
+        DateTimeParserBucket test = new DateTimeParserBucket(100, ISO_0400, LOCALE, 2000, 2000);
+        test.saveField(DateTimeFieldType.hourOfDay(), 2);
+        assertEquals(2 * MILLIS_PER_HOUR + 100 - OFFSET_0400, test.computeMillis(false));
+        Object state = test.saveState();
+        assertEquals(2 * MILLIS_PER_HOUR + 100 - OFFSET_0400, test.computeMillis(false));
+        test.saveField(DateTimeFieldType.minuteOfHour(), 6);
+        assertEquals(2 * MILLIS_PER_HOUR + 6 * MILLIS_PER_MINUTE + 100 - OFFSET_0400, test.computeMillis(false));
+        assertEquals(true, test.restoreState(state));
+        assertEquals(2 * MILLIS_PER_HOUR + 100 - OFFSET_0400, test.computeMillis(false));
+        test.saveField(DateTimeFieldType.minuteOfHour(), 7);
+        assertEquals(2 * MILLIS_PER_HOUR + 7 * MILLIS_PER_MINUTE + 100 - OFFSET_0400, test.computeMillis(false));
+        assertEquals(true, test.restoreState(state));
+        assertEquals(2 * MILLIS_PER_HOUR + 100 - OFFSET_0400, test.computeMillis(false));
+    }
+
+    public void testSaveRestoreState_avoidSideEffects() {
+        // computeMillis() has side effects, so check works without it
+        DateTimeParserBucket test = new DateTimeParserBucket(100, ISO_0400, LOCALE, 2000, 2000);
+        test.saveField(DateTimeFieldType.hourOfDay(), 2);
+        Object state = test.saveState();
+        test.saveField(DateTimeFieldType.minuteOfHour(), 6);
+        assertEquals(true, test.restoreState(state));
+        test.saveField(DateTimeFieldType.minuteOfHour(), 7);
+        assertEquals(2 * MILLIS_PER_HOUR + 7 * MILLIS_PER_MINUTE + 100 - OFFSET_0400, test.computeMillis(false));
+        assertEquals(true, test.restoreState(state));
+        assertEquals(2 * MILLIS_PER_HOUR + 100 - OFFSET_0400, test.computeMillis(false));
+    }
+
+    public void testSaveRestoreState_offset() {
+        DateTimeParserBucket test = new DateTimeParserBucket(100, ISO_0400, LOCALE, 2000, 2000);
+        test.saveField(DateTimeFieldType.hourOfDay(), 2);
+        assertEquals(2 * MILLIS_PER_HOUR + 100 - OFFSET_0400, test.computeMillis(false));
+        Object state = test.saveState();
+        assertEquals(2 * MILLIS_PER_HOUR + 100 - OFFSET_0400, test.computeMillis(false));
+        test.setOffset((Integer) 0);
+        assertEquals(2 * MILLIS_PER_HOUR + 100, test.computeMillis(false));
+        assertEquals(true, test.restoreState(state));
+        assertEquals(2 * MILLIS_PER_HOUR + 100 - OFFSET_0400, test.computeMillis(false));
+    }
+
+    public void testSaveRestoreState_zone() {
+        DateTimeParserBucket test = new DateTimeParserBucket(100, ISO_0400, LOCALE, 2000, 2000);
+        test.saveField(DateTimeFieldType.hourOfDay(), 2);
+        assertEquals(2 * MILLIS_PER_HOUR + 100 - OFFSET_0400, test.computeMillis(false));
+        Object state = test.saveState();
+        assertEquals(2 * MILLIS_PER_HOUR + 100 - OFFSET_0400, test.computeMillis(false));
+        test.setZone(DateTimeZone.UTC);
+        assertEquals(2 * MILLIS_PER_HOUR + 100, test.computeMillis(false));
+        assertEquals(true, test.restoreState(state));
+        assertEquals(2 * MILLIS_PER_HOUR + 100 - OFFSET_0400, test.computeMillis(false));
+    }
+
+    public void testSaveRestoreState_text() {
+        DateTimeParserBucket test = new DateTimeParserBucket(100, ISO_0400, LOCALE, 2000, 2000);
+        test.saveField(DateTimeFieldType.hourOfDay(), "2", Locale.ENGLISH);
+        assertEquals(2 * MILLIS_PER_HOUR + 100 - OFFSET_0400, test.computeMillis(false));
+        Object state = test.saveState();
+        assertEquals(2 * MILLIS_PER_HOUR + 100 - OFFSET_0400, test.computeMillis(false));
+        test.saveField(DateTimeFieldType.minuteOfHour(), "6", Locale.ENGLISH);
+        assertEquals(2 * MILLIS_PER_HOUR + 6 * MILLIS_PER_MINUTE + 100 - OFFSET_0400, test.computeMillis(false));
+        assertEquals(true, test.restoreState(state));
+        assertEquals(2 * MILLIS_PER_HOUR + 100 - OFFSET_0400, test.computeMillis(false));
+    }
+
+    public void testSaveRestoreState_twoStates() {
+        DateTimeParserBucket test = new DateTimeParserBucket(100, ISO_0400, LOCALE, 2000, 2000);
+        test.saveField(DateTimeFieldType.hourOfDay(), 2);
+        assertEquals(2 * MILLIS_PER_HOUR + 100 - OFFSET_0400, test.computeMillis(false));
+        Object state1 = test.saveState();
+        assertEquals(2 * MILLIS_PER_HOUR + 100 - OFFSET_0400, test.computeMillis(false));
+        test.saveField(DateTimeFieldType.minuteOfHour(), 6);
+        assertEquals(2 * MILLIS_PER_HOUR + 6 * MILLIS_PER_MINUTE + 100 - OFFSET_0400, test.computeMillis(false));
+        Object state2 = test.saveState();
+        assertEquals(2 * MILLIS_PER_HOUR + 6 * MILLIS_PER_MINUTE + 100 - OFFSET_0400, test.computeMillis(false));
+        test.saveField(DateTimeFieldType.secondOfMinute(), 8);
+        assertEquals(2 * MILLIS_PER_HOUR + 6 * MILLIS_PER_MINUTE + 8000 + 100 - OFFSET_0400, test.computeMillis(false));
+        assertEquals(true, test.restoreState(state2));
+        assertEquals(2 * MILLIS_PER_HOUR + 6 * MILLIS_PER_MINUTE + 100 - OFFSET_0400, test.computeMillis(false));
+        assertEquals(true, test.restoreState(state1));
+        assertEquals(2 * MILLIS_PER_HOUR + 100 - OFFSET_0400, test.computeMillis(false));
+        assertEquals(true, test.restoreState(state2));
+        assertEquals(2 * MILLIS_PER_HOUR + 6 * MILLIS_PER_MINUTE + 100 - OFFSET_0400, test.computeMillis(false));
+        assertEquals(true, test.restoreState(state1));
+        assertEquals(2 * MILLIS_PER_HOUR + 100 - OFFSET_0400, test.computeMillis(false));
+    }
+
+    public void testSaveRestoreState_sameStates() {
+        DateTimeParserBucket test = new DateTimeParserBucket(100, ISO_0400, LOCALE, 2000, 2000);
+        test.saveField(DateTimeFieldType.hourOfDay(), 2);
+        assertEquals(2 * MILLIS_PER_HOUR + 100 - OFFSET_0400, test.computeMillis(false));
+        Object state1 = test.saveState();
+        Object state2 = test.saveState();
+        assertEquals(2 * MILLIS_PER_HOUR + 100 - OFFSET_0400, test.computeMillis(false));
+        test.saveField(DateTimeFieldType.minuteOfHour(), 6);
+        assertEquals(2 * MILLIS_PER_HOUR + 6 * MILLIS_PER_MINUTE + 100 - OFFSET_0400, test.computeMillis(false));
+        assertEquals(true, test.restoreState(state2));
+        assertEquals(2 * MILLIS_PER_HOUR + 100 - OFFSET_0400, test.computeMillis(false));
+        test.saveField(DateTimeFieldType.minuteOfHour(), 8);
+        assertEquals(2 * MILLIS_PER_HOUR + 8 * MILLIS_PER_MINUTE + 100 - OFFSET_0400, test.computeMillis(false));
+        assertEquals(true, test.restoreState(state1));
+        assertEquals(2 * MILLIS_PER_HOUR + 100 - OFFSET_0400, test.computeMillis(false));
+        assertEquals(true, test.restoreState(state2));
+        assertEquals(2 * MILLIS_PER_HOUR + 100 - OFFSET_0400, test.computeMillis(false));
+        assertEquals(true, test.restoreState(state1));
+        assertEquals(2 * MILLIS_PER_HOUR + 100 - OFFSET_0400, test.computeMillis(false));
+    }
+
+    public void testSaveRestoreState_badType() {
+        DateTimeParserBucket bucket1 = new DateTimeParserBucket(100, ISO_0400, LOCALE, 2000, 2000);
+        DateTimeParserBucket bucket2 = new DateTimeParserBucket(100, BUDDHIST_PARIS, LOCALE, 2000, 2000);
+        assertEquals(false, bucket1.restoreState(null));
+        assertEquals(false, bucket1.restoreState(""));
+        assertEquals(false, bucket2.restoreState(bucket1.saveState()));
+    }
+
+}

From 20f6e455e8a37977c2b7209cf3833e049ca2abed Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Thu, 8 May 2014 00:40:17 +0100
Subject: [PATCH 76/86] Allow DateTimeParserBucket to be reused

See #111
---
 RELEASE-NOTES.txt                             |   5 +
 .../joda/time/format/DateTimeFormatter.java   |  13 +-
 .../time/format/DateTimeParserBucket.java     | 114 +++++++++++++++---
 .../time/format/TestDateTimeParserBucket.java |  50 +++++++-
 4 files changed, 154 insertions(+), 28 deletions(-)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 9783116e8..8c07f5663 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -25,6 +25,11 @@ Enhancements since 2.3
   Remove unnecessary volatile on instance variable [#68]
   LocalDate hash code meets criteria of the racy single-check idiom
 
+- DateTimeParserBucket
+  Allow bucket to be re-used on a single thread [#111]
+  Potential for performance improvements due to lower garbage churn
+  Improvement only of interest to applications willing to write specialist code
+
 - Support Appendable throughout printing
   Ensure that Appendable can be used efficiently in printing [#120, #121, #122]
   No API change
diff --git a/src/main/java/org/joda/time/format/DateTimeFormatter.java b/src/main/java/org/joda/time/format/DateTimeFormatter.java
index 8693bc31e..45c3e1fa7 100644
--- a/src/main/java/org/joda/time/format/DateTimeFormatter.java
+++ b/src/main/java/org/joda/time/format/DateTimeFormatter.java
@@ -764,25 +764,16 @@ public int parseInto(ReadWritableInstant instant, String text, int position) {
      * The parse will use the ISO chronology, and the default time zone.
      * If the text contains a time zone string then that will be taken into account.
      *
-     * @param text  text to parse
+     * @param text  the text to parse, not null
      * @return parsed value expressed in milliseconds since the epoch
      * @throws UnsupportedOperationException if parsing is not supported
      * @throws IllegalArgumentException if the text to parse is invalid
      */
     public long parseMillis(String text) {
         DateTimeParser parser = requireParser();
-        
         Chronology chrono = selectChronology(iChrono);
         DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
-        int newPos = parser.parseInto(bucket, text, 0);
-        if (newPos >= 0) {
-            if (newPos >= text.length()) {
-                return bucket.computeMillis(true, text);
-            }
-        } else {
-            newPos = ~newPos;
-        }
-        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));
+        return bucket.doParseMillis(parser, text);
     }
 
     /**
diff --git a/src/main/java/org/joda/time/format/DateTimeParserBucket.java b/src/main/java/org/joda/time/format/DateTimeParserBucket.java
index 1832b4676..5e122d091 100644
--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java
+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java
@@ -63,6 +63,10 @@
     private final Locale iLocale;
     /** Used for parsing month/day without year. */
     private final int iDefaultYear;
+    /** The default zone from the constructor. */
+    private final DateTimeZone iDefaultZone;
+    /** The default pivot year from the constructor. */
+    private final Integer iDefaultPivotYear;
 
     /** The parsed zone, initialised to formatter zone. */
     private DateTimeZone iZone;
@@ -71,7 +75,7 @@
     /** Used for parsing two-digit years. */
     private Integer iPivotYear;
 
-    private SavedField[] iSavedFields = new SavedField[8];
+    private SavedField[] iSavedFields;
     private int iSavedFieldsCount;
     private boolean iSavedFieldsShared;
     
@@ -122,11 +126,65 @@ public DateTimeParserBucket(long instantLocal, Chronology chrono,
         super();
         chrono = DateTimeUtils.getChronology(chrono);
         iMillis = instantLocal;
-        iZone = chrono.getZone();
+        iDefaultZone = chrono.getZone();
         iChrono = chrono.withUTC();
         iLocale = (locale == null ? Locale.getDefault() : locale);
-        iPivotYear = pivotYear;
         iDefaultYear = defaultYear;
+        iDefaultPivotYear = pivotYear;
+        // reset
+        iZone = iDefaultZone;
+        iPivotYear = iDefaultPivotYear;
+        iSavedFields = new SavedField[8];
+    }
+
+    //-----------------------------------------------------------------------
+    /**
+     * Resets the state back to that when the object was constructed.
+     * <p>
+     * This resets the state of the bucket, allowing a single bucket to be re-used
+     * for many parses. The bucket must not be shared between threads.
+     * 
+     * @since 2.4
+     */
+    public void reset() {
+        iZone = iDefaultZone;
+        iOffset = null;
+        iPivotYear = iDefaultPivotYear;
+        iSavedFieldsCount = 0;
+        iSavedFieldsShared = false;
+        iSavedState = null;
+    }
+
+    /**
+     * Parses a datetime from the given text, returning the number of
+     * milliseconds since the epoch, 1970-01-01T00:00:00Z.
+     * <p>
+     * This parses the text using the parser into this bucket.
+     * The bucket is reset before parsing begins, allowing the bucket to be re-used.
+     * The bucket must not be shared between threads.
+     *
+     * @param parser  the parser to use, see {@link DateTimeFormatter#getParser()}, not null
+     * @param text  text to parse, not null
+     * @return parsed value expressed in milliseconds since the epoch
+     * @throws UnsupportedOperationException if parsing is not supported
+     * @throws IllegalArgumentException if the text to parse is invalid
+     * @since 2.4
+     */
+    public long parseMillis(DateTimeParser parser, CharSequence text) {
+        reset();
+        return doParseMillis(parser, text);
+    }
+
+    long doParseMillis(DateTimeParser parser, CharSequence text) {
+        int newPos = parser.parseInto(this, text.toString(), 0);
+        if (newPos >= 0) {
+            if (newPos >= text.length()) {
+                return computeMillis(true, text);
+            }
+        } else {
+            newPos = ~newPos;
+        }
+        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text.toString(), newPos));
     }
 
     //-----------------------------------------------------------------------
@@ -223,7 +281,9 @@ public Integer getPivotYear() {
      *
      * @param pivotYear  the pivot year to use
      * @since 1.1
+     * @deprecated this method should never have been public
      */
+    @Deprecated
     public void setPivotYear(Integer pivotYear) {
         iPivotYear = pivotYear;
     }
@@ -236,7 +296,7 @@ public void setPivotYear(Integer pivotYear) {
      * @param value  the value
      */
     public void saveField(DateTimeField field, int value) {
-        saveField(new SavedField(field, value));
+        obtainSaveField().init(field, value);
     }
     
     /**
@@ -246,7 +306,7 @@ public void saveField(DateTimeField field, int value) {
      * @param value  the value
      */
     public void saveField(DateTimeFieldType fieldType, int value) {
-        saveField(new SavedField(fieldType.getField(iChrono), value));
+        obtainSaveField().init(fieldType.getField(iChrono), value);
     }
     
     /**
@@ -257,10 +317,10 @@ public void saveField(DateTimeFieldType fieldType, int value) {
      * @param locale  the locale to use
      */
     public void saveField(DateTimeFieldType fieldType, String text, Locale locale) {
-        saveField(new SavedField(fieldType.getField(iChrono), text, locale));
+        obtainSaveField().init(fieldType.getField(iChrono), text, locale);
     }
     
-    private void saveField(SavedField field) {
+    private SavedField obtainSaveField() {
         SavedField[] savedFields = iSavedFields;
         int savedFieldsCount = iSavedFieldsCount;
         
@@ -274,8 +334,12 @@ private void saveField(SavedField field) {
         }
         
         iSavedState = null;
-        savedFields[savedFieldsCount] = field;
+        SavedField saved = savedFields[savedFieldsCount];
+        if (saved == null) {
+            saved = savedFields[savedFieldsCount] = new SavedField();
+        }
         iSavedFieldsCount = savedFieldsCount + 1;
+        return saved;
     }
     
     /**
@@ -318,7 +382,7 @@ public boolean restoreState(Object savedState) {
      * @throws IllegalArgumentException if any field is out of range
      */
     public long computeMillis() {
-        return computeMillis(false, null);
+        return computeMillis(false, (CharSequence) null);
     }
     
     /**
@@ -330,7 +394,7 @@ public long computeMillis() {
      * @throws IllegalArgumentException if any field is out of range
      */
     public long computeMillis(boolean resetFields) {
-        return computeMillis(resetFields, null);
+        return computeMillis(resetFields, (CharSequence) null);
     }
 
     /**
@@ -344,9 +408,24 @@ public long computeMillis(boolean resetFields) {
      * @since 1.3
      */
     public long computeMillis(boolean resetFields, String text) {
+        return computeMillis(resetFields, (CharSequence) text);
+    }
+
+    /**
+     * Computes the parsed datetime by setting the saved fields.
+     * This method is idempotent, but it is not thread-safe.
+     *
+     * @param resetFields false by default, but when true, unsaved field values are cleared
+     * @param text optional text being parsed, to be included in any error message
+     * @return milliseconds since 1970-01-01T00:00:00Z
+     * @throws IllegalArgumentException if any field is out of range
+     * @since 2.4
+     */
+    public long computeMillis(boolean resetFields, CharSequence text) {
         SavedField[] savedFields = iSavedFields;
         int count = iSavedFieldsCount;
         if (iSavedFieldsShared) {
+            // clone so that sort does not affect saved state
             iSavedFields = savedFields = (SavedField[])iSavedFields.clone();
             iSavedFieldsShared = false;
         }
@@ -462,19 +541,22 @@ boolean restoreState(DateTimeParserBucket enclosing) {
     }
     
     static class SavedField implements Comparable<SavedField> {
-        final DateTimeField iField;
-        final int iValue;
-        final String iText;
-        final Locale iLocale;
+        DateTimeField iField;
+        int iValue;
+        String iText;
+        Locale iLocale;
+        
+        SavedField() {
+        }
         
-        SavedField(DateTimeField field, int value) {
+        void init(DateTimeField field, int value) {
             iField = field;
             iValue = value;
             iText = null;
             iLocale = null;
         }
         
-        SavedField(DateTimeField field, String text, Locale locale) {
+        void init(DateTimeField field, String text, Locale locale) {
             iField = field;
             iValue = 0;
             iText = text;
diff --git a/src/test/java/org/joda/time/format/TestDateTimeParserBucket.java b/src/test/java/org/joda/time/format/TestDateTimeParserBucket.java
index 892576e9b..fd83d2edc 100644
--- a/src/test/java/org/joda/time/format/TestDateTimeParserBucket.java
+++ b/src/test/java/org/joda/time/format/TestDateTimeParserBucket.java
@@ -35,7 +35,9 @@
     private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");
     private static final Chronology BUDDHIST_UTC = BuddhistChronology.getInstanceUTC();
     private static final Chronology BUDDHIST_PARIS = BuddhistChronology.getInstance(PARIS);
-    private static final Chronology ISO_0400 = ISOChronology.getInstance(DateTimeZone.forOffsetHours(4));
+    private static final Chronology ISO_UTC = ISOChronology.getInstanceUTC();
+    private static final DateTimeZone ZONE_0400 = DateTimeZone.forOffsetHours(4);
+    private static final Chronology ISO_0400 = ISOChronology.getInstance(ZONE_0400);
     private static final int MILLIS_PER_HOUR = 3600000;
     private static final int MILLIS_PER_MINUTE = 60000;
     private static final int OFFSET_0400 = 4 * MILLIS_PER_HOUR;
@@ -83,6 +85,7 @@ public void testConstructor_5arg() {
         assertEquals(PARIS, test.getZone());
     }
 
+    @SuppressWarnings("deprecation")
     public void testSetPivotYear() {
         DateTimeParserBucket test = new DateTimeParserBucket(100, BUDDHIST_PARIS, LOCALE, 2010, 2001);
         assertEquals((Integer) 2010, test.getPivotYear());
@@ -243,4 +246,49 @@ public void testSaveRestoreState_badType() {
         assertEquals(false, bucket2.restoreState(bucket1.saveState()));
     }
 
+    //-------------------------------------------------------------------------
+    public void testReset() {
+        DateTimeParserBucket test = new DateTimeParserBucket(100, ISO_0400, LOCALE, 2000, 2000);
+        assertEquals(ISO_UTC, test.getChronology());
+        assertEquals(LOCALE, test.getLocale());
+        assertEquals((Integer) 2000, test.getPivotYear());
+        assertEquals(null, test.getOffsetInteger());
+        assertEquals(ZONE_0400, test.getZone());
+        
+        test.setOffset((Integer) 200);
+        test.setZone(LONDON);
+        test.saveField(DateTimeFieldType.hourOfDay(), 2);
+        assertEquals(2 * MILLIS_PER_HOUR + 100 - 200, test.computeMillis(false));
+        assertEquals((Integer) 200, test.getOffsetInteger());
+        assertEquals(LONDON, test.getZone());
+        
+        test.reset();
+        assertEquals(ISO_UTC, test.getChronology());
+        assertEquals(LOCALE, test.getLocale());
+        assertEquals((Integer) 2000, test.getPivotYear());
+        assertEquals(null, test.getOffsetInteger());
+        assertEquals(ZONE_0400, test.getZone());
+        assertEquals(100 - OFFSET_0400, test.computeMillis(false));
+    }
+
+    public void testParse() {
+        DateTimeParserBucket test = new DateTimeParserBucket(0, ISO_0400, LOCALE, 2000, 2000);
+        DateTimeParser parser = new DateTimeParser() {
+            public int parseInto(DateTimeParserBucket bucket, String text, int position) {
+                bucket.saveField(DateTimeFieldType.hourOfDay(), 2);
+                bucket.saveField(DateTimeFieldType.minuteOfHour(), 6);
+                return position + 1;
+            }
+            public int estimateParsedLength() {
+                return 1;
+            }
+        };
+        long millis = test.parseMillis(parser, "A");
+        assertEquals(2 * MILLIS_PER_HOUR + 6 * MILLIS_PER_MINUTE - OFFSET_0400, millis);
+        millis = test.parseMillis(parser, "B");
+        assertEquals(2 * MILLIS_PER_HOUR + 6 * MILLIS_PER_MINUTE - OFFSET_0400, millis);
+        millis = test.parseMillis(parser, "C");
+        assertEquals(2 * MILLIS_PER_HOUR + 6 * MILLIS_PER_MINUTE - OFFSET_0400, millis);
+    }
+
 }

From 967c03394560f12db48d0806c0df3a0a79e13e87 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Thu, 29 May 2014 22:54:45 +0100
Subject: [PATCH 77/86] Parse based on CharSequence internally

Only access to CharSequence is via DateTimeParserBucket
Fixes #111
---
 RELEASE-NOTES.txt                             |   7 +
 .../org/joda/time/format/DateTimeFormat.java  |   6 +-
 .../joda/time/format/DateTimeFormatter.java   |  26 ++--
 .../time/format/DateTimeFormatterBuilder.java | 142 +++++++++++-------
 .../time/format/DateTimeParserBucket.java     |   6 +-
 .../format/DateTimeParserInternalParser.java  |  55 +++++++
 .../org/joda/time/format/FormatUtils.java     |   2 +-
 .../org/joda/time/format/InternalParser.java  |  56 +++++++
 .../format/InternalParserDateTimeParser.java  |  72 +++++++++
 .../time/format/TestDateTimeFormatter.java    |   2 +-
 10 files changed, 300 insertions(+), 74 deletions(-)
 create mode 100644 src/main/java/org/joda/time/format/DateTimeParserInternalParser.java
 create mode 100644 src/main/java/org/joda/time/format/InternalParser.java
 create mode 100644 src/main/java/org/joda/time/format/InternalParserDateTimeParser.java

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 8c07f5663..67de6d96c 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -30,6 +30,13 @@ Enhancements since 2.3
   Potential for performance improvements due to lower garbage churn
   Improvement only of interest to applications willing to write specialist code
 
+- Support CharSequence throughout parsing
+  Ensure that CharSequence can be used in parsing [#111]
+  This can only be accessed by creating a mutable DateTimeParserBucket
+  The bucket is a low-level construct for advanced use cases
+  Potential for performance improvements due to lower garbage churn
+  No API change
+
 - Support Appendable throughout printing
   Ensure that Appendable can be used efficiently in printing [#120, #121, #122]
   No API change
diff --git a/src/main/java/org/joda/time/format/DateTimeFormat.java b/src/main/java/org/joda/time/format/DateTimeFormat.java
index e7c050fc9..c947d43a7 100644
--- a/src/main/java/org/joda/time/format/DateTimeFormat.java
+++ b/src/main/java/org/joda/time/format/DateTimeFormat.java
@@ -785,7 +785,7 @@ private static int selectStyle(char ch) {
 
     //-----------------------------------------------------------------------
     static class StyleFormatter
-            implements InternalPrinter, DateTimeParser {
+            implements InternalPrinter, InternalParser {
 
         private static final ConcurrentHashMap<StyleFormatterCacheKey, DateTimeFormatter> cCache = new ConcurrentHashMap<StyleFormatterCacheKey, DateTimeFormatter>();
         
@@ -820,8 +820,8 @@ public int estimateParsedLength() {
             return 40;  // guess
         }
 
-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
-            DateTimeParser p = getFormatter(bucket.getLocale()).getParser();
+        public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {
+            InternalParser p = getFormatter(bucket.getLocale()).getParser0();
             return p.parseInto(bucket, text, position);
         }
 
diff --git a/src/main/java/org/joda/time/format/DateTimeFormatter.java b/src/main/java/org/joda/time/format/DateTimeFormatter.java
index 45c3e1fa7..6244369b0 100644
--- a/src/main/java/org/joda/time/format/DateTimeFormatter.java
+++ b/src/main/java/org/joda/time/format/DateTimeFormatter.java
@@ -92,7 +92,7 @@
     /** The internal printer used to output the datetime. */
     private final InternalPrinter iPrinter;
     /** The internal parser used to output the datetime. */
-    private final DateTimeParser iParser;
+    private final InternalParser iParser;
     /** The locale to use for printing and parsing. */
     private final Locale iLocale;
     /** Whether the offset is parsed. */
@@ -115,7 +115,7 @@
      */
     public DateTimeFormatter(
             DateTimePrinter printer, DateTimeParser parser) {
-        this(DateTimePrinterInternalPrinter.of(printer), parser);
+        this(DateTimePrinterInternalPrinter.of(printer), DateTimeParserInternalParser.of(parser));
     }
 
     /**
@@ -126,7 +126,7 @@ public DateTimeFormatter(
      * @param parser  the internal parser, null if cannot parse
      */
     DateTimeFormatter(
-            InternalPrinter printer, DateTimeParser parser) {
+            InternalPrinter printer, InternalParser parser) {
         super();
         iPrinter = printer;
         iParser = parser;
@@ -142,7 +142,7 @@ public DateTimeFormatter(
      * Constructor.
      */
     private DateTimeFormatter(
-            InternalPrinter printer, DateTimeParser parser,
+            InternalPrinter printer, InternalParser parser,
             Locale locale, boolean offsetParsed,
             Chronology chrono, DateTimeZone zone,
             Integer pivotYear, int defaultYear) {
@@ -200,6 +200,10 @@ public boolean isParser() {
      * @return the internal parser; is null if parsing not supported
      */
     public DateTimeParser getParser() {
+        return InternalParserDateTimeParser.of(iParser);
+    }
+
+    InternalParser getParser0() {
         return iParser;
     }
 
@@ -728,7 +732,7 @@ private InternalPrinter requirePrinter() {
      * @throws IllegalArgumentException if any field is out of range
      */
     public int parseInto(ReadWritableInstant instant, String text, int position) {
-        DateTimeParser parser = requireParser();
+        InternalParser parser = requireParser();
         if (instant == null) {
             throw new IllegalArgumentException("Instant must not be null");
         }
@@ -770,7 +774,7 @@ public int parseInto(ReadWritableInstant instant, String text, int position) {
      * @throws IllegalArgumentException if the text to parse is invalid
      */
     public long parseMillis(String text) {
-        DateTimeParser parser = requireParser();
+        InternalParser parser = requireParser();
         Chronology chrono = selectChronology(iChrono);
         DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
         return bucket.doParseMillis(parser, text);
@@ -827,7 +831,7 @@ public LocalTime parseLocalTime(String text) {
      * @since 2.0
      */
     public LocalDateTime parseLocalDateTime(String text) {
-        DateTimeParser parser = requireParser();
+        InternalParser parser = requireParser();
         
         Chronology chrono = selectChronology(null).withUTC();  // always use UTC, avoiding DST gaps
         DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
@@ -868,7 +872,7 @@ public LocalDateTime parseLocalDateTime(String text) {
      * @throws IllegalArgumentException if the text to parse is invalid
      */
     public DateTime parseDateTime(String text) {
-        DateTimeParser parser = requireParser();
+        InternalParser parser = requireParser();
         
         Chronology chrono = selectChronology(null);
         DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
@@ -913,7 +917,7 @@ public DateTime parseDateTime(String text) {
      * @throws IllegalArgumentException if the text to parse is invalid
      */
     public MutableDateTime parseMutableDateTime(String text) {
-        DateTimeParser parser = requireParser();
+        InternalParser parser = requireParser();
         
         Chronology chrono = selectChronology(null);
         DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);
@@ -945,8 +949,8 @@ public MutableDateTime parseMutableDateTime(String text) {
      * 
      * @throws UnsupportedOperationException if parsing is not supported
      */
-    private DateTimeParser requireParser() {
-        DateTimeParser parser = iParser;
+    private InternalParser requireParser() {
+        InternalParser parser = iParser;
         if (parser == null) {
             throw new UnsupportedOperationException("Parsing not supported");
         }
diff --git a/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java b/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java
index bdf21d8d9..9aa4f1a18 100644
--- a/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java
+++ b/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java
@@ -105,9 +105,9 @@ public DateTimeFormatter toFormatter() {
         if (isPrinter(f)) {
             printer = (InternalPrinter) f;
         }
-        DateTimeParser parser = null;
+        InternalParser parser = null;
         if (isParser(f)) {
-            parser = (DateTimeParser) f;
+            parser = (InternalParser) f;
         }
         if (printer != null || parser != null) {
             return new DateTimeFormatter(printer, parser);
@@ -151,7 +151,8 @@ public DateTimePrinter toPrinter() {
     public DateTimeParser toParser() {
         Object f = getFormatter();
         if (isParser(f)) {
-            return (DateTimeParser) f;
+            InternalParser ip = (InternalParser) f;
+            return InternalParserDateTimeParser.of(ip);
         }
         throw new UnsupportedOperationException("Parsing is not supported");
     }
@@ -216,7 +217,7 @@ public DateTimeFormatterBuilder append(DateTimeFormatter formatter) {
         if (formatter == null) {
             throw new IllegalArgumentException("No formatter supplied");
         }
-        return append0(formatter.getPrinter0(), formatter.getParser());
+        return append0(formatter.getPrinter0(), formatter.getParser0());
     }
 
     /**
@@ -254,7 +255,7 @@ public DateTimeFormatterBuilder append(DateTimePrinter printer) {
      */
     public DateTimeFormatterBuilder append(DateTimeParser parser) {
         checkParser(parser);
-        return append0(null, parser);
+        return append0(null, DateTimeParserInternalParser.of(parser));
     }
 
     /**
@@ -274,7 +275,7 @@ public DateTimeFormatterBuilder append(DateTimeParser parser) {
     public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser parser) {
         checkPrinter(printer);
         checkParser(parser);
-        return append0(DateTimePrinterInternalPrinter.of(printer), parser);
+        return append0(DateTimePrinterInternalPrinter.of(printer), DateTimeParserInternalParser.of(parser));
     }
 
     /**
@@ -312,17 +313,17 @@ public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[]
             if (parsers[0] == null) {
                 throw new IllegalArgumentException("No parser supplied");
             }
-            return append0(DateTimePrinterInternalPrinter.of(printer), parsers[0]);
+            return append0(DateTimePrinterInternalPrinter.of(printer), DateTimeParserInternalParser.of(parsers[0]));
         }
 
-        DateTimeParser[] copyOfParsers = new DateTimeParser[length];
+        InternalParser[] copyOfParsers = new InternalParser[length];
         int i;
         for (i = 0; i < length - 1; i++) {
-            if ((copyOfParsers[i] = parsers[i]) == null) {
+            if ((copyOfParsers[i] = DateTimeParserInternalParser.of(parsers[i])) == null) {
                 throw new IllegalArgumentException("Incomplete parser array");
             }
         }
-        copyOfParsers[i] = parsers[i];
+        copyOfParsers[i] = DateTimeParserInternalParser.of(parsers[i]);
 
         return append0(DateTimePrinterInternalPrinter.of(printer), new MatchingParser(copyOfParsers));
     }
@@ -342,7 +343,7 @@ public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[]
      */
     public DateTimeFormatterBuilder appendOptional(DateTimeParser parser) {
         checkParser(parser);
-        DateTimeParser[] parsers = new DateTimeParser[] {parser, null};
+        InternalParser[] parsers = new InternalParser[] {DateTimeParserInternalParser.of(parser), null};
         return append0(null, new MatchingParser(parsers));
     }
 
@@ -378,7 +379,7 @@ private DateTimeFormatterBuilder append0(Object element) {
     }
 
     private DateTimeFormatterBuilder append0(
-            InternalPrinter printer, DateTimeParser parser) {
+            InternalPrinter printer, InternalParser parser) {
         iFormatter = null;
         iElementPairs.add(printer);
         iElementPairs.add(parser);
@@ -1171,7 +1172,7 @@ private boolean isPrinter(Object f) {
     }
 
     private boolean isParser(Object f) {
-        if (f instanceof DateTimeParser) {
+        if (f instanceof InternalParser) {
             if (f instanceof Composite) {
                 return ((Composite)f).isParser();
             }
@@ -1192,7 +1193,7 @@ static void appendUnknownString(Appendable appendable, int len) throws IOExcepti
 
     //-----------------------------------------------------------------------
     static class CharacterLiteral
-            implements InternalPrinter, DateTimeParser {
+            implements InternalPrinter, InternalParser {
 
         private final char iValue;
 
@@ -1219,7 +1220,7 @@ public int estimateParsedLength() {
             return 1;
         }
 
-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
+        public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {
             if (position >= text.length()) {
                 return ~position;
             }
@@ -1245,7 +1246,7 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
 
     //-----------------------------------------------------------------------
     static class StringLiteral
-            implements InternalPrinter, DateTimeParser {
+            implements InternalPrinter, InternalParser {
 
         private final String iValue;
 
@@ -1272,8 +1273,8 @@ public int estimateParsedLength() {
             return iValue.length();
         }
 
-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
-            if (text.regionMatches(true, position, iValue, 0, iValue.length())) {
+        public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {
+            if (csStartsWithIgnoreCase(text, position, iValue)) {
                 return position + iValue.length();
             }
             return ~position;
@@ -1282,7 +1283,7 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
 
     //-----------------------------------------------------------------------
     static abstract class NumberFormatter
-            implements InternalPrinter, DateTimeParser {
+            implements InternalPrinter, InternalParser {
         protected final DateTimeFieldType iFieldType;
         protected final int iMaxParsedDigits;
         protected final boolean iSigned;
@@ -1299,7 +1300,7 @@ public int estimateParsedLength() {
             return iMaxParsedDigits;
         }
 
-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
+        public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {
             int limit = Math.min(iMaxParsedDigits, text.length() - position);
 
             boolean negative = false;
@@ -1340,7 +1341,7 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
             if (length >= 9) {
                 // Since value may exceed integer limits, use stock parser
                 // which checks for this.
-                value = Integer.parseInt(text.substring(position, position += length));
+                value = Integer.parseInt(text.subSequence(position, position += length).toString());
             } else {
                 int i = position;
                 if (negative) {
@@ -1449,7 +1450,8 @@ protected FixedNumber(DateTimeFieldType fieldType, int numDigits, boolean signed
             super(fieldType, numDigits, signed, numDigits);
         }
 
-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
+        @Override
+        public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {
             int newPos = super.parseInto(bucket, text, position);
             if (newPos < 0) {
                 return newPos;
@@ -1476,7 +1478,7 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
 
     //-----------------------------------------------------------------------
     static class TwoDigitYear
-            implements InternalPrinter, DateTimeParser {
+            implements InternalPrinter, InternalParser {
 
         /** The field to print/parse. */
         private final DateTimeFieldType iType;
@@ -1495,7 +1497,7 @@ public int estimateParsedLength() {
             return iLenientParse ? 4 : 2;
         }
 
-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
+        public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {
             int limit = text.length() - position;
 
             if (!iLenientParse) {
@@ -1536,7 +1538,7 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
                     if (length >= 9) {
                         // Since value may exceed integer limits, use stock
                         // parser which checks for this.
-                        value = Integer.parseInt(text.substring(position, position += length));
+                        value = Integer.parseInt(text.subSequence(position, position += length).toString());
                     } else {
                         int i = position;
                         if (negative) {
@@ -1648,7 +1650,7 @@ private int getTwoDigitYear(ReadablePartial partial) {
 
     //-----------------------------------------------------------------------
     static class TextField
-            implements InternalPrinter, DateTimeParser {
+            implements InternalPrinter, InternalParser {
 
         private static Map<Locale, Map<DateTimeFieldType, Object[]>> cParseCache =
                     new ConcurrentHashMap<Locale, Map<DateTimeFieldType, Object[]>>();
@@ -1710,7 +1712,7 @@ public int estimateParsedLength() {
         }
 
         @SuppressWarnings("unchecked")
-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
+        public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {
             Locale locale = bucket.getLocale();
             // handle languages which might have non ASCII A-Z or punctuation
             // bug 1788282
@@ -1758,7 +1760,7 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
             // match the longest string first using our knowledge of the max length
             int limit = Math.min(text.length(), position + maxLength);
             for (int i = limit; i > position; i--) {
-                String match = text.substring(position, i);
+                String match = text.subSequence(position, i).toString();
                 if (validValues.containsKey(match)) {
                     bucket.saveField(iFieldType, match, locale);
                     return i;
@@ -1770,7 +1772,7 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
 
     //-----------------------------------------------------------------------
     static class Fraction
-            implements InternalPrinter, DateTimeParser {
+            implements InternalPrinter, InternalParser {
 
         private final DateTimeFieldType iFieldType;
         protected int iMinDigits;
@@ -1904,7 +1906,7 @@ public int estimateParsedLength() {
             return iMaxDigits;
         }
 
-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
+        public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {
             DateTimeField field = iFieldType.getField(bucket.getChronology());
             
             int limit = Math.min(iMaxDigits, text.length() - position);
@@ -1946,7 +1948,7 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
 
     //-----------------------------------------------------------------------
     static class TimeZoneOffset
-            implements InternalPrinter, DateTimeParser {
+            implements InternalPrinter, InternalParser {
 
         private final String iZeroOffsetPrintText;
         private final String iZeroOffsetParseText;
@@ -2051,7 +2053,7 @@ public int estimateParsedLength() {
             return estimatePrintedLength();
         }
 
-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
+        public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {
             int limit = text.length() - position;
 
             zeroOffset:
@@ -2067,7 +2069,7 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
                     bucket.setOffset(Integer.valueOf(0));
                     return position;
                 }
-                if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {
+                if (csStartsWithIgnoreCase(text, position, iZeroOffsetParseText)) {
                     bucket.setOffset(Integer.valueOf(0));
                     return position + iZeroOffsetParseText.length();
                 }
@@ -2226,7 +2228,7 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
          * Returns actual amount of digits to parse, but no more than original
          * 'amount' parameter.
          */
-        private int digitCount(String text, int position, int amount) {
+        private int digitCount(CharSequence text, int position, int amount) {
             int limit = Math.min(text.length() - position, amount);
             amount = 0;
             for (; limit > 0; limit--) {
@@ -2242,7 +2244,7 @@ private int digitCount(String text, int position, int amount) {
 
     //-----------------------------------------------------------------------
     static class TimeZoneName
-            implements InternalPrinter, DateTimeParser {
+            implements InternalPrinter, InternalParser {
 
         static final int LONG_NAME = 0;
         static final int SHORT_NAME = 1;
@@ -2287,13 +2289,12 @@ public int estimateParsedLength() {
             return (iType == SHORT_NAME ? 4 : 20);
         }
 
-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
+        public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {
             Map<String, DateTimeZone> parseLookup = iParseLookup;
             parseLookup = (parseLookup != null ? parseLookup : DateTimeUtils.getDefaultTimeZoneNames());
-            String str = text.substring(position);
             String matched = null;
             for (String name : parseLookup.keySet()) {
-                if (str.startsWith(name)) {
+                if (csStartsWith(text, position, name)) {
                     if (matched == null || name.length() > matched.length()) {
                         matched = name;
                     }
@@ -2309,7 +2310,7 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
 
     //-----------------------------------------------------------------------
     static enum TimeZoneId
-            implements InternalPrinter, DateTimeParser {
+            implements InternalPrinter, InternalParser {
 
         INSTANCE;
         static final Set<String> ALL_IDS = DateTimeZone.getAvailableIDs();
@@ -2340,11 +2341,10 @@ public int estimateParsedLength() {
             return MAX_LENGTH;
         }
 
-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
-            String str = text.substring(position);
+        public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {
             String best = null;
             for (String id : ALL_IDS) {
-                if (str.startsWith(id)) {
+                if (csStartsWith(text, position, id)) {
                     if (best == null || id.length() > best.length()) {
                         best = id;
                     }
@@ -2360,10 +2360,10 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
 
     //-----------------------------------------------------------------------
     static class Composite
-            implements InternalPrinter, DateTimeParser {
+            implements InternalPrinter, InternalParser {
 
         private final InternalPrinter[] iPrinters;
-        private final DateTimeParser[] iParsers;
+        private final InternalParser[] iParsers;
 
         private final int iPrintedLengthEstimate;
         private final int iParsedLengthEstimate;
@@ -2396,10 +2396,10 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
                 iParsedLengthEstimate = 0;
             } else {
                 int size = parserList.size();
-                iParsers = new DateTimeParser[size];
+                iParsers = new InternalParser[size];
                 int parseEst = 0;
                 for (int i=0; i<size; i++) {
-                    DateTimeParser parser = (DateTimeParser) parserList.get(i);
+                    InternalParser parser = (InternalParser) parserList.get(i);
                     parseEst += parser.estimateParsedLength();
                     iParsers[i] = parser;
                 }
@@ -2451,8 +2451,8 @@ public int estimateParsedLength() {
             return iParsedLengthEstimate;
         }
 
-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
-            DateTimeParser[] elements = iParsers;
+        public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {
+            InternalParser[] elements = iParsers;
             if (elements == null) {
                 throw new UnsupportedOperationException();
             }
@@ -2506,17 +2506,17 @@ private void addArrayToList(List<Object> list, Object[] array) {
 
     //-----------------------------------------------------------------------
     static class MatchingParser
-            implements DateTimeParser {
+            implements InternalParser {
 
-        private final DateTimeParser[] iParsers;
+        private final InternalParser[] iParsers;
         private final int iParsedLengthEstimate;
 
-        MatchingParser(DateTimeParser[] parsers) {
+        MatchingParser(InternalParser[] parsers) {
             super();
             iParsers = parsers;
             int est = 0;
             for (int i=parsers.length; --i>=0 ;) {
-                DateTimeParser parser = parsers[i];
+                InternalParser parser = parsers[i];
                 if (parser != null) {
                     int len = parser.estimateParsedLength();
                     if (len > est) {
@@ -2531,8 +2531,8 @@ public int estimateParsedLength() {
             return iParsedLengthEstimate;
         }
 
-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
-            DateTimeParser[] parsers = iParsers;
+        public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {
+            InternalParser[] parsers = iParsers;
             int length = parsers.length;
 
             final Object originalState = bucket.saveState();
@@ -2544,7 +2544,7 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
             int bestInvalidPos = position;
 
             for (int i=0; i<length; i++) {
-                DateTimeParser parser = parsers[i];
+                InternalParser parser = parsers[i];
                 if (parser == null) {
                     // The empty parser wins only if nothing is better.
                     if (bestValidPos <= position) {
@@ -2589,4 +2589,36 @@ public int parseInto(DateTimeParserBucket bucket, String text, int position) {
         }
     }
 
+    static boolean csStartsWith(CharSequence text, int position, String search) {
+        int searchLen = search.length();
+        if ((text.length() - position) < searchLen) {
+            return false;
+        }
+        for (int i = 0; i < searchLen; i++) {
+            if (text.charAt(position + i) != search.charAt(i)) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    static boolean csStartsWithIgnoreCase(CharSequence text, int position, String search) {
+        int searchLen = search.length();
+        if ((text.length() - position) < searchLen) {
+            return false;
+        }
+        for (int i = 0; i < searchLen; i++) {
+            char ch1 = text.charAt(position + i);
+            char ch2 = search.charAt(i);
+            if (ch1 != ch2) {
+                char u1 = Character.toUpperCase(ch1);
+                char u2 = Character.toUpperCase(ch2);
+                if (u1 != u2 && Character.toLowerCase(u1) != Character.toLowerCase(u2)) {
+                    return false;
+                }
+            }
+        }
+        return true;
+    }
+
 }
diff --git a/src/main/java/org/joda/time/format/DateTimeParserBucket.java b/src/main/java/org/joda/time/format/DateTimeParserBucket.java
index 5e122d091..a71a6db07 100644
--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java
+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java
@@ -172,11 +172,11 @@ public void reset() {
      */
     public long parseMillis(DateTimeParser parser, CharSequence text) {
         reset();
-        return doParseMillis(parser, text);
+        return doParseMillis(DateTimeParserInternalParser.of(parser), text);
     }
 
-    long doParseMillis(DateTimeParser parser, CharSequence text) {
-        int newPos = parser.parseInto(this, text.toString(), 0);
+    long doParseMillis(InternalParser parser, CharSequence text) {
+        int newPos = parser.parseInto(this, text, 0);
         if (newPos >= 0) {
             if (newPos >= text.length()) {
                 return computeMillis(true, text);
diff --git a/src/main/java/org/joda/time/format/DateTimeParserInternalParser.java b/src/main/java/org/joda/time/format/DateTimeParserInternalParser.java
new file mode 100644
index 000000000..31bf5f825
--- /dev/null
+++ b/src/main/java/org/joda/time/format/DateTimeParserInternalParser.java
@@ -0,0 +1,55 @@
+/*
+ *  Copyright 2001-2014 Stephen Colebourne
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.joda.time.format;
+
+/**
+ * Adapter between old and new parser interface.
+ *
+ * @author Stephen Colebourne
+ * @since 2.4
+ */
+class DateTimeParserInternalParser implements InternalParser {
+    
+    private final DateTimeParser underlying;
+
+    static InternalParser of(DateTimeParser underlying) {
+        if (underlying instanceof InternalParserDateTimeParser) {
+            return (InternalParser) underlying;
+        }
+        if (underlying == null) {
+            return null;
+        }
+        return new DateTimeParserInternalParser(underlying);
+    }
+
+    private DateTimeParserInternalParser(DateTimeParser underlying) {
+        this.underlying = underlying;
+    }
+
+    //-----------------------------------------------------------------------
+    DateTimeParser getUnderlying() {
+        return underlying;
+    }
+
+    public int estimateParsedLength() {
+        return underlying.estimateParsedLength();
+    }
+
+    public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {
+        return underlying.parseInto(bucket, text.toString(), position);
+    }
+
+}
diff --git a/src/main/java/org/joda/time/format/FormatUtils.java b/src/main/java/org/joda/time/format/FormatUtils.java
index 291221956..01e0f97e5 100644
--- a/src/main/java/org/joda/time/format/FormatUtils.java
+++ b/src/main/java/org/joda/time/format/FormatUtils.java
@@ -419,7 +419,7 @@ public static int calculateDigitCount(long value) {
                 ((int)(Math.log(value) / LOG_10) + 1)))));
     }
 
-    static int parseTwoDigits(String text, int position) {
+    static int parseTwoDigits(CharSequence text, int position) {
         int value = text.charAt(position) - '0';
         return ((value << 3) + (value << 1)) + text.charAt(position + 1) - '0';
     }
diff --git a/src/main/java/org/joda/time/format/InternalParser.java b/src/main/java/org/joda/time/format/InternalParser.java
new file mode 100644
index 000000000..ff0b1be8a
--- /dev/null
+++ b/src/main/java/org/joda/time/format/InternalParser.java
@@ -0,0 +1,56 @@
+/*
+ *  Copyright 2001-2014 Stephen Colebourne
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.joda.time.format;
+
+/**
+ * Internal interface for parsing textual representations of datetimes.
+ * <p>
+ * This has been separated from {@link DateTimeParser} to change to using
+ * {@code CharSequence}.
+ *
+ * @author Stephen Colebourne
+ * @since 2.4
+ */
+interface InternalParser {
+
+    /**
+     * Returns the expected maximum number of characters consumed.
+     * The actual amount should rarely exceed this estimate.
+     * 
+     * @return the estimated length
+     */
+    int estimateParsedLength();
+
+    /**
+     * Parse an element from the given text, saving any fields into the given
+     * DateTimeParserBucket. If the parse succeeds, the return value is the new
+     * text position. Note that the parse may succeed without fully reading the
+     * text.
+     * <p>
+     * If it fails, the return value is negative. To determine the position
+     * where the parse failed, apply the one's complement operator (~) on the
+     * return value.
+     *
+     * @param bucket  field are saved into this, not null
+     * @param text  the text to parse, not null
+     * @param position  position to start parsing from
+     * @return new position, negative value means parse failed -
+     *  apply complement operator (~) to get position of failure
+     * @throws IllegalArgumentException if any field is out of range
+     */
+    int parseInto(DateTimeParserBucket bucket, CharSequence text, int position);
+
+}
diff --git a/src/main/java/org/joda/time/format/InternalParserDateTimeParser.java b/src/main/java/org/joda/time/format/InternalParserDateTimeParser.java
new file mode 100644
index 000000000..c046c1856
--- /dev/null
+++ b/src/main/java/org/joda/time/format/InternalParserDateTimeParser.java
@@ -0,0 +1,72 @@
+/*
+ *  Copyright 2001-2014 Stephen Colebourne
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.joda.time.format;
+
+
+/**
+ * Adapter between old and new printer interface.
+ *
+ * @author Stephen Colebourne
+ * @since 2.4
+ */
+class InternalParserDateTimeParser implements DateTimeParser, InternalParser {
+    
+    private final InternalParser underlying;
+
+    static DateTimeParser of(InternalParser underlying) {
+        if (underlying instanceof DateTimeParserInternalParser) {
+            return ((DateTimeParserInternalParser) underlying).getUnderlying();
+        }
+        if (underlying instanceof DateTimeParser) {
+            return (DateTimeParser) underlying;
+        }
+        if (underlying == null) {
+            return null;
+        }
+        return new InternalParserDateTimeParser(underlying);
+    }
+
+    private InternalParserDateTimeParser(InternalParser underlying) {
+        this.underlying = underlying;
+    }
+
+    //-------------------------------------------------------------------------
+    public int estimateParsedLength() {
+        return underlying.estimateParsedLength();
+    }
+
+    public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) {
+        return underlying.parseInto(bucket, text, position);
+    }
+
+    public int parseInto(DateTimeParserBucket bucket, String text, int position) {
+        return underlying.parseInto(bucket, text, position);
+    }
+
+    //-----------------------------------------------------------------------
+    @Override
+    public boolean equals(Object obj) {
+        if (obj == this) {
+            return true;
+        }
+        if (obj instanceof InternalParserDateTimeParser) {
+            InternalParserDateTimeParser other = (InternalParserDateTimeParser) obj;
+            return underlying.equals(other.underlying);
+        }
+        return false;
+    }
+
+}
diff --git a/src/test/java/org/joda/time/format/TestDateTimeFormatter.java b/src/test/java/org/joda/time/format/TestDateTimeFormatter.java
index 9d6df3e94..61b9589c9 100644
--- a/src/test/java/org/joda/time/format/TestDateTimeFormatter.java
+++ b/src/test/java/org/joda/time/format/TestDateTimeFormatter.java
@@ -348,7 +348,7 @@ public void testPrinterParserMethods() {
             fail();
         } catch (UnsupportedOperationException ex) {}
         
-        f2 = new DateTimeFormatter((InternalPrinter) null, f.getParser());
+        f2 = new DateTimeFormatter((DateTimePrinter) null, f.getParser());
         assertEquals(null, f2.getPrinter());
         assertEquals(f.getParser(), f2.getParser());
         assertEquals(false, f2.isPrinter());

From 7161f9c03d40dbe6325906931a7b3d3a310bfb12 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Wed, 2 Jul 2014 07:18:08 +0100
Subject: [PATCH 78/86] Better Javadoc for formatters that only parse

See #97
---
 RELEASE-NOTES.txt                             |  8 ++--
 .../joda/time/format/ISODateTimeFormat.java   | 37 ++++++++++++++++---
 .../format/TestISODateTimeFormatParsing.java  | 26 +++++++++++++
 3 files changed, 62 insertions(+), 9 deletions(-)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 67de6d96c..7a9489e51 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -122,19 +122,21 @@ Bug fixes since 2.3
 - Remove uncaughtException calls [#59]
   Previously the code called ThreadGroup.uncaughtException() which was invalid
 
+- Fix Javadoc for ReadableDuration [#137]
+
+- Fix the links to the IANA time zone database [#83]
+
 - Better Javadoc for thread saefty of DateTimeUtils [#67]
 
 - Better Javadoc for DateTimeComparator [#73]
 
-- Fix the links to the IANA time zone database [#83]
-
 - Better Javadoc for DateTimeFormatter parsing [#78]
 
 - Better Javadoc for DateTimeFormat fraction of second [#62]
 
 - Better Javadoc for DateTime toString and parse [#142]
 
-- Fix Javadoc for ReadableDuration [#137]
+- Better Javadoc for formatters that only parse [#97]
 
 
 Scala
diff --git a/src/main/java/org/joda/time/format/ISODateTimeFormat.java b/src/main/java/org/joda/time/format/ISODateTimeFormat.java
index af53ee4fc..00314da3b 100644
--- a/src/main/java/org/joda/time/format/ISODateTimeFormat.java
+++ b/src/main/java/org/joda/time/format/ISODateTimeFormat.java
@@ -481,6 +481,8 @@ private static void appendSeparator(DateTimeFormatterBuilder bld, boolean extend
     /**
      * Returns a generic ISO date parser for parsing dates with a possible zone.
      * <p>
+     * The returned formatter can only be used for parsing, printing is unsupported.
+     * <p>
      * It accepts formats described by the following syntax:
      * <pre>
      * date              = date-element ['T' offset]
@@ -497,6 +499,9 @@ public static DateTimeFormatter dateParser() {
 
     /**
      * Returns a generic ISO date parser for parsing local dates.
+     * <p>
+     * The returned formatter can only be used for parsing, printing is unsupported.
+     * <p>
      * This parser is initialised with the local (UTC) time zone.
      * <p>
      * It accepts formats described by the following syntax:
@@ -515,6 +520,8 @@ public static DateTimeFormatter localDateParser() {
     /**
      * Returns a generic ISO date parser for parsing dates.
      * <p>
+     * The returned formatter can only be used for parsing, printing is unsupported.
+     * <p>
      * It accepts formats described by the following syntax:
      * <pre>
      * date-element      = std-date-element | ord-date-element | week-date-element
@@ -529,6 +536,9 @@ public static DateTimeFormatter dateElementParser() {
 
     /**
      * Returns a generic ISO time parser for parsing times with a possible zone.
+     * <p>
+     * The returned formatter can only be used for parsing, printing is unsupported.
+     * <p>
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
      * <p>
      * It accepts formats described by the following syntax:
@@ -547,6 +557,9 @@ public static DateTimeFormatter timeParser() {
 
     /**
      * Returns a generic ISO time parser for parsing local times.
+     * <p>
+     * The returned formatter can only be used for parsing, printing is unsupported.
+     * <p>
      * This parser is initialised with the local (UTC) time zone.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
      * <p>
@@ -566,6 +579,9 @@ public static DateTimeFormatter localTimeParser() {
 
     /**
      * Returns a generic ISO time parser.
+     * <p>
+     * The returned formatter can only be used for parsing, printing is unsupported.
+     * <p>
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
      * <p>
      * It accepts formats described by the following syntax:
@@ -581,8 +597,11 @@ public static DateTimeFormatter timeElementParser() {
     }
 
     /**
-     * Returns a generic ISO datetime parser which parses either a date or
-     * a time or both. The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
+     * Returns a generic ISO datetime parser which parses either a date or a time or both.
+     * <p>
+     * The returned formatter can only be used for parsing, printing is unsupported.
+     * <p>
+     * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
      * <p>
      * It accepts formats described by the following syntax:
      * <pre>
@@ -605,8 +624,11 @@ public static DateTimeFormatter dateTimeParser() {
     }
 
     /**
-     * Returns a generic ISO datetime parser where the date is mandatory and
-     * the time is optional. This parser can parse zoned datetimes.
+     * Returns a generic ISO datetime parser where the date is mandatory and the time is optional.
+     * <p>
+     * The returned formatter can only be used for parsing, printing is unsupported.
+     * <p>
+     * This parser can parse zoned datetimes.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
      * <p>
      * It accepts formats described by the following syntax:
@@ -628,8 +650,11 @@ public static DateTimeFormatter dateOptionalTimeParser() {
     }
 
     /**
-     * Returns a generic ISO datetime parser where the date is mandatory and
-     * the time is optional. This parser only parses local datetimes.
+     * Returns a generic ISO datetime parser where the date is mandatory and the time is optional.
+     * <p>
+     * The returned formatter can only be used for parsing, printing is unsupported.
+     * <p>
+     * This parser only parses local datetimes.
      * This parser is initialised with the local (UTC) time zone.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
      * <p>
diff --git a/src/test/java/org/joda/time/format/TestISODateTimeFormatParsing.java b/src/test/java/org/joda/time/format/TestISODateTimeFormatParsing.java
index 482e51b1d..78288f4ac 100644
--- a/src/test/java/org/joda/time/format/TestISODateTimeFormatParsing.java
+++ b/src/test/java/org/joda/time/format/TestISODateTimeFormatParsing.java
@@ -91,6 +91,8 @@ public void test_dateParser() {
         assertParse(parser, false, "10.5");
         assertParse(parser, false, "10:20:30.040+02:00");
         assertParse(parser, false, "10.5+02:00");
+        
+        assertNoPrint(parser);
     }
 
     //-----------------------------------------------------------------------
@@ -120,6 +122,8 @@ public void test_localDateParser() {
         assertParse(parser, false, "10.5");
         assertParse(parser, false, "10:20:30.040+02:00");
         assertParse(parser, false, "10.5+02:00");
+        
+        assertNoPrint(parser);
     }
 
     //-----------------------------------------------------------------------
@@ -151,6 +155,8 @@ public void test_dateElementParser() {
         assertParse(parser, false, "10.5");
         assertParse(parser, false, "10:20:30.040+02:00");
         assertParse(parser, false, "10.5+02:00");
+        
+        assertNoPrint(parser);
     }
 
     //-----------------------------------------------------------------------
@@ -183,6 +189,8 @@ public void test_timeParser() {
         assertParse(parser, true, "10.5");
         assertParse(parser, true, "10:20:30.040+02:00");
         assertParse(parser, true, "10.5+02:00");
+        
+        assertNoPrint(parser);
     }
 
     //-----------------------------------------------------------------------
@@ -215,6 +223,8 @@ public void test_localTimeParser() {
         
         assertParse(parser, true, "00:00:10.512345678");
         assertEquals(10512, parser.parseMillis("00:00:10.512345678"));
+        
+        assertNoPrint(parser);
     }
 
     //-----------------------------------------------------------------------
@@ -247,6 +257,8 @@ public void test_timeElementParser() {
         assertParse(parser, true, "00:00:10.512345678");
         // result is offset by London DST in 1970-01-01
         assertEquals(10512, parser.parseMillis("00:00:10.512345678") + DateTimeZone.getDefault().getOffset(0L));
+        
+        assertNoPrint(parser);
     }
 
     //-----------------------------------------------------------------------
@@ -275,6 +287,8 @@ public void test_dateTimeParser() {
         assertParse(parser, false, "10.5");
         assertParse(parser, false, "10:20:30.040+02:00");
         assertParse(parser, false, "10.5+02:00");
+        
+        assertNoPrint(parser);
     }
 
     //-----------------------------------------------------------------------
@@ -303,6 +317,8 @@ public void test_dateOptionalTimeParser() {
         assertParse(parser, false, "10.5");
         assertParse(parser, false, "10:20:30.040+02:00");
         assertParse(parser, false, "10.5+02:00");
+        
+        assertNoPrint(parser);
     }
 
     //-----------------------------------------------------------------------
@@ -332,6 +348,8 @@ public void test_localDateOptionalTimeParser() {
         assertParse(parser, false, "10.5");
         assertParse(parser, false, "10:20:30.040+02:00");
         assertParse(parser, false, "10.5+02:00");
+        
+        assertNoPrint(parser);
     }
 
     //-----------------------------------------------------------------------
@@ -823,4 +841,12 @@ private void assertParse(DateTimeFormatter parser, String str, DateTime expected
         assertEquals(expected, dt);
     }
 
+    private void assertNoPrint(DateTimeFormatter parser) {
+        try {
+            parser.print(new DateTime(2012, 6, 30, 12, 0, 0));
+        } catch (UnsupportedOperationException ex) {
+            // expected
+        }
+    }
+
 }

From 04909bda4b942b4ad90fef5afc4e7cd484ee5f11 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Wed, 2 Jul 2014 08:12:58 +0100
Subject: [PATCH 79/86] Better Javadoc for formatters

See #97
---
 .../joda/time/format/ISODateTimeFormat.java   | 85 +++++++++++++++++++
 1 file changed, 85 insertions(+)

diff --git a/src/main/java/org/joda/time/format/ISODateTimeFormat.java b/src/main/java/org/joda/time/format/ISODateTimeFormat.java
index 00314da3b..f32a6f4c6 100644
--- a/src/main/java/org/joda/time/format/ISODateTimeFormat.java
+++ b/src/main/java/org/joda/time/format/ISODateTimeFormat.java
@@ -680,6 +680,9 @@ public static DateTimeFormatter localDateOptionalTimeParser() {
     /**
      * Returns a formatter for a full date as four digit year, two digit month
      * of year, and two digit day of month (yyyy-MM-dd).
+     * <p>
+     * The returned formatter prints and parse only this format.
+     * See {@link #dateParser()} for a more flexible parse that accepts different formats.
      * 
      * @return a formatter for yyyy-MM-dd
      */
@@ -691,8 +694,12 @@ public static DateTimeFormatter date() {
      * Returns a formatter for a two digit hour of day, two digit minute of
      * hour, two digit second of minute, three digit fraction of second, and
      * time zone offset (HH:mm:ss.SSSZZ).
+     * <p>
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
+     * <p>
+     * The returned formatter prints and parse only this format, which includes milliseconds.
+     * See {@link #timeParser()} for a more flexible parse that accepts different formats.
      * 
      * @return a formatter for HH:mm:ss.SSSZZ
      */
@@ -703,8 +710,12 @@ public static DateTimeFormatter time() {
     /**
      * Returns a formatter for a two digit hour of day, two digit minute of
      * hour, two digit second of minute, and time zone offset (HH:mm:ssZZ).
+     * <p>
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
+     * <p>
+     * The returned formatter prints and parse only this format, which excludes milliseconds.
+     * See {@link #timeParser()} for a more flexible parse that accepts different formats.
      * 
      * @return a formatter for HH:mm:ssZZ
      */
@@ -716,8 +727,12 @@ public static DateTimeFormatter timeNoMillis() {
      * Returns a formatter for a two digit hour of day, two digit minute of
      * hour, two digit second of minute, three digit fraction of second, and
      * time zone offset prefixed by 'T' ('T'HH:mm:ss.SSSZZ).
+     * <p>
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
+     * <p>
+     * The returned formatter prints and parse only this format, which includes milliseconds.
+     * See {@link #timeParser()} for a more flexible parse that accepts different formats.
      * 
      * @return a formatter for 'T'HH:mm:ss.SSSZZ
      */
@@ -729,8 +744,12 @@ public static DateTimeFormatter tTime() {
      * Returns a formatter for a two digit hour of day, two digit minute of
      * hour, two digit second of minute, and time zone offset prefixed
      * by 'T' ('T'HH:mm:ssZZ).
+     * <p>
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
+     * <p>
+     * The returned formatter prints and parse only this format, which excludes milliseconds.
+     * See {@link #timeParser()} for a more flexible parse that accepts different formats.
      * 
      * @return a formatter for 'T'HH:mm:ssZZ
      */
@@ -741,8 +760,12 @@ public static DateTimeFormatter tTimeNoMillis() {
     /**
      * Returns a formatter that combines a full date and time, separated by a 'T'
      * (yyyy-MM-dd'T'HH:mm:ss.SSSZZ).
+     * <p>
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
+     * <p>
+     * The returned formatter prints and parse only this format, which includes milliseconds.
+     * See {@link #dateTimeParser()} for a more flexible parse that accepts different formats.
      * 
      * @return a formatter for yyyy-MM-dd'T'HH:mm:ss.SSSZZ
      */
@@ -753,8 +776,12 @@ public static DateTimeFormatter dateTime() {
     /**
      * Returns a formatter that combines a full date and time without millis,
      * separated by a 'T' (yyyy-MM-dd'T'HH:mm:ssZZ).
+     * <p>
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
+     * <p>
+     * The returned formatter prints and parse only this format, which excludes milliseconds.
+     * See {@link #dateTimeParser()} for a more flexible parse that accepts different formats.
      * 
      * @return a formatter for yyyy-MM-dd'T'HH:mm:ssZZ
      */
@@ -765,6 +792,9 @@ public static DateTimeFormatter dateTimeNoMillis() {
     /**
      * Returns a formatter for a full ordinal date, using a four
      * digit year and three digit dayOfYear (yyyy-DDD).
+     * <p>
+     * The returned formatter prints and parse only this format.
+     * See {@link #dateParser()} for a more flexible parse that accepts different formats.
      * 
      * @return a formatter for yyyy-DDD
      * @since 1.1
@@ -776,8 +806,12 @@ public static DateTimeFormatter ordinalDate() {
     /**
      * Returns a formatter for a full ordinal date and time, using a four
      * digit year and three digit dayOfYear (yyyy-DDD'T'HH:mm:ss.SSSZZ).
+     * <p>
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
+     * <p>
+     * The returned formatter prints and parse only this format, which includes milliseconds.
+     * See {@link #dateTimeParser()} for a more flexible parse that accepts different formats.
      * 
      * @return a formatter for yyyy-DDD'T'HH:mm:ss.SSSZZ
      * @since 1.1
@@ -789,8 +823,12 @@ public static DateTimeFormatter ordinalDateTime() {
     /**
      * Returns a formatter for a full ordinal date and time without millis,
      * using a four digit year and three digit dayOfYear (yyyy-DDD'T'HH:mm:ssZZ).
+     * <p>
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
+     * <p>
+     * The returned formatter prints and parse only this format, which excludes milliseconds.
+     * See {@link #dateTimeParser()} for a more flexible parse that accepts different formats.
      * 
      * @return a formatter for yyyy-DDD'T'HH:mm:ssZZ
      * @since 1.1
@@ -802,6 +840,9 @@ public static DateTimeFormatter ordinalDateTimeNoMillis() {
     /**
      * Returns a formatter for a full date as four digit weekyear, two digit
      * week of weekyear, and one digit day of week (xxxx-'W'ww-e).
+     * <p>
+     * The returned formatter prints and parse only this format.
+     * See {@link #dateParser()} for a more flexible parse that accepts different formats.
      * 
      * @return a formatter for xxxx-'W'ww-e
      */
@@ -812,8 +853,12 @@ public static DateTimeFormatter weekDate() {
     /**
      * Returns a formatter that combines a full weekyear date and time,
      * separated by a 'T' (xxxx-'W'ww-e'T'HH:mm:ss.SSSZZ).
+     * <p>
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
+     * <p>
+     * The returned formatter prints and parse only this format, which includes milliseconds.
+     * See {@link #dateTimeParser()} for a more flexible parse that accepts different formats.
      * 
      * @return a formatter for xxxx-'W'ww-e'T'HH:mm:ss.SSSZZ
      */
@@ -824,8 +869,12 @@ public static DateTimeFormatter weekDateTime() {
     /**
      * Returns a formatter that combines a full weekyear date and time without millis,
      * separated by a 'T' (xxxx-'W'ww-e'T'HH:mm:ssZZ).
+     * <p>
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
+     * <p>
+     * The returned formatter prints and parse only this format, which excludes milliseconds.
+     * See {@link #dateTimeParser()} for a more flexible parse that accepts different formats.
      * 
      * @return a formatter for xxxx-'W'ww-e'T'HH:mm:ssZZ
      */
@@ -837,6 +886,8 @@ public static DateTimeFormatter weekDateTimeNoMillis() {
     /**
      * Returns a basic formatter for a full date as four digit year, two digit
      * month of year, and two digit day of month (yyyyMMdd).
+     * <p>
+     * The returned formatter prints and parse only this format.
      * 
      * @return a formatter for yyyyMMdd
      */
@@ -848,8 +899,11 @@ public static DateTimeFormatter basicDate() {
      * Returns a basic formatter for a two digit hour of day, two digit minute
      * of hour, two digit second of minute, three digit millis, and time zone
      * offset (HHmmss.SSSZ).
+     * <p>
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
+     * <p>
+     * The returned formatter prints and parse only this format, which includes milliseconds.
      * 
      * @return a formatter for HHmmss.SSSZ
      */
@@ -860,8 +914,11 @@ public static DateTimeFormatter basicTime() {
     /**
      * Returns a basic formatter for a two digit hour of day, two digit minute
      * of hour, two digit second of minute, and time zone offset (HHmmssZ).
+     * <p>
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
+     * <p>
+     * The returned formatter prints and parse only this format, which excludes milliseconds.
      * 
      * @return a formatter for HHmmssZ
      */
@@ -873,8 +930,11 @@ public static DateTimeFormatter basicTimeNoMillis() {
      * Returns a basic formatter for a two digit hour of day, two digit minute
      * of hour, two digit second of minute, three digit millis, and time zone
      * offset prefixed by 'T' ('T'HHmmss.SSSZ).
+     * <p>
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
+     * <p>
+     * The returned formatter prints and parse only this format, which includes milliseconds.
      * 
      * @return a formatter for 'T'HHmmss.SSSZ
      */
@@ -886,8 +946,11 @@ public static DateTimeFormatter basicTTime() {
      * Returns a basic formatter for a two digit hour of day, two digit minute
      * of hour, two digit second of minute, and time zone offset prefixed by 'T'
      * ('T'HHmmssZ).
+     * <p>
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
+     * <p>
+     * The returned formatter prints and parse only this format, which excludes milliseconds.
      * 
      * @return a formatter for 'T'HHmmssZ
      */
@@ -898,8 +961,11 @@ public static DateTimeFormatter basicTTimeNoMillis() {
     /**
      * Returns a basic formatter that combines a basic date and time, separated
      * by a 'T' (yyyyMMdd'T'HHmmss.SSSZ).
+     * <p>
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
+     * <p>
+     * The returned formatter prints and parse only this format, which includes milliseconds.
      * 
      * @return a formatter for yyyyMMdd'T'HHmmss.SSSZ
      */
@@ -910,8 +976,11 @@ public static DateTimeFormatter basicDateTime() {
     /**
      * Returns a basic formatter that combines a basic date and time without millis,
      * separated by a 'T' (yyyyMMdd'T'HHmmssZ).
+     * <p>
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
+     * <p>
+     * The returned formatter prints and parse only this format, which excludes milliseconds.
      * 
      * @return a formatter for yyyyMMdd'T'HHmmssZ
      */
@@ -922,6 +991,8 @@ public static DateTimeFormatter basicDateTimeNoMillis() {
     /**
      * Returns a formatter for a full ordinal date, using a four
      * digit year and three digit dayOfYear (yyyyDDD).
+     * <p>
+     * The returned formatter prints and parse only this format.
      * 
      * @return a formatter for yyyyDDD
      * @since 1.1
@@ -933,8 +1004,11 @@ public static DateTimeFormatter basicOrdinalDate() {
     /**
      * Returns a formatter for a full ordinal date and time, using a four
      * digit year and three digit dayOfYear (yyyyDDD'T'HHmmss.SSSZ).
+     * <p>
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
+     * <p>
+     * The returned formatter prints and parse only this format, which includes milliseconds.
      * 
      * @return a formatter for yyyyDDD'T'HHmmss.SSSZ
      * @since 1.1
@@ -946,8 +1020,11 @@ public static DateTimeFormatter basicOrdinalDateTime() {
     /**
      * Returns a formatter for a full ordinal date and time without millis,
      * using a four digit year and three digit dayOfYear (yyyyDDD'T'HHmmssZ).
+     * <p>
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
+     * <p>
+     * The returned formatter prints and parse only this format, which excludes milliseconds.
      * 
      * @return a formatter for yyyyDDD'T'HHmmssZ
      * @since 1.1
@@ -959,6 +1036,8 @@ public static DateTimeFormatter basicOrdinalDateTimeNoMillis() {
     /**
      * Returns a basic formatter for a full date as four digit weekyear, two
      * digit week of weekyear, and one digit day of week (xxxx'W'wwe).
+     * <p>
+     * The returned formatter prints and parse only this format.
      * 
      * @return a formatter for xxxx'W'wwe
      */
@@ -969,8 +1048,11 @@ public static DateTimeFormatter basicWeekDate() {
     /**
      * Returns a basic formatter that combines a basic weekyear date and time,
      * separated by a 'T' (xxxx'W'wwe'T'HHmmss.SSSZ).
+     * <p>
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
+     * <p>
+     * The returned formatter prints and parse only this format, which includes milliseconds.
      * 
      * @return a formatter for xxxx'W'wwe'T'HHmmss.SSSZ
      */
@@ -981,8 +1063,11 @@ public static DateTimeFormatter basicWeekDateTime() {
     /**
      * Returns a basic formatter that combines a basic weekyear date and time
      * without millis, separated by a 'T' (xxxx'W'wwe'T'HHmmssZ).
+     * <p>
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
+     * <p>
+     * The returned formatter prints and parse only this format, which excludes milliseconds.
      * 
      * @return a formatter for xxxx'W'wwe'T'HHmmssZ
      */

From 1379098f681f0d4d6f0a3403ab6727dc3437b6df Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Fri, 4 Jul 2014 12:29:56 +0100
Subject: [PATCH 80/86] Better Javadoc for formatters

Fixes #97
---
 .../joda/time/format/ISODateTimeFormat.java   | 78 +++++++++----------
 1 file changed, 39 insertions(+), 39 deletions(-)

diff --git a/src/main/java/org/joda/time/format/ISODateTimeFormat.java b/src/main/java/org/joda/time/format/ISODateTimeFormat.java
index f32a6f4c6..27d54b792 100644
--- a/src/main/java/org/joda/time/format/ISODateTimeFormat.java
+++ b/src/main/java/org/joda/time/format/ISODateTimeFormat.java
@@ -681,8 +681,8 @@ public static DateTimeFormatter localDateOptionalTimeParser() {
      * Returns a formatter for a full date as four digit year, two digit month
      * of year, and two digit day of month (yyyy-MM-dd).
      * <p>
-     * The returned formatter prints and parse only this format.
-     * See {@link #dateParser()} for a more flexible parse that accepts different formats.
+     * The returned formatter prints and parses only this format.
+     * See {@link #dateParser()} for a more flexible parser that accepts different formats.
      * 
      * @return a formatter for yyyy-MM-dd
      */
@@ -698,8 +698,8 @@ public static DateTimeFormatter date() {
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
      * <p>
-     * The returned formatter prints and parse only this format, which includes milliseconds.
-     * See {@link #timeParser()} for a more flexible parse that accepts different formats.
+     * The returned formatter prints and parses only this format, which includes milliseconds.
+     * See {@link #timeParser()} for a more flexible parser that accepts different formats.
      * 
      * @return a formatter for HH:mm:ss.SSSZZ
      */
@@ -714,8 +714,8 @@ public static DateTimeFormatter time() {
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
      * <p>
-     * The returned formatter prints and parse only this format, which excludes milliseconds.
-     * See {@link #timeParser()} for a more flexible parse that accepts different formats.
+     * The returned formatter prints and parses only this format, which excludes milliseconds.
+     * See {@link #timeParser()} for a more flexible parser that accepts different formats.
      * 
      * @return a formatter for HH:mm:ssZZ
      */
@@ -731,8 +731,8 @@ public static DateTimeFormatter timeNoMillis() {
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
      * <p>
-     * The returned formatter prints and parse only this format, which includes milliseconds.
-     * See {@link #timeParser()} for a more flexible parse that accepts different formats.
+     * The returned formatter prints and parses only this format, which includes milliseconds.
+     * See {@link #timeParser()} for a more flexible parser that accepts different formats.
      * 
      * @return a formatter for 'T'HH:mm:ss.SSSZZ
      */
@@ -748,8 +748,8 @@ public static DateTimeFormatter tTime() {
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
      * <p>
-     * The returned formatter prints and parse only this format, which excludes milliseconds.
-     * See {@link #timeParser()} for a more flexible parse that accepts different formats.
+     * The returned formatter prints and parses only this format, which excludes milliseconds.
+     * See {@link #timeParser()} for a more flexible parser that accepts different formats.
      * 
      * @return a formatter for 'T'HH:mm:ssZZ
      */
@@ -764,8 +764,8 @@ public static DateTimeFormatter tTimeNoMillis() {
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
      * <p>
-     * The returned formatter prints and parse only this format, which includes milliseconds.
-     * See {@link #dateTimeParser()} for a more flexible parse that accepts different formats.
+     * The returned formatter prints and parses only this format, which includes milliseconds.
+     * See {@link #dateTimeParser()} for a more flexible parser that accepts different formats.
      * 
      * @return a formatter for yyyy-MM-dd'T'HH:mm:ss.SSSZZ
      */
@@ -780,8 +780,8 @@ public static DateTimeFormatter dateTime() {
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
      * <p>
-     * The returned formatter prints and parse only this format, which excludes milliseconds.
-     * See {@link #dateTimeParser()} for a more flexible parse that accepts different formats.
+     * The returned formatter prints and parses only this format, which excludes milliseconds.
+     * See {@link #dateTimeParser()} for a more flexible parser that accepts different formats.
      * 
      * @return a formatter for yyyy-MM-dd'T'HH:mm:ssZZ
      */
@@ -793,8 +793,8 @@ public static DateTimeFormatter dateTimeNoMillis() {
      * Returns a formatter for a full ordinal date, using a four
      * digit year and three digit dayOfYear (yyyy-DDD).
      * <p>
-     * The returned formatter prints and parse only this format.
-     * See {@link #dateParser()} for a more flexible parse that accepts different formats.
+     * The returned formatter prints and parses only this format.
+     * See {@link #dateParser()} for a more flexible parser that accepts different formats.
      * 
      * @return a formatter for yyyy-DDD
      * @since 1.1
@@ -810,8 +810,8 @@ public static DateTimeFormatter ordinalDate() {
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
      * <p>
-     * The returned formatter prints and parse only this format, which includes milliseconds.
-     * See {@link #dateTimeParser()} for a more flexible parse that accepts different formats.
+     * The returned formatter prints and parses only this format, which includes milliseconds.
+     * See {@link #dateTimeParser()} for a more flexible parser that accepts different formats.
      * 
      * @return a formatter for yyyy-DDD'T'HH:mm:ss.SSSZZ
      * @since 1.1
@@ -827,8 +827,8 @@ public static DateTimeFormatter ordinalDateTime() {
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
      * <p>
-     * The returned formatter prints and parse only this format, which excludes milliseconds.
-     * See {@link #dateTimeParser()} for a more flexible parse that accepts different formats.
+     * The returned formatter prints and parses only this format, which excludes milliseconds.
+     * See {@link #dateTimeParser()} for a more flexible parser that accepts different formats.
      * 
      * @return a formatter for yyyy-DDD'T'HH:mm:ssZZ
      * @since 1.1
@@ -841,8 +841,8 @@ public static DateTimeFormatter ordinalDateTimeNoMillis() {
      * Returns a formatter for a full date as four digit weekyear, two digit
      * week of weekyear, and one digit day of week (xxxx-'W'ww-e).
      * <p>
-     * The returned formatter prints and parse only this format.
-     * See {@link #dateParser()} for a more flexible parse that accepts different formats.
+     * The returned formatter prints and parses only this format.
+     * See {@link #dateParser()} for a more flexible parser that accepts different formats.
      * 
      * @return a formatter for xxxx-'W'ww-e
      */
@@ -857,8 +857,8 @@ public static DateTimeFormatter weekDate() {
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
      * <p>
-     * The returned formatter prints and parse only this format, which includes milliseconds.
-     * See {@link #dateTimeParser()} for a more flexible parse that accepts different formats.
+     * The returned formatter prints and parses only this format, which includes milliseconds.
+     * See {@link #dateTimeParser()} for a more flexible parser that accepts different formats.
      * 
      * @return a formatter for xxxx-'W'ww-e'T'HH:mm:ss.SSSZZ
      */
@@ -873,8 +873,8 @@ public static DateTimeFormatter weekDateTime() {
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HH:mm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
      * <p>
-     * The returned formatter prints and parse only this format, which excludes milliseconds.
-     * See {@link #dateTimeParser()} for a more flexible parse that accepts different formats.
+     * The returned formatter prints and parses only this format, which excludes milliseconds.
+     * See {@link #dateTimeParser()} for a more flexible parser that accepts different formats.
      * 
      * @return a formatter for xxxx-'W'ww-e'T'HH:mm:ssZZ
      */
@@ -887,7 +887,7 @@ public static DateTimeFormatter weekDateTimeNoMillis() {
      * Returns a basic formatter for a full date as four digit year, two digit
      * month of year, and two digit day of month (yyyyMMdd).
      * <p>
-     * The returned formatter prints and parse only this format.
+     * The returned formatter prints and parses only this format.
      * 
      * @return a formatter for yyyyMMdd
      */
@@ -903,7 +903,7 @@ public static DateTimeFormatter basicDate() {
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
      * <p>
-     * The returned formatter prints and parse only this format, which includes milliseconds.
+     * The returned formatter prints and parses only this format, which includes milliseconds.
      * 
      * @return a formatter for HHmmss.SSSZ
      */
@@ -918,7 +918,7 @@ public static DateTimeFormatter basicTime() {
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
      * <p>
-     * The returned formatter prints and parse only this format, which excludes milliseconds.
+     * The returned formatter prints and parses only this format, which excludes milliseconds.
      * 
      * @return a formatter for HHmmssZ
      */
@@ -934,7 +934,7 @@ public static DateTimeFormatter basicTimeNoMillis() {
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
      * <p>
-     * The returned formatter prints and parse only this format, which includes milliseconds.
+     * The returned formatter prints and parses only this format, which includes milliseconds.
      * 
      * @return a formatter for 'T'HHmmss.SSSZ
      */
@@ -950,7 +950,7 @@ public static DateTimeFormatter basicTTime() {
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
      * <p>
-     * The returned formatter prints and parse only this format, which excludes milliseconds.
+     * The returned formatter prints and parses only this format, which excludes milliseconds.
      * 
      * @return a formatter for 'T'HHmmssZ
      */
@@ -965,7 +965,7 @@ public static DateTimeFormatter basicTTimeNoMillis() {
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
      * <p>
-     * The returned formatter prints and parse only this format, which includes milliseconds.
+     * The returned formatter prints and parses only this format, which includes milliseconds.
      * 
      * @return a formatter for yyyyMMdd'T'HHmmss.SSSZ
      */
@@ -980,7 +980,7 @@ public static DateTimeFormatter basicDateTime() {
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
      * <p>
-     * The returned formatter prints and parse only this format, which excludes milliseconds.
+     * The returned formatter prints and parses only this format, which excludes milliseconds.
      * 
      * @return a formatter for yyyyMMdd'T'HHmmssZ
      */
@@ -992,7 +992,7 @@ public static DateTimeFormatter basicDateTimeNoMillis() {
      * Returns a formatter for a full ordinal date, using a four
      * digit year and three digit dayOfYear (yyyyDDD).
      * <p>
-     * The returned formatter prints and parse only this format.
+     * The returned formatter prints and parses only this format.
      * 
      * @return a formatter for yyyyDDD
      * @since 1.1
@@ -1008,7 +1008,7 @@ public static DateTimeFormatter basicOrdinalDate() {
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
      * <p>
-     * The returned formatter prints and parse only this format, which includes milliseconds.
+     * The returned formatter prints and parses only this format, which includes milliseconds.
      * 
      * @return a formatter for yyyyDDD'T'HHmmss.SSSZ
      * @since 1.1
@@ -1024,7 +1024,7 @@ public static DateTimeFormatter basicOrdinalDateTime() {
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
      * <p>
-     * The returned formatter prints and parse only this format, which excludes milliseconds.
+     * The returned formatter prints and parses only this format, which excludes milliseconds.
      * 
      * @return a formatter for yyyyDDD'T'HHmmssZ
      * @since 1.1
@@ -1037,7 +1037,7 @@ public static DateTimeFormatter basicOrdinalDateTimeNoMillis() {
      * Returns a basic formatter for a full date as four digit weekyear, two
      * digit week of weekyear, and one digit day of week (xxxx'W'wwe).
      * <p>
-     * The returned formatter prints and parse only this format.
+     * The returned formatter prints and parses only this format.
      * 
      * @return a formatter for xxxx'W'wwe
      */
@@ -1052,7 +1052,7 @@ public static DateTimeFormatter basicWeekDate() {
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
      * <p>
-     * The returned formatter prints and parse only this format, which includes milliseconds.
+     * The returned formatter prints and parses only this format, which includes milliseconds.
      * 
      * @return a formatter for xxxx'W'wwe'T'HHmmss.SSSZ
      */
@@ -1067,7 +1067,7 @@ public static DateTimeFormatter basicWeekDateTime() {
      * The time zone offset is 'Z' for zero, and of the form '\u00b1HHmm' for non-zero.
      * The parser is strict by default, thus time string {@code 24:00} cannot be parsed.
      * <p>
-     * The returned formatter prints and parse only this format, which excludes milliseconds.
+     * The returned formatter prints and parses only this format, which excludes milliseconds.
      * 
      * @return a formatter for xxxx'W'wwe'T'HHmmssZ
      */

From 70ee94062e12002575a2d1d398d315915b646221 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 26 Jul 2014 20:07:31 +0100
Subject: [PATCH 81/86] Add link to external user guide

---
 src/site/xdoc/related.xml | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/site/xdoc/related.xml b/src/site/xdoc/related.xml
index bdef4477f..34b3dae5d 100644
--- a/src/site/xdoc/related.xml
+++ b/src/site/xdoc/related.xml
@@ -34,6 +34,7 @@ A library providing persistence via the DataNucleus platform.</li>
 Notes on Joda-Time and JAXB.</li>
 <li><a href="https://github.com/muuki88/joda-osgi">P2 update site</a>
 Eclipse P2 update site.</li>
+<li><a href="http://www.studytrails.com/java/jodatime/">External Study Trails user guide</a></li>
 </ul>
 <p>
 If your open source library provides a value added feature on top of Joda-Time, then let us know!

From a1b12631a26324acab5348e2b9d51773f382e657 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 26 Jul 2014 21:13:36 +0100
Subject: [PATCH 82/86] Fix Period construction during DST overlap

If one end was within a DST overlap and the other end
beyond the overlap then the calculated period was incorrect
Fixes #156
---
 RELEASE-NOTES.txt                             |  5 +++
 .../org/joda/time/chrono/BaseChronology.java  |  4 ++-
 .../joda/time/TestPeriod_Constructors.java    | 33 +++++++++++++++++++
 3 files changed, 41 insertions(+), 1 deletion(-)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 7a9489e51..2e9f269d5 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -84,6 +84,11 @@ Bug fixes since 2.3
   A slew of tests were added and a variety of bugs fixed
   This affects DateTimeField.getDurationField() and DateTimeField.getRangeDurationField()
 
+- Period construction during DST overlap [#156]
+  When creating a period, if one end is within a DST overlap and one beyond the overlap
+  then the calculated period was incorrect.
+  The calculation has been changed no ensure no extra hour is added.
+
 - DateTimeUtils.isContiguous(ReadablePartial) [#89]
   The isContiguous() method could throw a NullPointerException when evaluating weird partials
 
diff --git a/src/main/java/org/joda/time/chrono/BaseChronology.java b/src/main/java/org/joda/time/chrono/BaseChronology.java
index cf3ae1597..fded10cf0 100644
--- a/src/main/java/org/joda/time/chrono/BaseChronology.java
+++ b/src/main/java/org/joda/time/chrono/BaseChronology.java
@@ -258,7 +258,9 @@ public long set(ReadablePartial partial, long instant) {
             for (int i = 0; i < size; i++) {
                 DurationField field = period.getFieldType(i).getField(this);
                 int value = field.getDifference(endInstant, startInstant);
-                startInstant = field.add(startInstant, value);
+                if (value != 0) {
+                    startInstant = field.add(startInstant, value);
+                }
                 values[i] = value;
             }
         }
diff --git a/src/test/java/org/joda/time/TestPeriod_Constructors.java b/src/test/java/org/joda/time/TestPeriod_Constructors.java
index 11a019a84..1ebf258e3 100644
--- a/src/test/java/org/joda/time/TestPeriod_Constructors.java
+++ b/src/test/java/org/joda/time/TestPeriod_Constructors.java
@@ -34,6 +34,7 @@
     // (before the late 90's they were all over the place)
 
     private static final DateTimeZone LONDON = DateTimeZone.forID("Europe/London");
+    private static final DateTimeZone PARIS = DateTimeZone.forID("Europe/Paris");
     
     long y2002days = 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 
                      366 + 365 + 365 + 365 + 366 + 365 + 365 + 365 + 366 + 365 + 
@@ -688,6 +689,38 @@ public void testConstructor_RI_RI5() throws Throwable {
         assertEquals(0, test.getMillis());
     }
 
+    public void testConstructor_RI_RI6() throws Throwable {
+        DateTimeZone zone = PARIS;
+        DateTime dt1 = new DateTime(2013, 10, 27, 2, 0, 0, zone).withLaterOffsetAtOverlap();
+        DateTime dt2 = new DateTime(2013, 10, 27, 2, 15, 0, zone).withLaterOffsetAtOverlap();
+        Period test = new Period(dt1, dt2);
+        assertEquals(PeriodType.standard(), test.getPeriodType());
+        assertEquals(0, test.getYears());
+        assertEquals(0, test.getMonths());
+        assertEquals(0, test.getWeeks());
+        assertEquals(0, test.getDays());
+        assertEquals(0, test.getHours());
+        assertEquals(15, test.getMinutes());
+        assertEquals(0, test.getSeconds());
+        assertEquals(0, test.getMillis());
+    }
+
+    public void testConstructor_RI_RI7() throws Throwable {
+        DateTimeZone zone = PARIS;
+        DateTime dt1 = new DateTime(2013, 10, 27, 2, 0, 0, zone).withEarlierOffsetAtOverlap();
+        DateTime dt2 = new DateTime(2013, 10, 27, 2, 15, 0, zone).withLaterOffsetAtOverlap();
+        Period test = new Period(dt1, dt2);
+        assertEquals(PeriodType.standard(), test.getPeriodType());
+        assertEquals(0, test.getYears());
+        assertEquals(0, test.getMonths());
+        assertEquals(0, test.getWeeks());
+        assertEquals(0, test.getDays());
+        assertEquals(1, test.getHours());
+        assertEquals(15, test.getMinutes());
+        assertEquals(0, test.getSeconds());
+        assertEquals(0, test.getMillis());
+    }
+
     //-----------------------------------------------------------------------
     public void testConstructor_RI_RI_PeriodType1() throws Throwable {
         DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);

From b9a9b5737163f5b60643a37aa57893fc248c5439 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sat, 26 Jul 2014 23:33:10 +0100
Subject: [PATCH 83/86] Fixed conversion from Local to UTC

DateTimeZone.getOffsetFromLocal() method
Fixed to handle the last cutover in DST history correctly
Rewrite docs and tests
Fixes #76
---
 RELEASE-NOTES.txt                             |   4 +
 src/main/java/org/joda/time/DateTimeZone.java |  33 ++-
 .../org/joda/time/chrono/ZonedChronology.java |   7 +-
 .../joda/time/TestDateTimeZoneCutover.java    | 218 ++++++++++--------
 4 files changed, 155 insertions(+), 107 deletions(-)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 2e9f269d5..10a662a08 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -84,6 +84,10 @@ Bug fixes since 2.3
   A slew of tests were added and a variety of bugs fixed
   This affects DateTimeField.getDurationField() and DateTimeField.getRangeDurationField()
 
+- Fixed another edge case in conversion from Local to UTC  [#76]
+  The DateTimeZone.getOffsetFromLocal() method was fixed to handle the last cutover
+  in DST history correctly.
+
 - Period construction during DST overlap [#156]
   When creating a period, if one end is within a DST overlap and one beyond the overlap
   then the calculated period was incorrect.
diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java
index a8d815e62..b51db3ad2 100644
--- a/src/main/java/org/joda/time/DateTimeZone.java
+++ b/src/main/java/org/joda/time/DateTimeZone.java
@@ -885,22 +885,25 @@ public boolean isStandardOffset(long instant) {
      * offset transitions (due to DST or other historical changes), ranges of
      * local times may map to different UTC times.
      * <p>
-     * This method will return an offset suitable for calculating an instant
-     * after any DST gap. For example, consider a zone with a cutover
-     * from 01:00 to 01:59:<br />
-     * Input: 00:00  Output: 00:00<br />
-     * Input: 00:30  Output: 00:30<br />
-     * Input: 01:00  Output: 02:00<br />
-     * Input: 01:30  Output: 02:30<br />
-     * Input: 02:00  Output: 02:00<br />
-     * Input: 02:30  Output: 02:30<br />
+     * For overlaps (where the local time is ambiguous), this method returns the
+     * offset applicable before the gap. The effect of this is that any instant
+     * calculated using the offset from an overlap will be in "summer" time.
      * <p>
-     * During a DST overlap (where the local time is ambiguous) this method will return
-     * the earlier instant. The combination of these two rules is to always favour
-     * daylight (summer) time over standard (winter) time.
+     * For gaps, this method returns the offset applicable before the gap, ie "winter" offset.
+     * However, the effect of this is that any instant calculated using the offset
+     * from a gap will be after the gap, in "summer" time.
+     * <p>
+     * For example, consider a zone with a gap from 01:00 to 01:59:<br />
+     * Input: 00:00 (before gap) Output: Offset applicable before gap  DateTime: 00:00<br />
+     * Input: 00:30 (before gap) Output: Offset applicable before gap  DateTime: 00:30<br />
+     * Input: 01:00 (in gap)     Output: Offset applicable before gap  DateTime: 02:00<br />
+     * Input: 01:30 (in gap)     Output: Offset applicable before gap  DateTime: 02:30<br />
+     * Input: 02:00 (after gap)  Output: Offset applicable after gap   DateTime: 02:00<br />
+     * Input: 02:30 (after gap)  Output: Offset applicable after gap   DateTime: 02:30<br />
      * <p>
      * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.
      * Prior to v1.5, the DST gap behaviour was also not defined.
+     * In v2.4, the documentation was clarified again.
      *
      * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for
      * @return the millisecond offset to subtract from local time to get UTC time
@@ -920,7 +923,13 @@ public int getOffsetFromLocal(long instantLocal) {
                 // back before the transition, whereas it should be
                 // on or after the transition
                 long nextLocal = nextTransition(instantAdjusted);
+                if (nextLocal == (instantLocal - offsetLocal)) {
+                    nextLocal = Long.MAX_VALUE;
+                }
                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
+                if (nextAdjusted == (instantLocal - offsetAdjusted)) {
+                    nextAdjusted = Long.MAX_VALUE;
+                }
                 if (nextLocal != nextAdjusted) {
                     return offsetLocal;
                 }
diff --git a/src/main/java/org/joda/time/chrono/ZonedChronology.java b/src/main/java/org/joda/time/chrono/ZonedChronology.java
index c7c2da693..31e67ed32 100644
--- a/src/main/java/org/joda/time/chrono/ZonedChronology.java
+++ b/src/main/java/org/joda/time/chrono/ZonedChronology.java
@@ -137,11 +137,12 @@ public long getDateTimeMillis(long instant,
     private long localToUTC(long localInstant) {
         DateTimeZone zone = getZone();
         int offset = zone.getOffsetFromLocal(localInstant);
-        localInstant -= offset;
-        if (offset != zone.getOffset(localInstant)) {
+        long utcInstant = localInstant - offset;
+        int offsetBasedOnUtc = zone.getOffset(utcInstant);
+        if (offset != offsetBasedOnUtc) {
             throw new IllegalInstantException(localInstant, zone.getID());
         }
-        return localInstant;
+        return utcInstant;
     }
 
     protected void assemble(Fields fields) {
diff --git a/src/test/java/org/joda/time/TestDateTimeZoneCutover.java b/src/test/java/org/joda/time/TestDateTimeZoneCutover.java
index 394aa71cf..695ad6c77 100644
--- a/src/test/java/org/joda/time/TestDateTimeZoneCutover.java
+++ b/src/test/java/org/joda/time/TestDateTimeZoneCutover.java
@@ -277,22 +277,23 @@ public void test_MockTurkIsCorrect() {
     }
 
     public void test_getOffsetFromLocal_Turk() {
-        doTest_getOffsetFromLocal_Turk(-1, 23, 0, "2007-03-31T23:00:00.000-05:00");
-        doTest_getOffsetFromLocal_Turk(-1, 23, 30, "2007-03-31T23:30:00.000-05:00");
-        doTest_getOffsetFromLocal_Turk(0, 0, 0, "2007-04-01T01:00:00.000-04:00");
-        doTest_getOffsetFromLocal_Turk(0, 0, 30, "2007-04-01T01:30:00.000-04:00");
-        doTest_getOffsetFromLocal_Turk(0, 1, 0, "2007-04-01T01:00:00.000-04:00");
-        doTest_getOffsetFromLocal_Turk(0, 1, 30, "2007-04-01T01:30:00.000-04:00");
-        doTest_getOffsetFromLocal_Turk(0, 2, 0, "2007-04-01T02:00:00.000-04:00");
-        doTest_getOffsetFromLocal_Turk(0, 3, 0, "2007-04-01T03:00:00.000-04:00");
-        doTest_getOffsetFromLocal_Turk(0, 4, 0, "2007-04-01T04:00:00.000-04:00");
-        doTest_getOffsetFromLocal_Turk(0, 5, 0, "2007-04-01T05:00:00.000-04:00");
-        doTest_getOffsetFromLocal_Turk(0, 6, 0, "2007-04-01T06:00:00.000-04:00");
-    }
-
-    private void doTest_getOffsetFromLocal_Turk(int days, int hour, int min, String expected) {
+        doTest_getOffsetFromLocal_Turk(-1, 23, 0, "2007-03-31T23:00:00.000-05:00", -5);
+        doTest_getOffsetFromLocal_Turk(-1, 23, 30, "2007-03-31T23:30:00.000-05:00", -5);
+        doTest_getOffsetFromLocal_Turk(0, 0, 0, "2007-04-01T01:00:00.000-04:00", -5);
+        doTest_getOffsetFromLocal_Turk(0, 0, 30, "2007-04-01T01:30:00.000-04:00", -5);
+        doTest_getOffsetFromLocal_Turk(0, 1, 0, "2007-04-01T01:00:00.000-04:00", -4);
+        doTest_getOffsetFromLocal_Turk(0, 1, 30, "2007-04-01T01:30:00.000-04:00", -4);
+        doTest_getOffsetFromLocal_Turk(0, 2, 0, "2007-04-01T02:00:00.000-04:00", -4);
+        doTest_getOffsetFromLocal_Turk(0, 3, 0, "2007-04-01T03:00:00.000-04:00", -4);
+        doTest_getOffsetFromLocal_Turk(0, 4, 0, "2007-04-01T04:00:00.000-04:00", -4);
+        doTest_getOffsetFromLocal_Turk(0, 5, 0, "2007-04-01T05:00:00.000-04:00", -4);
+        doTest_getOffsetFromLocal_Turk(0, 6, 0, "2007-04-01T06:00:00.000-04:00", -4);
+    }
+
+    private void doTest_getOffsetFromLocal_Turk(int days, int hour, int min, String expected, int expOffset) {
         DateTime dt = new DateTime(2007, 4, 1, hour, min, 0, 0, DateTimeZone.UTC).plusDays(days);
         int offset = MOCK_TURK.getOffsetFromLocal(dt.getMillis());
+        assertEquals(expOffset * 3600000L, offset);
         DateTime res = new DateTime(dt.getMillis() - offset, MOCK_TURK);
         assertEquals(res.toString(), expected, res.toString());
     }
@@ -495,19 +496,19 @@ public void test_NewYorkIsCorrect_Spring() {
     }
 
     public void test_getOffsetFromLocal_NewYork_Spring() {
-        doTest_getOffsetFromLocal(3, 11, 1, 0, "2007-03-11T01:00:00.000-05:00", ZONE_NEW_YORK);
-        doTest_getOffsetFromLocal(3, 11, 1,30, "2007-03-11T01:30:00.000-05:00", ZONE_NEW_YORK);
+        doTest_getOffsetFromLocal(3, 11, 1, 0, "2007-03-11T01:00:00.000-05:00", -5, ZONE_NEW_YORK);
+        doTest_getOffsetFromLocal(3, 11, 1,30, "2007-03-11T01:30:00.000-05:00", -5, ZONE_NEW_YORK);
         
-        doTest_getOffsetFromLocal(3, 11, 2, 0, "2007-03-11T03:00:00.000-04:00", ZONE_NEW_YORK);
-        doTest_getOffsetFromLocal(3, 11, 2,30, "2007-03-11T03:30:00.000-04:00", ZONE_NEW_YORK);
+        doTest_getOffsetFromLocal(3, 11, 2, 0, "2007-03-11T03:00:00.000-04:00", -5, ZONE_NEW_YORK);
+        doTest_getOffsetFromLocal(3, 11, 2,30, "2007-03-11T03:30:00.000-04:00", -5, ZONE_NEW_YORK);
         
-        doTest_getOffsetFromLocal(3, 11, 3, 0, "2007-03-11T03:00:00.000-04:00", ZONE_NEW_YORK);
-        doTest_getOffsetFromLocal(3, 11, 3,30, "2007-03-11T03:30:00.000-04:00", ZONE_NEW_YORK);
-        doTest_getOffsetFromLocal(3, 11, 4, 0, "2007-03-11T04:00:00.000-04:00", ZONE_NEW_YORK);
-        doTest_getOffsetFromLocal(3, 11, 5, 0, "2007-03-11T05:00:00.000-04:00", ZONE_NEW_YORK);
-        doTest_getOffsetFromLocal(3, 11, 6, 0, "2007-03-11T06:00:00.000-04:00", ZONE_NEW_YORK);
-        doTest_getOffsetFromLocal(3, 11, 7, 0, "2007-03-11T07:00:00.000-04:00", ZONE_NEW_YORK);
-        doTest_getOffsetFromLocal(3, 11, 8, 0, "2007-03-11T08:00:00.000-04:00", ZONE_NEW_YORK);
+        doTest_getOffsetFromLocal(3, 11, 3, 0, "2007-03-11T03:00:00.000-04:00", -4, ZONE_NEW_YORK);
+        doTest_getOffsetFromLocal(3, 11, 3,30, "2007-03-11T03:30:00.000-04:00", -4, ZONE_NEW_YORK);
+        doTest_getOffsetFromLocal(3, 11, 4, 0, "2007-03-11T04:00:00.000-04:00", -4, ZONE_NEW_YORK);
+        doTest_getOffsetFromLocal(3, 11, 5, 0, "2007-03-11T05:00:00.000-04:00", -4, ZONE_NEW_YORK);
+        doTest_getOffsetFromLocal(3, 11, 6, 0, "2007-03-11T06:00:00.000-04:00", -4, ZONE_NEW_YORK);
+        doTest_getOffsetFromLocal(3, 11, 7, 0, "2007-03-11T07:00:00.000-04:00", -4, ZONE_NEW_YORK);
+        doTest_getOffsetFromLocal(3, 11, 8, 0, "2007-03-11T08:00:00.000-04:00", -4, ZONE_NEW_YORK);
     }
 
     public void test_DateTime_setHourAcross_NewYork_Spring() {
@@ -642,21 +643,21 @@ public void test_NewYorkIsCorrect_Autumn() {
     }
 
     public void test_getOffsetFromLocal_NewYork_Autumn() {
-        doTest_getOffsetFromLocal(11, 4, 0, 0, "2007-11-04T00:00:00.000-04:00", ZONE_NEW_YORK);
-        doTest_getOffsetFromLocal(11, 4, 0,30, "2007-11-04T00:30:00.000-04:00", ZONE_NEW_YORK);
+        doTest_getOffsetFromLocal(11, 4, 0, 0, "2007-11-04T00:00:00.000-04:00", -4, ZONE_NEW_YORK);
+        doTest_getOffsetFromLocal(11, 4, 0,30, "2007-11-04T00:30:00.000-04:00", -4, ZONE_NEW_YORK);
         
-        doTest_getOffsetFromLocal(11, 4, 1, 0, "2007-11-04T01:00:00.000-04:00", ZONE_NEW_YORK);
-        doTest_getOffsetFromLocal(11, 4, 1,30, "2007-11-04T01:30:00.000-04:00", ZONE_NEW_YORK);
+        doTest_getOffsetFromLocal(11, 4, 1, 0, "2007-11-04T01:00:00.000-04:00", -4, ZONE_NEW_YORK);
+        doTest_getOffsetFromLocal(11, 4, 1,30, "2007-11-04T01:30:00.000-04:00", -4, ZONE_NEW_YORK);
         
-        doTest_getOffsetFromLocal(11, 4, 2, 0, "2007-11-04T02:00:00.000-05:00", ZONE_NEW_YORK);
-        doTest_getOffsetFromLocal(11, 4, 2,30, "2007-11-04T02:30:00.000-05:00", ZONE_NEW_YORK);
-        doTest_getOffsetFromLocal(11, 4, 3, 0, "2007-11-04T03:00:00.000-05:00", ZONE_NEW_YORK);
-        doTest_getOffsetFromLocal(11, 4, 3,30, "2007-11-04T03:30:00.000-05:00", ZONE_NEW_YORK);
-        doTest_getOffsetFromLocal(11, 4, 4, 0, "2007-11-04T04:00:00.000-05:00", ZONE_NEW_YORK);
-        doTest_getOffsetFromLocal(11, 4, 5, 0, "2007-11-04T05:00:00.000-05:00", ZONE_NEW_YORK);
-        doTest_getOffsetFromLocal(11, 4, 6, 0, "2007-11-04T06:00:00.000-05:00", ZONE_NEW_YORK);
-        doTest_getOffsetFromLocal(11, 4, 7, 0, "2007-11-04T07:00:00.000-05:00", ZONE_NEW_YORK);
-        doTest_getOffsetFromLocal(11, 4, 8, 0, "2007-11-04T08:00:00.000-05:00", ZONE_NEW_YORK);
+        doTest_getOffsetFromLocal(11, 4, 2, 0, "2007-11-04T02:00:00.000-05:00", -5, ZONE_NEW_YORK);
+        doTest_getOffsetFromLocal(11, 4, 2,30, "2007-11-04T02:30:00.000-05:00", -5, ZONE_NEW_YORK);
+        doTest_getOffsetFromLocal(11, 4, 3, 0, "2007-11-04T03:00:00.000-05:00", -5, ZONE_NEW_YORK);
+        doTest_getOffsetFromLocal(11, 4, 3,30, "2007-11-04T03:30:00.000-05:00", -5, ZONE_NEW_YORK);
+        doTest_getOffsetFromLocal(11, 4, 4, 0, "2007-11-04T04:00:00.000-05:00", -5, ZONE_NEW_YORK);
+        doTest_getOffsetFromLocal(11, 4, 5, 0, "2007-11-04T05:00:00.000-05:00", -5, ZONE_NEW_YORK);
+        doTest_getOffsetFromLocal(11, 4, 6, 0, "2007-11-04T06:00:00.000-05:00", -5, ZONE_NEW_YORK);
+        doTest_getOffsetFromLocal(11, 4, 7, 0, "2007-11-04T07:00:00.000-05:00", -5, ZONE_NEW_YORK);
+        doTest_getOffsetFromLocal(11, 4, 8, 0, "2007-11-04T08:00:00.000-05:00", -5, ZONE_NEW_YORK);
     }
 
     public void test_DateTime_constructor_NewYork_Autumn() {
@@ -826,19 +827,19 @@ public void test_MoscowIsCorrect_Spring() {
     }
 
     public void test_getOffsetFromLocal_Moscow_Spring() {
-        doTest_getOffsetFromLocal(3, 25, 1, 0, "2007-03-25T01:00:00.000+03:00", ZONE_MOSCOW);
-        doTest_getOffsetFromLocal(3, 25, 1,30, "2007-03-25T01:30:00.000+03:00", ZONE_MOSCOW);
+        doTest_getOffsetFromLocal(3, 25, 1, 0, "2007-03-25T01:00:00.000+03:00", 3, ZONE_MOSCOW);
+        doTest_getOffsetFromLocal(3, 25, 1,30, "2007-03-25T01:30:00.000+03:00", 3, ZONE_MOSCOW);
         
-        doTest_getOffsetFromLocal(3, 25, 2, 0, "2007-03-25T03:00:00.000+04:00", ZONE_MOSCOW);
-        doTest_getOffsetFromLocal(3, 25, 2,30, "2007-03-25T03:30:00.000+04:00", ZONE_MOSCOW);
+        doTest_getOffsetFromLocal(3, 25, 2, 0, "2007-03-25T03:00:00.000+04:00", 3, ZONE_MOSCOW);
+        doTest_getOffsetFromLocal(3, 25, 2,30, "2007-03-25T03:30:00.000+04:00", 3, ZONE_MOSCOW);
         
-        doTest_getOffsetFromLocal(3, 25, 3, 0, "2007-03-25T03:00:00.000+04:00", ZONE_MOSCOW);
-        doTest_getOffsetFromLocal(3, 25, 3,30, "2007-03-25T03:30:00.000+04:00", ZONE_MOSCOW);
-        doTest_getOffsetFromLocal(3, 25, 4, 0, "2007-03-25T04:00:00.000+04:00", ZONE_MOSCOW);
-        doTest_getOffsetFromLocal(3, 25, 5, 0, "2007-03-25T05:00:00.000+04:00", ZONE_MOSCOW);
-        doTest_getOffsetFromLocal(3, 25, 6, 0, "2007-03-25T06:00:00.000+04:00", ZONE_MOSCOW);
-        doTest_getOffsetFromLocal(3, 25, 7, 0, "2007-03-25T07:00:00.000+04:00", ZONE_MOSCOW);
-        doTest_getOffsetFromLocal(3, 25, 8, 0, "2007-03-25T08:00:00.000+04:00", ZONE_MOSCOW);
+        doTest_getOffsetFromLocal(3, 25, 3, 0, "2007-03-25T03:00:00.000+04:00", 4, ZONE_MOSCOW);
+        doTest_getOffsetFromLocal(3, 25, 3,30, "2007-03-25T03:30:00.000+04:00", 4, ZONE_MOSCOW);
+        doTest_getOffsetFromLocal(3, 25, 4, 0, "2007-03-25T04:00:00.000+04:00", 4, ZONE_MOSCOW);
+        doTest_getOffsetFromLocal(3, 25, 5, 0, "2007-03-25T05:00:00.000+04:00", 4, ZONE_MOSCOW);
+        doTest_getOffsetFromLocal(3, 25, 6, 0, "2007-03-25T06:00:00.000+04:00", 4, ZONE_MOSCOW);
+        doTest_getOffsetFromLocal(3, 25, 7, 0, "2007-03-25T07:00:00.000+04:00", 4, ZONE_MOSCOW);
+        doTest_getOffsetFromLocal(3, 25, 8, 0, "2007-03-25T08:00:00.000+04:00", 4, ZONE_MOSCOW);
     }
 
     public void test_DateTime_setHourAcross_Moscow_Spring() {
@@ -887,32 +888,32 @@ public void test_MoscowIsCorrect_Autumn() {
     }
 
     public void test_getOffsetFromLocal_Moscow_Autumn() {
-        doTest_getOffsetFromLocal(10, 28, 0, 0, "2007-10-28T00:00:00.000+04:00", ZONE_MOSCOW);
-        doTest_getOffsetFromLocal(10, 28, 0,30, "2007-10-28T00:30:00.000+04:00", ZONE_MOSCOW);
-        doTest_getOffsetFromLocal(10, 28, 1, 0, "2007-10-28T01:00:00.000+04:00", ZONE_MOSCOW);
-        doTest_getOffsetFromLocal(10, 28, 1,30, "2007-10-28T01:30:00.000+04:00", ZONE_MOSCOW);
+        doTest_getOffsetFromLocal(10, 28, 0, 0, "2007-10-28T00:00:00.000+04:00", 4, ZONE_MOSCOW);
+        doTest_getOffsetFromLocal(10, 28, 0,30, "2007-10-28T00:30:00.000+04:00", 4, ZONE_MOSCOW);
+        doTest_getOffsetFromLocal(10, 28, 1, 0, "2007-10-28T01:00:00.000+04:00", 4, ZONE_MOSCOW);
+        doTest_getOffsetFromLocal(10, 28, 1,30, "2007-10-28T01:30:00.000+04:00", 4, ZONE_MOSCOW);
         
-        doTest_getOffsetFromLocal(10, 28, 2, 0, "2007-10-28T02:00:00.000+04:00", ZONE_MOSCOW);
-        doTest_getOffsetFromLocal(10, 28, 2,30, "2007-10-28T02:30:00.000+04:00", ZONE_MOSCOW);
-        doTest_getOffsetFromLocal(10, 28, 2,30,59,999, "2007-10-28T02:30:59.999+04:00", ZONE_MOSCOW);
-        doTest_getOffsetFromLocal(10, 28, 2,59,59,998, "2007-10-28T02:59:59.998+04:00", ZONE_MOSCOW);
-        doTest_getOffsetFromLocal(10, 28, 2,59,59,999, "2007-10-28T02:59:59.999+04:00", ZONE_MOSCOW);
+        doTest_getOffsetFromLocal(10, 28, 2, 0, "2007-10-28T02:00:00.000+04:00", 4, ZONE_MOSCOW);
+        doTest_getOffsetFromLocal(10, 28, 2,30, "2007-10-28T02:30:00.000+04:00", 4, ZONE_MOSCOW);
+        doTest_getOffsetFromLocal(10, 28, 2,30,59,999, "2007-10-28T02:30:59.999+04:00", 4, ZONE_MOSCOW);
+        doTest_getOffsetFromLocal(10, 28, 2,59,59,998, "2007-10-28T02:59:59.998+04:00", 4, ZONE_MOSCOW);
+        doTest_getOffsetFromLocal(10, 28, 2,59,59,999, "2007-10-28T02:59:59.999+04:00", 4, ZONE_MOSCOW);
         
-        doTest_getOffsetFromLocal(10, 28, 3, 0, "2007-10-28T03:00:00.000+03:00", ZONE_MOSCOW);
-        doTest_getOffsetFromLocal(10, 28, 3,30, "2007-10-28T03:30:00.000+03:00", ZONE_MOSCOW);
-        doTest_getOffsetFromLocal(10, 28, 4, 0, "2007-10-28T04:00:00.000+03:00", ZONE_MOSCOW);
-        doTest_getOffsetFromLocal(10, 28, 5, 0, "2007-10-28T05:00:00.000+03:00", ZONE_MOSCOW);
-        doTest_getOffsetFromLocal(10, 28, 6, 0, "2007-10-28T06:00:00.000+03:00", ZONE_MOSCOW);
-        doTest_getOffsetFromLocal(10, 28, 7, 0, "2007-10-28T07:00:00.000+03:00", ZONE_MOSCOW);
-        doTest_getOffsetFromLocal(10, 28, 8, 0, "2007-10-28T08:00:00.000+03:00", ZONE_MOSCOW);
+        doTest_getOffsetFromLocal(10, 28, 3, 0, "2007-10-28T03:00:00.000+03:00", 3, ZONE_MOSCOW);
+        doTest_getOffsetFromLocal(10, 28, 3,30, "2007-10-28T03:30:00.000+03:00", 3, ZONE_MOSCOW);
+        doTest_getOffsetFromLocal(10, 28, 4, 0, "2007-10-28T04:00:00.000+03:00", 3, ZONE_MOSCOW);
+        doTest_getOffsetFromLocal(10, 28, 5, 0, "2007-10-28T05:00:00.000+03:00", 3, ZONE_MOSCOW);
+        doTest_getOffsetFromLocal(10, 28, 6, 0, "2007-10-28T06:00:00.000+03:00", 3, ZONE_MOSCOW);
+        doTest_getOffsetFromLocal(10, 28, 7, 0, "2007-10-28T07:00:00.000+03:00", 3, ZONE_MOSCOW);
+        doTest_getOffsetFromLocal(10, 28, 8, 0, "2007-10-28T08:00:00.000+03:00", 3, ZONE_MOSCOW);
     }
 
     public void test_getOffsetFromLocal_Moscow_Autumn_overlap_mins() {
         for (int min = 0; min < 60; min++) {
             if (min < 10) {
-                doTest_getOffsetFromLocal(10, 28, 2, min, "2007-10-28T02:0" + min + ":00.000+04:00", ZONE_MOSCOW);
+                doTest_getOffsetFromLocal(10, 28, 2, min, "2007-10-28T02:0" + min + ":00.000+04:00", 4, ZONE_MOSCOW);
             } else {
-                doTest_getOffsetFromLocal(10, 28, 2, min, "2007-10-28T02:" + min + ":00.000+04:00", ZONE_MOSCOW);
+                doTest_getOffsetFromLocal(10, 28, 2, min, "2007-10-28T02:" + min + ":00.000+04:00", 4, ZONE_MOSCOW);
             }
         }
     }
@@ -969,43 +970,43 @@ public void test_GuatemataIsCorrect_Autumn() {
 
     public void test_getOffsetFromLocal_Guatemata_Autumn() {
         doTest_getOffsetFromLocal( 2006, 9,30,23, 0,
-                                  "2006-09-30T23:00:00.000-05:00", ZONE_GUATEMALA);
+                                  "2006-09-30T23:00:00.000-05:00", -5, ZONE_GUATEMALA);
         doTest_getOffsetFromLocal( 2006, 9,30,23,30,
-                                  "2006-09-30T23:30:00.000-05:00", ZONE_GUATEMALA);
+                                  "2006-09-30T23:30:00.000-05:00", -5, ZONE_GUATEMALA);
         
         doTest_getOffsetFromLocal( 2006, 9,30,23, 0,
-                                  "2006-09-30T23:00:00.000-05:00", ZONE_GUATEMALA);
+                                  "2006-09-30T23:00:00.000-05:00", -5, ZONE_GUATEMALA);
         doTest_getOffsetFromLocal( 2006, 9,30,23,30,
-                                  "2006-09-30T23:30:00.000-05:00", ZONE_GUATEMALA);
+                                  "2006-09-30T23:30:00.000-05:00", -5, ZONE_GUATEMALA);
         
         doTest_getOffsetFromLocal( 2006,10, 1, 0, 0,
-                                  "2006-10-01T00:00:00.000-06:00", ZONE_GUATEMALA);
+                                  "2006-10-01T00:00:00.000-06:00", -6, ZONE_GUATEMALA);
         doTest_getOffsetFromLocal( 2006,10, 1, 0,30,
-                                  "2006-10-01T00:30:00.000-06:00", ZONE_GUATEMALA);
+                                  "2006-10-01T00:30:00.000-06:00", -6, ZONE_GUATEMALA);
         doTest_getOffsetFromLocal( 2006,10, 1, 1, 0,
-                                  "2006-10-01T01:00:00.000-06:00", ZONE_GUATEMALA);
+                                  "2006-10-01T01:00:00.000-06:00", -6, ZONE_GUATEMALA);
         doTest_getOffsetFromLocal( 2006,10, 1, 1,30,
-                                  "2006-10-01T01:30:00.000-06:00", ZONE_GUATEMALA);
+                                  "2006-10-01T01:30:00.000-06:00", -6, ZONE_GUATEMALA);
         doTest_getOffsetFromLocal( 2006,10, 1, 2, 0,
-                                  "2006-10-01T02:00:00.000-06:00", ZONE_GUATEMALA);
+                                  "2006-10-01T02:00:00.000-06:00", -6, ZONE_GUATEMALA);
         doTest_getOffsetFromLocal( 2006,10, 1, 2,30,
-                                  "2006-10-01T02:30:00.000-06:00", ZONE_GUATEMALA);
+                                  "2006-10-01T02:30:00.000-06:00", -6, ZONE_GUATEMALA);
         doTest_getOffsetFromLocal( 2006,10, 1, 3, 0,
-                                  "2006-10-01T03:00:00.000-06:00", ZONE_GUATEMALA);
+                                  "2006-10-01T03:00:00.000-06:00", -6, ZONE_GUATEMALA);
         doTest_getOffsetFromLocal( 2006,10, 1, 3,30,
-                                  "2006-10-01T03:30:00.000-06:00", ZONE_GUATEMALA);
+                                  "2006-10-01T03:30:00.000-06:00", -6, ZONE_GUATEMALA);
         doTest_getOffsetFromLocal( 2006,10, 1, 4, 0,
-                                  "2006-10-01T04:00:00.000-06:00", ZONE_GUATEMALA);
+                                  "2006-10-01T04:00:00.000-06:00", -6, ZONE_GUATEMALA);
         doTest_getOffsetFromLocal( 2006,10, 1, 4,30,
-                                  "2006-10-01T04:30:00.000-06:00", ZONE_GUATEMALA);
+                                  "2006-10-01T04:30:00.000-06:00", -6, ZONE_GUATEMALA);
         doTest_getOffsetFromLocal( 2006,10, 1, 5, 0,
-                                  "2006-10-01T05:00:00.000-06:00", ZONE_GUATEMALA);
+                                  "2006-10-01T05:00:00.000-06:00", -6, ZONE_GUATEMALA);
         doTest_getOffsetFromLocal( 2006,10, 1, 5,30,
-                                  "2006-10-01T05:30:00.000-06:00", ZONE_GUATEMALA);
+                                  "2006-10-01T05:30:00.000-06:00", -6, ZONE_GUATEMALA);
         doTest_getOffsetFromLocal( 2006,10, 1, 6, 0,
-                                  "2006-10-01T06:00:00.000-06:00", ZONE_GUATEMALA);
+                                  "2006-10-01T06:00:00.000-06:00", -6, ZONE_GUATEMALA);
         doTest_getOffsetFromLocal( 2006,10, 1, 6,30,
-                                  "2006-10-01T06:30:00.000-06:00", ZONE_GUATEMALA);
+                                  "2006-10-01T06:30:00.000-06:00", -6, ZONE_GUATEMALA);
     }
 
     public void test_DateTime_plusHour_Guatemata_Autumn() {
@@ -1048,6 +1049,38 @@ public void test_DateTime_minusHour_Guatemata_Autumn() {
         assertEquals("2006-09-30T20:00:00.000-05:00", minus7.toString());
     }
 
+    //-----------------------------------------------------------------------
+    //-----------------------------------------------------------------------
+    //-----------------------------------------------------------------------
+    /** America/Rio_Branco gap cutover from 2008-06-23T23:59-05:00 to 2008-06-24T01:00-04:00 */
+    private static long CUTOVER_RIO_BRANCO_AUTUMN = 1214283600000L; // 2008-06-24T01:00:00.000-04:00
+    private static final DateTimeZone ZONE_RIO_BRANCO = DateTimeZone.forID("America/Rio_Branco");
+
+    //-----------------------------------------------------------------------
+    public void test_RioBrancoIsCorrect_Spring() {
+        DateTime pre = new DateTime(CUTOVER_RIO_BRANCO_AUTUMN - 1L, ZONE_RIO_BRANCO);
+        assertEquals("2008-06-23T23:59:59.999-05:00", pre.toString());
+        DateTime at = new DateTime(CUTOVER_RIO_BRANCO_AUTUMN, ZONE_RIO_BRANCO);
+        assertEquals("2008-06-24T01:00:00.000-04:00", at.toString());
+        DateTime post = new DateTime(CUTOVER_RIO_BRANCO_AUTUMN + 1L, ZONE_RIO_BRANCO);
+        assertEquals("2008-06-24T01:00:00.001-04:00", post.toString());
+    }
+
+    public void test_getOffsetFromLocal_RioBranco_Spring() {
+        doTest_getOffsetFromLocal(2008, 6, 23, 23, 0, "2008-06-23T23:00:00.000-05:00", -5, ZONE_RIO_BRANCO);
+        doTest_getOffsetFromLocal(2008, 6, 23, 23, 30, "2008-06-23T23:30:00.000-05:00", -5, ZONE_RIO_BRANCO);
+        
+        doTest_getOffsetFromLocal(2008, 6, 24, 0, 0, "2008-06-24T01:00:00.000-04:00", -5, ZONE_RIO_BRANCO);
+        doTest_getOffsetFromLocal(2008, 6, 24, 0, 30, "2008-06-24T01:30:00.000-04:00", -5, ZONE_RIO_BRANCO);
+        
+        doTest_getOffsetFromLocal(2008, 6, 24, 1, 0, "2008-06-24T01:00:00.000-04:00", -4, ZONE_RIO_BRANCO);
+        doTest_getOffsetFromLocal(2008, 6, 24, 1, 30, "2008-06-24T01:30:00.000-04:00", -4, ZONE_RIO_BRANCO);
+        doTest_getOffsetFromLocal(2008, 6, 24, 2, 0, "2008-06-24T02:00:00.000-04:00", -4, ZONE_RIO_BRANCO);
+        doTest_getOffsetFromLocal(2008, 6, 24, 2, 30, "2008-06-24T02:30:00.000-04:00", -4, ZONE_RIO_BRANCO);
+        doTest_getOffsetFromLocal(2008, 6, 24, 5, 0, "2008-06-24T05:00:00.000-04:00", -4, ZONE_RIO_BRANCO);
+        doTest_getOffsetFromLocal(2008, 6, 24, 5, 30, "2008-06-24T05:30:00.000-04:00", -4, ZONE_RIO_BRANCO);
+    }
+
     //-----------------------------------------------------------------------
     //-----------------------------------------------------------------------
     //-----------------------------------------------------------------------
@@ -1318,21 +1351,22 @@ public void testDateTimeCreation_losAngeles() {
     //-----------------------------------------------------------------------
     //-----------------------------------------------------------------------
     //-----------------------------------------------------------------------
-    private void doTest_getOffsetFromLocal(int month, int day, int hour, int min, String expected, DateTimeZone zone) {
-        doTest_getOffsetFromLocal(2007, month, day, hour, min, 0, 0, expected, zone);
+    private void doTest_getOffsetFromLocal(int month, int day, int hour, int min, String expected, int expOffset, DateTimeZone zone) {
+        doTest_getOffsetFromLocal(2007, month, day, hour, min, 0, 0, expected, expOffset, zone);
     }
 
-    private void doTest_getOffsetFromLocal(int month, int day, int hour, int min, int sec, int milli, String expected, DateTimeZone zone) {
-        doTest_getOffsetFromLocal(2007, month, day, hour, min, sec, milli, expected, zone);
+    private void doTest_getOffsetFromLocal(int month, int day, int hour, int min, int sec, int milli, String expected, int expOffset, DateTimeZone zone) {
+        doTest_getOffsetFromLocal(2007, month, day, hour, min, sec, milli, expected, expOffset, zone);
     }
 
-    private void doTest_getOffsetFromLocal(int year, int month, int day, int hour, int min, String expected, DateTimeZone zone) {
-        doTest_getOffsetFromLocal(year, month, day, hour, min, 0, 0, expected, zone);
+    private void doTest_getOffsetFromLocal(int year, int month, int day, int hour, int min, String expected, int expOffset, DateTimeZone zone) {
+        doTest_getOffsetFromLocal(year, month, day, hour, min, 0, 0, expected, expOffset, zone);
     }
 
-    private void doTest_getOffsetFromLocal(int year, int month, int day, int hour, int min, int sec, int milli, String expected, DateTimeZone zone) {
+    private void doTest_getOffsetFromLocal(int year, int month, int day, int hour, int min, int sec, int milli, String expected, int expOffset, DateTimeZone zone) {
         DateTime dt = new DateTime(year, month, day, hour, min, sec, milli, DateTimeZone.UTC);
         int offset = zone.getOffsetFromLocal(dt.getMillis());
+        assertEquals(expOffset * 3600000L, offset);
         DateTime res = new DateTime(dt.getMillis() - offset, zone);
         assertEquals(res.toString(), expected, res.toString());
     }

From 894cad68e3e2ed2697e60244e11bb7089d5978e8 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 27 Jul 2014 13:49:51 +0100
Subject: [PATCH 84/86] Update to time-zone data 2014e

---
 RELEASE-NOTES.txt                             |   2 +-
 src/main/java/org/joda/time/tz/src/Readme.txt |   2 +-
 src/main/java/org/joda/time/tz/src/africa     | 259 +++++++++++++-----
 src/main/java/org/joda/time/tz/src/antarctica |  66 +++--
 src/main/java/org/joda/time/tz/src/asia       | 126 +++++----
 .../java/org/joda/time/tz/src/australasia     |  81 ++++--
 src/main/java/org/joda/time/tz/src/backward   |  12 +-
 src/main/java/org/joda/time/tz/src/etcetera   |   4 +-
 src/main/java/org/joda/time/tz/src/europe     | 223 ++++++++++-----
 .../java/org/joda/time/tz/src/northamerica    | 161 +++++------
 .../java/org/joda/time/tz/src/southamerica    |  83 +++++-
 11 files changed, 659 insertions(+), 360 deletions(-)

diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index 10a662a08..ee163b76e 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -62,7 +62,7 @@ Source compatible - Yes
 Serialization compatible - Yes
 
 Data compatible - Yes, except
- - DateTimeZone data updated to version 2013d
+ - DateTimeZone data updated to version 2014e
 
 Semantic compatible - Yes, except
 - DateTimeField duration fields have been fixed
diff --git a/src/main/java/org/joda/time/tz/src/Readme.txt b/src/main/java/org/joda/time/tz/src/Readme.txt
index 2ddfc0585..7ae4077c9 100644
--- a/src/main/java/org/joda/time/tz/src/Readme.txt
+++ b/src/main/java/org/joda/time/tz/src/Readme.txt
@@ -1,2 +1,2 @@
 The data files in this directory were obtained from the public IANA time zone database,
-http://www.iana.org/time-zones, version 2013d.
+http://www.iana.org/time-zones, version 2014e.
diff --git a/src/main/java/org/joda/time/tz/src/africa b/src/main/java/org/joda/time/tz/src/africa
index a92d7f511..90f773578 100644
--- a/src/main/java/org/joda/time/tz/src/africa
+++ b/src/main/java/org/joda/time/tz/src/africa
@@ -239,13 +239,13 @@ Rule	Egypt	1990	1994	-	May	 1	1:00	1:00	S
 # http://www.worldtimezone.com/dst_news/dst_news_egypt04.html
 # </a>
 Rule	Egypt	1995	2010	-	Apr	lastFri	 0:00s	1:00	S
-Rule	Egypt	1995	2005	-	Sep	lastThu	23:00s	0	-
+Rule	Egypt	1995	2005	-	Sep	lastThu	24:00	0	-
 # From Steffen Thorsen (2006-09-19):
 # The Egyptian Gazette, issue 41,090 (2006-09-18), page 1, reports:
 # Egypt will turn back clocks by one hour at the midnight of Thursday
 # after observing the daylight saving time since May.
 # http://news.gom.com.eg/gazette/pdf/2006/09/18/01.pdf
-Rule	Egypt	2006	only	-	Sep	21	23:00s	0	-
+Rule	Egypt	2006	only	-	Sep	21	24:00	0	-
 # From Dirk Losch (2007-08-14):
 # I received a mail from an airline which says that the daylight
 # saving time in Egypt will end in the night of 2007-09-06 to 2007-09-07.
@@ -254,7 +254,7 @@ Rule	Egypt	2006	only	-	Sep	21	23:00s	0	-
 # http://www.timeanddate.com/worldclock/city.html?n=53
 # From Steffen Thorsen (2007-09-04): The official information...:
 # http://www.sis.gov.eg/En/EgyptOnline/Miscellaneous/000002/0207000000000000001580.htm
-Rule	Egypt	2007	only	-	Sep	Thu>=1	23:00s	0	-
+Rule	Egypt	2007	only	-	Sep	Thu>=1	24:00	0	-
 # From Abdelrahman Hassan (2007-09-06):
 # Due to the Hijri (lunar Islamic calendar) year being 11 days shorter
 # than the year of the Gregorian calendar, Ramadan shifts earlier each
@@ -335,11 +335,85 @@ Rule	Egypt	2007	only	-	Sep	Thu>=1	23:00s	0	-
 # http://www.worldtimezone.com/dst_news/dst_news_egypt02.html
 # </a>
 
-Rule	Egypt	2008	only	-	Aug	lastThu	23:00s	0	-
-Rule	Egypt	2009	only	-	Aug	20	23:00s	0	-
-Rule	Egypt	2010	only	-	Aug	11	0:00	0	-
-Rule	Egypt	2010	only	-	Sep	10	0:00	1:00	S
-Rule	Egypt	2010	only	-	Sep	lastThu	23:00s	0	-
+# From Ahmad El-Dardiry (2014-05-07):
+# Egypt is to change back to Daylight system on May 15
+# http://english.ahram.org.eg/NewsContent/1/64/100735/Egypt/Politics-/Egypts-government-to-reapply-daylight-saving-time-.aspx
+
+# From Gunther Vermier (2015-05-13):
+# our Egypt office confirms that the change will be at 15 May "midnight" (24:00)
+
+# From Imed Chihi (2014-06-04):
+# We have finally "located" a precise official reference about the DST changes
+# in Egypt.  The Ministers Cabinet decision is explained at
+# http://www.cabinet.gov.eg/Media/CabinetMeetingsDetails.aspx?id=347 ...
+# [T]his (Arabic) site is not accessible outside Egypt, but the page ...
+# translates into: "With regard to daylight saving time, it is scheduled to
+# take effect at exactly twelve o'clock this evening, Thursday, 15 MAY 2014,
+# to be suspended by twelve o'clock on the evening of Thursday, 26 JUN 2014,
+# and re-established again at the end of the month of Ramadan, at twelve
+# o'clock on the evening of Thursday, 31 JUL 2014."  This statement has been
+# reproduced by other (more accessible) sites[, e.g.,]...
+# http://elgornal.net/news/news.aspx?id=4699258
+
+# From Paul Eggert (2014-06-04):
+# Sarah El Deeb and Lee Keath of AP report that the Egyptian government says
+# the change is because of blackouts in Cairo, even though Ahram Online (cited
+# above) says DST had no affect on electricity consumption.  There is
+# no information about when DST will end this fall.  See:
+# http://abcnews.go.com/International/wireStory/el-sissi-pushes-egyptians-line-23614833
+#
+# For now, guess that later spring and fall transitions will use
+# 2010's rules, and guess that Egypt will switch to standard time at
+# 24:00 the last Thursday before Ramadan, and back to DST at 00:00 the
+# first Friday after Ramadan.  To implement this,
+# transition dates for 2015 through 2037 were determined by running
+# the following program under GNU Emacs 24.3, with the results integrated
+# by hand into the table below.  Ramadan again intrudes on the guessed
+# DST starting in 2038, but that's beyond our somewhat-arbitrary cutoff.
+# (let ((islamic-year 1436))
+#   (while (< islamic-year 1460)
+#     (let ((a (calendar-islamic-to-absolute (list 9 1 islamic-year)))
+#           (b (calendar-islamic-to-absolute (list 10 1 islamic-year)))
+#           (friday 5))
+#       (while (/= friday (mod a 7))
+#         (setq a (1- a)))
+#       (while (/= friday (mod b 7))
+#         (setq b (1+ b)))
+#       (setq a (1- a))
+#       (setq b (1- b))
+#       (setq a (calendar-gregorian-from-absolute a))
+#       (setq b (calendar-gregorian-from-absolute b))
+#       (insert
+#        (format
+#         (concat "Rule\tEgypt\t%d\tonly\t-\t%s\t%2d\t24:00\t0\t-\n"
+#                 "Rule\tEgypt\t%d\tonly\t-\t%s\t%2d\t24:00\t1:00\tS\n")
+#         (car (cdr (cdr a))) (calendar-month-name (car a) t) (car (cdr a))
+#         (car (cdr (cdr b))) (calendar-month-name (car b) t) (car (cdr b)))))
+#     (setq islamic-year (+ 1 islamic-year))))
+Rule	Egypt	2008	only	-	Aug	lastThu	24:00	0	-
+Rule	Egypt	2009	only	-	Aug	20	24:00	0	-
+Rule	Egypt	2010	only	-	Aug	10	24:00	0	-
+Rule	Egypt	2010	only	-	Sep	 9	24:00	1:00	S
+Rule	Egypt	2010	only	-	Sep	lastThu	24:00	0	-
+Rule	Egypt	2014	only	-	May	15	24:00	1:00	S
+Rule	Egypt	2014	only	-	Jun	26	24:00	0	-
+Rule	Egypt	2014	only	-	Jul	31	24:00	1:00	S
+Rule	Egypt	2014	max	-	Sep	lastThu	24:00	0	-
+Rule	Egypt	2015	2019	-	Apr	lastFri	 0:00s	1:00	S
+Rule	Egypt	2015	only	-	Jun	11	24:00	0	-
+Rule	Egypt	2015	only	-	Jul	23	24:00	1:00	S
+Rule	Egypt	2016	only	-	Jun	 2	24:00	0	-
+Rule	Egypt	2016	only	-	Jul	 7	24:00	1:00	S
+Rule	Egypt	2017	only	-	May	25	24:00	0	-
+Rule	Egypt	2017	only	-	Jun	29	24:00	1:00	S
+Rule	Egypt	2018	only	-	May	10	24:00	0	-
+Rule	Egypt	2018	only	-	Jun	14	24:00	1:00	S
+Rule	Egypt	2019	only	-	May	 2	24:00	0	-
+Rule	Egypt	2019	only	-	Jun	 6	24:00	1:00	S
+Rule	Egypt	2020	only	-	May	28	24:00	1:00	S
+Rule	Egypt	2021	only	-	May	13	24:00	1:00	S
+Rule	Egypt	2022	only	-	May	 5	24:00	1:00	S
+Rule	Egypt	2023	max	-	Apr	lastFri	 0:00s	1:00	S
 
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone	Africa/Cairo	2:05:09 -	LMT	1900 Oct
@@ -451,6 +525,14 @@ Zone	Africa/Monrovia	-0:43:08 -	LMT	1882
 # (either two days before them or five days after them, so as to fall on
 # lastFri instead of lastSun).
 
+# From Even Scharning (2013-10-25):
+# The scheduled end of DST in Libya on Friday, October 25, 2013 was
+# cancelled yesterday....
+# http://www.libyaherald.com/2013/10/24/correction-no-time-change-tomorrow/
+#
+# From Paul Eggert (2013-10-25):
+# For now, assume they're reverting to the pre-2012 rules of permanent UTC+2.
+
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 Rule	Libya	1951	only	-	Oct	14	2:00	1:00	S
 Rule	Libya	1952	only	-	Jan	 1	0:00	0	-
@@ -467,8 +549,8 @@ Rule	Libya	1987	1989	-	Apr	 1	0:00	1:00	S
 Rule	Libya	1987	1989	-	Oct	 1	0:00	0	-
 Rule	Libya	1997	only	-	Apr	 4	0:00	1:00	S
 Rule	Libya	1997	only	-	Oct	 4	0:00	0	-
-Rule	Libya	2013	max	-	Mar	lastFri	1:00	1:00	S
-Rule	Libya	2013	max	-	Oct	lastFri	2:00	0	-
+Rule	Libya	2013	only	-	Mar	lastFri	1:00	1:00	S
+Rule	Libya	2013	only	-	Oct	lastFri	2:00	0	-
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone	Africa/Tripoli	0:52:44 -	LMT	1920
 			1:00	Libya	CE%sT	1959
@@ -479,7 +561,8 @@ Zone	Africa/Tripoli	0:52:44 -	LMT	1920
 			2:00	-	EET	1996 Sep 30
 			1:00	Libya	CE%sT	1997 Oct  4
 			2:00	-	EET	2012 Nov 10 2:00
-			1:00	Libya	CE%sT
+			1:00	Libya	CE%sT	2013 Oct 25 2:00
+			2:00	-	EET
 
 # Madagascar
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
@@ -684,15 +767,6 @@ Zone	Indian/Mayotte	3:00:56 -	LMT	1911 Jul	# Mamoutzou
 # http://www.google.com/search?hl=en&q=Conseil+de+gouvernement+maroc+heure+avance&btnG=Search
 # </a>
 
-# From Alex Krivenyshev (2008-05-09):
-# Is Western Sahara (part which administrated by Morocco) going to follow
-# Morocco DST changes?  Any information?  What about other part of
-# Western Sahara - under administration of POLISARIO Front (also named
-# SADR Saharawi Arab Democratic Republic)?
-
-# From Arthur David Olson (2008-05-09):
-# XXX--guess that it is only Morocco for now; guess only 2008 for now.
-
 # From Steffen Thorsen (2008-08-27):
 # Morocco will change the clocks back on the midnight between August 31
 # and September 1. They originally planned to observe DST to near the end
@@ -858,34 +932,49 @@ Zone	Indian/Mayotte	3:00:56 -	LMT	1911 Jul	# Mamoutzou
 # transitions would be 2013-07-07 and 2013-08-10; see:
 # http://www.maroc.ma/en/news/morocco-suspends-daylight-saving-time-july-7-aug10
 
-# From Paul Eggert (2013-07-03):
-# To estimate what the Moroccan government will do in future years,
-# transition dates for 2014 through 2021 were determined by running
-# the following program under GNU Emacs 24.3:
-#
-# (let ((islamic-year 1435))
-#   (while (< islamic-year 1444)
-#     (let ((a
-#	     (calendar-gregorian-from-absolute
-#	      (calendar-islamic-to-absolute (list 9 1 islamic-year))))
-#	    (b
-#	     (calendar-gregorian-from-absolute
-#	      (calendar-islamic-to-absolute (list 10 1 islamic-year)))))
-#	(insert
-#	 (format
-#	  (concat "Rule\tMorocco\t%d\tonly\t-\t%s\t %2d\t 3:00\t0\t-\n"
-#		  "Rule\tMorocco\t%d\tonly\t-\t%s\t %2d\t 2:00\t1:00\tS\n")
-#	  (car (cdr (cdr a))) (calendar-month-name (car a) t) (car (cdr a))
-#	  (car (cdr (cdr b))) (calendar-month-name (car b) t) (car (cdr b)))))
+# From Steffen Thorsen (2013-09-28):
+# Morocco extends DST by one month, on very short notice, just 1 day
+# before it was going to end.  There is a new decree (2.13.781) for
+# this, where DST from now on goes from last Sunday of March at 02:00
+# to last Sunday of October at 03:00, similar to EU rules.  Official
+# source (French):
+# http://www.maroc.gov.ma/fr/actualites/lhoraire-dete-gmt1-maintenu-jusquau-27-octobre-2013
+# Another source (specifying the time for start and end in the decree):
+# http://www.lemag.ma/Heure-d-ete-au-Maroc-jusqu-au-27-octobre_a75620.html
+
+# From Sebastien Willemijns (2014-03-18):
+# http://www.afriquinfos.com/articles/2014/3/18/maroc-heure-dete-avancez-tous-horloges-247891.asp
+
+# From Milamber Space Network (2014-06-05):
+# The Moroccan government has recently announced that the country will return
+# to standard time at 03:00 on Saturday, June 28, 2014 local time....  DST
+# will resume again at 02:00 on Saturday, August 2, 2014....
+# http://www.mmsp.gov.ma/fr/actualites.aspx?id=586
+
+# From Paul Eggert (2014-06-05):
+# For now, guess that later spring and fall transitions will use 2014's rules,
+# and guess that Morocco will switch to standard time at 03:00 the last
+# Saturday before Ramadan, and back to DST at 02:00 the first Saturday after
+# Ramadan.  To implement this, transition dates for 2015 through 2037 were
+# determined by running the following program under GNU Emacs 24.3, with the
+# results integrated by hand into the table below.
+# (let ((islamic-year 1436))
+#   (while (< islamic-year 1460)
+#     (let ((a (calendar-islamic-to-absolute (list 9 1 islamic-year)))
+#           (b (calendar-islamic-to-absolute (list 10 1 islamic-year)))
+#           (saturday 6))
+#       (while (/= saturday (mod (setq a (1- a)) 7)))
+#       (while (/= saturday (mod b 7))
+#         (setq b (1+ b)))
+#       (setq a (calendar-gregorian-from-absolute a))
+#       (setq b (calendar-gregorian-from-absolute b))
+#       (insert
+#        (format
+#         (concat "Rule\tMorocco\t%d\tonly\t-\t%s\t%2d\t 3:00\t0\t-\n"
+#                 "Rule\tMorocco\t%d\tonly\t-\t%s\t%2d\t 2:00\t1:00\tS\n")
+#         (car (cdr (cdr a))) (calendar-month-name (car a) t) (car (cdr a))
+#         (car (cdr (cdr b))) (calendar-month-name (car b) t) (car (cdr b)))))
 #     (setq islamic-year (+ 1 islamic-year))))
-#
-# with the results hand-edited for 2020-2022, when the normal spring-forward
-# date falls during the estimated Ramadan.
-#
-# From 2023 through 2038 Ramadan is not predicted to overlap with
-# daylight saving time.  Starting in 2039 there will be overlap again,
-# but 32-bit time_t values roll around in 2038 so for now do not worry
-# about dates after 2038.
 
 # RULE	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 
@@ -907,43 +996,65 @@ Rule	Morocco	1978	only	-	Aug	 4	 0:00	0	-
 Rule	Morocco	2008	only	-	Jun	 1	 0:00	1:00	S
 Rule	Morocco	2008	only	-	Sep	 1	 0:00	0	-
 Rule	Morocco	2009	only	-	Jun	 1	 0:00	1:00	S
-Rule	Morocco	2009	only	-	Aug	 21	 0:00	0	-
+Rule	Morocco	2009	only	-	Aug	21	 0:00	0	-
 Rule	Morocco	2010	only	-	May	 2	 0:00	1:00	S
 Rule	Morocco	2010	only	-	Aug	 8	 0:00	0	-
 Rule	Morocco	2011	only	-	Apr	 3	 0:00	1:00	S
-Rule	Morocco	2011	only	-	Jul	 31	 0	0	-
-Rule	Morocco	2012	2019	-	Apr	 lastSun 2:00	1:00	S
-Rule	Morocco	2012	max	-	Sep	 lastSun 3:00	0	-
-Rule	Morocco	2012	only	-	Jul	 20	 3:00	0	-
-Rule	Morocco	2012	only	-	Aug	 20	 2:00	1:00	S
-Rule	Morocco	2013	only	-	Jul	  7	 3:00	0	-
-Rule	Morocco	2013	only	-	Aug	 10	 2:00	1:00	S
-Rule	Morocco	2014	only	-	Jun	 29	 3:00	0	-
-Rule	Morocco	2014	only	-	Jul	 29	 2:00	1:00	S
-Rule	Morocco	2015	only	-	Jun	 18	 3:00	0	-
-Rule	Morocco	2015	only	-	Jul	 18	 2:00	1:00	S
-Rule	Morocco	2016	only	-	Jun	  7	 3:00	0	-
-Rule	Morocco	2016	only	-	Jul	  7	 2:00	1:00	S
-Rule	Morocco	2017	only	-	May	 27	 3:00	0	-
-Rule	Morocco	2017	only	-	Jun	 26	 2:00	1:00	S
-Rule	Morocco	2018	only	-	May	 16	 3:00	0	-
-Rule	Morocco	2018	only	-	Jun	 15	 2:00	1:00	S
-Rule	Morocco	2019	only	-	May	  6	 3:00	0	-
-Rule	Morocco	2019	only	-	Jun	  5	 2:00	1:00	S
-Rule	Morocco	2020	only	-	May	 24	 2:00	1:00	S
-Rule	Morocco	2021	only	-	May	 13	 2:00	1:00	S
-Rule	Morocco	2022	only	-	May	  3	 2:00	1:00	S
-Rule	Morocco	2023	max	-	Apr	 lastSun 2:00	1:00	S
+Rule	Morocco	2011	only	-	Jul	31	 0	0	-
+Rule	Morocco	2012	2013	-	Apr	lastSun	 2:00	1:00	S
+Rule	Morocco	2012	only	-	Sep	30	 3:00	0	-
+Rule	Morocco	2012	only	-	Jul	20	 3:00	0	-
+Rule	Morocco	2012	only	-	Aug	20	 2:00	1:00	S
+Rule	Morocco	2013	only	-	Jul	 7	 3:00	0	-
+Rule	Morocco	2013	only	-	Aug	10	 2:00	1:00	S
+Rule	Morocco	2013	max	-	Oct	lastSun	 3:00	0	-
+Rule	Morocco	2014	2022	-	Mar	lastSun	 2:00	1:00	S
+Rule	Morocco	2014	only	-	Jun	28	 3:00	0	-
+Rule	Morocco	2014	only	-	Aug	 2	 2:00	1:00	S
+Rule	Morocco	2015	only	-	Jun	13	 3:00	0	-
+Rule	Morocco	2015	only	-	Jul	18	 2:00	1:00	S
+Rule	Morocco	2016	only	-	Jun	 4	 3:00	0	-
+Rule	Morocco	2016	only	-	Jul	 9	 2:00	1:00	S
+Rule	Morocco	2017	only	-	May	20	 3:00	0	-
+Rule	Morocco	2017	only	-	Jul	 1	 2:00	1:00	S
+Rule	Morocco	2018	only	-	May	12	 3:00	0	-
+Rule	Morocco	2018	only	-	Jun	16	 2:00	1:00	S
+Rule	Morocco	2019	only	-	May	 4	 3:00	0	-
+Rule	Morocco	2019	only	-	Jun	 8	 2:00	1:00	S
+Rule	Morocco	2020	only	-	Apr	18	 3:00	0	-
+Rule	Morocco	2020	only	-	May	30	 2:00	1:00	S
+Rule	Morocco	2021	only	-	Apr	10	 3:00	0	-
+Rule	Morocco	2021	only	-	May	15	 2:00	1:00	S
+Rule	Morocco	2022	only	-	Apr	 2	 3:00	0	-
+Rule	Morocco	2022	only	-	May	 7	 2:00	1:00	S
+Rule	Morocco	2023	only	-	Apr	22	 2:00	1:00	S
+Rule	Morocco	2024	only	-	Apr	13	 2:00	1:00	S
+Rule	Morocco	2025	only	-	Apr	 5	 2:00	1:00	S
+Rule	Morocco	2026	max	-	Mar	lastSun	 2:00	1:00	S
+Rule	Morocco	2035	only	-	Oct	27	 3:00	0	-
+Rule	Morocco	2036	only	-	Oct	18	 3:00	0	-
+Rule	Morocco	2037	only	-	Oct	10	 3:00	0	-
 
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone Africa/Casablanca	-0:30:20 -	LMT	1913 Oct 26
 			 0:00	Morocco	WE%sT	1984 Mar 16
 			 1:00	-	CET	1986
 			 0:00	Morocco	WE%sT
+
 # Western Sahara
+#
+# From Gwillim Law (2013-10-22):
+# A correspondent who is usually well informed about time zone matters
+# ... says that Western Sahara observes daylight saving time, just as
+# Morocco does.
+#
+# From Paul Eggert (2013-10-23):
+# Assume that this has been true since Western Sahara switched to GMT,
+# since most of it was then controlled by Morocco.
+
 Zone Africa/El_Aaiun	-0:52:48 -	LMT	1934 Jan
 			-1:00	-	WAT	1976 Apr 14
-			 0:00	-	WET
+			 0:00	Morocco	WE%sT
 
 # Mozambique
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
@@ -1100,9 +1211,7 @@ Zone	Africa/Khartoum	2:10:08 -	LMT	1931
 			3:00	-	EAT
 
 # South Sudan
-Zone	Africa/Juba	2:06:24 -	LMT	1931
-			2:00	Sudan	CA%sT	2000 Jan 15 12:00
-			3:00	-	EAT
+Link Africa/Khartoum Africa/Juba
 
 # Swaziland
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
diff --git a/src/main/java/org/joda/time/tz/src/antarctica b/src/main/java/org/joda/time/tz/src/antarctica
index 9bf2494ad..8f8e408d0 100644
--- a/src/main/java/org/joda/time/tz/src/antarctica
+++ b/src/main/java/org/joda/time/tz/src/antarctica
@@ -16,9 +16,9 @@
 #
 # Except for the French entries,
 # I made up all time zone abbreviations mentioned here; corrections welcome!
-# FORMAT is `zzz' and GMTOFF is 0 for locations while uninhabited.
+# FORMAT is 'zzz' and GMTOFF is 0 for locations while uninhabited.
 
-# These rules are stolen from the `southamerica' file.
+# These rules are stolen from the 'southamerica' file.
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 Rule	ArgAQ	1964	1966	-	Mar	 1	0:00	0	-
 Rule	ArgAQ	1964	1966	-	Oct	15	0:00	1:00	S
@@ -228,25 +228,43 @@ Zone Antarctica/Syowa	0	-	zzz	1957 Jan 29
 # Scott Island (never inhabited)
 #
 # year-round base
-# Scott, Ross Island, since 1957-01, is like Antarctica/McMurdo.
-#
-# These rules for New Zealand are stolen from the `australasia' file.
-# Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
-Rule	NZAQ	1974	only	-	Nov	 3	2:00s	1:00	D
-Rule	NZAQ	1975	1988	-	Oct	lastSun	2:00s	1:00	D
-Rule	NZAQ	1989	only	-	Oct	 8	2:00s	1:00	D
-Rule	NZAQ	1990	2006	-	Oct	Sun>=1	2:00s	1:00	D
-Rule	NZAQ	1975	only	-	Feb	23	2:00s	0	S
-Rule	NZAQ	1976	1989	-	Mar	Sun>=1	2:00s	0	S
-Rule	NZAQ	1990	2007	-	Mar	Sun>=15	2:00s	0	S
-Rule	NZAQ	2007	max	-	Sep	lastSun	2:00s	1:00	D
-Rule	NZAQ	2008	max	-	Apr	Sun>=1	2:00s	0	S
+# Scott Base, Ross Island, since 1957-01.
+# See Pacific/Auckland.
 
 # Norway - territories
 # Bouvet (never inhabited)
 #
 # claims
 # Peter I Island (never inhabited)
+#
+# year-round base
+# Troll, Queen Maud Land, -720041+0023206, since 2005-02-12
+#
+# From Paul-Inge Flakstad (2014-03-10):
+# I recently had a long dialog about this with the developer of timegenie.com.
+# In the absence of specific dates, he decided to choose some likely ones:
+#   GMT +1 - From March 1 to the last Sunday in March
+#   GMT +2 - From the last Sunday in March until the last Sunday in October
+#   GMT +1 - From the last Sunday in October until November 7
+#   GMT +0 - From November 7 until March 1
+# The dates for switching to and from UTC+0 will probably not be absolutely
+# correct, but they should be quite close to the actual dates.
+#
+# From Paul Eggert (2014-03-21):
+# The CET-switching Troll rules require zic from tzcode 2014b or later, so as
+# suggested by Bengt-Inge Larsson comment them out for now, and approximate
+# with only UTC and CEST.  Uncomment them when 2014b is more prevalent.
+#
+# Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
+#Rule	Troll	2005	max	-	Mar	 1	1:00u	1:00	CET
+Rule	Troll	2005	max	-	Mar	lastSun	1:00u	2:00	CEST
+#Rule	Troll	2005	max	-	Oct	lastSun	1:00u	1:00	CET
+#Rule	Troll	2004	max	-	Nov	 7	1:00u	0:00	UTC
+# Remove the following line when uncommenting the above '#Rule' lines.
+Rule	Troll	2004	max	-	Oct	lastSun	1:00u	0:00	UTC
+# Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
+Zone Antarctica/Troll	0	-	zzz	2005 Feb 12
+     			0:00	Troll	%s
 
 # Poland - year-round base
 # Arctowski, King George Island, -620945-0582745, since 1977
@@ -268,11 +286,11 @@ Rule	NZAQ	2008	max	-	Apr	Sun>=1	2:00s	0	S
 # From Lee Hotz (2001-03-08):
 # I queried the folks at Columbia who spent the summer at Vostok and this is
 # what they had to say about time there:
-# ``in the US Camp (East Camp) we have been on New Zealand (McMurdo)
+# "in the US Camp (East Camp) we have been on New Zealand (McMurdo)
 # time, which is 12 hours ahead of GMT. The Russian Station Vostok was
 # 6 hours behind that (although only 2 miles away, i.e. 6 hours ahead
 # of GMT). This is a time zone I think two hours east of Moscow. The
-# natural time zone is in between the two: 8 hours ahead of GMT.''
+# natural time zone is in between the two: 8 hours ahead of GMT."
 #
 # From Paul Eggert (2001-05-04):
 # This seems to be hopelessly confusing, so I asked Lee Hotz about it
@@ -337,16 +355,8 @@ Zone Antarctica/Palmer	0	-	zzz	1965
 			-4:00	ChileAQ	CL%sT
 #
 #
-# McMurdo, Ross Island, since 1955-12
-# Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
-Zone Antarctica/McMurdo	0	-	zzz	1956
-			12:00	NZAQ	NZ%sT
-#
-# Amundsen-Scott, South Pole, continuously occupied since 1956-11-20
-#
-# From Paul Eggert (1996-09-03):
-# Normally it wouldn't have a separate entry, since it's like the
-# larger Antarctica/McMurdo since 1970, but it's too famous to omit.
+# McMurdo Station, Ross Island, since 1955-12
+# Amundsen-Scott South Pole Station, continuously occupied since 1956-11-20
 #
 # From Chris Carrier (1996-06-27):
 # Siple, the first commander of the South Pole station,
@@ -368,4 +378,4 @@ Zone Antarctica/McMurdo	0	-	zzz	1956
 # we have to go around and set them back 5 minutes or so.
 # Maybe if we let them run fast all of the time, we'd get to leave here sooner!!
 #
-Link	Antarctica/McMurdo	Antarctica/South_Pole
+# See 'australasia' for Antarctica/McMurdo.
diff --git a/src/main/java/org/joda/time/tz/src/asia b/src/main/java/org/joda/time/tz/src/asia
index 79cfc4883..24566ca0f 100644
--- a/src/main/java/org/joda/time/tz/src/asia
+++ b/src/main/java/org/joda/time/tz/src/asia
@@ -6,7 +6,7 @@
 # go ahead and edit the file (and please send any changes to
 # tz@iana.org for general use in the future).
 
-# From Paul Eggert (2013-02-21):
+# From Paul Eggert (2013-08-11):
 #
 # A good source for time zone historical data outside the U.S. is
 # Thomas G. Shanks and Rique Pottenger, The International Atlas (6th edition),
@@ -44,11 +44,11 @@
 #	4:00 GST	Gulf*
 #	5:30 IST	India
 #	7:00 ICT	Indochina*
-#	7:00 WIT	west Indonesia
-#	8:00 CIT	central Indonesia
+#	7:00 WIB	west Indonesia (Waktu Indonesia Barat)
+#	8:00 WITA	central Indonesia (Waktu Indonesia Tengah)
 #	8:00 CST	China
 #	9:00 CJT	Central Japanese Time (1896/1937)*
-#	9:00 EIT	east Indonesia
+#	9:00 WIT	east Indonesia (Waktu Indonesia Timur)
 #	9:00 JST  JDT	Japan
 #	9:00 KST  KDT	Korea
 #	9:30 CST	(Australian) Central Standard Time
@@ -756,7 +756,7 @@ Zone	Asia/Dili	8:22:20 -	LMT	1912
 			8:00	-	TLT	1942 Feb 21 23:00 # E Timor Time
 			9:00	-	JST	1945 Sep 23
 			9:00	-	TLT	1976 May  3
-			8:00	-	CIT	2000 Sep 17 00:00
+			8:00	-	WITA	2000 Sep 17 00:00
 			9:00	-	TLT
 
 # India
@@ -793,36 +793,53 @@ Zone	Asia/Kolkata	5:53:28 -	LMT	1880	# Kolkata
 # (Hollandia).  For now, assume all Indonesian locations other than Jayapura
 # switched on 1945-09-23.
 #
+# From Paul Eggert (2013-08-11):
+# Normally the tz database uses English-language abbreviations, but in
+# Indonesia it's typical to use Indonesian-language abbreviations even
+# when writing in English.  For example, see the English-language
+# summary published by the Time and Frequency Laboratory of the
+# Research Center for Calibration, Instrumentation and Metrology,
+# Indonesia, <http://time.kim.lipi.go.id/time-eng.php> (2006-09-29).
+# The abbreviations are:
+#
+# WIB  - UTC+7 - Waktu Indonesia Barat (Indonesia western time)
+# WITA - UTC+8 - Waktu Indonesia Tengah (Indonesia central time)
+# WIT  - UTC+9 - Waktu Indonesia Timur (Indonesia eastern time)
+#
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
+# Java, Sumatra
 Zone Asia/Jakarta	7:07:12 -	LMT	1867 Aug 10
 # Shanks & Pottenger say the next transition was at 1924 Jan 1 0:13,
 # but this must be a typo.
-			7:07:12	-	JMT	1923 Dec 31 23:47:12 # Jakarta
+			7:07:12	-	BMT	1923 Dec 31 23:47:12 # Batavia
 			7:20	-	JAVT	1932 Nov	 # Java Time
-			7:30	-	WIT	1942 Mar 23
+			7:30	-	WIB	1942 Mar 23
 			9:00	-	JST	1945 Sep 23
-			7:30	-	WIT	1948 May
-			8:00	-	WIT	1950 May
-			7:30	-	WIT	1964
-			7:00	-	WIT
+			7:30	-	WIB	1948 May
+			8:00	-	WIB	1950 May
+			7:30	-	WIB	1964
+			7:00	-	WIB
+# west and central Borneo
 Zone Asia/Pontianak	7:17:20	-	LMT	1908 May
 			7:17:20	-	PMT	1932 Nov    # Pontianak MT
-			7:30	-	WIT	1942 Jan 29
+			7:30	-	WIB	1942 Jan 29
 			9:00	-	JST	1945 Sep 23
-			7:30	-	WIT	1948 May
-			8:00	-	WIT	1950 May
-			7:30	-	WIT	1964
-			8:00	-	CIT	1988 Jan  1
-			7:00	-	WIT
+			7:30	-	WIB	1948 May
+			8:00	-	WIB	1950 May
+			7:30	-	WIB	1964
+			8:00	-	WITA	1988 Jan  1
+			7:00	-	WIB
+# Sulawesi, Lesser Sundas, east and south Borneo
 Zone Asia/Makassar	7:57:36 -	LMT	1920
 			7:57:36	-	MMT	1932 Nov    # Macassar MT
-			8:00	-	CIT	1942 Feb  9
+			8:00	-	WITA	1942 Feb  9
 			9:00	-	JST	1945 Sep 23
-			8:00	-	CIT
+			8:00	-	WITA
+# Maluku Islands, West Papua, Papua
 Zone Asia/Jayapura	9:22:48 -	LMT	1932 Nov
-			9:00	-	EIT	1944 Sep  1
+			9:00	-	WIT	1944 Sep  1
 			9:30	-	CST	1964
-			9:00	-	EIT
+			9:00	-	WIT
 
 # Iran
 
@@ -1073,8 +1090,13 @@ Rule	Zion	1986	only	-	May	18	0:00	1:00	D
 Rule	Zion	1986	only	-	Sep	 7	0:00	0	S
 Rule	Zion	1987	only	-	Apr	15	0:00	1:00	D
 Rule	Zion	1987	only	-	Sep	13	0:00	0	S
-Rule	Zion	1988	only	-	Apr	 9	0:00	1:00	D
-Rule	Zion	1988	only	-	Sep	 3	0:00	0	S
+
+# From Avigdor Finkelstein (2014-03-05):
+# I check the Parliament (Knesset) records and there it's stated that the
+# [1988] transition should take place on Saturday night, when the Sabbath
+# ends and changes to Sunday.
+Rule	Zion	1988	only	-	Apr	10	0:00	1:00	D
+Rule	Zion	1988	only	-	Sep	 4	0:00	0	S
 
 # From Ephraim Silverberg
 # (1997-03-04, 1998-03-16, 1998-12-28, 2000-01-17, 2000-07-25, 2004-12-22,
@@ -1325,22 +1347,6 @@ Zone	Asia/Tokyo	9:18:59	-	LMT	1887 Dec 31 15:00u
 # "Jordan will switch to winter time on Friday, October 27".
 #
 
-# From Phil Pizzey (2009-04-02):
-# ...I think I may have spotted an error in the timezone data for
-# Jordan.
-# The current (2009d) asia file shows Jordan going to daylight
-# saving
-# time on the last Thursday in March.
-#
-# Rule  Jordan      2000  max	-  Mar   lastThu     0:00s 1:00  S
-#
-# However timeanddate.com, which I usually find reliable, shows Jordan
-# going to daylight saving time on the last Friday in March since 2002.
-# Please see
-# <a href="http://www.timeanddate.com/worldclock/timezone.html?n=11">
-# http://www.timeanddate.com/worldclock/timezone.html?n=11
-# </a>
-
 # From Steffen Thorsen (2009-04-02):
 # This single one might be good enough, (2009-03-24, Arabic):
 # <a href="http://petra.gov.jo/Artical.aspx?Lng=2&Section=8&Artical=95279">
@@ -1363,10 +1369,22 @@ Zone	Asia/Tokyo	9:18:59	-	LMT	1887 Dec 31 15:00u
 # switch back to standard time this winter, so the will stay on DST
 # until about the same time next year (at least).
 # http://www.petra.gov.jo/Public_News/Nws_NewsDetails.aspx?NewsID=88950
-#
-# From Paul Eggert (2012-10-25):
-# For now, assume this is just a one-year measure.  If it becomes
-# permanent, we should move Jordan from EET to AST effective tomorrow.
+
+# From Steffen Thorsen (2013-12-11):
+# Jordan Times and other sources say that Jordan is going back to
+# UTC+2 on 2013-12-19 at midnight:
+# http://jordantimes.com/govt-decides-to-switch-back-to-wintertime
+# Official, in Arabic:
+# http://www.petra.gov.jo/public_news/Nws_NewsDetails.aspx?Menu_ID=&Site_Id=2&lang=1&NewsID=133230&CatID=14
+# ... Our background/permalink about it
+# http://www.timeanddate.com/news/time/jordan-reverses-dst-decision.html
+# ...
+# http://www.petra.gov.jo/Public_News/Nws_NewsDetails.aspx?lang=2&site_id=1&NewsID=133313&Type=P
+# ... says midnight for the coming one and 1:00 for the ones in the future
+# (and they will use DST again next year, using the normal schedule).
+
+# From Paul Eggert (2013-12-11):
+# As Steffen suggested, consider the past 21-month experiment to be DST.
 
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 Rule	Jordan	1973	only	-	Jun	6	0:00	1:00	S
@@ -1392,12 +1410,14 @@ Rule	Jordan	1995	1998	-	Sep	Fri>=15	0:00s	0	-
 Rule	Jordan	1999	only	-	Jul	 1	0:00s	1:00	S
 Rule	Jordan	1999	2002	-	Sep	lastFri	0:00s	0	-
 Rule	Jordan	2000	2001	-	Mar	lastThu	0:00s	1:00	S
-Rule	Jordan	2002	max	-	Mar	lastThu	24:00	1:00	S
+Rule	Jordan	2002	2012	-	Mar	lastThu	24:00	1:00	S
 Rule	Jordan	2003	only	-	Oct	24	0:00s	0	-
 Rule	Jordan	2004	only	-	Oct	15	0:00s	0	-
 Rule	Jordan	2005	only	-	Sep	lastFri	0:00s	0	-
 Rule	Jordan	2006	2011	-	Oct	lastFri	0:00s	0	-
-Rule	Jordan	2013	max	-	Oct	lastFri	0:00s	0	-
+Rule	Jordan	2013	only	-	Dec	20	0:00	0	-
+Rule	Jordan	2014	max	-	Mar	lastThu	24:00	1:00	S
+Rule	Jordan	2014	max	-	Oct	lastFri	0:00s	0	-
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone	Asia/Amman	2:23:44 -	LMT	1931
 			2:00	Jordan	EE%sT
@@ -2280,9 +2300,18 @@ Zone	Asia/Karachi	4:28:12 -	LMT	1907
 # http://www.samanews.com/index.php?act=Show&id=154120
 # http://safa.ps/details/news/99844/%D8%B1%D8%A7%D9%85-%D8%A7%D9%84%D9%84%D9%87-%D8%A8%D8%AF%D8%A1-%D8%A7%D9%84%D8%AA%D9%88%D9%82%D9%8A%D8%AA-%D8%A7%D9%84%D8%B5%D9%8A%D9%81%D9%8A-29-%D8%A7%D9%84%D8%AC%D8%A7%D8%B1%D9%8A.html
 
-# From Paul Eggert (2013-04-15):
+# From Steffen Thorsen (2013-09-24):
+# The Gaza and West Bank are ending DST Thursday at midnight
+# (2013-09-27 00:00:00) (one hour earlier than last year...).
+# This source in English, says "that winter time will go into effect
+# at midnight on Thursday in the West Bank and Gaza Strip":
+# http://english.wafa.ps/index.php?action=detail&id=23246
+# official source...:
+# http://www.palestinecabinet.gov.ps/ar/Views/ViewDetails.aspx?pid=1252
+
+# From Paul Eggert (2013-09-24):
 # For future dates, guess the last Thursday in March at 24:00 through
-# the first Friday on or after September 21 at 01:00.  This is consistent with
+# the first Friday on or after September 21 at 00:00.  This is consistent with
 # the predictions in today's editions of the following URLs,
 # which are for Gaza and Hebron respectively:
 # http://www.timeanddate.com/worldclock/timezone.html?n=702
@@ -2313,7 +2342,8 @@ Rule Palestine	2011	only	-	Aug	 1	0:00	0	-
 Rule Palestine	2011	only	-	Aug	30	0:00	1:00	S
 Rule Palestine	2011	only	-	Sep	30	0:00	0	-
 Rule Palestine	2012	max	-	Mar	lastThu	24:00	1:00	S
-Rule Palestine	2012	max	-	Sep	Fri>=21	1:00	0	-
+Rule Palestine	2012	only	-	Sep	21	1:00	0	-
+Rule Palestine	2013	max	-	Sep	Fri>=21	0:00	0	-
 
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone	Asia/Gaza	2:17:52	-	LMT	1900 Oct
diff --git a/src/main/java/org/joda/time/tz/src/australasia b/src/main/java/org/joda/time/tz/src/australasia
index 797f81ce2..2a8297b01 100644
--- a/src/main/java/org/joda/time/tz/src/australasia
+++ b/src/main/java/org/joda/time/tz/src/australasia
@@ -250,24 +250,14 @@ Zone Antarctica/Macquarie 0	-	zzz	1899 Nov
 Zone Indian/Christmas	7:02:52 -	LMT	1895 Feb
 			7:00	-	CXT	# Christmas Island Time
 
-# Cook Is
-# From Shanks & Pottenger:
-# Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
-Rule	Cook	1978	only	-	Nov	12	0:00	0:30	HS
-Rule	Cook	1979	1991	-	Mar	Sun>=1	0:00	0	-
-Rule	Cook	1979	1990	-	Oct	lastSun	0:00	0:30	HS
-# Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
-Zone Pacific/Rarotonga	-10:39:04 -	LMT	1901		# Avarua
-			-10:30	-	CKT	1978 Nov 12	# Cook Is Time
-			-10:00	Cook	CK%sT
-
-# Cocos
+# Cocos (Keeling) Is
 # These islands were ruled by the Ross family from about 1830 to 1978.
 # We don't know when standard time was introduced; for now, we guess 1900.
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone	Indian/Cocos	6:27:40	-	LMT	1900
 			6:30	-	CCT	# Cocos Islands Time
 
+
 # Fiji
 
 # Milne gives 11:55:44 for Suva.
@@ -352,18 +342,30 @@ Zone	Indian/Cocos	6:27:40	-	LMT	1900
 # today confirmed that Fiji will start daylight savings at 2 am on Sunday 21st
 # October 2012 and end at 3 am on Sunday 20th January 2013.
 # http://www.fiji.gov.fj/index.php?option=com_content&view=article&id=6702&catid=71&Itemid=155
-#
-# From Paul Eggert (2012-08-31):
-# For now, guess a pattern of the penultimate Sundays in October and January.
+
+# From the Fijian Government Media Center (2013-08-30) via David Wheeler:
+# Fiji will start daylight savings on Sunday 27th October, 2013 ...
+# move clocks forward by one hour from 2am
+# http://www.fiji.gov.fj/Media-Center/Press-Releases/DAYLIGHT-SAVING-STARTS-ON-SUNDAY,-27th-OCTOBER-201.aspx
+
+# From Steffen Thorsen (2013-01-10):
+# Fiji will end DST on 2014-01-19 02:00:
+# http://www.fiji.gov.fj/Media-Center/Press-Releases/DAYLIGHT-SAVINGS-TO-END-THIS-MONTH-%281%29.aspx
+
+# From Paul Eggert (2014-01-10):
+# For now, guess that Fiji springs forward the Sunday before the fourth
+# Monday in October, and springs back the penultimate Sunday in January.
+# This is ad hoc, but matches recent practice.
 
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 Rule	Fiji	1998	1999	-	Nov	Sun>=1	2:00	1:00	S
 Rule	Fiji	1999	2000	-	Feb	lastSun	3:00	0	-
 Rule	Fiji	2009	only	-	Nov	29	2:00	1:00	S
 Rule	Fiji	2010	only	-	Mar	lastSun	3:00	0	-
-Rule	Fiji	2010	max	-	Oct	Sun>=18	2:00	1:00	S
+Rule	Fiji	2010	max	-	Oct	Sun>=21	2:00	1:00	S
 Rule	Fiji	2011	only	-	Mar	Sun>=1	3:00	0	-
-Rule	Fiji	2012	max	-	Jan	Sun>=18	3:00	0	-
+Rule	Fiji	2012	2013	-	Jan	Sun>=18	3:00	0	-
+Rule	Fiji	2014	max	-	Jan	Sun>=18	2:00	0	-
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone	Pacific/Fiji	11:55:44 -	LMT	1915 Oct 26	# Suva
 			12:00	Fiji	FJ%sT	# Fiji Time
@@ -461,7 +463,8 @@ Rule	NZ	1934	1940	-	Apr	lastSun	2:00	0	M
 Rule	NZ	1934	1940	-	Sep	lastSun	2:00	0:30	S
 Rule	NZ	1946	only	-	Jan	 1	0:00	0	S
 # Since 1957 Chatham has been 45 minutes ahead of NZ, but there's no
-# convenient notation for this so we must duplicate the Rule lines.
+# convenient single notation for the date and time of this transition
+# so we must duplicate the Rule lines.
 Rule	NZ	1974	only	-	Nov	Sun>=1	2:00s	1:00	D
 Rule	Chatham	1974	only	-	Nov	Sun>=1	2:45s	1:00	D
 Rule	NZ	1975	only	-	Feb	lastSun	2:00s	0	S
@@ -487,6 +490,7 @@ Zone Pacific/Auckland	11:39:04 -	LMT	1868 Nov  2
 Zone Pacific/Chatham	12:13:48 -	LMT	1957 Jan  1
 			12:45	Chatham	CHA%sT
 
+Link Pacific/Auckland Antarctica/McMurdo
 
 # Auckland Is
 # uninhabited; Maori and Moriori, colonial settlers, pastoralists, sealers,
@@ -498,6 +502,17 @@ Zone Pacific/Chatham	12:13:48 -	LMT	1957 Jan  1
 # previously whalers, sealers, pastoralists, and scientific personnel wintered
 # was probably like Pacific/Auckland
 
+# Cook Is
+# From Shanks & Pottenger:
+# Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
+Rule	Cook	1978	only	-	Nov	12	0:00	0:30	HS
+Rule	Cook	1979	1991	-	Mar	Sun>=1	0:00	0	-
+Rule	Cook	1979	1990	-	Oct	lastSun	0:00	0:30	HS
+# Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
+Zone Pacific/Rarotonga	-10:39:04 -	LMT	1901		# Avarua
+			-10:30	-	CKT	1978 Nov 12	# Cook Is Time
+			-10:00	Cook	CK%sT
+
 ###############################################################################
 
 
@@ -736,7 +751,7 @@ Zone Pacific/Funafuti	11:56:52 -	LMT	1901
 # 1886-1891; Baker was similar but exact dates are not known.
 # Inhabited by civilians 1935-1942; U.S. military bases 1943-1944;
 # uninhabited thereafter.
-# Howland observed Hawaii Standard Time (UTC-10:30) in 1937;
+# Howland observed Hawaii Standard Time (UT-10:30) in 1937;
 # see page 206 of Elgen M. Long and Marie K. Long,
 # Amelia Earhart: the Mystery Solved, Simon & Schuster (2000).
 # So most likely Howland and Baker observed Hawaii Time from 1935
@@ -749,8 +764,32 @@ Zone Pacific/Funafuti	11:56:52 -	LMT	1901
 # no information; was probably like Pacific/Kiritimati
 
 # Johnston
-# Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
-Zone Pacific/Johnston	-10:00	-	HST
+#
+# From Paul Eggert (2014-03-11):
+# Sometimes Johnston kept Hawaii time, and sometimes it was an hour behind.
+# Details are uncertain.  We have no data for Johnston after 1970, so
+# treat it like Hawaii for now.
+#
+# In his memoirs of June 6th to October 4, 1945
+# <http://www.315bw.org/Herb_Bach.htm> (2005), Herbert C. Bach writes,
+# "We started our letdown to Kwajalein Atoll and landed there at 5:00 AM
+# Johnston time, 1:30 AM Kwajalein time."  This was in June 1945, and
+# confirms that Johnston kept the same time as Honolulu in summer 1945.
+#
+# From Lyle McElhaney (2014-03-11):
+# [W]hen JI was being used for that [atomic bomb] testing, the time being used
+# was not Hawaiian time but rather the same time being used on the ships,
+# which had a GMT offset of -11 hours.  This apparently applied to at least the
+# time from Operation Newsreel (Hardtack I/Teak shot, 1958-08-01) to the last
+# Operation Fishbowl shot (Tightrope, 1962-11-04).... [See] Herman Hoerlin,
+# "The United States High-Altitude Test Experience: A Review Emphasizing the
+# Impact on the Environment", Los Alamos LA-6405, Oct 1976
+# <http://www.fas.org/sgp/othergov/doe/lanl/docs1/00322994.pdf>.
+# See the table on page 4 where he lists GMT and local times for the tests; a
+# footnote for the JI tests reads that local time is "JI time = Hawaii Time
+# Minus One Hour".
+#
+# See 'northamerica' for Pacific/Johnston.
 
 # Kingman
 # uninhabited
diff --git a/src/main/java/org/joda/time/tz/src/backward b/src/main/java/org/joda/time/tz/src/backward
index dc7769fb1..06fb192eb 100644
--- a/src/main/java/org/joda/time/tz/src/backward
+++ b/src/main/java/org/joda/time/tz/src/backward
@@ -22,15 +22,17 @@ Link	America/Kentucky/Louisville	America/Louisville
 Link	America/Argentina/Mendoza	America/Mendoza
 Link	America/Rio_Branco	America/Porto_Acre
 Link	America/Argentina/Cordoba	America/Rosario
-Link	America/St_Thomas	America/Virgin
+Link	America/Denver		America/Shiprock
+Link	America/Port_of_Spain	America/Virgin
+Link	Pacific/Auckland	Antarctica/South_Pole
 Link	Asia/Ashgabat		Asia/Ashkhabad
+Link	Asia/Kolkata		Asia/Calcutta
 Link	Asia/Chongqing		Asia/Chungking
 Link	Asia/Dhaka		Asia/Dacca
 Link	Asia/Kathmandu		Asia/Katmandu
-Link	Asia/Kolkata		Asia/Calcutta
 Link	Asia/Macau		Asia/Macao
-Link	Asia/Jerusalem		Asia/Tel_Aviv
 Link	Asia/Ho_Chi_Minh	Asia/Saigon
+Link	Asia/Jerusalem		Asia/Tel_Aviv
 Link	Asia/Thimphu		Asia/Thimbu
 Link	Asia/Makassar		Asia/Ujung_Pandang
 Link	Asia/Ulaanbaatar	Asia/Ulan_Bator
@@ -88,10 +90,10 @@ Link	Pacific/Auckland	NZ
 Link	Pacific/Chatham		NZ-CHAT
 Link	America/Denver		Navajo
 Link	Asia/Shanghai		PRC
+Link	Pacific/Pohnpei		Pacific/Ponape
 Link	Pacific/Pago_Pago	Pacific/Samoa
-Link	Pacific/Chuuk		Pacific/Yap
 Link	Pacific/Chuuk		Pacific/Truk
-Link	Pacific/Pohnpei		Pacific/Ponape
+Link	Pacific/Chuuk		Pacific/Yap
 Link	Europe/Warsaw		Poland
 Link	Europe/Lisbon		Portugal
 Link	Asia/Taipei		ROC
diff --git a/src/main/java/org/joda/time/tz/src/etcetera b/src/main/java/org/joda/time/tz/src/etcetera
index a9ff72938..9ba7f7bdd 100644
--- a/src/main/java/org/joda/time/tz/src/etcetera
+++ b/src/main/java/org/joda/time/tz/src/etcetera
@@ -31,9 +31,9 @@ Link	Etc/GMT				Etc/GMT0
 # even though this is the opposite of what many people expect.
 # POSIX has positive signs west of Greenwich, but many people expect
 # positive signs east of Greenwich.  For example, TZ='Etc/GMT+4' uses
-# the abbreviation "GMT+4" and corresponds to 4 hours behind UTC
+# the abbreviation "GMT+4" and corresponds to 4 hours behind UT
 # (i.e. west of Greenwich) even though many people would expect it to
-# mean 4 hours ahead of UTC (i.e. east of Greenwich).
+# mean 4 hours ahead of UT (i.e. east of Greenwich).
 #
 # In the draft 5 of POSIX 1003.1-200x, the angle bracket notation allows for
 # TZ='<GMT-4>+4'; if you want time zone abbreviations conforming to
diff --git a/src/main/java/org/joda/time/tz/src/europe b/src/main/java/org/joda/time/tz/src/europe
index 0f429da8b..7ae96ffc9 100644
--- a/src/main/java/org/joda/time/tz/src/europe
+++ b/src/main/java/org/joda/time/tz/src/europe
@@ -6,7 +6,7 @@
 # go ahead and edit the file (and please send any changes to
 # tz@iana.org for general use in the future).
 
-# From Paul Eggert (2006-03-22):
+# From Paul Eggert (2014-05-31):
 # A good source for time zone historical data outside the U.S. is
 # Thomas G. Shanks and Rique Pottenger, The International Atlas (6th edition),
 # San Diego: ACS Publications, Inc. (2003).
@@ -17,6 +17,9 @@
 # published semiannually.  Law sent in several helpful summaries
 # of the IATA's data after 1990.
 #
+# A reliable and entertaining source about time zones is
+# Derek Howse, Greenwich time and longitude, Philip Wilson Publishers (1997).
+#
 # Except where otherwise noted, Shanks & Pottenger is the source for
 # entries through 1991, and IATA SSIM is the source for entries afterwards.
 #
@@ -26,9 +29,9 @@
 #	Whitman Publishing Co, 2 Niagara Av, Ealing, London (undated),
 #	which I found in the UCLA library.
 #
-#	<a href="http://www.pettswoodvillage.co.uk/Daylight_Savings_William_Willett.pdf">
 #	William Willett, The Waste of Daylight, 19th edition
-#	</a> (1914-03)
+#	<http://cs.ucla.edu/~eggert/The-Waste-of-Daylight-19th.pdf>
+#	[PDF] (1914-03)
 #
 #	Milne J. Civil time. Geogr J. 1899 Feb;13(2):173-94
 #	<http://www.jstor.org/stable/1774359>.  He writes:
@@ -42,7 +45,7 @@
 #	</a> (1998-09-21, in Portuguese)
 
 #
-# I invented the abbreviations marked `*' in the following table;
+# I invented the abbreviations marked '*' in the following table;
 # the rest are from earlier versions of this file, or from other sources.
 # Corrections are welcome!
 #                   std dst  2dst
@@ -58,10 +61,7 @@
 #        1:00       CET CEST CEMT Central Europe
 #        1:00:14    SET           Swedish (1879-1899)*
 #        2:00       EET EEST      Eastern Europe
-#        3:00       MSK MSD       Moscow
-#
-# A reliable and entertaining source about time zones, especially in Britain,
-# Derek Howse, Greenwich time and longitude, Philip Wilson Publishers (1997).
+#        3:00       MSK MSD  MSM* Moscow
 
 # From Peter Ilieve (1994-12-04),
 # The original six [EU members]: Belgium, France, (West) Germany, Italy,
@@ -96,7 +96,7 @@
 # and a sketch map showing some of the sightlines involved. One paragraph
 # of the text said:
 #
-# `An old stone obelisk marking a forgotten terrestrial meridian stands
+# 'An old stone obelisk marking a forgotten terrestrial meridian stands
 # beside the river at Kew. In the 18th century, before time and longitude
 # was standardised by the Royal Observatory in Greenwich, scholars observed
 # this stone and the movement of stars from Kew Observatory nearby. They
@@ -140,7 +140,7 @@
 # From Paul Eggert (2003-09-27):
 # Summer Time was first seriously proposed by William Willett (1857-1915),
 # a London builder and member of the Royal Astronomical Society
-# who circulated a pamphlet ``The Waste of Daylight'' (1907)
+# who circulated a pamphlet "The Waste of Daylight" (1907)
 # that proposed advancing clocks 20 minutes on each of four Sundays in April,
 # and retarding them by the same amount on four Sundays in September.
 # A bill was drafted in 1909 and introduced in Parliament several times,
@@ -165,10 +165,10 @@
 #	</a>
 
 # From Paul Eggert (1996-09-03):
-# The OED Supplement says that the English originally said ``Daylight Saving''
+# The OED Supplement says that the English originally said "Daylight Saving"
 # when they were debating the adoption of DST in 1908; but by 1916 this
 # term appears only in quotes taken from DST's opponents, whereas the
-# proponents (who eventually won the argument) are quoted as using ``Summer''.
+# proponents (who eventually won the argument) are quoted as using "Summer".
 
 # From Arthur David Olson (1989-01-19):
 #
@@ -208,9 +208,9 @@
 # which could not be said to run counter to any official description.
 
 # From Paul Eggert (2000-10-02):
-# Howse writes (p 157) `DBST' too, but `BDST' seems to have been common
+# Howse writes (p 157) 'DBST' too, but 'BDST' seems to have been common
 # and follows the more usual convention of putting the location name first,
-# so we use `BDST'.
+# so we use 'BDST'.
 
 # Peter Ilieve (1998-04-19) described at length
 # the history of summer time legislation in the United Kingdom.
@@ -431,6 +431,8 @@ Rule	GB-Eire 1981	1989	-	Oct	Sun>=23	1:00u	0	GMT
 Rule	GB-Eire 1990	1995	-	Oct	Sun>=22	1:00u	0	GMT
 # Summer Time Order 1997 (S.I. 1997/2982)
 # See EU for rules starting in 1996.
+#
+# Use Europe/London for Jersey, Guernsey, and the Isle of Man.
 
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone	Europe/London	-0:01:15 -	LMT	1847 Dec  1 0:00s
@@ -556,11 +558,11 @@ Rule	Russia	1917	only	-	Dec	28	 0:00	0	MMT	# Moscow Mean Time
 Rule	Russia	1918	only	-	May	31	22:00	2:00	MDST	# Moscow Double Summer Time
 Rule	Russia	1918	only	-	Sep	16	 1:00	1:00	MST
 Rule	Russia	1919	only	-	May	31	23:00	2:00	MDST
-Rule	Russia	1919	only	-	Jul	 1	 2:00	1:00	S
-Rule	Russia	1919	only	-	Aug	16	 0:00	0	-
-Rule	Russia	1921	only	-	Feb	14	23:00	1:00	S
-Rule	Russia	1921	only	-	Mar	20	23:00	2:00	M # Midsummer
-Rule	Russia	1921	only	-	Sep	 1	 0:00	1:00	S
+Rule	Russia	1919	only	-	Jul	 1	 2:00	1:00	MSD
+Rule	Russia	1919	only	-	Aug	16	 0:00	0	MSK
+Rule	Russia	1921	only	-	Feb	14	23:00	1:00	MSD
+Rule	Russia	1921	only	-	Mar	20	23:00	2:00	MSM # Midsummer
+Rule	Russia	1921	only	-	Sep	 1	 0:00	1:00	MSD
 Rule	Russia	1921	only	-	Oct	 1	 0:00	0	-
 # Act No.925 of the Council of Ministers of the USSR (1980-10-24):
 Rule	Russia	1981	1984	-	Apr	 1	 0:00	1:00	S
@@ -797,7 +799,7 @@ Zone	Europe/Brussels	0:17:30 -	LMT	1880
 			1:00	EU	CE%sT
 
 # Bosnia and Herzegovina
-# see Serbia
+# See Europe/Belgrade.
 
 # Bulgaria
 #
@@ -825,10 +827,10 @@ Zone	Europe/Sofia	1:33:16 -	LMT	1880
 			2:00	EU	EE%sT
 
 # Croatia
-# see Serbia
+# See Europe/Belgrade.
 
 # Cyprus
-# Please see the `asia' file for Asia/Nicosia.
+# Please see the 'asia' file for Asia/Nicosia.
 
 # Czech Republic
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
@@ -845,6 +847,7 @@ Zone	Europe/Prague	0:57:44 -	LMT	1850
 			1:00	C-Eur	CE%sT	1944 Sep 17 2:00s
 			1:00	Czech	CE%sT	1979
 			1:00	EU	CE%sT
+# Use Europe/Prague also for Slovakia.
 
 # Denmark, Faroe Islands, and Greenland
 
@@ -1008,12 +1011,12 @@ Zone America/Thule	-4:35:08 -	LMT	1916 Jul 28 # Pituffik air base
 # From Peter Ilieve (1996-10-28):
 # [IATA SSIM (1992/1996) claims that the Baltic republics switch at 01:00s,
 # but a relative confirms that Estonia still switches at 02:00s, writing:]
-# ``I do not [know] exactly but there are some little different
+# "I do not [know] exactly but there are some little different
 # (confusing) rules for International Air and Railway Transport Schedules
 # conversion in Sunday connected with end of summer time in Estonia....
 # A discussion is running about the summer time efficiency and effect on
 # human physiology.  It seems that Estonia maybe will not change to
-# summer time next spring.''
+# summer time next spring."
 
 # From Peter Ilieve (1998-11-04), heavily edited:
 # <a href="http://trip.rk.ee/cgi-bin/thw?${BASE}=akt&${OOHTML}=rtd&TA=1998&TO=1&AN=1390">
@@ -1068,7 +1071,7 @@ Zone	Europe/Tallinn	1:39:00	-	LMT	1880
 # Well, here in Helsinki we're just changing from summer time to regular one,
 # and it's supposed to change at 4am...
 
-# From Janne Snabb (2010-0715):
+# From Janne Snabb (2010-07-15):
 #
 # I noticed that the Finland data is not accurate for years 1981 and 1982.
 # During these two first trial years the DST adjustment was made one hour
@@ -1125,7 +1128,7 @@ Link	Europe/Helsinki	Europe/Mariehamn
 
 
 #
-# Shank & Pottenger seem to use `24:00' ambiguously; resolve it with Whitman.
+# Shank & Pottenger seem to use '24:00' ambiguously; resolve it with Whitman.
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 Rule	France	1916	only	-	Jun	14	23:00s	1:00	S
 Rule	France	1916	1919	-	Oct	Sun>=1	23:00s	0	-
@@ -1415,7 +1418,7 @@ Zone Atlantic/Reykjavik	-1:27:24 -	LMT	1837
 # <a href="http://toi.iriti.cnr.it/uk/ienitlt.html">
 # Day-light Saving Time in Italy (2006-02-03)
 # </a>
-# (`FP' below), taken from an Italian National Electrotechnical Institute
+# ('FP' below), taken from an Italian National Electrotechnical Institute
 # publication. When the three sources disagree, guess who's right, as follows:
 #
 # year	FP	Shanks&P. (S)	Whitman (W)	Go with:
@@ -1561,10 +1564,22 @@ Zone	Europe/Riga	1:36:24	-	LMT	1880
 			2:00	EU	EE%sT
 
 # Liechtenstein
-# Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
-Zone	Europe/Vaduz	0:38:04 -	LMT	1894 Jun
-			1:00	-	CET	1981
-			1:00	EU	CE%sT
+
+# From Paul Eggert (2013-09-09):
+# Shanks & Pottenger say Vaduz is like Zurich.
+
+# From Alois Treindl (2013-09-18):
+# http://www.eliechtensteinensia.li/LIJ/1978/1938-1978/1941.pdf
+# ... confirms on p. 6 that Liechtenstein followed Switzerland in 1941 and 1942.
+# I ... translate only the last two paragraphs:
+#    ... during second world war, in the years 1941 and 1942, Liechtenstein
+#    introduced daylight saving time, adapting to Switzerland.  From 1943 on
+#    central European time was in force throughout the year.
+#    From a report of the duke's government to the high council,
+#    regarding the introduction of a time law, of 31 May 1977.
+
+Link Europe/Zurich Europe/Vaduz
+
 
 # Lithuania
 
@@ -1652,7 +1667,7 @@ Zone Europe/Luxembourg	0:24:36 -	LMT	1904 Jun
 			1:00	EU	CE%sT
 
 # Macedonia
-# see Serbia
+# See Europe/Belgrade.
 
 # Malta
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
@@ -1745,7 +1760,7 @@ Zone	Europe/Monaco	0:29:32 -	LMT	1891 Mar 15
 			1:00	EU	CE%sT
 
 # Montenegro
-# see Serbia
+# See Europe/Belgrade.
 
 # Netherlands
 
@@ -1860,7 +1875,7 @@ Zone	Europe/Oslo	0:43:00 -	LMT	1895 Jan  1
 # before 1895, and therefore probably changed the local time somewhere
 # between 1895 and 1925 (inclusive).
 
-# From Paul Eggert (2001-05-01):
+# From Paul Eggert (2013-09-04):
 #
 # Actually, Jan Mayen was never occupied by Germany during World War II,
 # so it must have diverged from Oslo time during the war, as Oslo was
@@ -1871,7 +1886,7 @@ Zone	Europe/Oslo	0:43:00 -	LMT	1895 Jan  1
 # 1941 with a small Norwegian garrison and continued operations despite
 # frequent air ttacks from Germans.  In 1943 the Americans established a
 # radiolocating station on the island, called "Atlantic City".  Possibly
-# the UTC offset changed during the war, but I think it unlikely that
+# the UT offset changed during the war, but I think it unlikely that
 # Jan Mayen used German daylight-saving rules.
 #
 # Svalbard is more complicated, as it was raided in August 1941 by an
@@ -1884,9 +1899,8 @@ Zone	Europe/Oslo	0:43:00 -	LMT	1895 Jan  1
 # the German armed forces at the Svalbard weather station code-named
 # Haudegen did not surrender to the Allies until September 1945.
 #
-# All these events predate our cutoff date of 1970.  Unless we can
-# come up with more definitive info about the timekeeping during the
-# war years it's probably best just do...the following for now:
+# All these events predate our cutoff date of 1970, so use Europe/Oslo
+# for these regions.
 Link	Europe/Oslo	Arctic/Longyearbyen
 
 # Poland
@@ -2144,7 +2158,7 @@ Zone Europe/Bucharest	1:44:24 -	LMT	1891 Oct
 # so we (Novosibirsk) simply did not switch.
 #
 # From Andrey A. Chernov (1996-10-04):
-# `MSK' and `MSD' were born and used initially on Moscow computers with
+# 'MSK' and 'MSD' were born and used initially on Moscow computers with
 # UNIX-like OSes by several developer groups (e.g. Demos group, Kiae group)....
 # The next step was the UUCP network, the Relcom predecessor
 # (used mainly for mail), and MSK/MSD was actively used there.
@@ -2203,6 +2217,7 @@ Zone Europe/Kaliningrad	 1:22:00 -	LMT	1893 Apr
 Zone Europe/Moscow	 2:30:20 -	LMT	1880
 			 2:30	-	MMT	1916 Jul  3 # Moscow Mean Time
 			 2:30:48 Russia	%s	1919 Jul  1 2:00
+			 3:00	Russia	%s	1921 Oct
 			 3:00	Russia	MSK/MSD	1922 Oct
 			 2:00	-	EET	1930 Jun 21
 			 3:00	Russia	MSK/MSD	1991 Mar 31 2:00s
@@ -2361,7 +2376,7 @@ Zone Asia/Yakutsk	 8:38:40 -	LMT	1919 Dec 15
 Zone Asia/Vladivostok	 8:47:44 -	LMT	1922 Nov 15
 			 9:00	-	VLAT	1930 Jun 21 # Vladivostok Time
 			10:00	Russia	VLA%sT	1991 Mar 31 2:00s
-			 9:00	Russia	VLA%sST	1992 Jan 19 2:00s
+			 9:00	Russia	VLA%sT	1992 Jan 19 2:00s
 			10:00	Russia	VLA%sT	2011 Mar 27 2:00s
 			11:00	-	VLAT
 
@@ -2443,6 +2458,9 @@ Zone Asia/Anadyr	11:49:56 -	LMT	1924 May  2
 			11:00	Russia	ANA%sT	2011 Mar 27 2:00s
 			12:00	-	ANAT
 
+# San Marino
+# See Europe/Rome.
+
 # Serbia
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone	Europe/Belgrade	1:22:00	-	LMT	1884
@@ -2465,7 +2483,7 @@ Link Europe/Belgrade Europe/Zagreb	# Croatia
 Link Europe/Prague Europe/Bratislava
 
 # Slovenia
-# see Serbia
+# See Europe/Belgrade.
 
 # Spain
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
@@ -2599,7 +2617,7 @@ Zone Europe/Stockholm	1:12:12 -	LMT	1879 Jan  1
 # and their performance improved enormously.  Communities began to keep
 # mean time in preference to apparent time -- Geneva from 1780 ....
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
-# From Whitman (who writes ``Midnight?''):
+# From Whitman (who writes "Midnight?"):
 # Rule	Swiss	1940	only	-	Nov	 2	0:00	1:00	S
 # Rule	Swiss	1940	only	-	Dec	31	0:00	0	-
 # From Shanks & Pottenger:
@@ -2644,23 +2662,53 @@ Zone Europe/Stockholm	1:12:12 -	LMT	1879 Jan  1
 # The 1940 rules must be deleted.
 #
 # One further detail for Switzerland, which is probably out of scope for
-# most users of tzdata:
-# The zone file
-# Zone    Europe/Zurich   0:34:08 -       LMT     1848 Sep 12
-#                          0:29:44 -       BMT     1894 Jun #Bern Mean Time
-#                          1:00    Swiss   CE%sT   1981
-#                          1:00    EU      CE%sT
+# most users of tzdata: The [Europe/Zurich zone] ...
 # describes all of Switzerland correctly, with the exception of
 # the Cantone Geneve (Geneva, Genf). Between 1848 and 1894 Geneve did not
 # follow Bern Mean Time but kept its own local mean time.
 # To represent this, an extra zone would be needed.
+#
+# From Alois Treindl (2013-09-11):
+# The Federal regulations say
+# http://www.admin.ch/opc/de/classified-compilation/20071096/index.html
+# ... the meridian for Bern mean time ... is 7 degrees 26'22.50".
+# Expressed in time, it is 0h29m45.5s.
+
+# From Pierre-Yves Berger (2013-09-11):
+# the "Circulaire du conseil federal" (December 11 1893)
+# <http://www.amtsdruckschriften.bar.admin.ch/viewOrigDoc.do?id=10071353> ...
+# clearly states that the [1894-06-01] change should be done at midnight
+# but if no one is present after 11 at night, could be postponed until one
+# hour before the beginning of service.
+
+# From Paul Eggert (2013-09-11):
+# Round BMT to the nearest even second, 0:29:46.
+#
+# We can find no reliable source for Shanks's assertion that all of Switzerland
+# except Geneva switched to Bern Mean Time at 00:00 on 1848-09-12.  This book:
+#
+#	Jakob Messerli. Gleichmassig, punktlich, schnell: Zeiteinteilung und
+#	Zeitgebrauch in der Schweiz im 19. Jahrhundert. Chronos, Zurich 1995,
+#	ISBN 3-905311-68-2, OCLC 717570797.
+#
+# suggests that the transition was more gradual, and that the Swiss did not
+# agree about civil time during the transition.  The timekeeping it gives the
+# most detail for is postal and telegraph time: here, federal legislation (the
+# "Bundesgesetz uber die Erstellung von elektrischen Telegraphen") passed on
+# 1851-11-23, and an official implementation notice was published 1853-07-16
+# (Bundesblatt 1853, Bd. II, S. 859).  On p 72 Messerli writes that in
+# practice since July 1853 Bernese time was used in "all postal and telegraph
+# offices in Switzerland from Geneva to St. Gallen and Basel to Chiasso"
+# (Google translation).  For now, model this transition as occurring on
+# 1853-07-16, though it probably occurred at some other date in Zurich, and
+# legal civil time probably changed at still some other transition date.
 
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 Rule	Swiss	1941	1942	-	May	Mon>=1	1:00	1:00	S
 Rule	Swiss	1941	1942	-	Oct	Mon>=1	2:00	0	-
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
-Zone	Europe/Zurich	0:34:08 -	LMT	1848 Sep 12
-			0:29:44	-	BMT	1894 Jun # Bern Mean Time
+Zone	Europe/Zurich	0:34:08 -	LMT	1853 Jul 16 # See above comment.
+			0:29:46	-	BMT	1894 Jun # Bern Mean Time
 			1:00	Swiss	CE%sT	1981
 			1:00	EU	CE%sT
 
@@ -2698,14 +2746,18 @@ Zone	Europe/Zurich	0:34:08 -	LMT	1848 Sep 12
 # According to the articles linked below, Turkey will change into summer
 # time zone (GMT+3) on March 28, 2011 at 3:00 a.m. instead of March 27.
 # This change is due to a nationwide exam on 27th.
-#
-# <a href="http://www.worldbulletin.net/?aType=haber&ArticleID=70872">
 # http://www.worldbulletin.net/?aType=haber&ArticleID=70872
-# </a>
 # Turkish:
-# <a href="http://www.hurriyet.com.tr/ekonomi/17230464.asp?gid=373">
 # http://www.hurriyet.com.tr/ekonomi/17230464.asp?gid=373
-# </a>
+
+# From Faruk Pasin (2014-02-14):
+# The DST for Turkey has been changed for this year because of the
+# Turkish Local election....
+# http://www.sabah.com.tr/Ekonomi/2014/02/12/yaz-saatinde-onemli-degisiklik
+# ... so Turkey will move clocks forward one hour on March 31 at 3:00 a.m.
+# From Paul Eggert (2014-02-17):
+# Here is an English-language source:
+# http://www.worldbulletin.net/turkey/129016/turkey-switches-to-daylight-saving-time-march-31
 
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 Rule	Turkey	1916	only	-	May	 1	0:00	1:00	S
@@ -2774,6 +2826,8 @@ Zone	Europe/Istanbul	1:55:52 -	LMT	1880
 			2:00	Turkey	EE%sT	2007
 			2:00	EU	EE%sT	2011 Mar 27 1:00u
 			2:00	-	EET	2011 Mar 28 1:00u
+			2:00	EU	EE%sT	2014 Mar 30 1:00u
+			2:00	-	EET	2014 Mar 31 1:00u
 			2:00	EU	EE%sT
 Link	Europe/Istanbul	Asia/Istanbul	# Istanbul is in both continents.
 
@@ -2795,19 +2849,13 @@ Link	Europe/Istanbul	Asia/Istanbul	# Istanbul is in both continents.
 # approval from 266 deputies.
 #
 # Ukraine abolishes transter back to the winter time (in Russian)
-# <a href="http://news.mail.ru/politics/6861560/">
 # http://news.mail.ru/politics/6861560/
-# </a>
 #
 # The Ukrainians will no longer change the clock (in Russian)
-# <a href="http://www.segodnya.ua/news/14290482.html">
 # http://www.segodnya.ua/news/14290482.html
-# </a>
 #
 # Deputies cancelled the winter time (in Russian)
-# <a href="http://www.pravda.com.ua/rus/news/2011/09/20/6600616/">
 # http://www.pravda.com.ua/rus/news/2011/09/20/6600616/
-# </a>
 #
 # From Philip Pizzey (2011-10-18):
 # Today my Ukrainian colleagues have informed me that the
@@ -2818,18 +2866,39 @@ Link	Europe/Istanbul	Asia/Istanbul	# Istanbul is in both continents.
 # As far as I understand, the recent change to the Ukrainian time zone
 # (Europe/Kiev) to introduce permanent daylight saving time (similar
 # to Russia) was reverted today:
-#
-# <a href="http://portal.rada.gov.ua/rada/control/en/publish/article/info_left?art_id=287324&cat_id=105995">
 # http://portal.rada.gov.ua/rada/control/en/publish/article/info_left?art_id=287324&cat_id=105995
-# </a>
 #
 # Also reported by Alexander Bokovoy (2011-10-18) who also noted:
 # The law documents themselves are at
-#
-# <a href="http://w1.c1.rada.gov.ua/pls/zweb_n/webproc4_1?id=&pf3511=41484">
 # http://w1.c1.rada.gov.ua/pls/zweb_n/webproc4_1?id=&pf3511=41484
-# </a>
 
+# From Vladimir in Moscow via Alois Treindl re Kiev time 1991/2 (2014-02-28):
+# First in Ukraine they changed Time zone from UTC+3 to UTC+2 with DST:
+#       03 25 1990 02:00 -03.00 1       Time Zone 3 with DST
+#       07 01 1990 02:00 -02.00 1       Time Zone 2 with DST
+# * Ukrainian Government's Resolution of 18.06.1990, No. 134.
+# http://search.ligazakon.ua/l_doc2.nsf/link1/T001500.html
+#
+# They did not end DST in September, 1990 (according to the law,
+# "summer time" was still in action):
+#       09 30 1990 03:00 -02.00 1       Time Zone 2 with DST
+# * Ukrainian Government's Resolution of 21.09.1990, No. 272.
+# http://search.ligazakon.ua/l_doc2.nsf/link1/KP900272.html
+#
+# Again no change in March, 1991 ("summer time" in action):
+#       03 31 1991 02:00 -02.00 1       Time Zone 2 with DST
+#
+# DST ended in September 1991 ("summer time" ended):
+#       09 29 1991 03:00 -02.00 0       Time Zone 2, no DST
+# * Ukrainian Government's Resolution of 25.09.1991, No. 225.
+# http://www.uazakon.com/documents/date_21/pg_iwgdoc.htm
+# This is an answer.
+#
+# Since 1992 they had normal DST procedure:
+#       03 29 1992 02:00 -02.00 1       DST started
+#       09 27 1992 03:00 -02.00 0       DST ended
+# * Ukrainian Government's Resolution of 20.03.1992, No. 139.
+# http://www.uazakon.com/documents/date_8u/pg_grcasa.htm
 
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 # Most of Ukraine since 1970 has been like Kiev.
@@ -2840,9 +2909,8 @@ Zone Europe/Kiev	2:02:04 -	LMT	1880
 			2:00	-	EET	1930 Jun 21
 			3:00	-	MSK	1941 Sep 20
 			1:00	C-Eur	CE%sT	1943 Nov  6
-			3:00	Russia	MSK/MSD	1990
-			3:00	-	MSK	1990 Jul  1 2:00
-			2:00	-	EET	1992
+			3:00	Russia	MSK/MSD	1990 Jul  1 2:00
+			2:00	1:00	EEST	1991 Sep 29 3:00
 			2:00	E-Eur	EE%sT	1995
 			2:00	EU	EE%sT
 # Ruthenia used CET 1990/1991.
@@ -2884,7 +2952,7 @@ Zone Europe/Simferopol	2:16:24 -	LMT	1880
 # From Paul Eggert (2006-03-22):
 # The _Economist_ (1994-05-28, p 45) reports that central Crimea switched
 # from Kiev to Moscow time sometime after the January 1994 elections.
-# Shanks (1999) says ``date of change uncertain'', but implies that it happened
+# Shanks (1999) says "date of change uncertain", but implies that it happened
 # sometime between the 1994 DST switches.  Shanks & Pottenger simply say
 # 1994-09-25 03:00, but that can't be right.  For now, guess it
 # changed in May.
@@ -2896,7 +2964,18 @@ Zone Europe/Simferopol	2:16:24 -	LMT	1880
 # Assume it happened in March by not changing the clocks.
 			3:00	Russia	MSK/MSD	1997
 			3:00	-	MSK	1997 Mar lastSun 1:00u
-			2:00	EU	EE%sT
+# From Alexander Krivenyshev (2014-03-17):
+# time change at 2:00 (2am) on March 30, 2014
+# http://vz.ru/news/2014/3/17/677464.html
+# From Paul Eggert (2014-03-30):
+# Simferopol and Sevastopol reportedly changed their central town clocks
+# late the previous day, but this appears to have been ceremonial
+# and the discrepancies are small enough to not worry about.
+			2:00	EU	EE%sT	2014 Mar 30 2:00
+			4:00	-	MSK
+
+# Vatican City
+# See Europe/Rome.
 
 ###############################################################################
 
diff --git a/src/main/java/org/joda/time/tz/src/northamerica b/src/main/java/org/joda/time/tz/src/northamerica
index 1964903eb..9660a46d2 100644
--- a/src/main/java/org/joda/time/tz/src/northamerica
+++ b/src/main/java/org/joda/time/tz/src/northamerica
@@ -20,7 +20,7 @@
 # Howse writes (pp 121-125) that time zones were invented by
 # Professor Charles Ferdinand Dowd (1825-1904),
 # Principal of Temple Grove Ladies' Seminary (Saratoga Springs, NY).
-# His pamphlet ``A System of National Time for Railroads'' (1870)
+# His pamphlet "A System of National Time for Railroads" (1870)
 # was the result of his proposals at the Convention of Railroad Trunk Lines
 # in New York City (1869-10).  His 1870 proposal was based on Washington, DC,
 # but in 1872-05 he moved the proposed origin to Greenwich.
@@ -40,8 +40,8 @@
 
 # From Paul Eggert (2001-03-06):
 # Daylight Saving Time was first suggested as a joke by Benjamin Franklin
-# in his whimsical essay ``An Economical Project for Diminishing the Cost
-# of Light'' published in the Journal de Paris (1784-04-26).
+# in his whimsical essay "An Economical Project for Diminishing the Cost
+# of Light" published in the Journal de Paris (1784-04-26).
 # Not everyone is happy with the results:
 #
 #	I don't really care how time is reckoned so long as there is some
@@ -167,8 +167,8 @@ Zone	PST8PDT		 -8:00	US	P%sT
 #    of the Aleutian islands.   No DST.
 
 # From Paul Eggert (1995-12-19):
-# The tables below use `NST', not `NT', for Nome Standard Time.
-# I invented `CAWT' for Central Alaska War Time.
+# The tables below use 'NST', not 'NT', for Nome Standard Time.
+# I invented 'CAWT' for Central Alaska War Time.
 
 # From U. S. Naval Observatory (1989-01-19):
 # USA  EASTERN       5 H  BEHIND UTC    NEW YORK, WASHINGTON
@@ -237,9 +237,9 @@ Zone	PST8PDT		 -8:00	US	P%sT
 # H.R. 6, Energy Policy Act of 2005, SEC. 110. DAYLIGHT SAVINGS.
 #   (a) Amendment- Section 3(a) of the Uniform Time Act of 1966 (15
 #   U.S.C. 260a(a)) is amended--
-#     (1) by striking `first Sunday of April' and inserting `second
+#     (1) by striking 'first Sunday of April' and inserting 'second
 #     Sunday of March'; and
-#     (2) by striking `last Sunday of October' and inserting `first
+#     (2) by striking 'last Sunday of October' and inserting 'first
 #     Sunday of November'.
 #   (b) Effective Date- Subsection (a) shall take effect 1 year after the
 #   date of enactment of this Act or March 1, 2007, whichever is later.
@@ -391,9 +391,10 @@ Zone America/Denver	-6:59:56 -	LMT	1883 Nov 18 12:00:04
 # US Pacific time, represented by Los Angeles
 #
 # California, northern Idaho (Benewah, Bonner, Boundary, Clearwater,
-# Idaho, Kootenai, Latah, Lewis, Nez Perce, and Shoshone counties,
-# and the northern three-quarters of Idaho county),
-# most of Nevada, most of Oregon, and Washington
+# Kootenai, Latah, Lewis, Nez Perce, and Shoshone counties, Idaho county
+# north of the Salmon River, and the towns of Burgdorf and Warren),
+# Nevada (except West Wendover), Oregon (except the northern 3/4 of
+# Malheur county), and Washington
 #
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER
 Rule	CA	1948	only	-	Mar	14	2:00	1:00	D
@@ -600,6 +601,8 @@ Zone Pacific/Honolulu	-10:31:26 -	LMT	1896 Jan 13 12:00 #Schmitt&Cox
 			-10:30	-	HST	1947 Jun  8 2:00 #Schmitt&Cox+2
 			-10:00	-	HST
 
+Link Pacific/Honolulu Pacific/Johnston
+
 # Now we turn to US areas that have diverged from the consensus since 1970.
 
 # Arizona mostly uses MST.
@@ -636,8 +639,9 @@ Zone America/Phoenix	-7:28:18 -	LMT	1883 Nov 18 11:31:42
 # Navajo Nation participates in the Daylight Saving Time policy, due to its
 # large size and location in three states."  (The "only" means that other
 # tribal nations don't use DST.)
-
-Link America/Denver America/Shiprock
+#
+# From Paul Eggert (2013-08-26):
+# See America/Denver for a zone appropriate for the Navajo Nation.
 
 # Southern Idaho (Ada, Adams, Bannock, Bear Lake, Bingham, Blaine,
 # Boise, Bonneville, Butte, Camas, Canyon, Caribou, Cassia, Clark,
@@ -677,13 +681,13 @@ Zone America/Boise	-7:44:49 -	LMT	1883 Nov 18 12:15:11
 #   and Switzerland counties have their own time zone histories as noted below.
 #
 # Shanks partitioned Indiana into 345 regions, each with its own time history,
-# and wrote ``Even newspaper reports present contradictory information.''
+# and wrote "Even newspaper reports present contradictory information."
 # Those Hoosiers!  Such a flighty and changeable people!
 # Fortunately, most of the complexity occurred before our cutoff date of 1970.
 #
 # Other than Indianapolis, the Indiana place names are so nondescript
-# that they would be ambiguous if we left them at the `America' level.
-# So we reluctantly put them all in a subdirectory `America/Indiana'.
+# that they would be ambiguous if we left them at the 'America' level.
+# So we reluctantly put them all in a subdirectory 'America/Indiana'.
 
 # From Paul Eggert (2005-08-16):
 # http://www.mccsc.edu/time.html says that Indiana will use DST starting 2006.
@@ -947,8 +951,8 @@ Zone America/Kentucky/Monticello -5:39:24 - LMT	1883 Nov 18 12:20:36
 # This story is too entertaining to be false, so go with Howse over Shanks.
 #
 # From Paul Eggert (2001-03-06):
-# Garland (1927) writes ``Cleveland and Detroit advanced their clocks
-# one hour in 1914.''  This change is not in Shanks.  We have no more
+# Garland (1927) writes "Cleveland and Detroit advanced their clocks
+# one hour in 1914."  This change is not in Shanks.  We have no more
 # info, so omit this for now.
 #
 # Most of Michigan observed DST from 1973 on, but was a bit late in 1975.
@@ -988,7 +992,7 @@ Zone America/Menominee	-5:50:27 -	LMT	1885 Sep 18 12:00
 # occupied 1857/1900 by the Navassa Phosphate Co
 # US lighthouse 1917/1996-09
 # currently uninhabited
-# see Mark Fineman, ``An Isle Rich in Guano and Discord'',
+# see Mark Fineman, "An Isle Rich in Guano and Discord",
 # _Los Angeles Times_ (1998-11-10), A1, A10; it cites
 # Jimmy Skaggs, _The Great Guano Rush_ (1994).
 
@@ -1015,14 +1019,14 @@ Zone America/Menominee	-5:50:27 -	LMT	1885 Sep 18 12:00
 #	Whitman Publishing Co, 2 Niagara Av, Ealing, London (undated),
 #	which I found in the UCLA library.
 #
-#	<a href="http://www.pettswoodvillage.co.uk/Daylight_Savings_William_Willett.pdf">
 #	William Willett, The Waste of Daylight, 19th edition
-#	</a> (1914-03)
+#	<http://cs.ucla.edu/~eggert/The-Waste-of-Daylight-19th.pdf>
+#	[PDF] (1914-03)
 #
 #	Milne J. Civil time. Geogr J. 1899 Feb;13(2):173-94
 #	<http://www.jstor.org/stable/1774359>.
 #
-# See the `europe' file for Greenland.
+# See the 'europe' file for Greenland.
 
 # Canada
 
@@ -1223,7 +1227,7 @@ Zone America/St_Johns	-3:30:52 -	LMT	1884
 
 # most of east Labrador
 
-# The name `Happy Valley-Goose Bay' is too long; use `Goose Bay'.
+# The name 'Happy Valley-Goose Bay' is too long; use 'Goose Bay'.
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone America/Goose_Bay	-4:01:40 -	LMT	1884 # Happy Valley-Goose Bay
 			-3:30:52 -	NST	1918
@@ -1340,25 +1344,27 @@ Zone America/Moncton	-4:19:08 -	LMT	1883 Dec  9
 
 # Quebec
 
-# From Paul Eggert (2006-07-09):
-# Shanks & Pottenger write that since 1970 most of Quebec has been
-# like Montreal.
+# From Paul Eggert (2013-08-30):
+# Since 1970 most of Quebec has been like Toronto.
+# However, because earlier versions of the tz database mistakenly relied on data
+# from Shanks & Pottenger saying that Quebec differed from Ontario after 1970,
+# a separate entry was created for most of Quebec.  We're loath to lose
+# its pre-1970 info, even though the tz database is normally limited to
+# zones that differ after 1970, so keep this otherwise out-of-scope entry.
 
-# From Paul Eggert (2006-06-27):
 # Matthews and Vincent (1998) also write that Quebec east of the -63
 # meridian is supposed to observe AST, but residents as far east as
 # Natashquan use EST/EDT, and residents east of Natashquan use AST.
-# In "Official time in Quebec" the Quebec department of justice writes in
-# http://www.justice.gouv.qc.ca/english/publications/generale/temps-regl-1-a.htm
-# that "The residents of the Municipality of the
-# Cote-Nord-du-Golfe-Saint-Laurent and the municipalities of Saint-Augustin,
-# Bonne-Esperance and Blanc-Sablon apply the Official Time Act as it is
-# written and use Atlantic standard time all year round. The same applies to
-# the residents of the Native facilities along the lower North Shore."
-# <http://www.assnat.qc.ca/eng/37legislature2/Projets-loi/Publics/06-a002.htm>
+# The Quebec department of justice writes in
+# "The situation in Minganie and Basse-Cote-Nord"
+# http://www.justice.gouv.qc.ca/english/publications/generale/temps-minganie-a.htm
+# that the coastal strip from just east of Natashquan to Blanc-Sablon
+# observes Atlantic standard time all year round.
+# http://www.assnat.qc.ca/Media/Process.aspx?MediaId=ANQ.Vigie.Bll.DocumentGenerique_8845en
 # says this common practice was codified into law as of 2007.
 # For lack of better info, guess this practice began around 1970, contra to
 # Shanks & Pottenger who have this region observing AST/ADT.
+# for post-1970 data America/Puerto_Rico.
 
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 Rule	Mont	1917	only	-	Mar	25	2:00	1:00	D
@@ -1402,7 +1408,6 @@ Zone America/Montreal	-4:54:16 -	LMT	1884
 			-5:00	Mont	E%sT	1974
 			-5:00	Canada	E%sT
 
-
 # Ontario
 
 # From Paul Eggert (2006-07-09):
@@ -1621,7 +1626,7 @@ Zone America/Thunder_Bay -5:57:00 -	LMT	1895
 			-6:00	-	CST	1910
 			-5:00	-	EST	1942
 			-5:00	Canada	E%sT	1970
-			-5:00	Mont	E%sT	1973
+			-5:00	Toronto	E%sT	1973
 			-5:00	-	EST	1974
 			-5:00	Canada	E%sT
 Zone America/Nipigon	-5:53:04 -	LMT	1895
@@ -2208,7 +2213,7 @@ Zone America/Dawson	-9:17:40 -	LMT	1900 Aug 20
 # From Paul Eggert (1996-06-12):
 # For an English translation of the decree, see
 # <a href="http://mexico-travel.com/extra/timezone_eng.html">
-# ``Diario Oficial: Time Zone Changeover'' (1996-01-04).
+# "Diario Oficial: Time Zone Changeover" (1996-01-04).
 # </a>
 
 # From Rives McDow (1998-10-08):
@@ -2545,9 +2550,7 @@ Zone America/Santa_Isabel	-7:39:28 -	LMT	1922 Jan  1  0:20:32
 ###############################################################################
 
 # Anguilla
-# Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
-Zone America/Anguilla	-4:12:16 -	LMT	1912 Mar 2
-			-4:00	-	AST
+# See 'southamerica'.
 
 # Antigua and Barbuda
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
@@ -2616,13 +2619,13 @@ Zone	America/Belize	-5:52:48 -	LMT	1912 Apr
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone Atlantic/Bermuda	-4:19:18 -	LMT	1930 Jan  1 2:00    # Hamilton
 			-4:00	-	AST	1974 Apr 28 2:00
-			-4:00	Bahamas	A%sT	1976
+			-4:00	Canada	A%sT	1976
 			-4:00	US	A%sT
 
 # Cayman Is
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone	America/Cayman	-5:25:32 -	LMT	1890		# Georgetown
-			-5:07:12 -	KMT	1912 Feb    # Kingston Mean Time
+			-5:07:11 -	KMT	1912 Feb    # Kingston Mean Time
 			-5:00	-	EST
 
 # Costa Rica
@@ -2637,7 +2640,7 @@ Rule	CR	1991	1992	-	Jan	Sat>=15	0:00	1:00	D
 # go with Shanks & Pottenger.
 Rule	CR	1991	only	-	Jul	 1	0:00	0	S
 Rule	CR	1992	only	-	Mar	15	0:00	0	S
-# There are too many San Joses elsewhere, so we'll use `Costa Rica'.
+# There are too many San Joses elsewhere, so we'll use 'Costa Rica'.
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone America/Costa_Rica	-5:36:13 -	LMT	1890		# San Jose
 			-5:36:13 -	SJMT	1921 Jan 15 # San Jose Mean Time
@@ -2663,6 +2666,11 @@ Zone America/Costa_Rica	-5:36:13 -	LMT	1890		# San Jose
 # to DST--and one more hour on 1999-04-04--when the announcers will have
 # returned to Baltimore, which switches on that date.)
 
+# From Steffen Thorsen (2013-11-11):
+# DST start in Cuba in 2004 ... does not follow the same rules as the
+# years before.  The correct date should be Sunday 2004-03-28 00:00 ...
+# https://web.archive.org/web/20040402060750/http://www.granma.cu/espanol/2004/marzo/sab27/reloj.html
+
 # From Evert van der Veer via Steffen Thorsen (2004-10-28):
 # Cuba is not going back to standard time this year.
 # From Paul Eggert (2006-03-22):
@@ -2852,7 +2860,8 @@ Rule	Cuba	1996	only	-	Oct	 6	0:00s	0	S
 Rule	Cuba	1997	only	-	Oct	12	0:00s	0	S
 Rule	Cuba	1998	1999	-	Mar	lastSun	0:00s	1:00	D
 Rule	Cuba	1998	2003	-	Oct	lastSun	0:00s	0	S
-Rule	Cuba	2000	2004	-	Apr	Sun>=1	0:00s	1:00	D
+Rule	Cuba	2000	2003	-	Apr	Sun>=1	0:00s	1:00	D
+Rule	Cuba	2004	only	-	Mar	lastSun	0:00s	1:00	D
 Rule	Cuba	2006	2010	-	Oct	lastSun	0:00s	0	S
 Rule	Cuba	2007	only	-	Mar	Sun>=8	0:00s	1:00	D
 Rule	Cuba	2008	only	-	Mar	Sun>=15	0:00s	1:00	D
@@ -2869,9 +2878,7 @@ Zone	America/Havana	-5:29:28 -	LMT	1890
 			-5:00	Cuba	C%sT
 
 # Dominica
-# Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
-Zone America/Dominica	-4:05:36 -	LMT	1911 Jul 1 0:01		# Roseau
-			-4:00	-	AST
+# See 'southamerica'.
 
 # Dominican Republic
 
@@ -2920,18 +2927,10 @@ Zone America/El_Salvador -5:56:48 -	LMT	1921		# San Salvador
 			-6:00	Salv	C%sT
 
 # Grenada
-# Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
-Zone	America/Grenada	-4:07:00 -	LMT	1911 Jul	# St George's
-			-4:00	-	AST
-
 # Guadeloupe
-# Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
-Zone America/Guadeloupe	-4:06:08 -	LMT	1911 Jun 8	# Pointe a Pitre
-			-4:00	-	AST
 # St Barthelemy
-Link America/Guadeloupe	America/St_Barthelemy
 # St Martin (French part)
-Link America/Guadeloupe	America/Marigot
+# See 'southamerica'.
 
 # Guatemala
 #
@@ -3074,17 +3073,12 @@ Zone America/Tegucigalpa -5:48:52 -	LMT	1921 Apr
 # Great Swan I ceded by US to Honduras in 1972
 
 # Jamaica
-
-# From Bob Devine (1988-01-28):
-# Follows US rules.
-
-# From U. S. Naval Observatory (1989-01-19):
-# JAMAICA             5 H  BEHIND UTC
-
-# From Shanks & Pottenger:
+# Shanks & Pottenger give -5:07:12, but Milne records -5:07:10.41 from an
+# unspecified official document, and says "This time is used throughout the
+# island".  Go with Milne.  Round to the nearest second as required by zic.
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
-Zone	America/Jamaica	-5:07:12 -	LMT	1890		# Kingston
-			-5:07:12 -	KMT	1912 Feb    # Kingston Mean Time
+Zone	America/Jamaica	-5:07:11 -	LMT	1890		# Kingston
+			-5:07:11 -	KMT	1912 Feb    # Kingston Mean Time
 			-5:00	-	EST	1974 Apr 28 2:00
 			-5:00	US	E%sT	1984
 			-5:00	-	EST
@@ -3098,12 +3092,7 @@ Zone America/Martinique	-4:04:20 -      LMT	1890		# Fort-de-France
 			-4:00	-	AST
 
 # Montserrat
-# From Paul Eggert (2006-03-22):
-# In 1995 volcanic eruptions forced evacuation of Plymouth, the capital.
-# world.gazetteer.com says Cork Hill is the most populous location now.
-# Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
-Zone America/Montserrat	-4:08:52 -	LMT	1911 Jul 1 0:01   # Cork Hill
-			-4:00	-	AST
+# See 'southamerica'.
 
 # Nicaragua
 #
@@ -3177,7 +3166,7 @@ Zone	America/Panama	-5:18:08 -	LMT	1890
 			-5:00	-	EST
 
 # Puerto Rico
-# There are too many San Juans elsewhere, so we'll use `Puerto_Rico'.
+# There are too many San Juans elsewhere, so we'll use 'Puerto_Rico'.
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone America/Puerto_Rico -4:24:25 -	LMT	1899 Mar 28 12:00    # San Juan
 			-4:00	-	AST	1942 May  3
@@ -3185,18 +3174,11 @@ Zone America/Puerto_Rico -4:24:25 -	LMT	1899 Mar 28 12:00    # San Juan
 			-4:00	-	AST
 
 # St Kitts-Nevis
-# Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
-Zone America/St_Kitts	-4:10:52 -	LMT	1912 Mar 2	# Basseterre
-			-4:00	-	AST
-
 # St Lucia
-# Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
-Zone America/St_Lucia	-4:04:00 -	LMT	1890		# Castries
-			-4:04:00 -	CMT	1912	    # Castries Mean Time
-			-4:00	-	AST
+# See 'southamerica'.
 
 # St Pierre and Miquelon
-# There are too many St Pierres elsewhere, so we'll use `Miquelon'.
+# There are too many St Pierres elsewhere, so we'll use 'Miquelon'.
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone America/Miquelon	-3:44:40 -	LMT	1911 May 15	# St Pierre
 			-4:00	-	AST	1980 May
@@ -3204,10 +3186,7 @@ Zone America/Miquelon	-3:44:40 -	LMT	1911 May 15	# St Pierre
 			-3:00	Canada	PM%sT
 
 # St Vincent and the Grenadines
-# Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
-Zone America/St_Vincent	-4:04:56 -	LMT	1890		# Kingstown
-			-4:04:56 -	KMT	1912	   # Kingstown Mean Time
-			-4:00	-	AST
+# See 'southamerica'.
 
 # Turks and Caicos
 #
@@ -3237,15 +3216,9 @@ Rule	TC	2007	max	-	Mar	Sun>=8	2:00	1:00	D
 Rule	TC	2007	max	-	Nov	Sun>=1	2:00	0	S
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone America/Grand_Turk	-4:44:32 -	LMT	1890
-			-5:07:12 -	KMT	1912 Feb    # Kingston Mean Time
+			-5:07:11 -	KMT	1912 Feb    # Kingston Mean Time
 			-5:00	TC	E%sT
 
 # British Virgin Is
-# Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
-Zone America/Tortola	-4:18:28 -	LMT	1911 Jul    # Road Town
-			-4:00	-	AST
-
 # Virgin Is
-# Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
-Zone America/St_Thomas	-4:19:44 -	LMT	1911 Jul    # Charlotte Amalie
-			-4:00	-	AST
+# See 'southamerica'.
diff --git a/src/main/java/org/joda/time/tz/src/southamerica b/src/main/java/org/joda/time/tz/src/southamerica
index 0d8ed7a33..5391055aa 100644
--- a/src/main/java/org/joda/time/tz/src/southamerica
+++ b/src/main/java/org/joda/time/tz/src/southamerica
@@ -451,6 +451,17 @@ Rule	Arg	2008	only	-	Oct	Sun>=15	0:00	1:00	S
 # rules...San Luis is still using "Western ARgentina Time" and it got
 # stuck on Summer daylight savings time even though the summer is over.
 
+# From Paul Eggert (2013-09-05):
+# Perhaps San Luis operates on the legal fiction that it is at UTC-4
+# with perpetual summer time, but ordinary usage typically seems to
+# just say it's at UTC-3; see, for example,
+# <http://es.wikipedia.org/wiki/Hora_oficial_argentina>.
+# We've documented similar situations as being plain changes to
+# standard time, so let's do that here too.  This does not change UTC
+# offsets, only tm_isdst and the time zone abbreviations.  One minor
+# plus is that this silences a zic complaint that there's no POSIX TZ
+# setting for time stamps past 2038.
+
 # From Paul Eggert (2013-02-21):
 # Milne says Cordoba time was -4:16:48.2.  Round to the nearest second.
 
@@ -588,7 +599,7 @@ Zone America/Argentina/Mendoza -4:35:16 - LMT	1894 Oct 31
 # San Luis (SL)
 
 Rule	SanLuis	2008	2009	-	Mar	Sun>=8	0:00	0	-
-Rule	SanLuis	2007	2009	-	Oct	Sun>=8	0:00	1:00	S
+Rule	SanLuis	2007	2008	-	Oct	Sun>=8	0:00	1:00	S
 
 Zone America/Argentina/San_Luis -4:25:24 - LMT	1894 Oct 31
 			-4:16:48 -	CMT	1920 May
@@ -604,7 +615,8 @@ Zone America/Argentina/San_Luis -4:25:24 - LMT	1894 Oct 31
 			-3:00	-	ART	2004 May 31
 			-4:00	-	WART	2004 Jul 25
 			-3:00	Arg	AR%sT	2008 Jan 21
-			-4:00	SanLuis	WAR%sT
+			-4:00	SanLuis	WAR%sT	2009 Oct 11
+			-3:00	-	ART
 #
 # Santa Cruz (SC)
 Zone America/Argentina/Rio_Gallegos -4:36:52 - LMT 1894 Oct 31
@@ -631,10 +643,7 @@ Zone America/Argentina/Ushuaia -4:33:12 - LMT 1894 Oct 31
 			-3:00	-	ART
 
 # Aruba
-# Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
-Zone	America/Aruba	-4:40:24 -	LMT	1912 Feb 12	# Oranjestad
-			-4:30	-	ANT	1965 # Netherlands Antilles Time
-			-4:00	-	AST
+Link America/Curacao America/Aruba
 
 # Bolivia
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
@@ -836,6 +845,21 @@ Zone	America/La_Paz	-4:32:36 -	LMT	1890
 # Tocantins state will have DST.
 # http://noticias.terra.com.br/brasil/noticias/0,,OI6232536-EI306.html
 
+# From Steffen Thorsen (2013-09-20):
+# Tocantins in Brazil is very likely not to observe DST from October....
+# http://conexaoto.com.br/2013/09/18/ministerio-confirma-que-tocantins-esta-fora-do-horario-de-verao-em-2013-mas-falta-publicacao-de-decreto
+# We will keep this article updated when this is confirmed:
+# http://www.timeanddate.com/news/time/brazil-starts-dst-2013.html
+
+# From Steffen Thorsen (2013-10-17):
+# http://www.timeanddate.com/news/time/acre-amazonas-change-time-zone.html
+# Senator Jorge Viana announced that Acre will change time zone on November 10.
+# He did not specify the time of the change, nor if western parts of Amazonas
+# will change as well.
+#
+# From Paul Eggert (2013-10-17):
+# For now, assume western Amazonas will change as well.
+
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 # Decree <a href="http://pcdsh01.on.br/HV20466.htm">20,466</a> (1931-10-01)
 # Decree <a href="http://pcdsh01.on.br/HV21896.htm">21,896</a> (1932-01-10)
@@ -1055,7 +1079,8 @@ Zone America/Araguaina	-3:12:48 -	LMT	1914
 			-3:00	-	BRT	1995 Sep 14
 			-3:00	Brazil	BR%sT	2003 Sep 24
 			-3:00	-	BRT	2012 Oct 21
-			-3:00	Brazil	BR%sT
+			-3:00	Brazil	BR%sT	2013 Sep
+			-3:00	-	BRT
 #
 # Alagoas (AL), Sergipe (SE)
 Zone America/Maceio	-2:22:52 -	LMT	1914
@@ -1123,13 +1148,15 @@ Zone America/Eirunepe	-4:39:28 -	LMT	1914
 			-5:00	-	ACT	1993 Sep 28
 			-5:00	Brazil	AC%sT	1994 Sep 22
 			-5:00	-	ACT	2008 Jun 24 00:00
-			-4:00	-	AMT
+			-4:00	-	AMT	2013 Nov 10
+			-5:00	-	ACT
 #
 # Acre (AC)
 Zone America/Rio_Branco	-4:31:12 -	LMT	1914
 			-5:00	Brazil	AC%sT	1988 Sep 12
 			-5:00	-	ACT	2008 Jun 24 00:00
-			-4:00	-	AMT
+			-4:00	-	AMT	2013 Nov 10
+			-5:00	-	ACT
 
 # Chile
 
@@ -1248,6 +1275,13 @@ Zone America/Rio_Branco	-4:31:12 -	LMT	1914
 # start date is 2013-09-08 00:00....
 # http://www.gob.cl/informa/2013/02/15/gobierno-anuncia-fechas-de-cambio-de-hora-para-el-ano-2013.htm
 
+# From Jose Miguel Garrido (2014-02-19):
+# Today appeared in the Diario Oficial a decree amending the time change
+# dates to 2014.
+# DST End: last Saturday of April 2014 (Sun 27 Apr 2014 03:00 UTC)
+# DST Start: first Saturday of September 2014 (Sun 07 Sep 2014 04:00 UTC)
+# http://www.diariooficial.interior.gob.cl//media/2014/02/19/do-20140219.pdf
+
 # NOTE: ChileAQ rules for Antarctic bases are stored separately in the
 # 'antarctica' file.
 
@@ -1350,12 +1384,12 @@ Zone	America/Curacao	-4:35:47 -	LMT	1912 Feb 12	# Willemstad
 			-4:00	-	AST
 
 # From Arthur David Olson (2011-06-15):
-# At least for now, use links for places with new iso3166 codes.
+# use links for places with new iso3166 codes.
 # The name "Lower Prince's Quarter" is both longer than fourteen charaters
 # and contains an apostrophe; use "Lower_Princes" below.
 
-Link	America/Curacao	America/Lower_Princes # Sint Maarten
-Link	America/Curacao	America/Kralendijk # Bonaire, Sint Estatius and Saba
+Link	America/Curacao	America/Lower_Princes	# Sint Maarten
+Link	America/Curacao	America/Kralendijk	# Caribbean Netherlands
 
 # Ecuador
 #
@@ -1496,10 +1530,16 @@ Zone	America/Guyana	-3:52:40 -	LMT	1915 Mar	# Georgetown
 			-4:00	-	GYT
 
 # Paraguay
+#
 # From Paul Eggert (2006-03-22):
 # Shanks & Pottenger say that spring transitions are from 01:00 -> 02:00,
 # and autumn transitions are from 00:00 -> 23:00.  Go with pre-1999
 # editions of Shanks, and with the IATA, who say transitions occur at 00:00.
+#
+# From Waldemar Villamayor-Venialbo (2013-09-20):
+# No time of the day is established for the adjustment, so people normally
+# adjust their clocks at 0 hour of the given dates.
+#
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 Rule	Para	1975	1988	-	Oct	 1	0:00	1:00	S
 Rule	Para	1975	1978	-	Mar	 1	0:00	0	-
@@ -1575,6 +1615,9 @@ Rule	Para	2010	2012	-	Apr	Sun>=8	0:00	0	-
 # From Carlos Raul Perasso (2013-03-15):
 # The change in Paraguay is now final.  Decree number 10780
 # http://www.presidencia.gov.py/uploads/pdf/presidencia-3b86ff4b691c79d4f5927ca964922ec74772ce857c02ca054a52a37b49afc7fb.pdf
+# From Carlos Raul Perasso (2014-02-28):
+# Decree 1264 can be found at:
+# http://www.presidencia.gov.py/archivos/documentos/DECRETO1264_ey9r8zai.pdf
 Rule	Para	2013	max	-	Mar	Sun>=22	0:00	0	-
 
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
@@ -1633,6 +1676,20 @@ Zone America/Paramaribo	-3:40:40 -	LMT	1911
 Zone America/Port_of_Spain -4:06:04 -	LMT	1912 Mar 2
 			-4:00	-	AST
 
+# These all agree with Trinidad and Tobago since 1970.
+Link America/Port_of_Spain America/Anguilla
+Link America/Port_of_Spain America/Dominica
+Link America/Port_of_Spain America/Grenada
+Link America/Port_of_Spain America/Guadeloupe
+Link America/Port_of_Spain America/Marigot	# St Martin (French part)
+Link America/Port_of_Spain America/Montserrat
+Link America/Port_of_Spain America/St_Barthelemy
+Link America/Port_of_Spain America/St_Kitts	# St Kitts & Nevis
+Link America/Port_of_Spain America/St_Lucia
+Link America/Port_of_Spain America/St_Thomas	# Virgin Islands (US)
+Link America/Port_of_Spain America/St_Vincent
+Link America/Port_of_Spain America/Tortola	# Virgin Islands (UK)
+
 # Uruguay
 # From Paul Eggert (1993-11-18):
 # Uruguay wins the prize for the strangest peacetime manipulation of the rules.
@@ -1650,7 +1707,7 @@ Rule	Uruguay	1937	1941	-	Mar	lastSun	 0:00	0	-
 # Whitman gives 1937 Oct 3; go with Shanks & Pottenger.
 Rule	Uruguay	1937	1940	-	Oct	lastSun	 0:00	0:30	HS
 # Whitman gives 1941 Oct 24 - 1942 Mar 27, 1942 Dec 14 - 1943 Apr 13,
-# and 1943 Apr 13 ``to present time''; go with Shanks & Pottenger.
+# and 1943 Apr 13 "to present time"; go with Shanks & Pottenger.
 Rule	Uruguay	1941	only	-	Aug	 1	 0:00	0:30	HS
 Rule	Uruguay	1942	only	-	Jan	 1	 0:00	0	-
 Rule	Uruguay	1942	only	-	Dec	14	 0:00	1:00	S

From ab9166ef7612ff3ad28537e7e52100f685a53e9c Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 27 Jul 2014 17:31:34 +0100
Subject: [PATCH 85/86] Switch to GitHub for downloads

---
 src/site/resources/download.html | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/site/resources/download.html b/src/site/resources/download.html
index 4eef86acc..6cd130692 100644
--- a/src/site/resources/download.html
+++ b/src/site/resources/download.html
@@ -1,6 +1,6 @@
 <head>
 <title>OpenGamma</title>
-<meta http-equiv="REFRESH" content="0;url=http://sourceforge.net/projects/joda-time/files/joda-time/">
+<meta http-equiv="REFRESH" content="0;url=https://github.com/JodaOrg/joda-time/releases">
 </head>
 <body></body>
 </html>

From 680f94d0565075e98e3c947d359e7e29451e1b96 Mon Sep 17 00:00:00 2001
From: Stephen Colebourne <scolebourne@joda.org>
Date: Sun, 27 Jul 2014 17:31:50 +0100
Subject: [PATCH 86/86] Release v2.4

---
 README.md                      |   4 +-
 pom.xml                        |   2 +-
 src/conf/MANIFEST.MF           |  20 ++--
 src/site/xdoc/index.xml        |  10 +-
 src/site/xdoc/installation.xml |   1 +
 src/site/xdoc/upgradeto240.xml | 175 +++++++++++++++++++++++++++++++++
 6 files changed, 194 insertions(+), 18 deletions(-)
 create mode 100644 src/site/xdoc/upgradeto240.xml

diff --git a/README.md b/README.md
index 9bcf72603..474ef6d10 100644
--- a/README.md
+++ b/README.md
@@ -46,11 +46,11 @@ Various documentation is available:
 
 
 ### Releases
-[Release 2.3](http://www.joda.org/joda-time/download.html) is the current latest release.
+[Release 2.4](http://www.joda.org/joda-time/download.html) is the current latest release.
 This release is considered stable and worthy of the 1.x tag.
 It depends on JDK 1.5 or later.
 
-Available in the [Maven Central repository](http://search.maven.org/#artifactdetails|joda-time|joda-time|2.3|jar)
+Available in the [Maven Central repository](http://search.maven.org/#artifactdetails|joda-time|joda-time|2.4|jar)
 
 
 ### Related projects
diff --git a/pom.xml b/pom.xml
index 52f47b375..e225bb5bd 100644
--- a/pom.xml
+++ b/pom.xml
@@ -9,7 +9,7 @@
   <artifactId>joda-time</artifactId>
   <packaging>jar</packaging>
   <name>Joda-Time</name>
-  <version>2.4-SNAPSHOT</version>
+  <version>2.4</version>
   <description>Date and time library to replace JDK date handling</description>
   <url>http://www.joda.org/joda-time/</url>
 
diff --git a/src/conf/MANIFEST.MF b/src/conf/MANIFEST.MF
index c5ce028c5..aafc39dce 100644
--- a/src/conf/MANIFEST.MF
+++ b/src/conf/MANIFEST.MF
@@ -2,22 +2,22 @@ Package: org.joda.time
 Extension-Name: joda-time
 Specification-Title: Joda-Time
 Specification-Vendor: Joda.org
-Specification-Version: 2.3
+Specification-Version: 2.4
 Implementation-Vendor: Joda.org
 Implementation-Title: org.joda.time
-Implementation-Version: 2.3
+Implementation-Version: 2.4
 Implementation-Vendor-Id: org.joda
 Bundle-ManifestVersion: 2
 Bundle-Vendor: Joda.org
 Bundle-Name: Joda-Time
 Bundle-SymbolicName: joda-time
-Bundle-Version: 2.3
-Export-Package: org.joda.time;version=2.3,
- org.joda.time.base;version=2.3,
- org.joda.time.chrono;version=2.3,
- org.joda.time.convert;version=2.3,
- org.joda.time.field;version=2.3,
- org.joda.time.format;version=2.3,
- org.joda.time.tz;version=2.3
+Bundle-Version: 2.4
+Export-Package: org.joda.time;version=2.4,
+ org.joda.time.base;version=2.4,
+ org.joda.time.chrono;version=2.4,
+ org.joda.time.convert;version=2.4,
+ org.joda.time.field;version=2.4,
+ org.joda.time.format;version=2.4,
+ org.joda.time.tz;version=2.4
 Bundle-License: Apache 2.0
 Bundle-DocURL: http://www.joda.org/joda-time/
diff --git a/src/site/xdoc/index.xml b/src/site/xdoc/index.xml
index 1aa869b43..20c2629f0 100644
--- a/src/site/xdoc/index.xml
+++ b/src/site/xdoc/index.xml
@@ -54,7 +54,7 @@ public boolean isJoinedInLastThreeMonths(<a href="apidocs/org/joda/time/DateTime
   return last3Months.contains(datetimeJoined);
 }
 -->
-Version 2.3 was released on 2013-08-16 -
+Version 2.4 was released on 2014-07-27 -
 <a href="download.html">Download now</a>
 </p>
 </section>
@@ -140,14 +140,14 @@ Various documentation is available:
 
 <section name="Releases">
 <p>
-<a href="download.html">Release 2.3</a>
+<a href="download.html">Release 2.4</a>
 is the current latest release.
 This release is an evolution of the 1.x codebase, not a major rewrite.
 It is considered stable and worthy of the 2.x tag.
 </p>
 <p>
-Version 2.3 is a bugfix release compatible with version 2.2.
-See the <a href="upgradeto230.html">upgrade notes</a> for full details.
+Version 2.4 is a bugfix release compatible with version 2.3.
+See the <a href="upgradeto240.html">upgrade notes</a> for full details.
 </p>
 <p>
 Version 2.x is almost completely source and binary compatible with version 1.x.
@@ -161,7 +161,7 @@ The main public API will remain backwards compatible for both source and binary
 The version number will change to 3.0 to indicate a significant change in compatibility.
 </p>
 <p>
-Available in <a href="http://search.maven.org/#artifactdetails|joda-time|joda-time|2.3|jar">Maven Central</a>.
+Available in <a href="http://search.maven.org/#artifactdetails|joda-time|joda-time|2.4|jar">Maven Central</a>.
 </p>
 
 <p>
diff --git a/src/site/xdoc/installation.xml b/src/site/xdoc/installation.xml
index fe4f8275b..e0e3cac46 100644
--- a/src/site/xdoc/installation.xml
+++ b/src/site/xdoc/installation.xml
@@ -22,6 +22,7 @@ of the source code suitable for linking to the jar file in IDEs such as Eclipse.
 <p>
 The release notes for upgraders can be found here:
 <ul>
+<li><a href="upgradeto240.html">Version 2.4</a> - upgrade from Version 2.3</li>
 <li><a href="upgradeto230.html">Version 2.3</a> - upgrade from Version 2.2</li>
 <li><a href="upgradeto220.html">Version 2.2</a> - upgrade from Version 2.1</li>
 <li><a href="upgradeto210.html">Version 2.1</a> - upgrade from Version 2.0</li>
diff --git a/src/site/xdoc/upgradeto240.xml b/src/site/xdoc/upgradeto240.xml
new file mode 100644
index 000000000..a621ab83e
--- /dev/null
+++ b/src/site/xdoc/upgradeto240.xml
@@ -0,0 +1,175 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+
+<document>
+ <properties>
+  <title>Java date and time API - Upgrade from 2.2 to 2.3</title>
+  <author>Stephen Colebourne</author>
+ </properties>
+
+<body>
+
+<section name="Upgrade">
+<p>
+These are the release notes and advice for upgrading Joda-Time from version 2.3 to version 2.4.
+<source>
+Joda-Time version 2.4
+---------------------
+
+Joda-Time is a date and time handling library that seeks to replace the JDK
+Date and Calendar classes.
+
+This release contains enhancements, bug fixes and a time zone update.
+The release runs on JDK 5 or later.
+
+Joda-Time is licensed under the business-friendly Apache License Version 2.
+This is the same license as all of Apache, plus other open source projects such as Spring.
+The intent is to make the code available to the Java community with the minimum
+of restrictions. If the license causes you problems please contact the mailing list.
+
+**  Please also check out our related projects   **
+** http://www.joda.org/joda-time/related.html **
+
+
+Enhancements since 2.3
+----------------------
+- Duration.multipliedBy(), .dividedBy(), .negated()
+  Additional methods on Duration
+
+- LocalDate.hashCode()
+  Remove unnecessary volatile on instance variable [#68]
+  LocalDate hash code meets criteria of the racy single-check idiom
+
+- DateTimeParserBucket
+  Allow bucket to be re-used on a single thread [#111]
+  Potential for performance improvements due to lower garbage churn
+  Improvement only of interest to applications willing to write specialist code
+
+- Support CharSequence throughout parsing
+  Ensure that CharSequence can be used in parsing [#111]
+  This can only be accessed by creating a mutable DateTimeParserBucket
+  The bucket is a low-level construct for advanced use cases
+  Potential for performance improvements due to lower garbage churn
+  No API change
+
+- Support Appendable throughout printing
+  Ensure that Appendable can be used efficiently in printing [#120, #121, #122]
+  No API change
+
+- Increased performance of chronology lookup [#126,#105]
+  No API change
+
+- Increased performance of formatter lookup [#127,#129]
+  No API change
+
+- Increased performance of symbols lookup [#143]
+  No API change
+
+
+Compatibility with 2.3
+----------------------
+Build system - Yes
+
+Binary compatible - Yes
+
+Source compatible - Yes
+
+Serialization compatible - Yes
+
+Data compatible - Yes, except
+ - DateTimeZone data updated to version 2014e
+
+Semantic compatible - Yes, except
+- DateTimeField duration fields have been fixed
+  For example, yearOfEra() now has a range of eras() rather than null
+  The DurationField instances now compare using equals() correctly
+- MutableDateTime.add(DateTimeFieldType,int), addDays(int) and friends [#77]
+  Adding zero will no longer change the offset during DST overlap in autumn/fall
+
+
+Deprecations since 2.3
+----------------------
+
+
+Bug fixes since 2.3
+-------------------
+- DateTimeField.getDurationField() / DateTimeField.getRangeDurationField() [#92,#93,#95]
+  Previously some of the complex cases were wrong, notably around centuries and eras
+  For example, yearOfEra() returned a range of null when it should be eras()
+  A slew of tests were added and a variety of bugs fixed
+  This affects DateTimeField.getDurationField() and DateTimeField.getRangeDurationField()
+
+- Fixed another edge case in conversion from Local to UTC  [#76]
+  The DateTimeZone.getOffsetFromLocal() method was fixed to handle the last cutover
+  in DST history correctly.
+
+- Period construction during DST overlap [#156]
+  When creating a period, if one end is within a DST overlap and one beyond the overlap
+  then the calculated period was incorrect.
+  The calculation has been changed no ensure no extra hour is added.
+
+- DateTimeUtils.isContiguous(ReadablePartial) [#89]
+  The isContiguous() method could throw a NullPointerException when evaluating weird partials
+
+- Period.normalizedStandard(PeriodType) [#79]
+  Fix handling of PeriodType when either years or months missing
+
+- Partial.with(DateTimeFieldType,int) [#88]
+  Validation in this method was not as thorough as that in the constructor
+  This allowed invalid partials to be created
+
+- MutableDateTime.add(DateTimeFieldType,int), addDays(int) and friends [#77]
+  Adding zero to a MutableDateTime used to change the offset during DST overlap in autumn/fall
+  This is now fixed to not change the offset
+
+- DateTime/MutableDateTime constructors taking millis now validate [#100]
+  Previously, new DateTime(Long.MAX_VALUE) would be accepted, now it will be rejected
+  This ensures that the maximum/minimum year are respected
+
+- Ensure isLeap() returns correct result for day fields [#110]
+  Day-of-month and day-of-year fields should report leap days
+
+- Insist that year > weekyear when creating Partial [#96,#98]
+  As these compare equal code previously allowed either order
+
+- Handle weird TimeZone implementations with null ID [#133]
+  Calling DateTimeZone.forTimeZone() would break if the ID was null
+
+- Handle broken Android implementations better [#103]
+  Apparently some Android implementations throw ClassCastException when comparing different types
+  Thats dumb and wrong but the change to handle it is harmless
+
+- Better concurrency in parsing [#101]
+
+- Better Javadoc for parsing of numbers in format patterns [#60]
+
+- Remove uncaughtException calls [#59]
+  Previously the code called ThreadGroup.uncaughtException() which was invalid
+
+- Fix Javadoc for ReadableDuration [#137]
+
+- Fix the links to the IANA time zone database [#83]
+
+- Better Javadoc for thread saefty of DateTimeUtils [#67]
+
+- Better Javadoc for DateTimeComparator [#73]
+
+- Better Javadoc for DateTimeFormatter parsing [#78]
+
+- Better Javadoc for DateTimeFormat fraction of second [#62]
+
+- Better Javadoc for DateTime toString and parse [#142]
+
+- Better Javadoc for formatters that only parse [#97]
+
+
+Scala
+--------
+Joda-Time uses annotations from Joda-Convert.
+In the Java programming language, this dependency is optional, however in Scala it is not.
+Scala users must manually add the Joda-Convert v1.2 dependency.
+</source>
+</p>
+</section>
+
+</body>
+</document>